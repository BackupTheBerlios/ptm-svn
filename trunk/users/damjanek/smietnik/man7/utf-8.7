.\" Hey Emacs! This file is -*- nroff -*- source.
.\"
.\" Copyright (C) Markus Kuhn, 1996, 2001
.\"
.\" This is free documentation; you can redistribute it and/or
.\" modify it under the terms of the GNU General Public License as
.\" published by the Free Software Foundation; either version 2 of
.\" the License, or (at your option) any later version.
.\"
.\" The GNU General Public License's references to "object code"
.\" and "executables" are to be interpreted as the output of any
.\" document formatting or typesetting system, including
.\" intermediate and printed output.
.\"
.\" This manual is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\" GNU General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public
.\" License along with this manual; if not, write to the Free
.\" Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111,
.\" USA.
.\"
.\" 1995-11-26  Markus Kuhn <mskuhn@cip.informatik.uni-erlangen.de>
.\"      First version written
.\" 2001-05-11  Markus Kuhn <mgk25@cl.cam.ac.uk>
.\"      Update
.\"
.\" Translation (c) 1998 "Gwidon S. Naskrent" <naskrent@hoth.amu.edu.pl>
.\" Last update Andrzej M. Krzysztofowicz <ankry@mif.pg.gda.pl>, Aug 2002,
.\"             man-pages 1.60
.\"
.TH UTF-8 7 2001-05-11 "GNU" "Podręcznik programisty Linuksa"
.SH NAZWA
UTF-8 \- zgodne z ASCII wielobajtowe kodowanie Unikodowe
.SH OPIS
Zestaw znaków
.B Unicode 3.0
zajmuje szesnastobitową przestrzeń kodową. Najprostsze kodowanie Unikodowe
(znane jako
.BR UCS-2 )
składa się z sekwencji słów szesnastobitowych. Takie łańcuchy mogą
zawierać jako część wielu znaków 16-bitowych bajty takie jak '\\0' lub '/',
które mają specjalne znaczenie w nazwach plików i innych parametrach
funkcji z biblioteki C. Dodatkowo, większość narzędzi uniksowych spodziewa
się plików ASCII i nie potrafi bez znacznych modyfikacji czytać słów
16-bitowych jako znaków. Z tych powodów
.B UCS-2
nie jest pożądanym zewnętrznym kodowaniem
.B Unicode
w nazwach plików, plikach tekstowych, zmiennych środowiskowych itd.
.BR "ISO 10646 Universal Character Set (UCS)" ,
nadzbiór Unicode, zajmuje nawet przestrzeń 31-bitową i oczywiste dlań
kodowanie
.B UCS-4
(sekwencja słów 32-bitowych) stwarza te same problemy.

Kodowanie
.B UTF-8
dla
.B Unicode
i
.B UCS
nie ma tych problemów i jest słuszną metodą używania zestawu znaków 
.B Unicode
w systemach operacyjnych wzorowanych na UNIX-ie.
.SH WŁAŚCIWOŚCI
Kodowanie
.B UTF-8 
ma następujące przydatne właściwości:
.TP 0.2i
*
.B UCS
znaki od 0x00000000 do 0x0000007f (klasyczne znaki
.BR US-ASCII )
zakodowane są po prostu jako bajty 0x00 do 0x7f (zgodność z
ASCII). Oznacza to, że pliki i łańcuchy które zawierają tylko siedmiobitowe
znaki ASCII mają takie samo kodowanie i w
.B ASCII
i w
.BR UTF-8 .
.TP
*
Wszystkie znaki
.B UCS
> 0x7f zakodowane są jako wielobajtowy ciąg składający się tylko
z bajtów w zakresie 0x80 do 0xfd, tak więc żadne bajty ASCII nie moga się
pojawić jako część innego znaku i nie występują tam problemy z np.
'\\0' czy '/'.
.TP
*
Zachowany jest leksykograficzny porządek sortowania łańcuchów w
.BR UCS-4 .
.TP
*
Za pomocą
.BR UTF-8
można zakodować wszystkie z możliwych 2^31 kodów UCS.
.TP
*
Bajty 0xfe i 0xff nie są nigdy używane w kodowaniu 
.BR UTF-8 .
.TP
*
Pierwszy bajt ciągu wielobajtowego reprezentującego pojedynczy znak
.B UCS
nie-ASCII zawsze zawiera się w zakresie 0xc0 do 0xfd i wskazuje
jak długi jest ów ciąg. Wszystkie pozostałe bajty takiego wielobajtowego
ciągu zawierają się w zakresie od 0x80 do 0xbf. Pozwala to na
łatwą resynchronizację i sprawia, że kodowanie jest niezależne od
stanu [systemu] oraz odporne na brakujące bajty.
.TP
*
Znaki
.B UCS
zakodowane w
.B UTF-8
mogą mieć długość do sześciu bajtów, jakkolwiek standard
.B Unicode
nie definiuje znaków powyżej 0x10ffff, więc znaki Unicode mogą mieć
maksymalnie cztery bajty w
.BR UTF-8 .
.SH KODOWANIE
Do reprezentacji znaku używane są następujące ciągi bajtów. Ciąg, którego
należy użyć zależy od numeru kodu UCS znaku:
.TP 0.4i
0x00000000 - 0x0000007F:
.RI 0 xxxxxxx
.TP
0x00000080 - 0x000007FF:
.RI 110 xxxxx 
.RI 10 xxxxxx
.TP
0x00000800 - 0x0000FFFF:
.RI 1110 xxxx
.RI 10 xxxxxx
.RI 10 xxxxxx
.TP
0x00010000 - 0x001FFFFF:
.RI 11110 xxx
.RI 10 xxxxxx
.RI 10 xxxxxx
.RI 10 xxxxxx
.TP
0x00200000 - 0x03FFFFFF:
.RI 111110 xx
.RI 10 xxxxxx
.RI 10 xxxxxx
.RI 10 xxxxxx
.RI 10 xxxxxx
.TP
0x04000000 - 0x7FFFFFFF:
.RI 1111110 x
.RI 10 xxxxxx
.RI 10 xxxxxx
.RI 10 xxxxxx
.RI 10 xxxxxx
.RI 10 xxxxxx
.PP
Pozycje bitowe
.I xxx
zostają wypełnione bitami numeru kodu znaku w reprezentacji dwójkowej.
Może zostać użyty tylko najkrótszy możliwy wielobajtowy ciąg, która
reprezentuje numer kodowy danego znaku.
.PP
Wartości kodowe
.B UCS
0xd800\(en0xdfff (zastępujące UTF-16), jak też 0xfffe i 0xffff (nie-znaki
w UCS) nie powinny wystąpić w strumieniach zgodnych z
.BR UTF-8 .
.SH PRZYKŁADY
Znak
.B Unicode
0xa9 = 1010 1001 (znak copyright) kodowany jest
w UTF-8 jako
.PP
.RS
11000010 10101001 = 0xc2 0xa9
.RE
.PP
a znak 0x2260 = 0010 0010 0110 0000 (symbol "nie równa się") kodowany
jest jako:
.PP
.RS
11100010 10001001 10100000 = 0xe2 0x89 0xa0
.RE
.SH "UWAGI O STOSOWANIU"
Aby włączyć obsługę
.B UTF-8
w aplikacjach, użytkownicy muszą wybrać locale
.BR UTF-8 ,
na przykład poprzez
.PP
.RS
export LANG=en_GB.UTF-8
.RE
.PP
Oprogramowanie, które musi wiedzieć, jakie kodowanie znaków jest używane
powinno zawsze ustawiać locale, na przykład za pomocą
.PP
.RS
setlocale(LC_CTYPE, "")
.RE
.PP
a programiści mogą wówczas sprawdzać wartość wyrażenia
.PP
.RS
strcmp(nl_langinfo(CODESET), "UTF-8") == 0
.RE
.PP
aby określić, czy zostało wybrane locale
.B UTF-8
i czy wszystko: standardowe wprowadzanie i wyprowadzanie danych otwartym
tekstem, komunikacja terminalowa, zawartosc plików tekstowych oraz zmienne
środowiska, jest zakodowane w
.BR UTF-8 .
.PP
Programiści przyzwyczajeni do jednobajtowego kodowania takiego, jak
.B US-ASCII
lub
.B ISO 8859
muszą wiedzieć, że dwa z dotychczasowych założeń nie są spełnione w locale
.BR UTF-8 .
Po pierwsze, pojedynczy bajt niekoniecznie nadal odpowiada pojedynczemu
znakowi. Po drugie, ponieważ nowoczesne emulatory terminali w trybie
.B UTF-8
wspierają również chińskie, japońskie i koreańskie
.BR "znaki o podwójnej długości" ,
jak też nie rozdzielone
.BR "znaki kombinowane" ,
wyprowadzenie pojedynczego znaku niekoniecznie przesuwa kursor o jedną
pozycję, jak to miało miejsce w
.BR ASCII .
Do zliczania znaków i pozycji kursora należy obecnie używać funkcji
bibliotecznych takich, jak
.BR mbsrtowcs (3)
i
.BR wcswidth (3).
.PP
Oficjalną sekwencją unikową przełączającą ze schematu kodowania
.B ISO 2022
(używaną na przykład przez terminale VT100) do
.B UTF-8
jest ESC % G
("\\x1b%G"). Odpowiadającą jej sekwencją powrotu z
.B UTF-8
do ISO 2022 jest ESC % @ ("\\x1b%@"). Inne sekwencje ISO 2022 (takie jak
przełączające zbiory G0 i G1) nie mają zastosowania w trybie UTF-8.
.PP
Można mieć nadzieję, że w przewidywalnej przyszłości
.B UTF-8
zastąpi na wszystkich poziomach
.B ASCII
i
.B ISO 8859
jako wspólne kodowanie znaków w systemach POSIX-owych, doprowadzając
do znacznego wzbogacenia środowiska obsługi czystego tekstu.
.SH ZABEZPIECZENIA
Standardy
.BR Unicode " i " UCS
wymagają, aby przy generowaniu
.B UTF-8
używać najkrótszej z możliwych postaci, np. generowanie dwubajtowej
sekwencji o pierwszym bajcie 0xc0 nie jest zgodne ze standardem.
.B Unicode 3.1
dodał wymaganie, aby zgodne ze standardem programy nie akceptowały innych
niż najkrótsze postaci jako swoich danych wejściowych. Jest to związane
z bezpieczeństwem: jeśli wprowadzane przez użytkownika dane są sprawdzane
pod kątem możliwych naruszeń bezpieczeństwa, program może sprawdzać jedynie
wersje
.B ASCII
wystąpień "/../", ";" lub NUL i przeoczyć, że jest wiele niezgodnych z
.B ASCII
sposobów przedstawienia tych rzeczy w nie-najkrótszym kodowaniu
.BR UTF-8 .
.SH STANDARDY
ISO/IEC 10646-1:2000, Unicode 3.1, RFC 2279, Plan 9.
.SH AUTOR
Markus Kuhn <mgk25@cl.cam.ac.uk>
.SH "ZOBACZ TAKŻE"
.BR nl_langinfo (3),
.BR setlocale (3),
.BR charsets (7),
.B unicode(7)

%& -translate-file=il2-pl
\def\fontprefix{pl}
\input texinfo   @c -*-texinfo-*-
@c %**start of header (This is for running Texinfo on a region.)
@setfilename gawk.info
@settitle Podręcznik użytkownika GNU awk
@documentencoding ISO-8859-2
@documentlanguage pl
@c %**end of header (This is for running Texinfo on a region.)

@c zmiany/komentarze tłumacza oznakowano 'HQ'

@c inside ifinfo for older versions of texinfo.tex
@ifinfo
@c I hope this is the right category
@dircategory Programming Languages
@direntry
* Gawk: (gawk).           Język przeszukiwania i przetwarzania tekstu.
@end direntry
@end ifinfo

@c @set xref-automatic-section-title
@c @set DRAFT

@c The following information should be updated here only!
@c This sets the edition of the document, the version of gawk it
@c applies to, and when the document was updated.
@set TITLE Efektywne programowanie w AWK
@set TITLEORG Effective AWK Programming
@set SUBTITLE Podręcznik użytkownika GNU awk
@set PATCHLEVEL 6
@set EDITION 1.0.@value{PATCHLEVEL}
@set VERSION 3.0
@set UPDATE-MONTH lipiec 2000
@iftex
@set DOCUMENT book
@end iftex
@ifinfo
@set DOCUMENT Info file
@end ifinfo

@ignore
Some comments on the layout for TeX.
1. Use at least texinfo.tex 2.159. It contains fixes that
   are needed to get the footings for draft mode to not appear.
2. I have done A LOT of work to make this look good. There are  `@page' commands
   and use of `@group ... @end group' in a number of places. If you muck
   with anything, it's your responsibility not to break the layout.
@end ignore

@c merge the function and variable indexes into the concept index
@ifinfo
@synindex fn cp
@synindex vr cp
@end ifinfo
@iftex
@syncodeindex fn cp
@syncodeindex vr cp
@end iftex

@c If "finalout" is commented out, the printed output will show
@c black boxes that mark lines that are too long.  Thus, it is
@c unwise to comment it out when running a master in case there are
@c overfulls which are deemed okay.

@ifclear DRAFT
@iftex
@finalout
@end iftex
@end ifclear

@smallbook
@iftex
@c @cropmarks
@end iftex

@ifinfo
Niniejszy plik opisuje @code{awk}, program do wybierania konkretnych
rekordów z pliku i wykonywania na nich działań.

To jest wydanie @value{EDITION} książki @cite{@value{TITLE}}; @*
opisujące wersję @value{VERSION}.@value{PATCHLEVEL} AWK w implementacji GNU.

Copyright (C) 1989, 1991, 1992, 1993, 1996-2000 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

@ignore
Permission is granted to process this file through TeX and print the
results, provided the printed document carries copying permission
notice identical to this one except for the removal of this paragraph
(this paragraph not being relevant to the printed manual).

@end ignore
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation approved
by the Foundation.


@end ifinfo

@setchapternewpage odd

@titlepage
@title @value{TITLE}
@subtitle @value{SUBTITLE}
@subtitle wydanie @value{EDITION}
@subtitle @value{UPDATE-MONTH}
@author Arnold D. Robbins
@ignore
@sp 1
@author W oparciu o @cite{The GAWK Manual},
@author autorstwa Robbinsa, Close'a, Rubina i Stallmana
@end ignore

@c Include the Distribution inside the titlepage environment so
@c that headings are turned off.  Headings on and off do not work.

@page
@vskip 0pt plus 1filll
@ifset LEGALJUNK
The programs and applications presented in this book have been
included for their instructional value.  They have been tested with care,
but are not guaranteed for any particular purpose.  The publisher does not
offer any warranties or representations, nor does it accept any
liabilities with respect to the programs or applications.
So there.
@sp 2
UNIX is a registered trademark of X/Open, Ltd. @*
Microsoft, MS, and MS-DOS are registered trademarks, and Windows is a
trademark of Microsoft Corporation in the United States and other
countries. @*
Atari, 520ST, 1040ST, TT, STE, Mega, and Falcon are registered trademarks
or trademarks of Atari Corporation. @*
DEC, Digital, OpenVMS, ULTRIX, and VMS, are trademarks of Digital Equipment
Corporation. @*
@end ifset
``To boldly go where no man has gone before'' is a
Registered Trademark of Paramount Pictures Corporation. @*
@c sorry, i couldn't resist
@sp 3
Copyright @copyright{} 1989, 1991, 1992, 1993, 1996-2000
Free Software Foundation, Inc. @*
Tytuł oryginalny: @value{TITLEORG}.
@sp 2

To jest wydanie @value{EDITION} książki @cite{@value{TITLE}}; @*
opisuje wersję @value{VERSION}.@value{PATCHLEVEL} (lub późniejszą)
AWK w implementacji GNU.

@sp 2
Opublikowana przez:

Free Software Foundation @*
59 Temple Place --- Suite 330 @*
Boston, MA  02111-1307 USA @*
Telefon: +1-617-542-5942 @*
Fax: +1-617-542-2652 @*
Email: @code{gnu@@gnu.org} @*
URL: @code{http://www.gnu.org/} @*

@sp 1
@c this ISBN can change!
@c This one is correct for gawk 3.0 and edition 1.0 from the FSF
ISBN 1-882114-26-4 @*

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation approved
by the Foundation.

@sp 2
Ilustracja na okładce: Etienne Suvasa.
@end titlepage

@c Thanks to Bob Chassell for directions on doing dedications.
@iftex
@headings off
@page
@w{ }
@sp 9
@center @i{Miriam, za dopełnianie mnie.}
@sp 1
@center @i{Chanie, za radość jaką nam przyniosłaś.}
@sp 1
@center @i{Ryfce, za wykładniczy wzrost.}
@sp 1
@center @i{Nachumowi, za dodany wymiar.}
@sp 1
@center @i{Malce, za nowy początek.}
@page
@w{ }
@page
@headings on
@end iftex

@iftex
@headings off
@evenheading @thispage@ @ @ @strong{@value{TITLE}} @| @|
@oddheading  @| @| @strong{@thischapter}@ @ @ @thispage
@ifset DRAFT
@evenfooting @today{} @| @emph{SZKIC!} @| Proszę nie rozpowszechniać
@oddfooting Proszę nie rozpowszechniać @| @emph{SZKIC!} @| @today{}
@end ifset
@end iftex

@ifinfo
@node Top, Przedmowa, (dir), (dir)
@top Ogólne wprowadzenie
@c Preface or Licensing nodes should come right after the Top
@c node, in `unnumbered' sections, then the chapter, `What is gawk'.

Niniejszy plik opisuje @code{awk}, program do wybierania konkretnych
rekordów z pliku i wykonywania na nich działań.

To jest wydanie @value{EDITION} książki @cite{@value{TITLE}}; @*
opisuje wersję @value{VERSION}.@value{PATCHLEVEL}
AWK w implementacji GNU of AWK.

@end ifinfo

@menu
* Przedmowa::                   O czym jest ta książka; krótka historia
                                i podziękowania.
* Czym jest awk::               Czym jest język @code{awk}; posługiwanie się
                                niniejszą książką.
* Zaczynamy::                   Podstawowe wprowadzenie do użytkowania @code{awk}.
                                Jak uruchamiać programy @code{awk}. Składnia
                                wiersza poleceń.
* Jednolinijkowce::             Krótkie, przykładowe programy @code{awk}.
* Regexp::                      Wszystko o dopasowywaniu za pomocą wyrażeń
                                regularnych.
* Czytanie plików::             Jak czytać pliki i operować na polach.
* Wypisywanie::                 Jak wypisywać wyniki w @code{awk}. Opisuje
                                instrukcje @code{print} i @code{printf}.
                                Opisuje też przekierowanie wyjścia.
* Wyrażenia::                   Wyrażenia są podstawowymi cegiełkami
                                instrukcji.
* Wzorce i akcje::              Przegląd wzorców i akcji.
* Instrukcje::                  Szczegółowo opisane rozmaite instrukcje
                                sterujące.
* Zmienne wbudowane::           Zmienne wbudowane
* Tablice::                     Opis i stosowanie tablic. Zawiera także
                                instrukcje sterujące dotyczące tablic.
* Wbudowane::                   Tu podsumowano funkcje wbudowane.
* Użytkownika::                 Szczegółowo opisano funkcje definiowane przez
                                użytkownika.
* Wywołanie gawk::              Jak uruchamiać @code{gawk}.
* Funkcje biblioteczne::        Biblioteczka funkcji @code{awk}.
* Przykładowe programy::        Wiele programów @code{awk} z pełnymi
                                objaśnieniami.
* Historia języka::             Ewolucja języka @code{awk}.
* Podsumowanie gawk::           Podsumowanie opcji i języka @code{gawk}.
* Instalacja::                  Instalowanie @code{gawk} na różnych
                                systemach operacyjnych.
* Uwagi::                       Co nieco o implementacji @code{gawk}.
* Słownik::                     Objaśnienie rzadziej spotykanych terminów.
* Kopiowanie::                  Prawo do kopiowania i rozpowszechniania
                                @code{gawk}.
* Indeks::                      Indeks pojęć i zmiennych.


* Historia::                    Historia @code{gawk} i @code{awk}.
* Historia podręcznika::        Krótka historia projektu GNU i niniejszej
                                książki.
* Podziękowania::               Podziękowania.
* Od tłumacza::                 Parę słów od tłumacza.
* Niniejszy podręcznik::        Posługiwanie się tą książką.  Zawiera
                                przykładowe pliki wejściowe.
* Konwencje::                   Konwencje typograficzne.
* Przykładowe pliki danych::    Przykładowe pliki danych do zastosowania
                                z programami @code{awk} pokazanymi
                                w tej książce.
* Nazwy::                       Jakiej nazwy użyć, by znaleźć @code{awk}.
* Uruchamianie gawk::           Jak uruchamiać programy @code{gawk}; zawiera
                                składnię wiersza poleceń.
* Jednorazowe::                 Uruchamianie krótkich jednorazowych
                                programów @code{awk}.
* Czytanie z terminala::        Niestosowanie plików wejściowych (pobieranie
                                wejścia z terminala).
* Długie::                      Umieszczanie stałych programów @code{awk}
                                w plikach.
* Skrypty wykonywalne::         Tworzenie samodzielnych programów @code{awk}.
* Komentarze::                  Dodawanie dokumentacji do programów @code{gawk}.
* Bardzo prosty::               Bardzo prosty przykład.
* Dwie reguły::                 Mniej prosty jednolinijkowy przykład z
                                dwoma regułami.
* Trudniejszy::                 Bardziej złożony przykład.
* Instrukcje/wiersze::          Podział lub łączenie instrukcji w wierszach.
* Inne cechy::                  Inne cechy @code{awk}.
* Kiedy::                       Kiedy stosować @code{gawk} a kiedy inne rzeczy.
* Używanie regexp::             Jak stosować wyrażenia regularne.
* Sekwencje specjalne::         Jak wypisać znaki niedrukowalne.
* Operatory regexp::            Operatory wyrażeń regularnych.
* Operatory regexp GNU::        Operatory specyficzne dla programów GNU.
* Wielkość liter::              Uwzględnianie wielkości liter w dopasowaniach.
* Lewe najdłuższe::             Jak bardzo pasuje tekst.
* Regexp obliczane::            Stosowanie dynamicznych wyrażeń regularnych.
* Rekordy::                     Sterowanie podziałem danych na rekordy.
* Pola::                        Wprowadzenie do pól.
* Pola nie-stałe::              Numery pól nie będące stałymi.
* Zmiana pól::                  Zmiana zawartości pól.
* Separatory pól::              Separator pól. Jak go zmienić.
* Podstawy podziału na pola::   W jaki sposób pola dzielone są przez
                                pojedyncze znaki lub proste łańcuchy.
* Regexp w podziale na pola::   Stosowanie wyrażeń regularnych do podziału
                                na pola.
* Pola jednoznakowe::           Jak z każdego znaku zrobić osobne pole.
* Separator pól w wierszu poleceń:: Ustalanie @code{FS} z wiersza poleceń.
* Podsumowanie podziału na pola:: Kwestie końcowe i tablica podsumowująca.
* Stały rozmiar::               Czytanie danych o stałej szerokości.
* Wiele wierszy::               Czytanie rekordów wielowierszowych.
* Getline::                     Odczyt plików pod bezpośrednią kontrolą
                                programu przy wykorzystaniu funkcji
                                @code{getline}.
* Wstęp do getline::            Wprowadzenie do funkcji @code{getline}.
* Zwykłe getline::              Użycie @code{getline} bez argumentów.
* Getline/Zmienna::             Użycie @code{getline} do zmiennej.
* Getline/Plik::                Użycie @code{getline} z pliku.
* Getline/Zmienna/Plik::        Użycie @code{getline} z pliku do zmiennej.
* Getline/Potok::               Użycie @code{getline} z potoku.
* Getline/Zmienna/Potok::       Użycie @code{getline} z potoku do zmiennej.
* Podsumowanie getline::        Podsumowanie wariantów @code{getline}.
* Print::                       Instrukcja @code{print}.
* Przykłady print::             Proste przykłady instrukcji @code{print}.
* Separatory wyjścia::          Separatory wyjścia. Jak je zmieniać.
* OFMT::                        Sterowanie wyjściem numerycznym przez @code{print}.
* Printf::                      Instrukcja @code{printf}.
* Podstawy printf::             Składnia instrukcji @code{printf}.
* Litery sterujące::            Litery sterujące formatem.
* Modyfikatory formatu::        Modyfikatory w specyfikacji formatu.
* Przykłady printf::            Kilka przykładów.
* Przekierowanie::              Jak przekierowywać wyjście do wielu plików
                                czy potoków.
* Pliki specjalne::             Interpretacja nazw plików przez @code{gawk}.
                                @code{gawk} pozwala na dostęp
                                do odziedziczonych deskryptorów plików.
* Zamykanie plików i potoków::  Zamykanie potoków oraz plików wejściowych
                                i wyjściowych.
* Stałe::                       Stałe łańcuchowe, numeryczne i regexp.
* Stałe skalarne::              Stałe numeryczne i łańcuchowe.
* Stałe regexp::                Wyrażenia regularne stałe.
* Używanie stałych regexp::     Kiedy i stosować stałe regexp.
* Zmienne::                     Zmienne dają nazwy wartościom do późniejszego
                                użytku.
* Używanie zmiennych::          Stosowanie zmiennych we własnych programach.
* Opcje przypisywania::         Nadawanie wartości zmiennym w wierszu
                                poleceń. Podsumowanie składni wiersza
                                poleceń. To zaawansowana metoda wprowadzania.
* Konwersja::                   Przekształcanie łańcuchów na liczby
                                i odwrotnie.
* Operatory arytmetyczne::      Operacje arytmetyczne (@samp{+}, @samp{-}, itd.)
* Konkatenacja::                Sklejanie łańcuchów.
* Operatory przypisania::       Zmienianie wartości zmiennej lub pola.
* Operatory inkrementacji::     Zwiększanie numerycznej wartości zmiennej.
* Wartości prawdy::             Co jest ``prawdziwe'' a co ``fałszywe''.
* Typy i porównania::           Jak zmienne otrzymują typy. Jak to wpływa na
                                porównania liczb i łańcuchów przez @samp{<},
                                itd.
* Operatory logiczne::          Łącznie wyrażeń porównania za pomocą
                                operatorów logicznych @samp{||} (``or''),
                                @samp{&&} (``and'') i @samp{!} (``not'').
* Wyrażenia warunkowe::         Wyrażenia warunkowe wybierają między dwoma
                                podwyrażeniami pod kontrolą trzeciego.
* Wywołania funkcji::           Wywołanie funkcji jest wyrażeniem.
* Priorytet::                   Jak łączą się różne operatory.
* Przegląd wzorców::            Co wchodzi w skład wzorca.
* Rodzaje wzorców::             Lista wszystkich rodzajów wzorców.
* Wzorce regexp::               Używanie wyrażeń regularnych jako wzorców.
* Wyrażenia wzorcami::          Jako wzorzec może być użyte dowolne wyrażenie.
* Zakresy::                     Para wzorców określa zakres rekordów.
* BEGIN/END::                   Podawanie reguł inicjujących i kończących.
* Używanie BEGIN/END::          Jak i dlaczego korzystać z reguł BEGIN/END.
* I/O i BEGIN/END::             Kwestie I/O w regułach BEGIN/END.
* Pusty::                       Pusty wzorzec, który dopasowuje każdy rekord.
* Przegląd akcji::              Co wchodzi w skład akcji.
* Instrukcja if::               Warunkowe wykonanie pewnych instrukcji @code{awk}.
* Instrukcja while::            Pętla dopóki jest spełniony warunek.
* Instrukcja do::               Wykonywanie w pętli zadanej akcji aż do
                                spełnienia pewnego warunku.
* Instrukcja for::              Inna instrukcja pętli, która zapewnia
                                klauzule inicjalizacji i inkrementacji.
* Instrukcja break::            Natychmiastowe opuszczenie najbardziej
                                wewnętrznej obejmującej pętli.
* Instrukcja continue::         Skok na koniec najbardziej wewnętrznej
                                obejmującej pętli.
* Instrukcja next::             Zakończenie przetwarzania bieżącego
                                rekordu wejściowego.
* Instrukcja nextfile::         Zakończenie przetwarzania bieżącego pliku.
* Instrukcja exit::             Zakończenie wykonywania @code{awk}.
* Modyfikowalne::               Zmienne wbudowane, którymi sterujemy
                                pracą @code{awk}.
* Auto-ustalane::               Zmienne wbudowane, w których @code{awk}
                                udostępnia różne informacje.
* ARGC i ARGV::                 Metody korzystania z @code{ARGC} i @code{ARGV}.
* Wprowadzenie do tablic::      Wprowadzenie do tablic.
* Odwołania do elementów::      Jak zbadać pojedynczy element tablicy.
* Przypisania do elementów::    Jak zmienić element tablicy.
* Przykład tablicy::            Prosty przykład tablicy.
* Przeglądanie tablic::         Odmiana instrukcji @code{for}. Wykonuje
                                pętlę po indeksach elementów tablicy.
* Delete::                      Instrukcja @code{delete} usuwa element z tablicy.
* Numeryczne indeksy tablic::   Jak w @code{awk} wykorzystywać liczby
                                jako indeksy.
* Niezainicjowane indeksy::     Stosowanie niezainicjowanych zmiennych
                                jako indeksów.
* Wielowymiarowe::              Emulacja tablic wielowymiarowych w @code{awk}.
* Przeglądanie wielowymiarowych:: Przeglądanie tablic wielowymiarowych.
* Efektywność tablic::            Specjalne wskazówki dotyczące @code{gawk}.
* Wywoływanie wbudowanych::     Jak wywoływać funkcje wbudowane.
* Funkcje numeryczne::          Funkcje działające na liczbach, m.in.
                                @code{int}, @code{sin} i @code{rand}.
* Funkcje łańcuchowe::          Funkcje do działań na łańcuchach, jak
                                @code{split}, @code{match} i @code{sprintf}.
* Funkcje I/O::                 Funkcje obsługi plików i poleceń powłoki.
* Funkcje czasu::               Funkcje do pracy ze znacznikami czasu.
* Składnia definicji::          Jak pisać definicje i co one znaczą.
* Przykład definicji::          Przykład definicji funkcji i co ona robi.
* Pułapki funkcji::             Rzeczy, na które lepiej uważać.
* Instrukcja return::           Określanie wartości, jaką zwraca funkcja.
* Opcje::                       Opcje wiersza poleceń i ich znaczenie.
* Inne argumenty::              Nazwy plików wejściowych i przypisania
                                zmiennych.
* Zmienna AWKPATH::             Katalogi przeszukiwania dla programów @code{awk}.
* Przestarzałe::                Przestarzałe opcje i/lub cechy.
* Nieudokumentowane::           Nieudokumentowane opcje i cechy.
* Znane błędy::                 Znane błędy @code{gawk}.
* Uwagi o przenośności::        Co zrobić, jeśli nie mamy @code{gawk}.
* Funkcja nextfile::            Dwie implementacje funkcji @code{nextfile}.
* Funkcja assert::              Funkcja do obsługi asercji w programach @code{awk}.
* Funkcja round::               Funkcja do zaokrąglania jeśli @code{sprintf}
                                nie robi tego poprawnie.
* Funkcje porządku::            Funkcje do stosowania znaków jako liczb
                                i odwrotnie.
* Funkcja join::                Funkcja do łączenia tablicy w łańcuch.
* Funkcja mktime::              Funkcja do przekształcania daty
                                w znacznik czasu.
* Funkcja gettimeofday::        Funkcja do pobierania sformatowanych czasów.
* Funkcja filetrans::           Funkcja obsługi przejść między plikami.
* Funkcja getopt::              Funkcja do przetwarzania argumentów wiersza
                                poleceń.
* Funkcje passwd::              Funkcje do pobierania danych o użytkownikach.
* Funkcje group::               Funkcje do pobierania danych o grupach.
* Nazwy biblioteczne::          Jak najlepiej nazywać prywatne zmienne
                                globalne w funkcjach bibliotecznych.
* Klony::                       Klony typowych narzędzi.
* Program cut::                 Narzędzie @code{cut}.
* Program egrep::               Narzędzie @code{egrep}.
* Program id::                  Narzędzie @code{id}.
* Program split::               Narzędzie @code{split}.
* Program tee::                 Narzędzie @code{tee}.
* Program uniq::                Narzędzie @code{uniq}.
* Program wc::                  Narzędzie @code{wc}.
* Rozmaite programy::           Parę interesujących programów @code{awk}.
* Program dupword::             Znajdowanie w dokumencie zdublowanych wyrazów.
* Program alarm::               Budzik.
* Program translate::           Program podobny do narzędzia @code{tr}.
* Program labels::              Drukowanie etykiet adresowych.
* Sortowanie wyrazów::          Program do tworzenia statystyki wyrazów.
* Sortowanie historii::         Usuwanie zdublowanych pozycji z pliku historii.
* Program extract::             Wyciąganie programów z plików
                                źródłowych Texinfo.
* Prosty sed::                  Prosty edytor strumieniowy.
* Program igawk::               Interfejs dla @code{awk}, który dołącza pliki.
* V7/SVR3.1::                   Główne zmiany między V7 a System V Release 3.1.
* SVR4::                        Pomniejsze zmiany między System V Release 3.1
                                a Release 4.
* POSIX::                       Nowe cechy ze standardu POSIX.
* BTL::                         Nowe cechy z wersji @code{awk} z Bell
                                Laboratories.
* POSIX/GNU::                   Rozszerzenia w @code{gawk} nie występujące
                                w POSIX @code{awk}.
* Podsumowanie wiersza poleceń:: Streszczenie wiersza poleceń.
* Podsumowanie języka::         Zwięzły przegląd języka.
* Zmienne/Pola::                Zmienne, pola i tablice.
* Podsumowanie pól::            Podział na pola wejściowe.
* Podsumowanie wbudowanych::    Zmienne wbudowane @code{awk}.
* Podsumowanie tablic::         Stosowanie tablic.
* Podsumowanie typów danych::   Wartości w @code{awk} są liczbami
                                lub łańcuchami.
* Podsumowanie reguł::          Wzorce i akcje, i ich części składowe.
* Podsumowanie wzorców::        Krótki przegląd wzorców.
* Podsumowanie regexp::         Krótki przegląd wyrażeń regularnych.
* Podsumowanie akcji::          Krótki przegląd akcji.
* Podsumowanie operatorów::     Operatory @code{awk}.
* Podsumowanie sterowania::     Instrukcje sterujące.
* Podsumowanie I/O::            Instrukcje wejścia/wyjścia.
* Podsumowanie printf::         Podsumowanie @code{printf}.
* Podsumowanie plików specjalnych:: Interpretowane wewnętrznie specjalne
                                nazwy plików.
* Podsumowanie funkcji wbudowanych:: Wbudowane funkcje numeryczne
                                i łańcuchowe.
* Podsumowanie funkcji czasu::  Wbudowane funkcje czasu.
* Podsumowanie stałych łańcuchowych:: Sekwencje specjalne w łańcuchach.
* Podsumowanie funkcji::        Definiowanie i wywoływanie funkcji.
* Cechy historyczne::           Nieudokumentowane, ale obsługiwane
                                ``możliwości''.
* Dystrybucja gawk::            Co jest w dystrybucji @code{gawk}.
* Pozyskiwanie::                Jak pozyskać dystrybucyjnę.
* Rozpakowywanie::              Jak rozpakować pakiet dystrybucyjny.
* Zawartość pakietu dystrybucyjnego:: Co jest w dystrybucji.
* Instalacja na Uniksie::       Instalowanie @code{gawk} na różnych wersjach
                                Uniksa.
* Szybka instalacja::           Kompilowanie @code{gawk} na Uniksie.
* Filozofia konfigurowania::    Jak to wszystko powinno działać.
* Instalacja na VMS::           Instalowanie @code{gawk} na VMS.
* Kompilacja na VMS::           Jak skompilować @code{gawk} na VMS.
* Szczegóły instalowania na VMS:: Jak zainstalować @code{gawk} na VMS.
* Uruchamianie na VMS::         Jak uruchamiać @code{gawk} na VMS.
* VMS POSIX::                   Alternatywne instrukcje dla VMS POSIX.
* Instalacja na PC::            Instalowanie i kopiowanie @code{gawk}
                                na MS-DOS i OS/2
* Instalacja na Atari::         Instalowanie @code{gawk} na Atari ST.
* Kompilowanie na Atari::       Kompilowanie @code{gawk} na Atari.
* Użytkowanie na Atari::        Uruchamianie @code{gawk} na Atari.
* Instalacja na Amidze::        Instalowanie @code{gawk} na Amidze.
* Błędy::                       Zgłaszanie problemów i błędów.
* Inne wersje::                 Inne wolnodostępne implementacje @code{awk}.
* Tryb zgodności::              Jak wyłączyć pewne rozszerzenia @code{gawk}.
* Uzupełnienia::                Tworzenie uzupełnień @code{gawk}.
* Dodawanie kodu::              Dodawanie kodu do głównego ciała @code{gawk}.
* Nowe przeniesienia::          Przenoszenie @code{gawk} na nowy system
                                operacyjny.
* Przyszłe rozszerzenia::       Nowe możliwości, które kiedyś mogą zostać
                                wprowadzone.
* Usprawnienia::                Sugestie usprawnień, jakie mogą wykonać
                                ochotnicy.
@end menu

@c dedication for Info file
@ifinfo
@center Miriam, za dopełnianie mnie.
@sp 1
@center Chanie, za radość jaką nam przyniosłaś.
@sp 1
@center Ryfce, za wykładniczy wzrost.
@sp 1
@center Nachumowi, za dodany wymiar.
@sp 1
@center Malce, za nowy początek.
@end ifinfo

@node Przedmowa, Czym jest awk, Top, Top
@unnumbered Przedmowa

@c I saw a comment somewhere that the preface should describe the book itself,
@c and the introduction should describe what the book covers.

Niniejsza książka uczy języka @code{awk} i jego efektywnego wykorzystania.
Powinieneś być już zaznajomiony z podstawowymi poleceniami systemu poleceń,
jak @code{cat} i @code{ls},@footnote{Polecenia te są dostępne w systemach
zgodnych z POSIX, jak też na tradycyjnych systemach opartych o UNIX.  Jeżeli
posługujesz się jakimś innym systemem operacyjnym, powinieneś przynajmniej
znać koncepcje przekierowania wejścia/wyjścia i potoków.} oraz podstawowymi
możliwościami powłoki, jak przekierowanie wejścia/wyjścia i potoki.

Implementacje języka @code{awk} dostępne są dla wielu różnych
środowisk obliczeniowych.  Niniejsza książka, mimo iż opisuje ogólnie język,
omawia także konkretną implementację @code{awk} o nazwie @code{gawk}
(co oznacza ``GNU Awk'').  @code{gawk} działa na szerokim spektrum systemów
uniksowych, począwszy od komputerów PC opartych na 80386, po wielkoskalowe
systemy, jak maszyny Cray.
@code{gawk} przeniesiono również na MS-DOS i OS/2 z PC, mikrokomputery Atari
i Amiga, oraz VMS.

@menu
* Historia::                    Historia @code{gawk} i @code{awk}.
* Historia podręcznika::        Krótka historia projektu GNU i niniejszej
                                książki.
* Podziękowania::               Podziękowania.
* Od tłumacza::                 Parę słów od tłumacza.
@end menu

@node Historia, Historia podręcznika, Przedmowa, Przedmowa
@unnumberedsec Historia @code{awk} i @code{gawk}

@cindex akronim
@cindex historia @code{awk}
@cindex Aho, Alfred
@cindex Weinberger, Peter
@cindex Kernighan, Brian
@cindex stary @code{awk}
@cindex nowy @code{awk}
Nazwa @code{awk} pochodzi od inicjałów jego projektantów:  Alfreda V.@:
Aho, Petera J.@: Weinbergera i Briana W.@:  Kernighana.  Pierwotna wersja
@code{awk} została napisana w 1977 roku w AT&T Bell Laboratories.
W 1985 nowa wersja uczyniła ten język programowania potężniejszym,
wprowadzając funkcje definiowane przez użytkownika, wiele strumieni
wejściowych i obliczane wyrażenia regularne.  Ta nowa wersja stała się
ogólnie dostępna z Unix System V Release 3.1.  Wersja w System V Release 4
dodała kilka nowych cech jak również oczyściła zachowanie w niektórych
``ciemnych kątach'' języka.  Późniejsza specyfikacja @code{awk}
w standardzie POSIX Command Language and Utilities objaśniła język w oparciu
o opinie zarówno projektantów @code{gawk}, jak i projektantów pierwotnego
@code{awk} z Bell Labs.

Implementacja GNU, @code{gawk}, została napisana w 1986 przez Paula Rubina
i Jay Fenlason, z poradą Richarda Stallmana.  John Woods również wniósł
część kodu.  W 1988 i 1989 David Trueman z pomocą Arnolda Robbinsa,
gruntownie przeredagowali @code{gawk} w kierunku zgodności z nowszym
@code{awk}.  Obecny rozwój koncentruje się na usuwaniu błędów, poprawie
efektywności, zgodności ze standardami i, od czasu do czasu, nowych cechach.

@node Historia podręcznika, Podziękowania, Historia, Przedmowa
@unnumberedsec Projekt GNU i ta książka

@cindex Free Software Foundation
@cindex Stallman, Richard
Free Software Foundation (FSF) jest organizacją non-profit, której
celem jest tworzenie i rozpowszechnianie swobodnie dostępnego
oprogramowania.  Została założona przez Richarda M.@:  Stallmana, autora
oryginalnego edytora Emacs.  GNU Emacs jest obecnie najszerzej używaną
wersją Emacsa.

@cindex GNU, Projekt
@cindex Projekt GNU
Projekt GNU jest nieustającym wysiłkiem ze strony Free Software
Foundation by stworzyć pełne, swobodnie dostępne, zgodne z POSIX środowisko
obliczeniowe.  (GNU oznacza ``GNU's not Unix'' -- GNU to nie Unix.)
W celu zagwarantowania, że kod źródłowy ich oprogramowania będzie
zawsze dostępny dla użytkownika, FSF stosuje ``Powszechną Licencję Publiczną
GNU'' (``GNU General Public License'' lub GPL).  Dla informacji czytelnika
dołączono tu egzemplarz GPL
(@pxref{Kopiowanie, ,GNU GENERAL PUBLIC LICENSE}).
GPL ma zastosowanie w odniesieniu do kodu źródłowego @code{gawk} w języku C.

Zostały ukończone i są swobodnie dostępne: powłoka, edytor (Emacs), wysoce
przenośne optymalizujące kompilatory C, C++ i C-obiektowego, debuger
symboliczny i  dziesiątki wielkich i małych narzędzi (jak @code{gawk}).
W momencie pisania (początek 1997) tej książki, jądro systemu operacyjnego
GNU (HURD), zostało już wydane, ale wciąż jest na wczesnym etapie rozwoju.

@cindex Linux
@cindex NetBSD
@cindex FreeBSD
Dopóki system operacyjny GNU nie zostanie pełniej rozwinięty, powinieneś
rozważyć używanie Linuksa, swobodnie dostępnego, uniksopodobnego systemu
operacyjnego na 80386, DEC Alpha, Sun SPARC i inne systemy.
Istnieje wiele książek o Linuksie.  Jedną ze wolnodostępnych jest
@cite{Linux Installation and Getting Started}, Matta Welsha.  Dostępnych
jest wiele dystrybucji Linuksa, często w sklepach komputerowych lub na
CD-ROM w komplecie z książkami o Linuksie.  (Istnieją trzy inne swobodnie
dostępne, uniksopodobne systemy operacyjne na 80386 i inne systemy, NetBSD,
FreeBSD i OpenBSD.
Wszystkie oparte są o 4.4-Lite Berkeley Software Distribution i
wykorzystują najświeższe wersje @code{gawk} jako swoje wersje @code{awk}.)

@iftex
Książka, którą teraz czytasz jest w rzeczywistości darmowa.  Zawarte w niej
informacje są swobodnie dostępne dla każdego. Nadający się do przetwarzania
automatycznego kod źródłowy tej książki dostarczany jest z @code{gawk},
a każdy może wziąć ją na kopiarkę i zrobić sobie tyle kopii ile zechce.
(Poświęć chwilę na sprawdzenie zezwolenia na kopiowanie na stronie z prawami
autorskimi.)

Jeżeli zapłaciłeś za tę książkę, to faktycznie zapłaciłeś za jej ładne
wydrukowanie i oprawienie, i pokrycie związanych z jej produkcją kosztów
wydawcy.  Dołożyliśmy starań, by utrzymać te koszty na rozsądnym poziomie;
większość osób woli oprawioną książkę niż ponad 330 stron zkserowanych
stron, które następnie muszą być trzymane w skoroszycie (nie wspominając
o czasie i pracy włożonej w kopiowanie).
To samo dotyczy tworzenia tej książki ze źródła nadającego się
do automatycznego przetworzenia; cena detaliczna jest tylko nieco wyższa
od kosztu wydrukowania jej na drukarce laserowej.
@end iftex

Sama książka przeszła kilka poprzednich, wstępnych wydań.  Jesienią 1988
rozpocząłem pracę od wstępnego szkicu podręcznika @cite{The GAWK Manual},
Diany Close, Paula Rubin i Richarda Stallmana.  Miał on około 90 stron,
i ledwie opisywał pierwotną, ``starą'' wersję @code{awk}.
Po znaczących korektach, pierwszą wersją @cite{The GAWK Manual}, jaką wydano
była Edycja 0.11 Beta w październiku 1989.  Następnie podręcznik przeszedł
bardziej znaczne zmiany w Edycji 0.13 z grudnia 1991.
David Trueman, Pat Rankin i Michal Jaegermann wnieśli swoje sekcje do
podręcznika w Edycji 0.13.  Została ona opublikowana przez FSF w formie
drukowanej książki na początku 1992.  Od tej pory było kilka pomniejszych
wydań, by wymienić Edycję 0.14 z listopada 1992, opublikowaną przez FSF
w styczniu 1993, i Edycję 0.16 z sierpnia 1993.

Edycja 1.0 @cite{@value{TITLE}} jest w istotny sposób ponownym opracowaniem
@cite{The GAWK Manual}, z dużą ilością dodatkowego materiału.
FSF i ja zgodziliśmy się, że teraz ja jestem głównym autorem.
Czułem też, że potrzebuje ona bardziej opisowego tytułu.

@cite{@value{TITLE}} będzie bez wątpienia nadal się rozwijać.
Elektroniczna wersja dołączana jest do dystrybucji @code{gawk} z FSF.
Jeśli znajdziesz błąd w tej książce, proszę powiadom o nim!
@xref{Błędy, ,Zgłaszanie problemów i błędów}, gdzie podano
informacje na temat elektronicznego przesyłania zgłoszeń o błędach, albo
napisz do mnie w zastępstwie FSF.

@node Podziękowania, Od tłumacza, Historia podręcznika, Przedmowa
@unnumberedsec Podziękowania

@cindex Stallman, Richard
Chciałbym podziękować Richardowi M.@: Stallmanowi, za jego wizję lepszego
świata, i za jego odwagę w założeniu FSF i rozpoczęciu projektu GNU.

Początkowy szkic podręcznika @cite{The GAWK Manual} zawierał następujące
podziękowania:

@quotation
Podziękowanie za pomoc w stworzeniu tego podręcznika należy się wielu
ludziom.
Jay Fenlason wniósł wiele pomysłów i przykładowych programów.
Richard Mlynarik i Robert Chassell dali pomocne komentarze do
wersji roboczych tego podręcznika.
Dokument @cite{A Supplemental Document for @code{awk}} autorstwa
Johna W.@: Pierce'a z Wydziału Chemii UC w San Diego, zwrócił uwagę na kilka
kwestii związanych zarówno z implementacją @code{awk} jak i niniejszym
podręcznikiem, które inaczej by nam umknęły.
@end quotation

Niżej wymienieni ludzie dostarczyli wielu pomocnych komentarzy dotyczących
Edycji 0.13 podręcznika @cite{The GAWK Manual}: Rick Adams, Michael
Brennan, Rich Burridge, Diane Close, Christopher (``Topher'') Eliot, Michael
Lijewski, Pat Rankin, Miriam Robbins i Michal Jaegermann.

Poniższe osoby dostarczyły wielu pomocnych komentarzy dotyczących
Edycji 1.0 podręcznika @cite{@value{TITLE}}: Karl Berry, Michael Brennan,
Darrel Hankerson, Michal Jaegermann, Michael Lijewski i Miriam Robbins.
Pat Rankin, Michal Jaegermann, Darrel Hankerson i Scott Deifik
zaktualizowali własne odpowiednie sekcje w Edycji 1.0.

Robert J.@: Chassell dostarczył bardzo wartościowych porad dotyczących
posługiwania się Texinfo.  Należą mu się także specjalne podziękowania
za przekonanie mnie bym @emph{nie} zatytułował tej książki
@cite{How To Gawk Politely} (``Jak poprawnie gawkować'').  Karl Berry
znacząco pomógł przy @TeX{}-owej części Texinfo.

@cindex Trueman, David
Specjalne podziękowanie należy się Davidowi Truemanovi: był prawdziwym
strażnikiem rozwoju @code{gawk}, dzięki niemu program działa dobrze i bez
błędów.  Mimo iż nie jest już zaangażowany w prace przy @code{gawk},
praca z nim przy tym projekcie była prawdziwą przyjemnością.

@cindex Deifik, Scott
@cindex Hankerson, Darrel
@cindex Rommel, Kai Uwe
@cindex Rankin, Pat
@cindex Jaegermann, Michal
Scott Deifik, Darrel Hankerson, Kai Uwe Rommel, Pat Rankin i Michal
Jaegermann (niekoniecznie w tej kolejności) są długoletnimi członkami
``zespołu łamaczy d/s przenośności'' @code{gawk}.
@c   tłum: ``crack portability team''
Bez ich ciężkiej pracy i wsparcia @code{gawk} nie byłby nawet
w przybliżeniu tak wysokiej jakości programem jak jest obecnie.
Praca z tym zespołem wspaniałych ludzi była i jest przyjemnością.

@cindex Friedl, Jeffrey
Jeffrey Friedl wniósł nieocenioną pomoc przy wyłapywaniu wielu problemów,
jakie pojawiły się ostatniej chwili w wyrażeniach regularnych
@code{gawk} 3.0.

@cindex Kernighan, Brian
David i ja chcielibyśmy podziękować Brianowi Kernighanowi z Bell Labs
za nieocenione wsparcie podczas testowania i debugowania @code{gawk} oraz
za pomoc w wyjaśnieniu mnóstwa kwestii dotyczących języka.  Bez jego
pomocy nie zdołalibyśmy wykonać nawet w przybliżeniu tak dobrej roboty,
zarówno przy @code{gawk} jak i dokumentacji.

@cindex Hughes, Phil
Chciałbym podziękować Marshallowi i Elaine Hartholz z Seattle oraz Dr.@:
Bertowi i Ricie Schreiber z Detroit za długie okresy spokojnych wakacji
w ich domach, które pozwoliły mi na dokonanie znaczącego postępu w pracy nad
tą książką i nad samym @code{gawk}.  Phil Hughes z SSC wniósł swój wkład
w bardzo istotny sposób, pożyczając mi swojego laptopa z systemem Linux,
nie tylko jednokrotnie, ale dwa razy, umożliwiając mi wykonanie mnóstwa
pracy gdy byłem poza domem.

@cindex Robbins, Miriam
Na koniec, muszę podziękować swojej wspaniałej żonie, Miriam, za cierpliwość
podczas wielu wersji tego projektu, za korekty i za dzielenie się mną
z komputerem.
Chciałbym podziękować swoim rodzicom za ich miłość i za dobroć, w której
mnie wychowali i wykształcili.
Muszę też wyrazić swą wdzięczność B-gu, za wiele okazji jakie zesłał
na mojej drodze i za dary jakie mi ofiarował, bym mógł z tych okazji
skorzystać.
@sp 2
@noindent
Arnold Robbins @*
Atlanta, Georgia @*
Luty 1997

@ignore
Rzeczy wciąż nigdzie nie omówione:
PODSTAWY:
   Całkowite a zmiennoprzecinkowe
   Szesnastkowo a ósemkowo, a dziesiętnie
   Interpreter a kompilator
   input/output
@end ignore

@node Od tłumacza, , Podziękowania, Przedmowa
@unnumberedsec Od tłumacza
Niniejszy przekład powstał
w ramach @uref{http://ptm.linux.pl/, Projektu Tłumaczenia Manuali}.
Zgłoszenia błędów, komentarze i sugestie
proszę przesyłać na listę dyskusyjną Projektu: @email{ptm@@amg.net.pl}
lub ewentualnie do autora tłumaczenia.

Polską wersję Powszechnej Licencji Publicznej GNU (GNU GPL) można znaleźć
na @uref{http://www.linux.org.pl/} oraz @uref{http://gnu.org.pl/}.
Proszę pamiętać, że pod względem prawnym obowiązująca jest wyłącznie
oryginalna, angielska wersja.  Stanowisko FSF w tej kwestii wyjaśniono
na stronie @uref{http://www.gnu.org/copyleft/copyleft.html}.

W.Kotwica (@email{wkotwica@@post.pl})

@unnumberedsubsec Rozpowszechnianie
To jest nieoficjalne tłumaczenie warunków rozpowszechniania na język polski.
Nie zostało ono opublikowane przez Free Software Foundation
i pod względem prawnym nie stanowi warunków rozpowszechniania -- ustanawia
je wyłącznie oryginalny tekst angielski.  Jednak tłumacz ma nadzieję, że
pomoże ono lepiej zrozumieć warunki rozpowszechniania osobom mówiącym
po polsku.

This is an unofficial translation of the distribution terms into
Polish language. It was not published by the Free Software Foundation, and
does not legally state the distribution terms--only the original English text
does that. However, the translator hopes that it will help Polish language
speakers understand distribution terms better.

Zezwala się na tworzenie i rozpowszechnianie wiernych kopii
tego podręcznika, pod warunkiem, że na wszystkich kopiach zostanie zachowana
informacja o prawach autorskich i niniejsze zezwolenie.

Zezwala się na kopiowanie i rozpowszechnianie zmienionych wersji
tego podręcznika na warunkach jak dla wiernych kopii, pod warunkiem, że
cała praca pochodna będzie rozpowszechniana na warunkach zezwolenia
identycznego jak niniejsze.

Zezwala się na kopiowanie i rozpowszechnianie tłumaczeń tego
podręcznika na inny język, pod wyżej podanymi warunkami dla zmienionych
wersji, z wyjątkiem tego, że niniejsze zezwolenie może być ustanowione
w tłumaczeniu zaakceptowanym przez Fundację.

@node Czym jest awk, Zaczynamy, Przedmowa, Top
@chapter Wstęp

Jeśli przypominasz wielu z użytkowników komputerów, to zapewne często
robisz zmiany w rozmaitych plikach tekstowych w miejscach, gdzie
występują pewne wzorce, lub wyłuskujesz dane z fragmentów pewnych wierszy
odrzucając resztę.  Napisanie wykonującego to programu w języku takim
jak C czy Pascal jest czasochłonne i niewygodne, może też pochłonąć wiele
linii kodu.  Zadanie może być łatwiejsze przy użyciu @code{awk}.

Narzędzie @code{awk} interpretuje specjalizowany język programowania,
umożliwiający obsługę prostych zadań reformatowania danych za pomocą
zaledwie kilku linii kodu.

Wykonana w ramach GNU implementacja @code{awk} nazywa się @code{gawk}.
Jest w pełni zgodna w górę z wersją @code{awk} z System V
Release 4.  @code{gawk} jest też zgodny w górę ze specyfikacją POSIX
języka @code{awk}.  To znaczy, że wszystkie poprawnie napisane programy
@code{awk} powinny działać z @code{gawk}.  Zatem, zwykle nie rozróżniamy
@code{gawk} i innych implementacji @code{awk}.

@cindex zastosowania @code{awk}
Stosując @code{awk} można:

@itemize @bullet
@item
zarządzać małymi, osobistymi bazami danych

@item
generować raporty

@item
sprawdzać poprawność danych

@item
tworzyć indeksy i wykonywać inne zadania przygotowywania dokumentów

@item
a nawet eksperymentować z algorytmami, które później mogą być zaadaptowane
do innych języków komputerowych
@end itemize

@menu
* Niniejszy podręcznik::        Posługiwanie się tą książką.  Zawiera
                                przykładowe pliki wejściowe.
* Konwencje::                   Konwencje typograficzne.
* Przykładowe pliki danych::    Przykładowe pliki danych do zastosowania
                                z programami @code{awk} pokazanymi
                                w tej książce.
@end menu

@node Niniejszy podręcznik, Konwencje, Czym jest awk, Czym jest awk
@section Posługiwanie się tą książką
@cindex książka, używanie niniejszej
@cindex używanie niniejszej książki
@cindex język, @code{awk}
@cindex program, @code{awk}
@ignore
@cindex @code{awk} język
@cindex @code{awk} program
@end ignore

Określenie @code{awk} odnosi się do konkretnego programu oraz do języka
używanego, by powiedzieć temu programowi, co ma zrobić.  Gdy potrzebujemy
być precyzyjni, nazywamy program ``narzędziem @code{awk}'' zaś język
``językiem @code{awk}''.  Określenie @code{gawk} odnosi się do wersji
@code{awk} wykonanej jako część projektu GNU.  Celem tej książki
jest objaśnienie zarówno języka @code{awk} jak i sposobu uruchamiania
narzędzia @code{gawk}.

Głównym celem tej książki jest wyjaśnienie możliwości @code{awk}
zdefiniowanych w standardzie POSIX.  Zrobiono to w kontekście jednej
konkretnej implementacji, @code{gawk}.  Równocześnie usiłowano także opisać
istotne różnice pomiędzy @code{gawk} a innymi implementacjami @code{awk}.
I na koniec, odnotowano wszelkie cechy @code{gawk} nie istniejące
w standardzie POSIX dla @code{awk}.

@iftex
Niniejsza książka ma trudne zadanie bycia zarówno podręcznikiem jak
i informatorem.  Jeżeli jesteś nowicjuszem, możesz swobodnie pominąć
szczegóły, które wydają się zbyt skomplikowane.  Powinieneś też zignorować
wiele odsyłaczy.  Są one przeznaczone dla doświadczonych użytkowników
i wersji interaktywnej tego dokumentu w postaci Info.
@end iftex

Określenie @dfn{program @code{awk}} odnosi się do programu napisanego
w języku programowania @code{awk}.

@xref{Zaczynamy, ,Zaczynamy pracę z @code{awk}}, gdzie znaleźć
można same podstawy niezbędne do rozpoczęcia pracy z @code{awk}.

Dołączono nieco przydatnych ``jednolinijkowców'', by dać pojęcie o języku
@code{awk} (@pxref{Jednolinijkowce, ,Przydatne programy jednolinijkowe}).

Podano tu też wiele przykładowych programów @code{awk}
(@pxref{Funkcje biblioteczne, ,Biblioteczka funkcji @code{awk}}; również
@pxref{Przykładowe programy, ,Praktyczne programy @code{awk}}).

Całość języka @code{awk} podsumowano w krótkim informatorze
@ref{Podsumowanie gawk, ,Podsumowanie @code{gawk}}.  Zaglądnij tam, jeśli potrzebujesz
przypomnieć sobie jakąś konkretną cechę.

Jeżeli napotkasz termin, który nie jest ci znany, spróbuj poszukać go
w słowniku (@pxref{Słownik}).

W większości przypadków jako przykłady zastosowano kompletne programy
@code{awk}, ale w kilku bardziej zaawansowanych sekcjach pokazano tylko
część programu, ilustrującą opisywane pojęcie.

Mimo, że książka ta zasadniczo skierowana jest do osób, które nie spotkały
się dotąd z @code{awk}, zawiera też wiele informacji, które nawet
ekspert w @code{awk} powinien uznać za przydatne.  W szczególności,
zainteresować powinien opis POSIX @code{awk} i przykładowe programy w
@ref{Funkcje biblioteczne, ,Biblioteczka funkcji @code{awk}}, a także
@ref{Przykładowe programy, ,Praktyczne programy @code{awk}}.

@c fakenode --- for prepinfo
@unnumberedsubsec Ciemne kąty
@display
@i{Kto uchylił to okno?!?}
Hrabia Dracula
@end display
@sp 1

@cindex c.k., zobacz ``ciemny kąt''
@cindex ciemny kąt
Do powstania standardu POSIX (i @cite{The Gawk Manual}), wiele cech @code{awk}
było albo słabo udokumentowanych, albo w ogóle nie udokumentowanych.  Opisy
takich cech (często zwanych ``ciemnymi kątami'' -  ``dark corners'') odnotowane
są w niniejszej książce za pomocą ``(c.k.)''.
Pojawiają się też w indeksie pod hasłem ``ciemny kąt''.

@node Konwencje, Przykładowe pliki danych, Niniejszy podręcznik, Czym jest awk
@section Konwencje typograficzne

Książkę tę napisano za pomocą Texinfo, języka formatowania dokumentacji
GNU. Pojedynczy plik źródłowy Texinfo służy do utworzenia zarówno wersji
drukowanej dokumentacji jak i wersji interaktywnej.
@iftex
Z tego powodu, konwencje typograficzne są nieco odmienne niż w innych
książkach, które zapewne czytałeś.
@end iftex
@ifinfo
Ta sekcja pokrótce opisuje konwencje typograficzne stosowane w Texinfo.
@end ifinfo

Przykłady wpisywane w wierszu poleceń poprzedzane są standardowymi symbolami
zachęty powłoki, głównym i pomocniczym, @samp{$} i @samp{>}.
Wyjście poleceń poprzedzane jest glifem ``@print{}''.
Typowo reprezentuje on standardowe wyjście danego polecenia.
Komunikaty o błędach i inne wyniki na standardowym wyjściu błędów poprzedzane
są glifem ``@error{}''.  Na przykład:

@example
@group
$ echo hi on stdout
@print{} hi on stdout
$ echo hello on stderr 1>&2
@error{} hello on stderr
@end group
@end example

@c HQ @iftex
W tekście nazwy poleceń pojawiają się @code{tą czcionką}, podczas gdy
fragmenty kodu pojawiają się tą samą czcionką i cytowane @samp{w ten
sposób}.  Pewne rzeczy będą uwydatnione  @emph{jak ta}, a jeśli istotna
kwestia musi być szczególnie podkreślona, będzie to zrobione @strong{właśnie
tak}.  Pierwsze wystąpienie nowego określenia zwykle jest jego
@dfn{definicją} i pojawia się napisane tą samą czcionką, co poprzednie
wystąpienie ``definicji'' w tym zdaniu. Nazwy plików wskazywane są tak:
@file{/sciezka/do/pliku}.
@c HQ @end iftex

Znaki wpisywane z klawiatury wyglądają @kbd{w ten sposób}.  W szczególności,
istnieją znaki specjalne zwane ``znakami sterującymi'' (``control
characters'').  Są one znakami wprowadzanymi przez równoczesne przytrzymanie
klawisza @kbd{CONTROL} i innego klawisza.  Na przykład, @kbd{Control-d}
wprowadzane jest przez najpierw naciśnięcie i przytrzymanie klawisza
@kbd{CONTROL}, następnie naciśnięcie klawisza @kbd{d}, i na koniec puszczenie
obu klawiszy.

@node Przykładowe pliki danych,  , Konwencje, Czym jest awk
@section Pliki danych do przykładów

@cindex plik wejściowy, przykład
@cindex przykład pliku wejściowego
@cindex plik @file{BBS-list}
@cindex @file{BBS-list}, plik
Wiele przykładów w tej książce pobiera dane wejściowe z dwu przykładowych
plików danych.  Pierwszy, o nazwie @file{BBS-list}, reprezentuje zestawienie
systemów elektronicznych tablic ogłoszeniowych (BBS), z informacją o tych systemach.
Drugi plik danych, o nazwie @file{inventory-shipped}, zawiera dane
o wysyłkach towarów w kolejnych miesiącach.  W obu plikach każdy wiersz
uważany jest za jeden @dfn{rekord}.

W pliku @file{BBS-list}, każdy rekord zawiera nazwę komputera prowadzącego
BBS, jego numer telefonu, prędkość (prędkości) transmisji w bodach i kod
oznaczający godziny, w jakich działa BBS.  Litera @samp{A} w ostatniej
kolumnie oznacza, że BBS działa 24 godziny na dobę.  @samp{B} w ostatniej
kolumnie oznacza, że BBS działa tylko wieczorami i w weekendy.  @samp{C}
oznacza, że funkcjonuje tylko w weekendy.

@c 2e: Update the baud rates to reflect today's faster modems
@example
@c system mkdir eg
@c system mkdir eg/lib
@c system mkdir eg/data
@c system mkdir eg/prog
@c system mkdir eg/misc
@c file eg/data/BBS-list
aardvark     555-5553     1200/300          B
alpo-net     555-3412     2400/1200/300     A
barfly       555-7685     1200/300          A
bites        555-1675     2400/1200/300     A
camelot      555-0542     300               C
core         555-2912     1200/300          C
fooey        555-1234     2400/1200/300     B
foot         555-6699     1200/300          B
macfoo       555-6480     1200/300          A
sdace        555-3430     2400/1200/300     A
sabafoo      555-2127     1200/300          C
@c endfile
@end example

@cindex plik @file{inventory-shipped}
@cindex @file{inventory-shipped}, plik
Drugi plik danych, o nazwie @file{inventory-shipped}, reprezentuje dane
o dostawach towarów w ciągu roku.
Każdy rekord zawiera odpowiednio miesiąc roku, liczbę wysłanych zielonych
skrzyń, liczbę wysłanych czerwonych skrzyń i liczbę wysłanych niebieskich
skrzyń.  Jest w nim 16 pozycji, obejmujących 12 miesięcy jednego roku
i cztery miesiące następnego.

@example
@c file eg/data/inventory-shipped
Jan  13  25  15 115
Feb  15  32  24 226
Mar  15  24  34 228
Apr  31  52  63 420
May  16  34  29 208
Jun  31  42  75 492
Jul  24  34  67 436
Aug  15  34  47 316
Sep  13  55  37 277
Oct  29  54  68 525
Nov  20  87  82 577
Dec  17  35  61 401

Jan  21  36  64 620
Feb  26  58  80 652
Mar  24  75  70 495
Apr  21  70  74 514
@c endfile
@end example

@ifinfo
Jeżeli czytasz to w GNU Emacsie przy użyciu Info, możesz skopiować obszary
tekstu pokazujące przykłady do własnych plików testowych.  W ten sposób
będziesz mógł wypróbować przykłady pokazane w dalszej części niniejszego dokumentu.
Wykonuje się to poleceniem @kbd{M-x write-region} kopiującym
tekst z pliku Info do pliku, który będzie używany z @code{awk}
(@xref{Misc File Ops, , Miscellaneous File Operations, emacs, GNU Emacs Manual}).
Wykorzystując tę informację, stwórz własne pliki
@file{BBS-list} i @file{inventory-shipped} i przećwicz to, czego nauczyłeś
się w tej książce.

Jeżeli używasz samodzielnej wersji Info, zobacz
@ref{Program extract, ,Wydzielanie programów z plików źródłowych Texinfo},
gdzie opisano program @code{awk}, który wydzieli powyższe pliki danych
z @file{gawk.texi}, pliku źródłowego Texinfo niniejszego pliku Info.
@end ifinfo

@node Zaczynamy, Jednolinijkowce, Czym jest awk, Top
@chapter Zaczynamy pracę z @code{awk}
@cindex skrypt, definicja
@cindex reguła, definicja
@cindex program, definicja
@cindex podstawowa funkcja @code{awk}

Podstawową funkcją @code{awk} jest wyszukiwanie w plikach wierszy (lub innych
jednostek tekstu) zawierających pewien wzorzec.  Gdy wiersz pasuje do jednego
ze wzorców, @code{awk} wykonuje na nim zadane akcje.
@code{awk} kontynuuje takie przetwarzanie wierszy wejściowych aż do
osiągnięcia końca plików wejściowych.

@cindex sterowane danymi, języki
@cindex proceduralne, języki
@cindex język, sterowany danymi
@cindex język, proceduralny
Programy w @code{awk} różnią się od programów w większości innych języków,
gdyż są @dfn{sterowane danymi} (data-driven): to znaczy, opisujemy dane,
z którymi chcemy pracować, a następnie co zrobić po ich znalezieniu.
Inne języki przeważnie są @dfn{proceduralne}; musimy opisać, bardzo
szczegółowo, każdy krok jaki ma być wykonany przez program.  Pracując w
językach proceduralnych zwykle dużo trudniej jest precyzyjnie opisać dane,
jakie będzie przetwarzał program.  Z tego powodu, programy @code{awk} są
często budująco łatwe zarówno w pisaniu jak i czytaniu.

@cindex program, definicja
@cindex reguła, definicja
Przy uruchamianiu @code{awk}, określa się @dfn{program} @code{awk}, mówiący
@code{awk}, co ma zrobić.  Program taki składa się z szeregu @dfn{reguł}.
(Może też zawierać @dfn{definicje funkcji}, zaawansowaną cechę, o której
na razie nie będziemy mówić.
@xref{Użytkownika, ,Funkcje użytkownika}.)  Każda reguła określa jeden
wzorzec jaki ma być szukany i jedną akcję jaka zostanie wykonana po
znalezieniu tego wzorca.

Składniowo, reguła składa się ze wzorca, po którym następuje akcja.  Akcja
ujęta jest w nawiasy klamrowe, co oddziela ją od wzorca.
Reguły są zwykle rozdzielane znakami nowej linii.  Stąd też program
@code{awk} wygląda tak:

@example
@var{wzorzec} @{ @var{akcja} @}
@var{wzorzec} @{ @var{akcja} @}
@dots{}
@end example

@menu
* Nazwy::                       Jakiej nazwy użyć, by znaleźć @code{awk}.
* Uruchamianie gawk::           Jak uruchamiać programy @code{gawk}; zawiera
                                składnię wiersza poleceń.
* Bardzo prosty::               Bardzo prosty przykład.
* Dwie reguły::                 Mniej prosty jednolinijkowy przykład z
                                dwoma regułami.
* Trudniejszy::                 Bardziej złożony przykład.
* Instrukcje/wiersze::          Podział lub łączenie instrukcji w wierszach.
* Inne cechy::                  Inne cechy @code{awk}.
* Kiedy::                       Kiedy stosować @code{gawk} a kiedy inne rzeczy.
@end menu

@node Nazwy, Uruchamianie gawk , Zaczynamy, Zaczynamy
@section Inne imię róży

@cindex stary @code{awk} a nowy @code{awk}
@cindex nowy @code{awk} a stary @code{awk}
Język @code{awk} rozwijał się przez wiele lat.  Pełne szczegóły podano w
@ref{Historia języka, ,Ewolucja języka @code{awk}}.
Język opisany w tej książce często określany jest jako ``nowy @code{awk}''.

Z tego powodu wiele systemów posiada kilka wersji @code{awk}.
Niektóre z systemów mają narzędzie @code{awk} implementujące pierwotną wersję
języka @code{awk} a narzędzie @code{nawk} do nowej wersji.  Inne mają
@code{oawk} dla ``starego (old) języka @code{awk}'' zaś zwykłe @code{awk} do
nowego.  Pozostałe wciąż maja tylko jedną wersję, zwykle
nową.@footnote{Często systemy te używają @code{gawk} do realizacji
swego @code{awk}!}

Wszystko to razem powoduje, że podczas pisania programów trudno powiedzieć,
jaką z wersji @code{awk} powinno się uruchomić.  Najlepszą radą, jaką
możemy tu podać, jest sprawdzenie lokalnej dokumentacji.  Szukaj @code{awk},
@code{oawk} i @code{nawk}, również @code{gawk}.  Możliwe, że masz w systemie
jakąś wersję nowego @code{awk}, i uruchamiając swoje programy właśnie jej
powinieneś używać.  (Oczywiście, jeżeli czytasz tę książkę, są duże szanse
na to, że masz @code{gawk}!)

W całej tej książce, odnosząc się do cechy języka, która powinna być dostępna
w każdej pełnej implementacji POSIX @code{awk}, używamy po prostu terminu
@code{awk}.  Pisząc o możliwości specyficznej dla implementacji GNU,
posługujemy się terminem @code{gawk}.

@node Uruchamianie gawk, Bardzo prosty, Nazwy, Zaczynamy
@section Jak uruchamiać programy @code{awk}

@cindex wiersz poleceń, formaty
@cindex uruchamianie programów @code{awk}
Istnieje kilka sposobów uruchamiania programu @code{awk}.  Jeśli program jest
krótki, najłatwiej zawrzeć go w wierszu poleceń uruchamiającym @code{awk},
w ten sposób:

@example
awk '@var{program}' @var{plik-wej1} @var{plik-wej2} @dots{}
@end example

@noindent
gdzie @var{program} składa się z szeregu wzorców i akcji, jak opisano
wcześniej. (Przyczyna użycia pojedynczych cudzysłowów jest opisana poniżej,
w @ref{Jednorazowe, ,Programy @code{awk} jednorazowego użytku}.)

Gdy program jest długi, zwykle wygodniej umieścić go w pliku i uruchamiać
w taki sposób:

@example
awk -f @var{plik-programu} @var{plik-wej1} @var{plik-wej2} @dots{}
@end example

@menu
* Jednorazowe::                 Uruchamianie krótkich jednorazowych
                                programów @code{awk}.
* Czytanie z terminala::        Niestosowanie plików wejściowych (pobieranie
                                wejścia z terminala).
* Długie::                      Umieszczanie stałych programów @code{awk}
                                w plikach.
* Skrypty wykonywalne::         Tworzenie samodzielnych programów @code{awk}.
* Komentarze::                  Dodawanie dokumentacji do programów @code{gawk}.
@end menu

@node Jednorazowe, Czytanie z terminala, Uruchamianie gawk, Uruchamianie gawk
@subsection Programy @code{awk} jednorazowego użytku

Gdy zapoznasz się już z @code{awk}, będziesz często wpisywał proste programy
w chwili, gdy zechcesz z nich skorzystać.  Można wówczas zapisywać takie
programy jako pierwszy argument polecenia @code{awk}, tak:

@example
awk '@var{program}' @var{plik-wej1} @var{plik-wej2} @dots{}
@end example

@noindent
gdzie @var{program} składa się z szeregu @var{wzorców} i @var{akcji}, jak
to opisano wcześniej.

@cindex pojedyncze cudzysłowy, dlaczego potrzebne
@cindex apostrofy, dlaczego potrzebne
Ten format polecenia nakazuje @dfn{powłoce}, interpreterowi
poleceń, uruchomienie @code{awk} i użycie @var{programu} do przetwarzania
rekordów w pliku (plikach) wejściowym.  Wokół @var{programu} postawiono
pojedyncze cudzysłowy (apostrofy), tak że powłoka nie zinterpretuje żadnych
znaków @code{awk} jako znaków specjalnych powłoki.  Powodują one również, że
powłoka potraktuje cały @var{program} jako pojedynczy argument @code{awk} i
pozwalają, by @var{program} był dłuższy niż jeden wiersz.

Ten format przydaje się też do uruchamiania krótkich i średnich programów
@code{awk} ze skryptów powłoki, gdyż unika potrzeby stosowania odrębnego
pliku z programem @code{awk}.  Samodzielny skrypt powłoki jest bardziej
niezawodny, ponieważ nie ma innych plików, które mogłyby być źle
umieszczone.

@ref{Jednolinijkowce, ,Przydatne programy jednolinijkowe}, pokazuje kilka
krótkich, samodzielnych programów.

Na marginesie, ciekawe, że polecenie

@example
awk '/foo/' @var{pliki} @dots{}
@end example

@noindent
jest w gruncie rzeczy tym samym, co

@cindex @code{egrep}
@example
egrep foo @var{pliki} @dots{}
@end example

@node Czytanie z terminala, Długie, Jednorazowe, Uruchamianie gawk
@subsection Uruchamianie @code{awk} bez plików wejściowych

@cindex standardowe wejście
@cindex wejście, standardowe
Można też uruchamiać @code{awk} bez plików wejściowych.  Jeżeli wpiszemy
w wierszu poleceń:

@example
awk '@var{program}'
@end example

@noindent
to @code{awk} zastosuje @var{program} do @dfn{standardowego wejścia}, co
zwykle oznacza to, co wpisujemy na terminalu.  Trwa to do chwili wskazania
końca pliku przez naciśnięcie @kbd{Control-d}.  (W innych systemach
operacyjnych, znak końca pliku może być odmienny.  Na przykład, w OS/2
i MS-DOS, jest to @kbd{Control-z}.)

Na przykład, poniższy program wypisuje przyjazną poradę
(z Douglasa Adamsa @cite{Autostopem przez Galaktykę}),
byś nie przejmował się zawiłościami programowania komputerów
(@samp{BEGIN} jest cechą, której jeszcze nie omawialiśmy).

@example
$ awk "BEGIN @{ print \"Nie panikuj!\" @}"
@print{} Nie panikuj!

$ awk "BEGIN @{ print \"Don't Panic!\" @}"
@print{} Don't Panic!
@end example

@cindex cytowanie, powłoka
@cindex powłoka, cytowanie
Ten program w ogóle nie czyta wejścia. Znak @samp{\} przed każdym
z wewnętrznych cudzysłowów jest konieczny z powodu reguł cytowania powłoki,
konkretnie dlatego, że mieszamy cudzysłowy pojedyncze z podwójnymi.

Kolejny prosty program @code{awk} symuluje narzędzie @code{cat}. Kopiuje
wszystko, co zostanie wpisane z klawiatury, na standardowe wyjście.
(Pokrótce wyjaśniono, dlaczego działa.)

@example
$ awk '@{ print @}'
Now is the time for all good men
@print{} Now is the time for all good men
to come to the aid of their country.
@print{} to come to the aid of their country.
Four score and seven years ago, ...
@print{} Four score and seven years ago, ...
What, me worry?
@print{} What, me worry?
@kbd{Control-d}
@end example

@node Długie, Skrypty wykonywalne, Czytanie z terminala, Uruchamianie gawk
@subsection Uruchamianie długich programów

@cindex uruchamianie długich programów
@cindex @code{-f} opcja
@cindex plik programu @code{awk}
@cindex program, w pliku
Czasami programy @code{awk} są bardzo długie.  W tym przypadku wygodniej
jest umieścić program w osobnym pliku.  Chcąc nakazać @code{awk} użycie tego
pliku jako programu, wpisujemy:

@example
awk -f @var{plik-źródłowy} @var{plik-wej1} @var{plik-wej2} @dots{}
@end example

Opcja @samp{-f} poleca narzędziu @code{awk} pobranie programu @code{awk}
z pliku @var{plik-źródłowy}.  Jako @var{plik-źródłowy} można użyć dowolnej
nazwy pliku.  Na przykład, można umieścić program:

@example
BEGIN @{ print "Nie panikuj!" @}
@end example

@noindent
w pliku @file{porada}.  Wówczas to polecenie:

@example
awk -f porada
@end example

@noindent
robi to samo, co to:

@example
awk "BEGIN @{ print \"Nie panikuj!\" @}"
@end example

@cindex cytowanie, powłoka
@cindex powłoka, cytowanie
@noindent
które było objaśnione wcześniej
(@pxref{Czytanie z terminala, ,Uruchamianie @code{awk} bez plików wejściowych}).
Zauważ, że zwykle nie trzeba ujmować w pojedyncze cudzysłowy nazwy pliku
podawanego opcją @samp{-f}, gdyż większość nazw plików nie zawiera żadnych
znaków specjalnych powłoki.  Zwróć uwagę, że w pliku @file{porada} program
@code{awk} nie jest ujęty w apostrofy.  Są one potrzebne tylko dla programów
wpisywanych w wierszu poleceń @code{awk}.

Chcąc wyraźnie identyfikować pliki programów @code{awk}, można do nazwy pliku
dodać rozszerzenie @file{.awk}.  Nie ma to wpływu na wykonanie programu
@code{awk}, ale ułatwia utrzymanie porządku.

@node Skrypty wykonywalne, Komentarze, Długie, Uruchamianie gawk
@subsection Wykonywalne programy @code{awk}
@cindex skrypty wykonywalne
@cindex wykonywalne, skrypty
@cindex samodzielne programy
@cindex niezależne programy
@cindex program, samodzielny
@cindex program, niezależny
@cindex @code{#!} (skrypty wykonywalne)

Gdy nauczyłeś się już @code{awk}, możesz pisać niezależne skrypty @code{awk},
wykorzystując mechanizm skryptowy @samp{#!}.  Da się to zrobić w wielu
systemach uniksowych@footnote{Mechanizm @samp{#!} działa w systemach
Linux, systemach Unix pochodzących od Berkeley Unix, System V Release 4,
i niektórych systemach System V Release 3.} (i pewnego dnia
w systemie GNU).

Na przykład, możemy zaktualizować nasz plik @file{porada} by wyglądał tak:

@example
#! /bin/awk -f

BEGIN    @{ print "Nie panikuj!" @}
@end example

@noindent
Po uczynieniu go plikiem wykonywalnym (narzędziem @code{chmod}), można
po prostu wpisać @samp{porada} w wierszu powłoki, a system zorganizuje
uruchomienie @code{awk}@footnote{Wiersz rozpoczynający się od @samp{#!}
wyszczególnia pełną nazwę interpretera, jaki ma zostać uruchomiony,
i opcjonalny argument początkowy wiersza poleceń, jaki ma zostać przesłany
do interpretera.  System operacyjny uruchamia wówczas interpreter z zadanym
argumentem i pełną listą argumentów wykonywanego programu.  Pierwszy argument
listy jest pełną nazwą pliku programu @code{awk}.  Reszta listy argumentów
będzie albo opcjami @code{awk}, albo plikami danych, albo oboma.} tak,
jakby wpisano @samp{awk -f porada}.

@example
@group
$ porada
@print{} !
@end group
@end example

@noindent
Samodzielne skrypty @code{awk} są użyteczne, gdy chcemy napisać program,
który użytkownicy mogliby wywoływać bez potrzeby wiedzy o tym, że napisano
go w @code{awk}.

@strong{Uwaga!} Nie powinno się umieszczać więcej niż jednego argumentu
w wierszu @samp{#!} po ścieżce do @code{awk}. To nie zadziała. System
operacyjny traktuje resztę wiersza jako pojedynczy argument i przesyła go do
@code{awk}. Takie próby prowadzą do wprawiającego w zakłopotanie zachowania
się programu: najprawdopodobniej jakiegoś komunikatu diagnostycznego
@code{awk} o błędzie wywołania.

@cindex skrypty powłoki
@cindex powłoka, skrypty
Niektóre ze starszych systemów nie obsługują mechanizmu @samp{#!}. Można
osiągnąć podobny skutek wykorzystując zwykły skrypt powłoki.  Wyglądał by
jakoś tak:

@example
: Dwukropek zapewnia wykonanie przez standardową powłokę
awk '@var{program}' "$@@"
@end example

Przy stosowaniu tej techniki @emph{kluczowe} jest ujęcie @var{programu}
w pojedyncze cudzysłowy, by uchronić go przed interpretacją przez powłokę.
Jeżeli pominie się apostrofy, to wyniki może przewidzieć tylko czarodziej
powłoki.

Sekwencja @code{"$@@"} powoduje, że powłoka przekazuje wszystkie argumenty
wiersza poleceń programowi @code{awk}, bez ich interpretacji.  Pierwszy
wiersz, zaczynający się dwukropkiem, zastosowano by skrypt powłoki działał
nawet wtedy, gdy wywoła go użytkownik korzystający z powłoki C (csh).
(Nie wszystkie starsze systemy przestrzegają tej konwencji, ale wiele to robi.)
@c 2e:
@c Someday: (See @cite{The Bourne Again Shell}, by ??.)

@node Komentarze,  , Skrypty wykonywalne, Uruchamianie gawk
@subsection Komentarze w programach @code{awk}
@cindex @code{#} (komentarz)
@cindex komentarze
@cindex użycie komentarzy
@cindex dokumentowanie programów @code{awk}
@cindex programy, dokumentowanie

@dfn{Komentarz} jest tekstem zawartym w programie ze względu na
czytelnika-człowieka.  Nie jest faktycznie częścią programu.  Komentarze mogą
objaśniać, co program robi, i jak działa.  Prawie wszystkie języki
programowania umożliwiają stosowanie komentarzy, gdyż bez takiej dodatkowej
pomocy programy są na ogół trudne do zrozumienia.

W języku @code{awk} komentarz rozpoczyna się od znaku krzyżyka, @samp{#},
i rozciąga się do końca wiersza.  @samp{#} nie musi być pierwszym znakiem
wiersza. Język @code{awk} ignoruje dalszą część wiersza następującą po
krzyżyku.  Na przykład, możemy wstawić poniższe w @file{porada}:

@example
# Ten program wypisuje ładny przyjazny komunikat. Pomaga
# nowym użytkownikom uniknąć obaw przed komputerem.
BEGIN    @{ print "Nie panikuj!" @}
@end example

Można wstawiać wiersze komentarzy również w jednorazowe programy @code{awk}
wpisywane wprost z klawiatury, ale zwykle nie jest to zbyt przydatne.
Celem komentarza jest pomoc autorowi lub innej osobie w późniejszym
zrozumieniu programu.

@strong{Uwaga!} Jak wspomniano w
@ref{Jednorazowe, ,Programy @code{awk} jednorazowego użytku},
małe i średnie programy można umieszczać w pojedynczych cudzysłowach, w celu
zachowania samodzielności skryptów powłoki.  Przy takim postępowaniu,
@emph{nie należy} umieszczać apostrofu (tj. pojedynczego cudzysłowu)
w komentarzu (lub jakimkolwiek innym miejscu programu).  Powłoka
zinterpretuje go jako pojedynczy cudzysłów zamykający całość programu.
W rezultacie, zwykle powłoka wypisze komunikat o niedopasowanych
cudzysłowach, a jeśli @code{awk} rzeczywiście się uruchomi,
najprawdopodobniej wypisze dziwne komunikaty o błędach składniowych.
Na przykład:

@example
awk 'BEGIN @{ print "hello" @} # dź'bry, spryciarzu!'
@end example

@node Bardzo prosty, Dwie reguły, Uruchamianie gawk, Zaczynamy
@section Bardzo prosty przykład

Poniższe polecenie uruchamia prosty program @code{awk} wyszukujący w pliku
wejściowym @file{BBS-list} łańcucha znaków: @samp{foo}.  (Łańcuch znaków
zwykle nazywany jest @dfn{łańcuchem}.  Określenie @dfn{łańcuch} jest zapewne
oparte na podobnie używanych w języku angielskim wyrażeniach ``łańcuch
pereł'' czy ``łańcuch wagonów pociągu''.)

@example
awk '/foo/ @{ print $0 @}' BBS-list
@end example

@noindent
Gdy znalezione zostaną wiersze zawierające @samp{foo}, są one wypisywane,
gdyż @w{@samp{print $0}} oznacza wypisanie bieżącego wiersza.  (Samo
@samp{print} znaczy to samo, więc moglibyśmy zapisać to i w taki sposób.)

Zwróć uwagę na ukośniki, @samp{/}, otaczające łańcuch @samp{foo} w
naszym programie.  Ukośniki wskazują, że @samp{foo} jest wzorcem do
wyszukania.  Ten rodzaj wzorca nazywany jest @dfn{wyrażeniem regularnym}
(regular expression), i jest szczegółowo opisany dalej.
(@pxref{Regexp, ,Regular Expressions}).
Dopuszcza się, by wzorzec pasował do części słów.
Wokół programu @code{awk} mamy pojedyncze cudzysłowy, więc powłoka nie
będzie interpretować żadnych z nich jako swych znaków specjalnych.

A oto, co wypisuje ten program:

@example
@group
$ awk '/foo/ @{ print $0 @}' BBS-list
@print{} fooey        555-1234     2400/1200/300     B
@print{} foot         555-6699     1200/300          B
@print{} macfoo       555-6480     1200/300          A
@print{} sabafoo      555-2127     1200/300          C
@end group
@end example

@cindex akcja, domyślna
@cindex wzorzec, domyślny
@cindex domyślna akcja
@cindex dimyślny wzorzec
Można pominąć jedną z reguł @code{awk}, wzorzec albo akcję, ale nie obie
naraz.  Jeśli pominięto wzorzec, to akcja wykonywana jest dla @emph{każdego}
wiersza wejściowego.  Jeżeli pominięto akcję, to akcją domyślną jest
wypisanie wszystkich wierszy pasujących do danego wzorca.

@cindex pusta akcja
@cindex akcja, pusta
Zatem, w powyższym przykładzie mogliśmy opuścić akcję (polecenie @code{print}
i nawiasy klamrowe), a wynik byłby taki sam: zostałyby wypisane wszystkie
wiersze pasujące do wzorca @samp{foo}.  Przez analogię, pominięcie instrukcji
@code{print}, ale pozostawienie nawiasów klamrowych tworzy pustą akcję, która
nic nie robi.  Nie zostałyby wówczas wypisane żadne wiersze.

@node Dwie reguły, Trudniejszy, Bardzo prosty, Zaczynamy
@section Przykład z dwiema regułami
@cindex jak działa @code{awk}

Narzędzie @code{awk} czyta pliki wejściowe po jednym wierszu.  Dla każdego
wiersza @code{awk} wypróbowuje wzorce każdej z reguł.  Jeżeli pasuje kilka
wzorców, to wykonywanych jest kilka akcji, w kolejności, w jakiej występują
w programie @code{awk}.  Jeśli nie pasuje żaden wzorzec, to nie są wykonywane
żadne akcje.

Po przetworzeniu wszystkich reguł (może żadnej) pasujących do wiersza,
@code{awk} czyta następny wiersz (jednak,
@pxref{Instrukcja next, ,Instrukcja @code{next}},
oraz @pxref{Instrukcja nextfile, ,Instrukcja @code{nextfile}}).
Jest to powtarzane aż do napotkania końca pliku.

Na przykład, program @code{awk}:

@example
/12/  @{ print $0 @}
/21/  @{ print $0 @}
@end example

@noindent
zawiera dwie reguły.  Pierwsza ma łańcuch @samp{12} jako wzorzec a
@samp{print $0} jako akcję.  Druga reguła ma łańcuch @samp{21} za wzorzec,
i także @samp{print $0} jako akcję.  Akcja każdej z reguł jest ujęta we własną
parę nawiasów klamrowych.

Ten program @code{awk} wypisuje każdy wiersz, który zawiera łańcuch
@samp{12} @emph{lub} łańcuch @samp{21}.  Jeżeli wiersz zawiera oba te
łańcuchy, to jest wypisywany dwukrotnie, po jednym razie przez każdą
z reguł.

A oto, co się stanie, gdy uruchomimy ten program na naszych dwu przykładowych
plikach danych, @file{BBS-list} i @file{inventory-shipped}, jak pokazano
niżej:

@example
$ awk '/12/ @{ print $0 @}
>      /21/ @{ print $0 @}' BBS-list inventory-shipped
@print{} aardvark     555-5553     1200/300          B
@print{} alpo-net     555-3412     2400/1200/300     A
@print{} barfly       555-7685     1200/300          A
@print{} bites        555-1675     2400/1200/300     A
@print{} core         555-2912     1200/300          C
@print{} fooey        555-1234     2400/1200/300     B
@print{} foot         555-6699     1200/300          B
@print{} macfoo       555-6480     1200/300          A
@print{} sdace        555-3430     2400/1200/300     A
@print{} sabafoo      555-2127     1200/300          C
@print{} sabafoo      555-2127     1200/300          C
@print{} Jan  21  36  64 620
@print{} Apr  21  70  74 514
@end example

@noindent
Zwróć uwagę, że wiersz pliku @file{BBS-list} zaczynający się od
@samp{sabafoo} został wypisany dwukrotnie, po razie dla każdej z reguł.

@node Trudniejszy, Instrukcje/wiersze, Dwie reguły, Zaczynamy
@section Bardziej złożony przykład

@ignore
We have to use ls -lg here to get portable output across Unix systems.
The POSIX ls matches this behavior too. Sigh.
@end ignore
A teraz przykład dający pojęcie o tym, co robią typowe programy @code{awk}.
Przykład ten pokazuje jak można wykorzystać @code{awk} do sumowania,
wybierania i reorganizacji wyjścia z innego narzędzia.  Posługuje się
cechami, których jeszcze nie opisywaliśmy, więc nie przejmuj się jeśli nie
rozumiesz szczegółów.

@example
ls -lg | awk '$6 == "Nov" @{ sum += $5 @}
             END @{ print sum @}'
@end example

@cindex @code{csh}, kontynuacja odwrotnym ukośnikiem
@cindex kontynuacja odwrotnym ukośnikiem w @code{csh}
Polecenie to wypisuje całkowitą liczbę bajtów we wszystkich plikach bieżącego
katalogu, które ostatnio były modyfikowane w listopadzie (November),
dowolnego roku.  (W powłoce C trzeba byłoby wpisać średnik a po nim odwrotny
ukośnik na końcu pierwszego wiersza. W powłoce zgodnej z POSIX, jak powłoka
Bourne'a czy Bash, GNU Bourne-Again shell, można wpisać przykład, jak
pokazano.)
@ignore
FIXME:  how can users tell what shell they are running?  Need a footnote
or something, but getting into this is a distraction.
@end ignore

Część @w{@samp{ls -lg}} tego przykładu jest poleceniem systemu dającym listę
plików w katalogu, łącznie z rozmiarami plików i datami ich ostatniej zmiany.
Jego wyjście może wyglądać tak:

@example
-rw-r--r--  1 arnold   user   1933 Nov  7 13:05 Makefile
-rw-r--r--  1 arnold   user  10809 Nov  7 13:03 gawk.h
-rw-r--r--  1 arnold   user    983 Apr 13 12:14 gawk.tab.h
-rw-r--r--  1 arnold   user  31869 Jun 15 12:20 gawk.y
-rw-r--r--  1 arnold   user  22414 Nov  7 13:03 gawk1.c
-rw-r--r--  1 arnold   user  37455 Nov  7 13:03 gawk2.c
-rw-r--r--  1 arnold   user  27511 Dec  9 13:07 gawk3.c
-rw-r--r--  1 arnold   user   7989 Nov  7 13:03 gawk4.c
@end example

@noindent
Pierwsze pole zawiera prawa odczytu-zapisu, drugie liczbę dowiązań do pliku,
a trzecie identyfikuje właściciela pliku. Czwarte pole identyfikuje grupę
pliku. Piąte zawiera rozmiar pliku w bajtach. Szóste, siódme i ósme pole
zawierają odpowiednio: miesiąc dzień i czas ostatniej modyfikacji pliku.
Na koniec, pole dziewiąte zawiera nazwę pliku.

@cindex automatyczna inicjalizacja
@cindex inicjalizacja, automatyczna
@samp{$6 == "Nov"} w naszym programie @code{awk} jest wyrażeniem, które
sprawdza, czy szóste pole wyjścia z @w{@samp{ls -lg}} pasuje do łańcucha
@samp{Nov}.  Za każdym razem, gdy wiersz ma w szóstym polu łańcuch
@samp{Nov}, wykonywana jest akcja @samp{sum += $5}.  Dodaje ona szóste pole
(rozmiar pliku) do zmiennej @code{sum}.  W efekcie, gdy @code{awk} zakończy
odczyt wszystkich wierszy wejściowych, @code{sum} jest sumą rozmiarów plików,
których wiersze pasowały do wzorca.  (To działa, gdyż zmienne @code{awk} są
automatyczne inicjowane na zero.)

Po przetworzeniu ostatniego wiersza wyjścia z @code{ls}, wykonywana jest
reguła @code{END} i wypisywana jest wartość @code{sum}.  W tym przykładzie,
wartością @code{sum} byłoby 80600.

Takie bardziej zaawansowane techniki @code{awk} opisano w dalszych sekcjach
(@pxref{Przegląd akcji, ,Przegląd akcji}).  Zanim przejdziemy do
bardziej zaawansowanego programowania w @code{awk}, musimy wiedzieć jak
@code{awk} interpretuje zadane wejście i wyświetla wyjście.  Operując na
polach i używając instrukcji @code{print}, można tworzyć bardzo przydatne
i robiące wrażenie raporty.

@node Instrukcje/wiersze, Inne cechy, Trudniejszy, Zaczynamy
@section Instrukcje @code{awk} a wiersze
@cindex linia, łamanie
@cindex łamanie linii
@cindex nowa linia

Najczęściej, każdy wiersz programu @code{awk} jest osobną instrukcją lub
osobną regułą, jak tu:

@example
awk '/12/  @{ print $0 @}
     /21/  @{ print $0 @}' BBS-list inventory-shipped
@end example

Jednak, @code{gawk} ignoruje znaki nowej linii po dowolnym z:

@example
,    @{    ?    :    ||    &&    do    else
@end example

@noindent
Nowa linia w każdym innym miejscu jest uważana za koniec instrukcji.
(Rozbicie wierszy po @samp{?} i @samp{:} jest drobnym rozszerzeniem
@code{gawk}.  @samp{?} i @samp{:} odnoszą się tu do trójargumentowego
wyrażenia warunkowego opisanego
w @ref{Wyrażenia warunkowe, ,Wyrażenia warunkowe}.)

@cindex kontynuacja odwrotnym ukośnikiem
@cindex kontynuacja linii
@cindex linii kontynuacja
Jeśli chcielibyśmy rozbić pojedynczą instrukcję na dwa wiersze w miejscu,
gdzie przerwałby ją znak nowej linii, możemy ją @dfn{kontynuować} kończąc
pierwszy wiersz znakiem odwrotnego ukośnika, @samp{\}.  Odwrotny ukośnik
musi być ostatnim znakiem wiersza, by został rozpoznany jako znak
kontynuacji.  Jest to dozwolone absolutnie wszędzie w instrukcji @code{awk},
nawet w środku łańcucha czy wyrażenia regularnego.  Na przykład:

@example
awk '/To wyrażenie regularne jest za długie, więc kontynuujemy je\
 w kolejnym wierszu/ @{ print $1 @}'
@end example

@noindent
@cindex przenośność
Na ogół w przykładowych programach niniejszej książki nie stosowaliśmy
kontynuacji odwrotnym ukośnikiem.  Ponieważ w @code{gawk} nie ma ograniczenia
długości wiersza, nigdy nie jest to naprawdę konieczne; po prostu powoduje, że
programy są bardziej czytelne.  Z tego samego powodu, jak również dla
klarowności, w większości staraliśmy się trzymać krótkich instrukcji
w przykładowych programach tu prezentowanych.  Kontynuacja odwrotnym
ukośnikiem najbardziej przydaje się gdy program @code{awk} umieszczony jest
w odrębnym pliku, a nie wpisany w wierszu poleceń.  Powinniśmy też zauważyć,
że wiele implementacji @code{awk} jest bardziej drobiazgowych co do miejsca,
w którym można użyć takiej kontynuacji.  Zatem, dla maksymalnej przenośności
programów @code{awk}, najlepiej jest nie dzielić wierszy w środku wyrażeń
regularnych czy łańcuchów.

@cindex @code{csh}, kontynuacja odwrotnym ukośnikiem
@cindex kontynuacja odwrotnym ukośnikiem w @code{csh}
@strong{Uwaga: z powłoką C kontynuacja odwrotnym ukośnikiem nie działa
tak jak opisano powyżej.}  Kontynuacja z użyciem odwrotnego ukośnika
działa w programach zapisanych w plikach, jak też w jednorazowych programach
@emph{pod warunkiem}, że używamy powłoki zgodnej z POSIX, jak powłoka
Bourne'a czy Bash, GNU Bourne-Again shell.  Jednak powłoka C (@code{csh})
zachowuje się odmiennie!  Tam musimy użyć dwu kolejnych odwrotnych
ukośników, po których nastąpi znak nowej linii.  Należy też pamiętać,
że przy stosowaniu powłoki C @emph{każdy} znak nowej linii w programie awk
musi być poprzedzony odwrotnym ukośnikiem.  Dla ilustracji:

@example
% awk 'BEGIN @{ \
?   print \\
?       "hello, world" \
? @}'
@print{} hello, world
@end example

@noindent
Tu, @samp{%} i @samp{?} są głównym i pomocniczym znakiem zachęty powłoki C,
analogicznie do znanych z powłok standardowych @samp{$} i @samp{>}.

@code{awk} jest językiem wierszowym (``line-oriented'').  Akcja każdej reguły
musi się zaczynać w tym samym wierszu to wzorzec.  Chcąc mieć wiersz i akcję
w osobnych wierszach, @emph{musimy} użyć kontynuacji odwrotnym ukośnikiem
-- nie ma innego sposobu.

@cindex kontynuacja odwrotnym ukośnikiem a komentarze
@cindex komentarze a kontynuacja odwrotnym ukośnikiem
Zwróć uwagę, że kontynuacja odwrotnym ukośnikiem i komentarze nie
mieszają się.  Gdy tylko @code{awk} zauważy @samp{#} rozpoczynający
komentarz, ignoruje @emph{wszystko} w pozostałej części wiersza. Na
przykład:

@example
@group
$ gawk 'BEGIN @{ print "nie panikuj" # przyjazne \
>                                    BEGIN
> @}'
@error{} gawk: cmd. line:2:                BEGIN
@error{} gawk: cmd. line:2:                ^ parse error
@end group
@end example

@noindent
Wygląda to jakby odwrotny ukośnik miał kontynuować komentarz w następnym
wierszu. Jednak kombinacja odwrotny ukośnik-nowa linia nie zostanie nigdy
dostrzeżona, gdyż jest ``ukryta'' wewnątrz komentarza. Zatem, @samp{BEGIN}
odnotowywane jest jako błąd składni.

@cindex wiele instrukcji w jednym wierszu
Gdy instrukcje @code{awk} wewnątrz jednej reguły są krótkie, można umieścić
więcej niż jedną w pojedynczym wierszu.  Robi się to oddzielając
poszczególne instrukcje średnikiem, @samp{;}.

Odnosi się do także do samych reguł.
Zatem, poprzedni program możnaby zapisać:

@example
/12/ @{ print $0 @} ; /21/ @{ print $0 @}
@end example

@noindent
@strong{Zauważ:} wymagania, by reguły w tym samym wierszu były rozdzielone
średnikiem nie było w pierwotnym języku @code{awk}; zostało dodane dla
utrzymania spójności z traktowaniem instrukcji wewnątrz akcji.

@node Inne cechy, Kiedy, Instrukcje/wiersze, Zaczynamy
@section Inne cechy @code{awk}

Język @code{awk} dostarcza wielu predefiniowanych lub wbudowanych zmiennych,
których programy mogą używać do pozyskania informacji z @code{awk}.  Istnieją
też inne zmienne, za pomocą których program może kontrolować sposób, w jaki
@code{awk} przetwarza dane.

Dodatkowo, @code{awk} udostępnia wiele wbudowanych funkcji do typowych
operacji obliczeniowych i związanych z łańcuchami.

Stopniowo podczas naszej prezentacji języka @code{awk}, wprowadzimy
większość zmiennych i wiele funkcji. Są one w sposób systematyczny
zdefiniowane w @ref{Zmienne wbudowane} i @ref{Wbudowane, ,Funkcje wbudowane}.

@node Kiedy,  , Inne cechy, Zaczynamy
@section Kiedy stosować @code{awk}

@cindex kiedy stosować @code{awk}
@cindex zastosowania @code{awk}
Zapewne zastanawiasz się, do czego może ci się przydać @code{awk}.
Wykorzystując programy narzędziowe, zaawansowane wzorce, operatory pól,
instrukcje arytmetyczne i inne kryteria wyboru możesz tworzyć bardziej
złożone wyniki.  Język @code{awk} jest bardzo użyteczny w tworzeniu raportów
z ogromnych ilości danych pierwotnych, takich jak dane sumaryczne
z wyjścia innych programów narzędziowych, jak np. @code{ls}.
(@xref{Trudniejszy, ,Bardziej złożony przykład}.)

Programy napisane w @code{awk} są na ogół o wiele mniejsze, niż byłyby
w innych językach.  Powoduje to, że są łatwe w tworzeniu i użyciu.
Często programy @code{awk} mogą być szybko ułożone przy terminalu, użyte
jednokrotnie i wyrzucone.  Ponieważ są one interpretowane, można uniknąć
(zwykle długotrwałej) części typowego cyklu produkcyjnego oprogramowania
(edycja-kompilacja-testowanie-odpluskwianie), jaką jest kompilacja.

W @code{awk} napisano skomplikowane programy, łącznie z kompletnym
zmiennocelowym asemblerem dla mikroprocesorów ośmiobitowych (@pxref{Słownik},
gdzie znajduje się więcej informacji) i asemblerem mikrokodu dla
specjalizowanego komputera Prologu.  Jednak możliwości @code{awk} przy
zadaniach tej złożoności są nadszarpnięte.

Jeśli zaczniesz pisać skrypty @code{awk} dłuższe niż, powiedzmy, kilkaset
linijek, powinieneś rozważyć użycie innego języka programowania. Emacsowy Lisp
jest dobrym wyborem jeśli potrzebujemy wyrafinowanych możliwości pracy
z łańcuchami i dopasowywaniem wzorców.  Również powłoka jest dobra w
łańcuchach i dopasowywaniu wzorców; dodatkowo umożliwia stosowanie narzędzi
systemowych dające duże możliwości.  Bardziej konwencjonalne języki,
jak C, C++ i Lisp, oferują lepsze środki wspomagające programowanie systemowe
i zarządzanie złożonością wielkich programów.  Programy w tych językach mogą
wymagać większej liczby linii kodu źródłowego niż równoważne im programy
@code{awk}, lecz są łatwiejsze w konserwacji i zwykle działają efektywniej.

@node Jednolinijkowce, Regexp, Zaczynamy, Top
@chapter Przydatne programy jednolinijkowe

@cindex jednolinijkowce
Wiele przydatnych programów @code{awk} jest krótkich, mają linijkę czy dwie.
Oto kolekcja przydatnych programików na dobry początek.  Niektóre z nich
zawierają konstrukcje, o których jeszcze nie mówiono.  Opis danego programu
powinien dać ci pojęcie, o co chodzi, ale proszę przeczytaj resztę książki,
by stać się ekspertem od @code{awk}!

Większość tych przykładów używa pliku danych o nazwie @file{dane}.  Jest
to tylko wypełniacz; gdybyś chciał się nimi posłużyć, podstaw zamiast
@file{dane} własne nazwy plików.

@ifinfo
Ponieważ czytasz to jako dokumentację Info, każdy wiersz przykładowego kodu
zawarty jest w cudzysłowach, reprezentując tekst, jaki zostałby wpisany
z klawiatury dosłownie.  Same przykłady są poleceniami powłoki, używającymi
pojedynczych cudzysłowów do powstrzymania powłoki przed interpretacją
zawartości programu.
Przy czytaniu przykładów skoncentruj się na tekście pomiędzy
cudzysłowem otwierającym a zamykającym.
@end ifinfo

@table @code
@item awk '@{ if (length($0) > max) max = length($0) @}
@itemx @ @ @ @ @ END @{ print max @}' dane
Ten program wypisuje długość najdłuższego wiersza.

@item awk 'length($0) > 80' dane
Ten program wypisuje każdy wiersz dłuższy niż 80 znaków.  Jedyna reguła
jako wzorzec ma wyrażenie relacyjne i nie ma akcji (zatem używana
jest domyślna akcja, wypisanie rekordu).

@item expand@ dane@ |@ awk@ '@{ if (x < length()) x = length() @}
@itemx @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ END @{ print "maximum line length is " x @}'
Ten program wypisuje długość najdłuższego wiersza pliku @file{dane}.
Wejście przetwarzane jest programem @code{expand}, zmieniającym tabulacje
na spacje, zatem porównywane szerokości są faktycznie kolumnami od prawego
marginesu.

@item awk 'NF > 0' dane
Ten program wypisuje każdy wiersz mający co najmniej jedno pole.
Jest to prosty sposób na usunięcie pustych wierszy z pliku (lub raczej,
utworzenia nowego pliku podobnego do starego, ale z którego usunięto puste
wiersze).

@c Karl Berry points out that new users probably don't want to see
@c multiple ways to do things, just the `best' way.  He's probably
@c right.  At some point it might be worth adding something about there
@c often being multiple ways to do things in awk, but for now we'll
@c just take this one out.
@ignore
@item awk '@{ if (NF > 0) print @}' dane
Ten program również wypisuje każdy wiersz o najmniej jednym polu.  Zezwalamy
tu, by reguła dopasowywała każdy wiersz i decydujemy w akcji czy go
drukować.
@end ignore

@item awk@ 'BEGIN@ @{@ for (i = 1; i <= 7; i++)
@itemx @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ print int(101 * rand()) @}'
Ten program wypisuje siedem liczb losowych od zera do 100, włącznie.

@item ls -lg @var{pliki} | awk '@{ x += $5 @} ; END @{ print "ogółem bajtów: " x @}'
Ten program wypisuje całkowitą liczbę bajtów używanych przez @var{pliki}.

@item ls -lg @var{pliki} | awk '@{ x += $5 @}
@itemx @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ END @{ print "ogółem K-bajtów:  " (x + 1023)/1024 @}'
Ten program wypisuje całkowitą liczbę kilobajtów używanych przez @var{pliki}.

@item awk -F: '@{ print $1 @}' /etc/passwd | sort
Ten program wypisuje posortowaną listę nazw zgłoszeniowych wszystkich
użytkowników.

@item awk 'END @{ print NR @}' dane
Ten program zlicza wiersze pliku.

@item awk 'NR % 2 == 0' dane
Ten program wypisuje wiersze o parzystych numerach w pliku danych.
Gdybyśmy użyli zamiast powyższego wyrażenia @samp{NR % 2 == 1},
wypisywałby wiersze o numerach nieparzystych.
@end table

@node Regexp, Czytanie plików, Jednolinijkowce, Top
@chapter Wyrażenia regularne
@cindex wzorzec, wyrażenia regularne
@cindex regexp
@cindex regularne, wyrażenie
@cindex wyrażenie regularne
@cindex wyrażenia regularne jako wzorce

@dfn{Wyrażenie regularne} (regular expression), lub @dfn{regexp}, jest
metodą opisu zbioru łańcuchów.  Ponieważ wyrażenia regularne są tak
podstawową częścią programowania w języku @code{awk}, ich format
i stosowanie wymagają odrębnego rozdziału.

Wyrażenie regularne ujęte w ukośniki (@samp{/}) jest wzorcem
@code{awk}, dopasowującym każdy rekord wejściowy, którego tekst należy do
tego zbioru.

Najprostszym wyrażeniem regularnym jest ciąg liter, cyfr lub
zarówno liter jak cyfr.  Takie wyrażenie regularne dopasowuje dowolny łańcuch
zawierający ten ciąg.  Zatem, wyrażenie regularne @samp{foo} dopasowuje
dowolny łańcuch zawierający @samp{foo}.  Stąd też, wzorzec @code{/foo/}
dopasowuje dowolny rekord wejściowy zawierający trzy znaki @samp{foo},
@emph{w dowolnym miejscu} rekordu.  Inne rodzaje wyrażeń regularnych pozwalają
na określanie bardziej skomplikowanych klas łańcuchów.

@iftex
Początkowo, przykłady będą proste.  Kiedy wyjaśnimy więcej na temat
działania wyrażeń regularnych, przedstawimy bardziej skomplikowane
@end iftex

@menu
* Używanie regexp::             Jak stosować wyrażenia regularne.
* Sekwencje specjalne::         Jak wypisać znaki niedrukowalne.
* Operatory regexp::            Operatory wyrażeń regularnych.
* Operatory regexp GNU::        Operatory specyficzne dla programów GNU.
* Wielkość liter::              Uwzględnianie wielkości liter w dopasowaniach.
* Lewe najdłuższe::             Jak bardzo pasuje tekst.
* Regexp obliczane::            Stosowanie dynamicznych wyrażeń regularnych.
@end menu

@node Używanie regexp, Sekwencje specjalne, Regexp, Regexp
@section Jak stosować wyrażenia regularne

Przez umieszczenie go w ukośnikach wyrażenie regularne może być używane
jako wzorzec.  Jest ono wówczas sprawdzane z całym tekstem każdego rekordu.
(Normalnie, wystarczy mu dopasowanie tylko części tekstu, by sprawdzenie się
powiodło.)  To, na przykład, wypisuje drugie pole z każdego rekordu, który
gdziekolwiek zawiera trzy znaki @samp{foo}:

@example
@group
$ awk '/foo/ @{ print $2 @}' BBS-list
@print{} 555-1234
@print{} 555-6699
@print{} 555-6480
@print{} 555-2127
@end group
@end example

@cindex regexp, operatory dopasowania
@cindex łańcuchy, operatory dopasowania
@cindex operatory, dopasowanie łańcuchów
@cindex operatory, dopasowanie regexp
@cindex regexp, operatory dopasowania/niepasowania
@cindex @code{~} operator
@cindex @code{!~} operator
Wyrażeń regularnych można też używać w wyrażeniach dopasowania.  Wyrażenia
takie umożliwiają podanie łańcucha, który ma być dopasowywany; nie musi to
być cały bieżący rekord wejściowy.  Porównań wyrażeń regularnych dokonują
dwa operatory, @samp{~} i @samp{!~}.  Wyrażenia wykorzystujące te
operatory mogą być używane jako wzorce lub w instrukcjach @code{if},
@code{while}, @code{for} i @code{do}.

@ifinfo
@c dodanie tego xref w TeX za dużo miesza w formatowaniu
(@xref{Instrukcje, ,Instrukcje sterujące w akcjach}.)
@end ifinfo

@table @code
@item @var{wyr} ~ /@var{regexp}/
Jest prawdziwe jeśli wyrażenie @var{wyr} (wzięte jako łańcuch) pasuje do
@var{regexp}.  Poniższy przykład dopasowuje, lub wybiera, wszystkie rekordy
wejściowe zawierające dużą literę @samp{J} gdzieś w pierwszym polu:

@example
@group
$ awk '$1 ~ /J/' inventory-shipped
@print{} Jan  13  25  15 115
@print{} Jun  31  42  75 492
@print{} Jul  24  34  67 436
@print{} Jan  21  36  64 620
@end group
@end example

To samo robi to:

@example
awk '@{ if ($1 ~ /J/) print @}' inventory-shipped
@end example

@item @var{wyr} !~ /@var{regexp}/
Jest prawdą jeśli wyrażenie @var{wyr} (wzięte jako łańcuch znakowy)
@emph{nie} pasuje do @var{regexp}.  Poniższy przykład dopasowuje, lub
wybiera, wszystkie rekordy wejściowe, których pierwsze pole @emph{nie}
zawiera dużej litery @samp{J}:

@example
@group
$ awk '$1 !~ /J/' inventory-shipped
@print{} Feb  15  32  24 226
@print{} Mar  15  24  34 228
@print{} Apr  31  52  63 420
@print{} May  16  34  29 208
@dots{}
@end group
@end example
@end table

@cindex stała regexp
@cindex wyrażenie regularne stałe
Gdy wyrażenie regularne zapisane jest w ukośnikach, jak @code{/foo/},
nazywamy je @dfn{stałą regexp} (wyrażeniem regularnym stałym), podobnie jak
@code{5.27} jest stałą liczbową, a @code{"foo"} jest stałą łańcuchową.

@node Sekwencje specjalne, Operatory regexp, Używanie regexp, Regexp
@section Sekwencje specjalne

@cindex sekwencje specjalne, notacja
@cindex notacja sekwencji specjalnych
Pewne znaki nie mogą być zawarte dosłownie w stałych łańcuchowych
(@code{"foo"}) czy stałych wyrażeniach regularnych (@code{/foo/}).  Zamiast
tego są reprezentowane przez @dfn{sekwencje specjalne} (escape sequences),
będące ciągami znaków rozpoczynającymi się od odwrotnego ukośnika (@samp{\}).

Jednym z zastosowań sekwencji specjalnych jest włączanie znaku cudzysłowu
do stałej łańcuchowej.  Ponieważ zwykły cudzysłów kończyłby łańcuch, musimy
użyć @samp{\"} do przedstawienia rzeczywistego znaku cudzysłowu jako części
łańcucha.  Na przykład:

@example
$ awk 'BEGIN @{ print "He said \"hi!\" to her." @}'
@print{} He said "hi!" to her.
@end example

Sam znak odwrotnego ukośnika jest innym znakiem, który nie może dołączany
normalnie; piszemy @samp{\\} by umieścić pojedynczy odwrotny ukośnik
w łańcuchu lub wyrażeniu regularnym.  Zatem, łańcuch, którego zawartością
są dwa znaki: @samp{"} i @samp{\}, musi zostać zapisany @code{"\"\\"}.

Innym zastosowaniem odwrotnego ukośnika jest reprezentacja znaków takich jak
tabulacja czy znak nowej linii.  Mimo, że nic nie powstrzymuje cię przed
wprowadzeniem większości znaków niedrukowalnych do stałej łańcuchowej czy
regexp, mogą one wyglądać paskudnie.

A oto tabela wszystkich sekwencji specjalnych używanych w @code{awk}, razem
z tym, co oznaczają.  Wszystkie te sekwencje mają zastosowanie zarówno
do stałych łańcuchowych jak i do stałych regexp, chyba że powiedziano
inaczej.

@c @cartouche
@table @code
@item \\
Dosłowny odwrotny ukośnik (backslash), @samp{\}.

@cindex @code{awk} język, wersja V.4
@item \a
Znak alarmu (dzwonek, ``alert''), @kbd{Control-g}, kod ASCII 7 (BEL).

@item \b
Backspace, @kbd{Control-h}, kod ASCII 8 (BS).

@item \f
Wysuw strony, formfeed, @kbd{Control-l}, kod ASCII 12 (FF).

@item \n
Nowa linia, newline, @kbd{Control-j}, kod ASCII 10 (LF).

@item \r
Powrót karetki, carriage return, @kbd{Control-m}, kod ASCII 13 (CR).

@item \t
Tabulacja pozioma, @kbd{Control-i}, kod ASCII 9 (HT).

@cindex @code{awk} język, wersja V.4
@item \v
Tabulacja pionowa, @kbd{Control-k}, kod ASCII 11 (VT).

@item \@var{nnn}
Wartość ósemkowa @var{nnn}, gdzie @var{nnn} to jedna do trzech cyfr od
@samp{0} do @samp{7}.  Na przykład, kodem znaku ASCII ESC (escape)
jest @samp{\033}.

@cindex @code{awk} język, wersja V.4
@cindex @code{awk} język, wersja POSIX
@cindex POSIX @code{awk}
@item \x@var{hh}@dots{}
Wartość szesnastkowa @var{hh}, gdzie @var{hh} są cyframi szesnastkowymi
(@samp{0} do @samp{9} i albo @samp{A} do @samp{F} albo @samp{a} do
@samp{f}).  Podobnie jak w takiej samej konstrukcji w C, sekwencja specjalna
rozciąga się do napotkania pierwszego znaku nie będącego cyfrą szesnastkową.
Jednak użycie więcej niż dwu cyfr szesnastkowych daje niezdefiniowane
rezultaty. (Sekwencja specjalna @samp{\x} nie jest dozwolona w POSIX-owym
@code{awk}.)

@item \/
Dosłowny ukośnik (niezbędny tylko w stałych regexp).  Sekwencji tej używa
się chcąc zapisać stałą regexp zawierającą ukośnik. Ponieważ samo wyrażenie
regularne jest ograniczone ukośnikami, należy zacytować ukośnik będący
częścią wzorca, sygnalizując @code{awk}, by przetwarzał resztę wyrażenia.

@item \"
Dosłowny cudzysłów (niezbędny tylko w stałych łańcuchowych). Używany tylko
gdy chcemy zapisać stałą łańcuchową zawierającą cudzysłów. Ponieważ łańcuch
ograniczany jest cudzysłowami, należy zacytować ukośnik będący częścią
łańcucha, sygnalizując @code{awk}, by przetwarzał resztę łańcucha.
@end table
@c @end cartouche

W @code{gawk} istnieją dwie dodatkowe sekwencje specjalne, rozpoczynające
się odwrotnym ukośnikiem i mające specjalne znaczenie w wyrażeniach
regularnych.
@xref{Operatory regexp GNU, ,Dodatkowe operatory regexp w @code{gawk}}.

Co się stanie, jeśli w stałej łańcuchowej umieścimy odwrotny ukośnik
przed czymś, co nie jest jednym ze znaków wyszczególnionych powyżej?
POSIX @code{awk} celowo pozostawia ten przypadek niezdefiniowany.
Są dwie możliwości.

@itemize @bullet
@item
Usunięcie odwrotnego ukośnika. Robi tak zarówno uniksowy @code{awk}, jak
i @code{gawk}.  Na przykład, @code{"a\qc"} jest tym samym co @code{"aqc"}.

@item
Pozostawienie odwrotnego ukośnika w spokoju. Robią tak niektóre inne
implementacje @code{awk}.  W takich implementacjach, @code{"a\qc"} jest
tym samym, co napisanie @code{"a\\qc"}.
@end itemize

W wyrażeniu regularnym, odwrotny ukośnik przed znakiem nie znajdującym się
w powyższej tablicy, i nie wymienionym
w @ref{Operatory regexp GNU, ,Dodatkowe operatory regexp w @code{gawk}},
oznacza, że kolejny znak powinien być brany dosłownie, nawet jeśli normalnie byłby on
operatorem wyrażeń regularnych. Np., @code{/a\+b/} dopasowuje trzy znaki
@samp{a+b}.

@cindex przenośność
Dla zapewnienia pełnej przenośności, nie stosuj odwrotnego ukośnika przed
żadnym ze znaków nie podanych w tablicy powyżej.

Nasuwa się inna interesująca kwestia.
Załóżmy, że używamy sekwencji specjalnej z wartością ósemkową lub
szesnastkową do reprezentacji metaznaku wyrażeń regularnych
(@pxref{Operatory regexp, , Operatory wyrażeń regularnych}).  Czy @code{awk}
potraktuje ten znak jako znak dosłowny, czy też jako operator wyrażeń
regularnych?

@cindex ciemny kąt
Okazuje się, że historycznie takie znaki były brane dosłownie (c.k.).
Jednak standard POSIX wskazuje, że powinny być one traktowane jak
rzeczywiste metaznaki, i tak to robi @code{gawk}.  Jednak, w trybie
zgodności (@pxref{Opcje, ,Opcje wiersza poleceń}), @code{gawk} traktuje
znaki reprezentowane przez ósemkowe lub szesnastkowe sekwencje specjalne
dosłownie, gdy są one stosowane w stałych regexp.  Zatem, @code{/a\52b/}
jest równoważne @code{/a\*b/}.

Podsumowując:

@enumerate 1
@item
Sekwencje specjalne z tablicy powyżej są zawsze przetwarzane jako pierwsze,
zarówno w stałych łańcuchowych jak i w stałych regexp. Dzieje się to bardzo
wcześnie, zaraz po odczycie twego programu przez @code{awk}.

@item
@code{gawk} przetwarza zarówno stałe wyrażenia regularne jak i
dynamiczne wyrażenia regularne (@pxref{Regexp obliczane, ,Stosowanie dynamicznych wyrażeń regularnych}),
specjalne operatory podano
w @ref{Operatory regexp GNU, ,Dodatkowe operatory regexp w @code{gawk}}.

@item
Odwrotny ukośnik przed każdym innym znakiem oznacza, że znak ten należy
traktować dosłownie.
@end enumerate

@node Operatory regexp, Operatory regexp GNU, Sekwencje specjalne, Regexp
@section Operatory wyrażeń regularnych
@cindex metaznaki
@cindex metaznaki wyrażeń regularnych
@cindex operatory wyrażeń regularnych

Wyrażenia regularne można łączyć za pomocą niżej opisanych znaków,
zwanych @dfn{operatorami wyrażeń regularnych}, lub @dfn{metaznakami},
zwiększając moc i wszechstronność wyrażeń regularnych.

Wewnątrz wyrażeń regularnych poprawne są sekwencje specjalne opisane
@iftex
powyżej
@end iftex
w @ref{Sekwencje specjalne}.
Są one wprowadzane przez @samp{\}. Ich rozpoznawanie i przekształcanie na
odpowiadające im rzeczywiste znaki jest pierwszym krokiem przetwarzania
wyrażeń regularnych.

A oto tabela metaznaków.  Wszystkie znaki nie będące sekwencjami specjalnymi
i nie podane w tej tabeli znaczą same siebie.

@table @code
@item \
Służy do wyeliminowania specjalnego znaczenia znaku podczas dopasowywania.
Na przykład:

@example
\$
@end example

@noindent
dopasowuje znak @samp{$}.

@c NEEDED
@page
@cindex kotwice w wyrażeniach regularnych
@cindex wyrażenia regularne, kotwice
@item ^
Dopasowuje początek łańcucha.  Na przykład:

@example
^@@chapter
@end example

@noindent
dopasowuje @samp{@@chapter} na początku łańcucha, i może być wykorzystane
do identyfikacji rozdziałów w plikach źródłowych Texinfo. @samp{^} znany
jest jako @dfn{kotwica}, gdyż zaczepia wzorzec tak, by pasował tylko na
początku łańcucha.

Należy zdawać sobie sprawę z tego, że @samp{^} nie dopasowuje początku
wiersza zawartego w łańcuchu. W tym przykładzie warunek nie jest prawdziwy:

@example
if ("wiersz1\nWIERSZ 2" ~ /^W/) @dots{}
@end example

@item $
Podobne do @samp{^}, ale pasuje tylko na końcu łańcucha.  Na przykład:

@example
p$
@end example

@noindent
dopasowuje rekord kończący się na @samp{p}.  @samp{$} jest również
kotwicą, i również nie dopasowuje końca wiersza zawartego wewnątrz łańcucha.
W tym przykładzie warunek nie jest prawdziwy:

@example
if ("wiersz1\nWIERSZ 2" ~ /1$/) @dots{}
@end example

@item .
Kropka dopasowuje dowolny pojedynczy znak, @emph{również} znak nowej linii.
Na przykład:

@example
.P
@end example

@noindent
dopasowuje w łańcuchu dowolny pojedynczy znak, po którym następuje @samp{P}.
Posługując się konkatenacją (łączeniem) można tworzyć takie wyrażenia
regularne jak np. @samp{U.A}, dopasowujące dowolną trzyznakową sekwencję
rozpoczynającą się od @samp{U} a kończącą na @samp{A}.

@cindex @code{awk} język, wersja POSIX
@cindex POSIX @code{awk}
W trybie ścisłej zgodności z POSIX (@pxref{Opcje, ,Opcje wiersza poleceń}),
@samp{.} nie dopasowuje znaku @sc{nul}, będącego znakiem o wszystkich
bitach równych zero.  Bez ścisłej zgodności @sc{nul} jest po prostu
znakiem jak każdy inny. Inne wersje @code{awk} mogą nie umieć dopasować
znaku @sc{nul}.

@ignore
2e: Add stuff that character list is the POSIX terminology. In other
    literature known as character set or character class.
@end ignore

@cindex lista znaków
@item [@dots{}]
Zwane @dfn{listą znaków}.  Dopasowuje dowolny @emph{jeden} znak spośród
znaków zawartych w nawiasach kwadratowych.  Na przykład:

@example
[MVX]
@end example

@noindent
dopasowuje w łańcuchu dowolny ze znaków @samp{M}, @samp{V} albo @samp{X}.

Zakresy znaków wskazywane są przez użycie myślnika pomiędzy znakiem
rozpoczynającym a kończącym zakres, i ujęcie całości w nawiasy kwadratowe.
Na przykład:

@example
[0-9]
@end example

@noindent
dopasowuje dowolną cyfrę.
Dopuszcza się wielokrotne zakresy. Np. lista @code{@w{[A-Za-z0-9]}} jest
popularnym sposobem wyrażania pojęcia ``wszystkich znaków alfanumerycznych''
[tłum.: w alfabecie łacińskim].

Chcąc w liście ująć jeden ze znaków @samp{\}, @samp{]}, @samp{-} lub @samp{^}
należy postawić przed nim @samp{\}.  Na przykład:

@example
[d\]]
@end example

@noindent
dopasowuje albo @samp{d} albo @samp{]}.

@cindex @code{egrep}
Takie traktowanie odwrotnego ukośnika @samp{\} w liście znaków jest zgodne
z innymi implementacjami @code{awk}, jest też wymagane przez POSIX.
Wyrażenia regularne w @code{awk} są nadzbiorem specyfikacji
POSIX opisującej rozszerzone wyrażenia regularne (Extended Regular
Expressions, EREs).  ERE POSIX-a oparte są na wyrażeniach regularnych
akceptowanych przez tradycyjne narzędzie @code{egrep}.

@cindex klasy znaków
@cindex znaków klasy
@cindex @code{awk} język, wersja POSIX
@cindex POSIX @code{awk}
@dfn{Klasy znaków} są nową cechą wprowadzoną w standardzie POSIX.  Klasa
znaków jest specjalną notacją opisującą listy znaków mających specyficzne
właściwości, gdzie jednak same konkretne znaki mogą zmieniać się w
zależności od kraju i/lub zestawu znaków.  Na przykład, pojęcie tego, co
jest znakiem alfabetu, jest różne w USA i we Francji.

Klasa znaków jest poprawna wyłącznie @emph{wewnątrz} nawiasów kwadratowych
listy znaków w wyrażeniu regularnym.  Klasy znaków składają się z @samp{[:},
słowa kluczowego oznaczającego klasę, i @samp{:]}.  Oto klasy znaków
zdefiniowane przez standard POSIX.

@table @code
@item [:alnum:]
Znaki alfanumeryczne.

@item [:alpha:]
Znaki alfabetyczne.

@item [:blank:]
Znaki spacji i tabulacji.

@item [:cntrl:]
Znaki sterujące.

@item [:digit:]
Znaki numeryczne.

@item [:graph:]
Znaki, które są równocześnie drukowalne i widoczne.  (Spacja jest
drukowalna, lecz nie jest widoczna, podczas gdy @samp{a} jest drukowalne
i widoczne.)

@item [:lower:]
Znaki małych liter alfabetu.

@item [:print:]
Znaki drukowalne (znaki nie będące znakami sterującymi).

@item [:punct:]
Znaki przestankowe (znaki nie będące literami, cyframi, znakami
sterującymi czy odstępami).

@item [:space:]
Znaki odstępu (jak spacja, tabulacja czy wysuw strony, by wymienić
tylko niektóre z nich).

@item [:upper:]
Znaki dużych liter alfabetu.

@item [:xdigit:]
Znaki będące cyframi szesnastkowymi.
@end table

Na przykład, przed standardem POSIX, by dopasować znaki alfanumeryczne,
należało napisać @code{/[A-Za-z0-9]/}.  Jeżeli wykorzystywany zestaw
znaków miał inne znaki alfabetu, to powyższe by ich nie dopasowywało.
Za pomocą POSIX-owych klas znaków można napisać @code{/[[:alnum:]]/},
i będzie to dopasowywać @emph{wszystkie} znaki literowe i cyfrowe naszego
zestawu znaków.

@cindex elementy sortowania
@cindex sortowania, elementy
@cindex elementy porządkowania
@cindex porządkowania, elementy
W listach znaków mogą pojawić się dwie dodatkowe specjalne sekwencje.
Mają one zastosowanie w zestawach znaków innych niż ASCII,
mających pojedyncze symbole (zwane @dfn{elementami porządkowania},
collating elements) reprezentowane przez więcej niż jeden znak, lub
też kilka znaków, które są sobie równoważne przy @dfn{porządkowaniu} czy
sortowaniu.  (Np. we francuskim zwykłe ``e'' i z akcentem grave
``@`e'' są równoważne.)

@table @asis
@cindex symbole porządkowania
@cindex porządkowania symbole
@item Symbole porządkowania (collating symbols)
@dfn{Symbol porządkowania} jest wieloznakowym elementem porządkowania
ujętym pomiędzy @samp{[.} a @samp{.]}.  Na przykład, jeśli @samp{ch} jest
elementem porządkowania, to @code{[[.ch.]]} jest wyrażeniem regularnym
dopasowującym ten element porządkowania, podczas gdy @code{[ch]} jest
wyrażeniem regularnym dopasowującym albo @samp{c} albo @samp{h}.

@cindex klasy równoważności
@cindex równoważność, klasy
@item Klasy równoważności (equivalence classes)
@dfn{Klasa równoważności} jest specyficzną dla ustawień narodowych (locale)
nazwą znaków, które są sobie równoważne. Nazwa ta jest ujęta między
@samp{[=} i @samp{=]}.  Na przykład, można użyć nazwy @samp{e} do
przedstawienia wszystkich ``e'', ``@`e'' i ``@'e''.  W tym przypadku,
@code{[[=e]]} jest wyrażeniem regularnym dopasowującym dowolny ze znaków
@samp{e}, @samp{@'e} lub @samp{@`e}.
@end table

Możliwości te są bardzo cenne przy ustawieniach innych niż język angielski.

@strong{Uwaga!} Funkcje biblioteczne wykorzystywane przez @code{gawk}
do dopasowywania wyrażeń regularnych rozpoznają obecnie jedynie POSIX-owe
klasy znaków; nie rozpoznają symboli porządkowania ani klas równoważności.
@c może kiedyś ...

@cindex dopełniająca lista znaków
@cindex lista znaków, dopełnienie
@item [^ @dots{}]
Jest to @dfn{dopełniająca lista znaków}.  Pierwszym znakiem po @samp{[}
@emph{musi} być @samp{^}.  Zapis ten dopasowuje dowolne znaki @emph{oprócz}
tych, które znajdują się w nawiasach kwadratowych.
Na przykład:

@example
[^0-9]
@end example

@noindent
dopasowuje dowolny znak nie będący cyfrą.

@item |
Jest to @dfn{operator alternatywy}.  Służy do podawania alternatyw.
Na przykład:

@example
^P|[0-9]
@end example

@noindent
dopasowuje dowolny łańcuch, który pasuje albo do @samp{^P} albo do
@samp{[0-9]}.  To znaczy, że dopasowuje dowolny łańcuch zaczynający się
od @samp{P} lub zawierający cyfrę.

Alternatywa odnosi się do największego możliwego wyrażenia regularnego
występującego po jednej ze stron.  Innymi słowy, @samp{|} ma najniższy
priorytet ze wszystkich operatorów wyrażeń regularnych.

@item (@dots{})
Nawiasy zwykłe służą do grupowania wyrażeń regularnych i arytmetycznych.
Można stosować je do sklejania wyrażeń regularnych zawierających operator
alternatywy, @samp{|}.  Na przykład, @samp{@@(samp|code)\@{[^@}]+\@}}
dopasowuje zarówno @samp{@@code@{foo@}} jak i @samp{@@samp@{bar@}}.  (Są to
sekwencje sterujące formatowaniem Texinfo.)

@item *
Ten symbol oznacza, że poprzedzające go wyrażenie regularne ma być
powtórzone tyle razy, ile jest to niezbędne do znalezienia dopasowania.
Na przykład:

@example
ph*
@end example

@noindent
stosuje symbol @samp{*} do poprzedzającego go @samp{h} i szuka dopasowań
pojedynczego @samp{p}, po którym występuje dowolna ilość @samp{h}.
Dopasuje ono również samo @samp{p}, jeśli nie wystąpią żadne @samp{h}.

@samp{*} powtarza @emph{najmniejsze} możliwe poprzedzające go
wyrażenie.  (Chcąc powtórzyć większe wyrażenie należy użyć nawiasów.)
Odnajduje tyle powtórzeń, ile to możliwe.  Na przykład:

@example
awk '/\(c[ad][ad]*r x\)/ @{ print @}' sample
@end example

@noindent
wypisuje każdy rekord z @file{sample} zawierający łańcuch postaci
@samp{(car x)}, @samp{(cdr x)}, @samp{(cadr x)}, i tak dalej.
Zauważ cytowanie nawiasów przez poprzedzenie ich odwrotnymi ukośnikami.

@item +
Symbol zbliżony do @samp{*}, ale poprzedzające go wyrażenie musi
zostać dopasowane przynajmniej jeden raz.  To znaczy, że:

@example
wh+y
@end example

@noindent
będzie dopasowywać @samp{why} i @samp{whhy}, ale nie @samp{wy},
podczas gdy @samp{wh*y} dopasowywałoby wszystkie te trzy łańcuchy.
Prostszym sposobem zapisania ostatniego przykładu @samp{*} jest:

@example
awk '/\(c[ad]+r x\)/ @{ print @}' sample
@end example

@item ?
Symbol podobny do @samp{*}, ale poprzedzające wyrażenie regularne może być
dopasowane raz albo wcale.  Na przykład:

@example
fe?d
@end example

@noindent
dopasuje @samp{fed} i @samp{fd}, ale nic innego.

@cindex @code{awk} język, wersja POSIX
@cindex POSIX @code{awk}
@cindex wyrażenia przedziałowe
@item @{@var{n}@}
@itemx @{@var{n},@}
@itemx @{@var{n},@var{m}@}
Jedna lub dwie liczby w nawiasach klamrowych oznaczają @dfn{wyrażenie
przedziałowe} (interval expression).  Jeśli w nawiasach jest jedna liczba,
to poprzedzające wyrażenie regularne powtarzane jest @var{n} razy.  Jeżeli
są tam dwie liczby rozdzielone przecinkiem, to poprzedzające wyrażenie
powtarzane jest od @var{n} do @var{m} razy.  Jeśli jest tam jedna
liczba, po której następuje przecinek, to poprzedzające
wyrażenie powtarzane jest co najmniej @var{n} razy.

@table @code
@item wh@{3@}y
dopasowuje @samp{whhhy}, ale nie @samp{why} czy @samp{whhhhy}.

@item wh@{3,5@}y
dopasowuje tylko @samp{whhhy} lub @samp{whhhhy} lub @samp{whhhhhy}.

@item wh@{2,@}y
dopasowuje @samp{whhy} lub @samp{whhhy}, i tak dalej.
@end table

Wyrażenia przedziałowe nie były tradycyjnie dostępne w @code{awk}.  Zostały
dodane jako część standardu POSIX, by @code{awk} i @code{egrep} były ze sobą
zgodne.

Ponieważ jednak stare programy mogą wykorzystywać @samp{@{} i @samp{@}}
w stałych regexp, domyślnie @code{gawk} @emph{nie} dopasowuje wyrażeń
przedziałowych w wyrażeniach regularnych. Jeżeli podano opcję @samp{--posix}
lub @samp{--re-interval} (@pxref{Opcje, , Opcje wiersza poleceń}),
to wyrażenia przedziałowe w wyrażeniach regularnych są dozwolone.
@end table

@cindex priorytet, operatory wyrażeń regularnych
@cindex operatory wyrażeń regularnych, priorytet
W wyrażeniach regularnych najwyższy priorytet mają operatory @samp{*},
@samp{+} id @samp{?}, tak samo jak nawiasy klamrowe @samp{@{} and
@samp{@}}.  Po nich występuje łączenie, i na koniec @samp{|}.
Tak jak w arytmetyce, nawiasy okrągłe mogą zmienić sposób grupowania
operatorów.

Jeśli @code{gawk} pracuje w trybie zgodności
(@pxref{Opcje, ,Opcje wiersza poleceń}),
klasy znaków i wyrażenia przedziałowe w wyrażeniach regularnych nie są
dostępne.

W następnej sekcji
omówiono operatory wyrażeń regularnych specyficzne dla GNU i podano
więcej szczegółów dotyczących tego, jak opcje wiersza poleceń wpływają
na sposób, w jaki @code{gawk} interpretuje znaki w wyrażeniach regularnych.

@node Operatory regexp GNU, Wielkość liter, Operatory regexp, Regexp
@section Dodatkowe operatory regexp w @code{gawk}

@c This section adapted from the regex-0.12 manual

@cindex operatory regexp, specyficzne dla GNU
Programy GNU mające działające na wyrażeniach regularnych
udostępniają kilka dodatkowych operatorów tych wyrażeń.
Opisano je w niniejszej sekcji.  Są one specyficzne dla
@code{gawk}; nie są dostępne w innych implementacjach @code{awk}.

@cindex słowo, definicja w wyrażeniu regularnym
Większość dodatkowych operatorów przeznaczonych jest do zadań związanych z
dopasowywaniem słów.  Do naszych celów, @dfn{słowo} jest ciągiem jednej
lub więcej liter, cyfr lub znaków podkreślenia (@samp{_}).

@table @code
@cindex @code{\w} operator regexp
@item \w
Ten operator dopasowuje dowolny ze znaków tworzących słowa, tj. dowolną
literę, cyfrę lub podkreślenie.  Można traktować go jako skrót dla
@c @w{@code{[A-Za-z0-9_]}} lub
@w{@code{[[:alnum:]_]}}.

@cindex @code{\W} operator regexp
@item \W
Dopasowuje dowolny znak nie będący znakiem współtworzącym słowa.
Można traktować go jako skrót dla
@c @w{@code{[^A-Za-z0-9_]}} lub
@w{@code{[^[:alnum:]_]}}.

@cindex @code{\<} operator regexp
@item \<
Ten operator dopasowuje pusty łańcuch na początku słowa.  Na przykład,
@code{/\<away/} dopasowuje @samp{away}, ale nie @samp{stowaway}.

@cindex @code{\>} operator regexp
@item \>
Ten operator dopasowuje pusty łańcuch na końcu słowa.  Na przykład,
@code{/stow\>/} dopasowuje @samp{stow}, ale nie @samp{stowaway}.

@cindex @code{\y} operator regexp
@cindex granice słów, dopasowywanie
@item \y
Ten operator dopasowuje pusty łańcuch albo na początku albo na końcu słowa.
Na przykład, (angielskie boundar@strong{y} to ``granica'').  Na przykład,
@samp{\yballs?\y} dopasowuje @samp{ball} lub @samp{balls} jako osobne słowo.

@cindex @code{\B} operator regexp
@item \B
Dopasowuje pusty łańcuch wewnątrz słowa.  Inaczej mówiąc, @samp{\B}
dopasowuje łańcuch pusty występujący pomiędzy dwoma znakami budującymi
słowa. Na przykład, @code{/\Brat\B/} dopasowuje @samp{crate}, ale nie
dopasowuje @samp{dirty rat}.  @samp{\B} jest w gruncie rzeczy przeciwieństwem
@samp{\y}.
@end table

Istnieją jeszcze dwa inne operatory, operujące na buforach. W Emacsie
@dfn{bufor} jest, naturalnie, buforem Emacsa.  Przy innych programach,
procedury biblioteczne regexp używane przez @code{gawk} traktują jako bufor
cały łańcuch jaki ma zostać dopasowany.

W @code{awk}, ponieważ @samp{^} i @samp{$} zawsze działają jako początek
i koniec łańcuchów, wspomniane operatory nie wnoszą żadnych nowych
możliwości.  Udostępniane są z uwagi na zgodność z innym oprogramowaniem GNU.

@cindex operatory dopasowania bufora
@cindex bufor, operatory dopasowania
@table @code
@cindex @code{\`} operator regexp
@item \`
Operator ten dopasowuje pusty łańcuch na początku bufora.

@cindex @code{\'} operator regexp
@item \'
Operator ten dopasowuje pusty łańcuch na końcu bufora.
@end table

W innych programach GNU operatorem granicy słowa jest @samp{\b}.
Jednak powoduje to konflikt w występującą w języku @code{awk} definicji
@samp{\b} jako backspace, więc @code{gawk} używa innej litery.

Metodą alternatywną byłby wymóg dwu odwrotnych ukośników w operatorach
GNU, ale zostało to uznane za
zbyt mylące, a obecna metoda stosowania @samp{\y} dla GNU @samp{\b}
wygląda na mniejsze zło.

@c NOTE!!! Keep this in sync with the same table in the summary appendix!
@cindex regexp, wpływ opcji wiersza poleceń
@cindex wyrażenia regularne, wpływ opcji wiersza poleceń
Rozmaite opcje wiersza poleceń
(@pxref{Opcje, ,Opcje wiersza poleceń})
decydują o sposobie, w jaki @code{gawk} interpretuje znaki w wyrażeniach
regularnych.

@table @asis
@item Bez opcji
W przypadku domyślnym udostępnia wszystkie możliwości wyrażeń regularnych
POSIX-a i operatory GNU opisane
@iftex
powyżej.
@end iftex
@ifinfo
w @ref{Operatory regexp, , Operatory wyrażeń regularnych}.
@end ifinfo
Wyrażenia przedziałowe nie są jednak obsługiwane.

@item @code{--posix}
Obsługiwane są tylko wyrażenia regularne POSIX, operatory GNU nie mają
specjalnego znaczenia (np., @samp{\w} dopasowuje dosłowne @samp{w}).
Wyrażenia przedziałowe są dozwolone.

@item @code{--traditional}
Dopasowywane są wyrażenia regularne tradycyjnego uniksowego @code{awk}.
Operatory GNU nie mają znaczenia specjalnego, nie są dostępne wyrażenia
przedziałowe ani POSIX-owe klasy znaków (@code{[[:alnum:]]} i tak dalej).
Znaki opisane ósemkowymi i szesnastkowymi sekwencjami specjalnymi traktowane
są dosłownie, nawet jeśli reprezentują metaznaki wyrażeń regularnych.

@item @code{--re-interval}
Dopuszcza wyrażenia przedziałowe w wyrażeniach regularnych, nawet jeśli
podano @samp{--traditional}.
@end table

@node Wielkość liter, Lewe najdłuższe, Operatory regexp GNU, Regexp
@section Uwzględnianie wielkości liter w dopasowaniach

@cindex uzwględnianie wielkości liter
@cindex wielkość liter
@cindex ignorowanie wielkości liter
Normalnie w wyrażeniach regularnych wielkość liter jest znacząca,
zarówno przy dopasowywaniu zwykłych znaków (tj.@: nie metaznaków), jak i
wewnątrz zestawów znaków.  Stąd @samp{w} w wyrażeniu regularnych dopasowuje
wyłącznie małą literę @samp{w} a nie duże @samp{W}.

Najprostszym sposobem wykonania dopasowania niezależnego od wielkości liter
jest użycie listy znaków: @samp{[Ww]}.  Może być on jednak niewygodny
jeśli trzeba stosować go często; utrudnia też czytanie wyrażeń
regularnych.  Istnieją dwie alternatywne metody, które mogą się bardziej
podobać.
@c  There are two alternatives that you might prefer.

Jednym ze sposobów wykonania dopasowania bez rozróżniania wielkości liter
w danym miejscu programu jest konwersja danych na jednakową wielkość
liter, za pomocą wbudowanych funkcji łańcuchowych @code{tolower} lub
@code{toupper} (których jeszcze nie omawialiśmy;
@pxref{Funkcje łańcuchowe, ,Funkcje wbudowane działające na łańcuchach}).
Na przykład:

@example
tolower($1) ~ /foo/  @{ @dots{} @}
@end example

@noindent
przekształca pierwsze pole na małe litery przed wykonaniem na nim
dopasowania.  Działa to w dowolnej implementacji @code{awk} zgodnej z POSIX.

@cindex różnice między @code{gawk} a @code{awk}
@cindex @code{~} operator
@cindex @code{!~} operator
@vindex IGNORECASE
Inną metodą, specyficzną dla @code{gawk}, jest nadanie zmiennej
@code{IGNORECASE} wartości niezerowej (@pxref{Zmienne wbudowane}).
Gdy @code{IGNORECASE} jest niezerowe, @emph{wszystkie} operacje na
wyrażeniach regularnych i łańcuchach ignorują wielkość liter.
Zmiana wartości @code{IGNORECASE} steruje dynamicznie wrażliwością programu
na wielkość liter w trakcie jego działania.  Domyślnie wielkość znaków jest
istotna, ponieważ @code{IGNORECASE} (jak większość zmiennych) jest
inicjowana na zero.

@example
@group
x = "aB"
if (x ~ /ab/) @dots{}   # ten test się nie powiedzie
@end group

@group
IGNORECASE = 1
if (x ~ /ab/) @dots{}   # a teraz się uda
@end group
@end example

Ogólnie, nie można wykorzystać @code{IGNORECASE} do zrobienia pewnych reguł
niewrażliwymi na wielkość liter a innych wrażliwymi, gdyż nie ma możliwości
ustawienia @code{IGNORECASE} tylko dla wzorca konkretnej reguły.
@ignore
Nie jest to całkiem prawda. Rozważmy:

	IGNORECASE=1 && /foObAr/ { .... }
	IGNORECASE=0 || /foobar/ { .... }

Lecz jest to raczej zły styl pisania i nie chciałbym w to wchodzić
But that's pretty bad style and I don't want to get into it at this
late date.
@end ignore
Chcąc zrobić coś takiego, musimy użyć list znaków lub @code{tolower}.
Jednak jedną z rzeczy, jakie można zrobić z @code{IGNORECASE}, jest
dynamiczne włączanie lub wyłączanie uwzględniania wielkości liter dla
wszystkich reguł naraz.

@code{IGNORECASE} można ustawić w wierszu poleceń lub w regule @code{BEGIN}
(@pxref{Inne argumenty, ,Inne argumenty wiersza poleceń}; także
@pxref{Używanie BEGIN/END, ,Akcje początkowe i końcowe}).  Ustawienie
@code{IGNORECASE} z wiersza poleceń jest sposobem na uczynienie programu
niewrażliwym na wielkość liter bez konieczności zmieniania go.

Przed wersją 3.0 @code{gawk}, wartość @code{IGNORECASE} wpływała tylko
na operacje na wyrażeniach regularnych.  Nie dotyczyła porównywania
łańcuchów przez @samp{==}, @samp{!=}, i tak dalej.  Począwszy od
wersji 3.0, @code{IGNORECASE} ma wpływ zarówno na działania na wyrażeniach
regularnych jak i na łańcuchach.

@cindex ISO 8859-1
@cindex ISO Latin-1
Począwszy od wersji 3.0 @code{gawk}, równoważniki między dużymi a małymi
znakami oparte są na zestawie znaków ISO-8859-1 (ISO Latin-1). Zestaw ten
jest nadzbiorem tradycyjnych 128 znaków ASCII, udostępniającym też wiele
znaków odpowiednich do użytku w językach europejskich [tłum.: niestety --
zachodnioeuropejskich].
@ignore
Można zamiast tego używać czystego zestawu znaków ASCII jeśli @code{gawk}
zostanie skompilowany z @samp{-DUSE_PURE_ASCII}.
@end ignore

Wartość @code{IGNORECASE} nie ma znaczenia jeśli @code{gawk} pracuje w
trybie zgodności (@pxref{Opcje, ,Opcje wiersza poleceń}).  W trybie
zgodności wielkość liter jest zawsze istotna.

@node Lewe najdłuższe, Regexp obliczane, Wielkość liter, Regexp
@section Jak bardzo pasuje tekst?

@cindex lewe najdłuższe dopasowanie
@cindex dopasowanie, lewe najdłuższe
Rozważmy następujący przykład:

@example
echo aaaabcd | awk '@{ sub(/a+/, "<A>"); print @}'
@end example

Przykład ten wykorzystuje funkcję @code{sub} (której jeszcze nie omawialiśmy,
@pxref{Funkcje łańcuchowe, ,Funkcje wbudowane działające na łańcuchach})
do zmiany rekordu wejściowego.  Występujące tu wyrażenie regularne
@code{/a+/} oznacza ``co najmniej jeden znak @samp{a}'',
a tekstem zastępującym jest @samp{<A>}.

Wejście zawiera cztery znaki @samp{a}.  Jakie będzie wyjście?
Inaczej mówiąc, ile to jest ``co najmniej jeden'' -- czy @code{awk}
dopasuje dwa, trzy czy wszystkie cztery znaki @samp{a}?

Odpowiedź brzmi: wyrażenia regularne @code{awk} (i POSIX-a) zawsze
dopasowują pierwszy z lewej @emph{najdłuższy} ciąg znaków wejściowych,
jaki można dopasować.  Zatem, w tym przykładzie, przez @samp{<A>}
zostaną zastąpione wszystkie cztery znaki @samp{a}.

@example
$ echo aaaabcd | awk '@{ sub(/a+/, "<A>"); print @}'
@print{} <A>bcd
@end example

Przy prostych sprawdzeniach typu pasuje/nie pasuje, nie jest to takie ważne.
Jednak przy
@c dokonywaniu podziału na pola i rekordy opartego na wyrażeniach
@c regularnych, czy przy
dopasowywaniu tekstów i podstawieniach przez funkcje
@code{match}, @code{sub}, @code{gsub} i @code{gensub}, jest bardzo istotne.
@ifinfo
@xref{Funkcje łańcuchowe, ,Funkcje wbudowane działające na łańcuchach},
gdzie bliżej opisano te funkcje.
@end ifinfo
Zrozumienie tej zasady jest również istotne przy podziale na pola i rekordy
opartym na wyrażeniach regularnych (@pxref{Rekordy, ,Jak wejście dzielone jest na rekordy},
a także @pxref{Separatory pól, ,Jak rozdzielać pola}).

@node Regexp obliczane, , Lewe najdłuższe, Regexp
@section Stosowanie dynamicznych wyrażeń regularnych

@cindex obliczane wyrażenia regularne
@cindex wyrażenia regularne, obliczane
@cindex dynamiczne wyrażenia regularne
@cindex wyrażenia regularne, dynamiczne
@cindex regexp, dynamiczne
@cindex @code{~} operator
@cindex @code{!~} operator
Prawa strona operatora @samp{~} lub @samp{!~} nie musi być stałym wyrażeniem
regularnym (tj.@: łańcuchem znaków pomiędzy ukośnikami).  Może być dowolnym
wyrażeniem.  Wyrażenie podlega wyliczeniu wartości i jej przekształceniu na
łańcuch, jeśli zachodzi taka potrzeba; zawartość łańcucha używana jest jako
wyrażenie regularne.  Wyrażenie regularne obliczane w ten sposób nazywane
jest @dfn{dynamicznym wyrażeniem regularnym}.  Na przykład:

@example
BEGIN @{ identifier_regexp = "[A-Za-z_][A-Za-z_0-9]*" @}
$0 ~ identifier_regexp    @{ print @}
@end example

@noindent
przypisuje do @code{identifier_regexp} wyrażenie regularne
opisujące nazwy zmiennych @code{awk} i sprawdza, czy rekord wejściowy
pasuje do tego wyrażenia.

@ignore
Do we want to use "^[A-Za-z_][A-Za-z_0-9]*$" to restrict the entire
record to just identifiers?  Doing that also would disrupt the flow of
the text.
@end ignore

@strong{Uwaga!} W stosowaniu operatorów @samp{~} i @samp{!~}
istnieje różnica pomiędzy stałym regexp ujętym w ukośniki a stałą
łańcuchową ujętą w cudzysłowy.  Jeśli mamy zamiar użyć stałej łańcuchowej,
powinniśmy rozumieć, że łańcuch w gruncie rzeczy badany jest
@emph{dwukrotnie}: za pierwszym razem gdy @code{awk} czyta program, i za
drugim gdy zamierza dopasować łańcuch stojący po lewej stronie operatora ze
wzorcem po prawej.  Obowiązuje to nie tylko dla stałych łańcuchowych, ale
i dowolnych wyrażeń o wartości łańcuchowej (jak  @code{identifier_regexp}
powyżej).

@cindex stałe regexp, różnica między ukośnikami a cudzysłowami
Co wynika z tego, że łańcuch jest sprawdzany dwukrotnie?  Istotna
różnica występuje przy sekwencjach specjalnych, w szczególności przy
odwrotnych ukośnikach.  W celu umieszczenia odwrotnego ukośnika w wyrażeniu
regularnym wewnątrz łańcucha musimy wpisać dwa odwrotne ukośniki.

Na przykład, @code{/\*/} jest stałą regexp opisującą dosłowne @samp{*}.
Potrzebny jest tylko jeden odwrotny ukośnik.  Chcąc zrobić to samo za
pomocą łańcucha, musielibyśmy wpisać @code{"\\*"}.  Pierwszy odwrotny
ukośnik służy tylko do zacytowania drugiego, tak że łańcuch faktycznie
zawiera dwa znaki @samp{\} i @samp{*}.

@cindex częste pomyłki
@cindex pomyłki, częste
@cindex błędy, częste
Skoro do opisu wyrażenia regularnego możemy użyć zarówno
stałej typu regexp jak i stałej łańcuchowej, którą z nich powinniśmy
zastosować?  Odpowiedź brzmi: ``stałą regexp'', z kilku powodów.

@enumerate 1
@item
Stałe łańcuchowe są bardziej skomplikowane w pisaniu i trudniejsze
w czytaniu.  Stosowanie stałych regexp powoduje, że
program staje się mniej podatny na błędy.  Brak zrozumienia różnicy
pomiędzy tymi dwoma rodzajami stałych jest typowym źródłem błędów.

@item
Używanie stałych regexp jest też bardziej efektywne: @code{awk} potrafi
zauważyć, że podaliśmy wyrażenie regularne i przechowuje je wewnętrznie
w postaci powodującej efektywniejsze dopasowywanie wzorców.  Przy zastosowaniu
stałej łańcuchowej, @code{awk} musi najpierw przekształcić łańcuch na taką
postać wewnętrzną, a następnie dopiero wykonać dopasowanie wzorca.

@item
Używanie stałych regexp to lepszy styl pisania; jasno pokazuje, że
mamy na myśli dopasowanie wyrażenia regularnego.
@end enumerate

@node Czytanie plików, Wypisywanie, Regexp, Top
@chapter Czytanie plików wejściowych

@cindex odczyt plików
@cindex czytanie plików
@cindex wejście
@cindex standardowe wejście
@vindex FILENAME
W typowym programie @code{awk}, całość wejścia czytana jest albo ze
standardowego wejścia (domyślnie z klawiatury, ale często potokiem z innego
polecenia) albo z plików, których nazwy podano w wierszu poleceń @code{awk}.
Jeżeli podano pliki wejściowe, to @code{awk} czyta je kolejno, odczytując
wszystkie dane z jednego przed przejściem do następnego.  Nazwę bieżącego
pliku wejściowego można znaleźć w zmiennej wbudowanej
@code{FILENAME} (@pxref{Zmienne wbudowane}).

Wejście czytane jest jednostkami zwanymi @dfn{rekordami}, i przetwarzane
przez reguły danego programu po jednym rekordzie naraz.  Domyślnie każdy
rekord jest jednym wierszem.  Każdy rekord jest automatycznie dzielony na
kawałki zwane @dfn{polami}.  Ułatwia to programom pracę z częściami rekordów.

Przy rzadkich okazjach zachodzi potrzeba zastosowania polecenia
@code{getline}.  Jest cenne, ponieważ potrafi bezpośrednio
pobierać dane z dowolnej ilości plików, a ponadto pliki, których
używa nie muszą być podane w wierszu poleceń
@code{awk} (@pxref{Getline, ,Odczyt bezpośredni przez @code{getline}}).

@menu
* Rekordy::                     Sterowanie podziałem danych na rekordy.
* Pola::                        Wprowadzenie do pól.
* Pola nie-stałe::              Numery pól nie będące stałymi.
* Zmiana pól::                  Zmiana zawartości pól.
* Separatory pól::              Separator pól. Jak go zmienić.
* Stały rozmiar::               Czytanie danych o stałej szerokości.
* Wiele wierszy::               Czytanie rekordów wielowierszowych.
* Getline::                     Odczyt plików pod bezpośrednią kontrolą
                                programu przy wykorzystaniu funkcji
                                @code{getline}.
@end menu

@node Rekordy, Pola, Czytanie plików, Czytanie plików
@section Jak wejście dzielone jest na rekordy

@cindex separator rekordów, @code{RS}
@cindex rekordy, separator @code{RS}
@cindex zmiana separatora rekordów
@cindex rekord, definicja
@vindex RS
Narzędzie @code{awk} dzieli wejście naszego programu @code{awk}
na rekordy i pola.
Rekordy oddzielane są znakiem nazywanym @dfn{separatorem rekordów}
(record separator).
Domyślnie separatorem rekordów jest znak nowej linii.
Z tego powodu domyślnie rekordy są pojedynczymi wierszami.
Jako separatora rekordów można użyć innego znaku, przypisując go
zmiennej wbudowanej @code{RS}.

Wartość @code{RS}, jak każdej innej zmiennej programu @code{awk},
można zmienić za pomocą operatora przypisania @samp{=}
(@pxref{Operatory przypisania, ,Wyrażenia przypisania}).
Nowy znak separatora rekordów powinien być ujęty w znaki cudzysłowu,
które sygnalizują stałą łańcuchową.  Często odpowiednim do wykonania takiej
zmiany miejscem jest początek wykonywania programu, przed przetworzeniem
czegokolwiek z wejścia, tak by pierwszy rekord został odczytany za pomocą
właściwego separatora.
Można to osiągnąć wykorzystując specjalny wzorzec @code{BEGIN}
(@pxref{BEGIN/END, ,Wzorce specjalne @code{BEGIN} i @code{END}}).
Na przykład:

@example
awk 'BEGIN @{ RS = "/" @} ; @{ print $0 @}' BBS-list
@end example

@noindent
zmienia wartość @code{RS} na @code{"/"}, przed odczytaniem czegokolwiek
z wejścia.  Pierwszym znakiem tego łańcucha jest ukośnik.  W rezultacie,
rekordy separowane są ukośnikami.  Następnie czytany jest plik wejściowy,
a druga reguła programu (akcja bez wzorca) wypisuje każdy rekord.  Ponieważ
każda instrukcja @code{print} na końcu swego wyjścia dodaje znak nowej
linii, efektem pracy tego programu jest skopiowanie wejścia z każdym
ukośnikiem zmienionym na znak nowej linii.  A oto wyniki uruchomienia
programu z plikiem @file{BBS-list}:

@example
@group
$ awk 'BEGIN @{ RS = "/" @} ; @{ print $0 @}' BBS-list
@print{} aardvark     555-5553     1200
@print{} 300          B
@print{} alpo-net     555-3412     2400
@print{} 1200
@print{} 300     A
@print{} barfly       555-7685     1200
@print{} 300          A
@print{} bites        555-1675     2400
@print{} 1200
@print{} 300     A
@print{} camelot      555-0542     300               C
@print{} core         555-2912     1200
@print{} 300          C
@print{} fooey        555-1234     2400
@print{} 1200
@print{} 300     B
@print{} foot         555-6699     1200
@print{} 300          B
@print{} macfoo       555-6480     1200
@print{} 300          A
@print{} sdace        555-3430     2400
@print{} 1200
@print{} 300     A
@print{} sabafoo      555-2127     1200
@print{} 300          C
@print{}
@end group
@end example

@noindent
Zauważ, że pozycja BBS-u @samp{camelot} nie została podzielona.
W pierwotnym pliku
(@pxref{Przykładowe pliki danych, , Pliki danych do przykładów}),
odpowiedni wiersz wygląda tak:

@example
camelot      555-0542     300               C
@end example

@noindent
Ponieważ @samp{camelot} ma tylko jedną prędkość transmisji, to w jego
rekordzie nie ma ukośników.

Można też zmienić separator rekordów w inny sposób, w wierszu poleceń,
wykorzystując możliwość przypisywania wartości
zmiennej (@pxref{Inne argumenty, ,Inne argumenty wiersza poleceń}).

@example
awk '@{ print $0 @}' RS="/" BBS-list
@end example

@noindent
Przed przetworzeniem @file{BBS-list} @code{RS} nadawana jest wartość @samp{/}.

Wykorzystanie jako separatora rekordów tak nietypowego znaku jak @samp{/}
daje w przeważającej większości przypadków prawidłowe zachowanie się
programu.  Jednak poniższy (skrajny) przykład potoku wypisuje zaskakujące
@samp{1}.  Występuje tu tylko jedno pole, składające się ze znaku nowej
linii.  Wartością zmiennej wbudowanej @code{NF} jest liczba pól bieżącego
rekordu.

@example
@group
$ echo | awk 'BEGIN @{ RS = "a" @} ; @{ print NF @}'
@print{} 1
@end group
@end example

@cindex ciemny kąt
@noindent
Osiągnięcie końca pliku wejściowego kończy bieżący rekord wejściowy, nawet
jeśli ostatni znak pliku nie jest znakiem z @code{RS}
(c.k.).

@cindex empty string
Łańcuch pusty, @code{""} (łańcuch nie zawierający żadnych znaków), ma
specjalne znaczenie jako wartość @code{RS}: oznacza on, że rekordy są
rozdzielone jednym lub wieloma wierszami pustymi, i niczym innym więcej.
@xref{Wiele wierszy, ,Rekordy wielowierszowe}, gdzie opisano szczegóły.

Jeżeli zmienimy wartość @code{RS} w środku działania @code{awk}, to nowa
wartość będzie używana do rozdzielania kolejnych rekordów, ale nie będzie to
mieć wpływu na aktualnie przetwarzany rekord (i rekordy już przetworzone).

@vindex RT
@cindex zakończenie rekordu, @code{RT}
@cindex zakończenie, rekordu
@cindex terminator, rekordu
@cindex różnice między @code{gawk} a @code{awk}
Po wyznaczeniu końca rekordu @code{gawk} nadaje zmiennej @code{RT} (record
terminator) wartość tekstu wejścia, który dopasował @code{RS}.

@cindex wyrażenia regularne jako separatory rekordów
Wartość @code{RS} nie jest w rzeczywistości ograniczona do łańcucha
jednoznakowego.  Może być dowolnym wyrażeniem regularnym
(@pxref{Regexp, ,Regular Expressions}).  Ogólnie, każdy rekord kończy się
na następnym łańcuchu pasującym do tego wyrażenia regularnego.  Następny
rekord zaczyna się na końcu dopasowanego łańcucha.  Ta ogólna zasada działa
faktycznie w zwykłym, codziennym przypadku, gdy @code{RS} zawiera tylko znak
nowej linii: rekord kończy się u początku następnego pasującego łańcucha
(następnego znaku nowej linii z wejścia) a kolejny rekord zaczyna się zaraz
za końcem tego łańcucha (od pierwszego znaku kolejnego wiersza).
Znak nowej linii, jako pasujący do @code{RS}, nie jest częścią żadnego
z tych rekordów.

Jeśli @code{RS} jest pojedynczym znakiem, to @code{RT} będzie zawierać ten
sam pojedynczy znak.  Jednak, gdy @code{RS} będzie wyrażeniem regularnym,
@code{RT} staje się bardziej przydatne.  Zawiera wówczas faktyczny tekst
wejściowy dopasowany wyrażeniem regularnym.

Poniższy przykład ilustruje obie te właściwości.
Nadaje @code{RS} wartość wyrażenia regularnego dopasowującego albo znak
nowej linii albo ciąg dużych liter z opcjonalnymi początkowymi i/lub
końcowymi białymi znakami (@pxref{Regexp, , Regular Expressions}).

@example
$ echo rekord 1 AAAA rekord 2 BBBB rekord 3 |
> gawk 'BEGIN @{ RS = "\n|( *[[:upper:]]+ *)" @}
>             @{ print "Rekord =", $0, "a RT =", RT @}'
@print{} Rekord = rekord 1 a RT =  AAAA
@print{} Rekord = rekord 2 a RT =  BBBB
@print{} Rekord = rekord 3 a RT =
@print{}
@end example

@noindent
Ostatni wiersz wyjścia ma dodatkowy pusty wiersz. Wynika to stąd, że
wartością @code{RT} jest znak nowej linii, po którym instrukcja @code{print}
dokłada swój własny końcowy znak nowej linii.

@xref{Prosty sed, ,Prosty edytor strumieniowy}, gdzie umieszczono przydatniejszy
przykład @code{RS} jako wyrażenia regularnego i wynikającego stąd @code{RT}.

@cindex różnice między @code{gawk} a @code{awk}
Użycie @code{RS} jako wyrażenia regularnego i zmienna @code{RT} są
rozszerzeniami.  Nie są one dostępne w trybie zgodności
(@pxref{Opcje, ,Opcje wiersza poleceń}).
W trybie tym do określenia końca rekordu używany jest tylko pierwszy znak
wartości @code{RS}.

@cindex liczba rekordów, @code{NR}, @code{FNR}
@vindex NR
@vindex FNR
Narzędzie @code{awk} zapamiętuje liczbę rekordów, jakie do tej pory
przeczytano z bieżącego pliku wejściowego.  Wartość ta przechowywana jest
we wbudowanej zmiennej o nazwie @code{FNR}.  Jest ona zerowana przy
rozpoczynaniu nowego pliku.  Inna zmienna wbudowana, @code{NR}, Jest
całkowitą liczbą rekordów przeczytanych dotąd ze wszystkich plików danych.
Zaczyna się od zera, ale nigdy nie jest automatycznie zerowana.

@node Pola, Pola nie-stałe, Rekordy, Czytanie plików
@section Badanie pól

@cindex sprawdzanie pól
@cindex pola
@cindex odwoływanie się do pól
Przy odczycie przez @code{awk} rekordu wejściowego, jest on automatycznie
rozdzielany, @dfn{parsowany}, przez interpreter na kawałki zwane
@dfn{polami} (fields).  Domyślnie pola rozdzielane są białymi znakami,
podobnie jak słowa w wierszu.

Biały znak w @code{awk} oznacza łańcuch złożony z jednej lub więcej spacji,
tabulacji lub znaków nowej linii; @footnote{W POSIX-owym @code{awk}, znaki
nowej linii przy podziale na pola nie są uważane za białe znaki.} inne
znaki, jak formfeed (znak wysuwu strony), i tak dalej, uważane za białe znaki
przez inne języki @emph{nie} są białymi znakami dla @code{awk}.

Celem istnienia pól jest zapewnienie nam wygodniejszego dostępu przy
odwoływaniu się do tych fragmentów rekordu.  Nie musimy ich używać -- jeśli
chcemy, możemy działać na całym rekordzie -- ale to dzięki polom proste
programy @code{awk} są tak efektywne.

@cindex @code{$} (operator pola)
@cindex pola, operator pola, @code{$}
Odwołując się do pola w programie @code{awk}, używamy znaku dolara, @samp{$},
po którym występuje numer żądanego pola.  Zatem, @code{$1} odnosi się do
pierwszego pola, @code{$2} do drugiego, i tak dalej.  Na przykład, załóżmy
że mamy następujący wiersz wejścia:

@example
To wygląda na całkiem ładny przykład.
@end example

@noindent
Pierwszym polem, lub @code{$1}, jest tutaj @samp{To}.  Drugim polem, lub
@code{$2}, jest @samp{wygląda}, i tak dalej.  Zauważ, że ostatnim polem
@code{$7}, jest @samp{przykład.}.  Ponieważ pomiędzy @samp{d} a @samp{.} nie
ma odstępu, kropka uważana jest za część siódmego pola.

@vindex NF
@cindex liczba pól, @code{NF}
@code{NF} jest zmienną wbudowaną, której wartość jest liczbą pól bieżącego
rekordu.
@code{awk} automatycznie aktualizuje wartość @code{NF} za każdym razem,
gdy czytany jest rekord.

Bez względu na to, ile jest pól, ostatnie pole można przedstawić jako
@code{$NF}.  Zatem w powyższym przykładzie @code{$NF} byłoby tym samym, co
@code{$7}, czyli @samp{przykład.}.  Dlaczego działa taka notacja wyjaśniono
poniżej (@pxref{Pola nie-stałe, ,Numery pól nie będące stałymi}).
Próbując odwołać się do pola za ostatnim polem, jak na przykład @code{$8}
gdy rekord ma tylko siedem pól, otrzymujemy łańcuch pusty.
@c the empty string acts like 0 in some contexts, but I don't want to
@c get into that here....

@code{$0}, wyglądający jak odwołanie do ``zerowego'' pola, jest przypadkiem
specjalnym:  reprezentuje cały rekord wejściowy.  @code{$0} wykorzystuje
się, gdy nie jesteśmy zainteresowani polami:

@c POTRZEBNE
@page
Oto jeszcze kilka przykładów:

@example
@group
$ awk '$1 ~ /foo/ @{ print $0 @}' BBS-list
@print{} fooey        555-1234     2400/1200/300     B
@print{} foot         555-6699     1200/300          B
@print{} macfoo       555-6480     1200/300          A
@print{} sabafoo      555-2127     1200/300          C
@end group
@end example

@noindent
W tym przykładzie wypisywany jest każdy rekord pliku @file{BBS-list},
którego pierwszego pole zawiera łańcuch @samp{foo}.  Operator @samp{~}
nazywany jest @dfn{operatorem dopasowania}
(@pxref{Używanie regexp, , Jak stosować wyrażenia regularne}).
Sprawdza on czy łańcuch (tutaj: pole @code{$1}) pasuje do zadanego wyrażenia
regularnego.

Poniższy przykład, w przeciwieństwie do poprzedniego, szuka @samp{foo}
w @emph{całym rekordzie} i wypisuje pierwsze i ostatnie pole dla każdego
dopasowanego rekordu wejściowego.

@example
@group
$ awk '/foo/ @{ print $1, $NF @}' BBS-list
@print{} fooey B
@print{} foot B
@print{} macfoo A
@print{} sabafoo C
@end group
@end example

@node Pola nie-stałe, Zmiana pól, Pola, Czytanie plików
@section Numery pól nie będące stałymi

Liczba pól nie musi być stała.  Po @samp{$} może wystąpić dowolne wyrażenie
języka @code{awk}.  Wartość wyrażenia będzie określać numer pola.  Jeżeli
wartością jest łańcuch, a nie liczba, to jest zostanie przekształcony
na liczbę.
Rozważmy przykład:

@example
awk '@{ print $NR @}'
@end example

@noindent
Przypomnijmy, że @code{NR} jest liczbą dotychczas odczytanych rekordów:
jeden przy pierwszym rekordzie, dwa przy drugim, itd.  Przykład wypisuje
więc pierwsze pole pierwszego rekordu, drugie pole drugiego rekordu, i tak
dalej.  Dla dwudziestego rekordu wypisywane jest pole numer 20.
Najprawdopodobniej rekord ma mniej niż 20 pól, więc nasz kod wypisze
pusty wiersz.

Oto inny przykład zastosowania wyrażeń jako numerów pól:

@example
awk '@{ print $(2*2) @}' BBS-list
@end example

@code{awk} musi wyznaczyć wartość wyrażenia @samp{(2*2)} i użyć jej jako
numeru pola, jakie ma być wypisane.  Znak @samp{*} reprezentuje mnożenie,
więc wyliczoną wartością wyrażenia @samp{2*2} jest cztery.
Ponieważ użyto nawiasów, mnożenie wykonywane jest przed operacją
@samp{$}.  Są one niezbędne zawsze wtedy, gdy w wyrażeniu określającym numer
pola występuje operator dwuargumentowy.  Nasz przykład, zatem, wypisuje
godziny pracy (czwarte pole) dla każdego wiersza pliku @file{BBS-list}.
(Wszystkie operatory @code{awk}, w kolejności malejących priorytetów
spisano w @ref{Priorytet, , Priorytet operatorów}.)
Jeśli obliczony numer pola wynosi zero, to otrzymujemy cały rekord.
Zatem, @code{$(2-2)} ma tę samą wartość, co @code{$0}.  Ujemne numery pól
są niedozwolone.  Próba ich użycia na ogół przerywa działanie programu
@code{awk}.  (Standard POSIX nie definiuje, co się dzieje przy odwołaniu
do ujemnego numeru pola.  @code{gawk} zauważa taką sytuację i przerywa
program.  Inne implementacje @code{awk} mogą się inaczej zachowywać.)

Jak wspomniano w @ref{Pola, ,Badanie pól},
liczba pól bieżącego rekordu przechowywana jest w zmiennej wbudowanej
@code{NF} (również @pxref{Zmienne wbudowane}).  Wyrażenie @code{$NF} nie
jest specjalną cechą: jest bezpośrednią konsekwencją wyznaczenia @code{NF}
i użycia otrzymanej wartości jako numeru pola.

@node Zmiana pól, Separatory pól, Pola nie-stałe, Czytanie plików
@section Zmiana zawartości pól

@cindex pola, zmiana zawartości
@cindex zmiana zawartości pola
@cindex przypisania do pól
W programie @code{awk} można zmieniać zawartość pól widzianych przez @code{awk}.
Zmienia to równocześnie to, co @code{awk} postrzega jako bieżący rekord
wejściowy.  (Faktyczne wejście pozostaje nietknięte; @code{awk} @emph{nigdy}
nie zmienia pliku wejściowego.)

Rozważmy taki przykład i jego wyniki:

@example
@group
$ awk '@{ $3 = $2 - 10; print $2, $3 @}' inventory-shipped
@print{} 13 3
@print{} 15 5
@print{} 15 5
@dots{}
@end group
@end example

@noindent
Znak @samp{-} reprezentuje odejmowanie, więc program przypisuje trzeciemu
polu, @code{$3}, nową wartość równą wartości drugiego pola minus
dziesięć, @samp{$2 - 10}.  (@xref{Operatory arytmetyczne, ,Operatory arytmetyczne}.)
Następnie wypisywane jest pole numer dwa i nowa wartość pola numer trzy.

Tekst w polu @code{$2} musi mieć sens jako liczba aby to zadziałało.
Łańcuch znaków musi zostać przekształcony na liczbę, by komputer mógł na nim
wykonać obliczenia arytmetyczne.  Wynikła z odejmowania liczba jest
powtórnie przekształcana na łańcuch znaków, który następnie staje się
polem numer trzy.
@xref{Konwersja, ,Konwersja łańcuchów i liczb}.

Przy zmianie wartości pola (postrzeganego przez @code{awk}), tekst rekordu
wejściowego jest przeliczany tak, by zawierał nowe pole w miejscu starego.
Stąd też, @code{$0} zmienia się, by odzwierciedlić odmienione pole.
Zatem, powyższy program wypisuje kopię pliku wejściowego, z dziesiątką odjętą
od drugiego pola każdego wiersza.

@example
@group
$ awk '@{ $2 = $2 - 10; print $0 @}' inventory-shipped
@print{} Jan 3 25 15 115
@print{} Feb 5 32 24 226
@print{} Mar 5 24 34 228
@dots{}
@end group
@end example

Można także przypisać wartość polom spoza zakresu.  Na przykład:

@example
$ awk '@{ $6 = ($5 + $4 + $3 + $2)
>        print $6 @}' inventory-shipped
@print{} 168
@print{} 297
@print{} 301
@dots{}
@end example

@noindent
Właśnie stworzyliśmy @code{$6}, którego wartością jest suma pól
@code{$2}, @code{$3}, @code{$4} i @code{$5}.  Znak @samp{+} reprezentuje
dodawanie.  W przypadku pliku @file{inventory-shipped} pole @code{$6}
przedstawia całkowitą liczbę paczek wysłanych w konkretnym miesiącu.

Tworzenie nowego pola zmienia używaną przez @code{awk} wewnętrzną kopię
rekordu wejściowego -- wartość @code{$0}.  Zatem, jeżeli po dodaniu pola
wykonamy @samp{print $0}, to wypisany rekord będzie zawierał nowe pole,
z odpowiednią ilością separatorów pól pomiędzy nim a uprzednio istniejącymi
polami.

Przeliczenie to ma wpływ na wartość @code{NF}
(liczbę pól; @pxref{Pola, ,Badanie pól}). Równocześnie zaś podlega
wpływom zmiennej @code{NF} i, elementowi jeszcze nie omawianemu,
@dfn{separatorowi pól wyjściowych}, @code{OFS}, używanemu do rozdzielania
pól (@pxref{Separatory wyjścia}).
Na przykład, wartość @code{NF} ustalana jest na numer najdalszego
stworzonego przez nas pola.

Zauważ jednak, że samo @emph{odwołanie się} do pola spoza zakresu
@emph{nie} zmienia wartości ani @code{$0} ani @code{NF}.  Odwołanie do pola
spoza zakresu jedynie daje pusty łańcuch.  Na przykład:

@example
if ($(NF+1) != "")
    print "nie może wystąpić"
else
    print "wszystko normalnie"
@end example

@noindent
powinno wypisać @samp{wszystko normalnie}, ponieważ @code{NF+1} z pewnością
będzie poza zakresem.  (@xref{Instrukcja if, ,Instrukcja @code{if}-@code{else}},
gdzie znajduje się więcej informacji o @code{if-else} w @code{awk}.
@xref{Typy i porównania, ,Typy zmiennych i wyrażenia porównania},
gdzie znaleźć można więcej szczegółów o operatorze @samp{!=}.)

Warto zapamiętać, że wykonanie przypisania do istniejącego pola
zmieni wartość @code{$0}, ale nie zmieni wartości @code{NF}, nawet jeśli
polu przypiszemy łańcuch pusty.  Na przykład:

@example
@group
$ echo a b c d | awk '@{ OFS = ":"; $2 = ""
>                       print $0; print NF @}'
@print{} a::c:d
@print{} 4
@end group
@end example

@noindent
Pole wciąż tu jest -- ma po prostu pustą wartość.  Można to rozpoznać po
obecności dwóch sąsiadujących ze sobą dwukropków.

Ten przykład pokazuje, co się dzieje, gdy tworzymy nowe pole.

@example
$ echo a b c d | awk '@{ OFS = ":"; $2 = ""; $6 = "nowe"
>                       print $0; print NF @}'
@print{} a::c:d::nowe
@print{} 6
@end example

@noindent
Wtrącone pole, @code{$5} utworzone jest z pustą wartością (wskazaną przez
druga parę sąsiadujących dwukropków).  @code{NF} jest zaktualizowane
wartością sześć.

Na koniec, pomniejszenie @code{NF} spowoduje utratę wartości pól po
przeliczeniu nowych wartości @code{NF} i @code{$0}.  Oto przykład:

@example
$ echo a b c d e f | ../gawk '@{ print "NF =", NF;
>                               NF = 3; print $0 @}'
@print{} NF = 6
@print{} a b c
@end example

@node Separatory pól, Stały rozmiar, Zmiana pól, Czytanie plików
@section Jak rozdzielać pola

Ta sekcja jest dość długa; opisuje jedną z najbardziej fundamentalnych
w @code{awk} operacji.

@menu
* Podstawy podziału na pola::   W jaki sposób pola dzielone są przez
                                pojedyncze znaki lub proste łańcuchy.
* Regexp w podziale na pola::   Stosowanie wyrażeń regularnych do podziału
                                na pola.
* Pola jednoznakowe::           Jak z każdego znaku zrobić osobne pole.
* Separator pól w wierszu poleceń:: Ustalanie @code{FS} z wiersza poleceń.
* Podsumowanie podziału na pola:: Kwestie końcowe i tablica podsumowująca.
@end menu

@node Podstawy podziału na pola, Regexp w podziale na pola, Separatory pól, Separatory pól
@subsection Podstawy podziału na pola
@vindex FS
@cindex pola, oddzielanie
@cindex separator pól, @code{FS}

@dfn{separator pól} (field separator), będący albo pojedynczym znakiem albo
wyrażeniem regularnym, odpowiada za sposób, w jaki @code{awk} dzieli rekord
wejściowy na pola.  @code{awk} przegląda rekord wejściowy szukając ciągów
znaków pasujących do separatora; same pola są tekstem pomiędzy
dopasowaniami.

W poniższych przykładach posługujemy się symbolem wyliczenia ``@bullet{}''
do przedstawienia spacji w wyjściu.

Jeżeli separatorem pól jest @samp{oo}, to poniższy wiersz:

@example
moo goo gai pan
@end example

@noindent
zostanie podzielony na trzy pola: @samp{m}, @samp{@bullet{}g}
i @samp{@bullet{}gai@bullet{}pan}.
Zwróć uwagę na początkowe spacje w wartościach drugiego i trzeciego pola.

@cindex częste pomyłki
@cindex pomyłki, częste
@cindex błędy, częste
Separator pól reprezentowany jest przez zmienną wbudowaną @code{FS}.
Uwaga programujący w powłoce!  @code{awk} @emph{nie} używa nazwy @code{IFS}
wykorzystywanej przez powłoki zgodne z POSIX-em (jak powłoka Bourne'a,
@code{sh}, czy GNU Bourne-Again Shell, Bash).

Wartość @code{FS} w programie @code{awk} zmieniamy za pomocą operatora
przypisania, @samp{=} (@pxref{Operatory przypisania, ,Wyrażenia przypisania}).
Często odpowiednim do tego momentem jest początek wykonywania programu,
przed przetwarzaniem wejścia, tak by już pierwszy rekord został odczytany
z właściwym separatorem.  Robimy to wykorzystując wzorzec specjalny
@code{BEGIN}
(@pxref{BEGIN/END, ,Wzorce specjalne @code{BEGIN} i @code{END}}).
Na przykład tutaj nadajemy zmiennej @code{FS} wartość @code{","}:

@example
awk 'BEGIN @{ FS = "," @} ; @{ print $2 @}'
@end example

@noindent
Przy wierszu wejściowym,

@example
John Q. Smith, 29 Oak St., Walamazoo, MI 42139
@end example

@noindent
program ten wydobywa i wypisuje łańcuch
@samp{@bullet{}29@bullet{}Oak@bullet{}St.}.

@cindex separator pól, wybór
@cindex wyrażenia regularne jako separatory pól
Czasem dane wejściowe zawierać będą znaki separujące, które nie rozdzielają
pól w sposób, jakiego byśmy się spodziewali.  Dajmy na to, imię i nazwisko
osoby w ostatnio użytym przykładzie może mieć dołączony tytuł czy
inny przyrostek, jak @samp{John Q. Smith, LXIX}.  Z wejścia zawierającego
takie dane osobowe:

@example
John Q. Smith, LXIX, 29 Oak St., Walamazoo, MI 42139
@end example

@noindent
@c careful of an overfull hbox here!
powyższy program wydzieliłby @samp{@bullet{}LXIX}, zamiast
@samp{@bullet{}29@bullet{}Oak@bullet{}St.}.
Jeżeli spodziewaliśmy się, że program wypisze adres, będziemy zaskoczeni.
Morał: należy ostrożnie dobierać układ danych i znaki separujące, by
zapobiec takim kłopotom.

@iftex
Jak już wiemy, normalnie
@end iftex
@ifinfo
Normalnie,
@end ifinfo
pola separowane są sekwencjami białych znaków (spacji, tabulacji i znaków
nowej linii), nie przez pojedyncze spacje: dwie kolejne spacje nie
rozgraniczają pustego pola.  Domyślną wartością separatora pól @code{FS}
jest łańcuch zawierający pojedynczą spację, @w{@code{" "}}.  Gdyby ta
wartość była interpretowana w zwykły sposób, to każdy znak spacji
rozdzielałby pola, zatem dwie sąsiednie spacje tworzyłyby puste pole pomiędzy
nimi.  Powodem, dla którego się tak nie dzieje, jest to, że pojedyncza
spacja jako wartość @code{FS} jest przypadkiem specjalnym: traktowana jest
jako określenie domyślnego sposobu rozgraniczania pól.

Jeżeli @code{FS} jest jakimś innym pojedynczym znakiem, to każde wystąpienie
tego znaku oddziela od siebie dwa pola.  Dwa sąsiadujące wystąpienia
ograniczają pole puste.  Jeśli znak ten pojawia się na początku lub końcu
wiersza, to również oddziela puste pole.  Znak spacji jest jedynym
pojedynczym znakiem nie przestrzegającym tych zasad.

@node Regexp w podziale na pola, Pola jednoznakowe, Podstawy podziału na pola, Separatory pól
@subsection Stosowanie wyrażeń regularnych do podziału na pola

Poprzednia podsekcja omawiała
stosowanie jako wartości @code{FS} pojedynczych znaków lub zwykłych łańcuchów.
Ogólniej, wartością @code{FS} może być łańcuch zawierający dowolne wyrażenie
regularne.  W takim przypadku, każde dopasowanie tego wyrażenia w rekordzie
separuje pola.  Na przykład, przypisanie:

@example
FS = ", \t"
@end example

@noindent
czyni ogranicznikiem każdy obszar rekordu wejściowego składający się
z przecinka z umieszczoną po nim spacją i tabulacją.  (@samp{\t} jest
@dfn{sekwencją specjalną} oznaczającą tabulację;
@pxref{Sekwencje specjalne},
gdzie znajduje się pełna lista podobnych sekwencji specjalnych.)

Jako mniej banalny przykład z wyrażeniem regularnym, załóżmy, że
chcielibyśmy, by pojedyncze spacje rozdzielały pola w taki sam sposób,
jak powyżej użyliśmy przecinków.  Możemy nadać @code{FS} wartość
@w{@code{"[@ ]"}} (lewy nawias kwadratowy, spacja, prawy nawias kwadratowy).
To wyrażenie regularne dopasowuje pojedynczą spację i nic więcej
(@pxref{Regexp, ,Regular Expressions}).

Pomiędzy dwoma przypadkami: @samp{FS = @w{" "}} (pojedyncza spacja)
a @samp{FS = @w{"[ \t\n]+"}} (lewy nawias kwadratowy, spacja, odwrotny
ukośnik, ``t'', odwrotny ukośnik, ``n'', prawy nawias kwadratowy, co tworzy
wyrażenie regularne dopasowujące jeden lub więcej znaków spacji, tabulacji
lub nowej linii), istnieje istotna różnica.  Przy obu wartościach @code{FS}
pola rozdzielane są ciągami spacji, tabulacji i/lub znaków nowej linii.
Jeżeli jednak wartością @code{FS} jest @w{@code{" "}}, to @code{awk} będzie
usuwał z rekordu początkowe i końcowe białe znaki, a dopiero następnie
decydował, gdzie znajdują się pola.

Na przykład, poniższy potok wypisuje @samp{b}:

@example
@group
$ echo ' a b c d ' | awk '@{ print $2 @}'
@print{} b
@end group
@end example

@noindent
Jednak ten potok wypisze @samp{a} (zwróć uwagę na dodatkowe spacje wokół
każdej z liter):

@example
$ echo ' a  b  c  d ' | awk 'BEGIN @{ FS = "[ \t]+" @}
>                                  @{ print $2 @}'
@print{} a
@end example

@noindent
@cindex łańcuch pusty
@cindex łańcuch zerowy
W tym przypadku, pierwsze pole jest @dfn{puste}, czyli jest łańcuchem
zerowym, pustym.

Obcinanie początkowych i końcowych białych znaków odbywa się także
podczas przeliczania wartości @code{$0}.  Na przykład, przeanalizujmy taki
potok:

@example
$ echo '   a b c d' | awk '@{ print; $2 = $2; print @}'
@print{}    a b c d
@print{} a b c d
@end example

@noindent
Pierwsza instrukcja @code{print} wypisuje rekord tak, jak został odczytany,
z nienaruszonym początkowym białym znakiem.  Przypisanie do @code{$2}
przebudowuje @code{$0} przez złączenie razem @code{$1} do @code{$NF},
rozdzielonych wartością @code{OFS}.  Ponieważ przy wykrywaniu @code{$1}
zignorowany został początkowy biały znak, nie stał się on częścią nowego
@code{$0}.  Ostatecznie, ostatnia instrukcja @code{print} wypisuje nowe
@code{$0}.

@node Pola jednoznakowe, Separator pól w wierszu poleceń, Regexp w podziale na pola, Separatory pól
@subsection Jak z każdego znaku zrobić osobne pole

@cindex różnice między @code{gawk} a @code{awk}
@cindex pola jednoznakowe
Zdarza się, że chcemy badać każdy znak rekordu z osobna.  W @code{gawk} jest
to łatwe, po prostu przypisujemy pusty łańcuch (@code{""}) do @code{FS}.
W tym przypadku, każdy pojedynczy znak rekordu stanie się odrębnym polem.
Oto przykład:

@example
@group
$ echo a b | gawk 'BEGIN @{ FS = "" @}
>                  @{
>                      for (i = 1; i <= NF; i = i + 1)
>                          print "W polu", i, "jest", $i
>                  @}'
@print{} W polu 1 jest a
@print{} W polu 2 jest
@print{} W polu 3 jest b
@end group
@end example

@cindex ciemny kąt
Tradycyjnie, zachowanie się programu przy @code{FS} równym @code{""} nie
było zdefiniowane.  W takim przypadku uniksowy @code{awk} traktowałby cały
rekord jako mający tylko jedno pole (c.k.).  W trybie zgodności
(@pxref{Opcje, ,Opcje wiersza poleceń}),
@code{gawk} także będzie się zachowywać się w ten sposób, jeśli @code{FS}
będzie łańcuchem pustym.

@node Separator pól w wierszu poleceń, Podsumowanie podziału na pola, Pola jednoznakowe, Separatory pól
@subsection Ustalanie @code{FS} z wiersza poleceń
@cindex @code{-F} opcja
@cindex separator pól, w wierszu poleceń
@cindex wiersz poleceń, nadawanie wartości @code{FS}

Zmiennej @code{FS} można nadać wartość w wierszu poleceń.  Wykorzystujemy do
tego opcję @samp{-F}.  Na przykład:

@example
awk -F, '@var{program}' @var{pliki-wejściowe}
@end example

@noindent
powoduje, że @code{FS} będzie znakiem @samp{,}.  Zauważ, że opcja ta
używa dużej litery @samp{F}.  W przeciwieństwie do niej, małe @samp{-f}
określa plik zawierający program @code{awk}.  W opcjach wiersza poleceń
wielkość liter jest istotna: opcje @samp{-F} i @samp{-f} nie mają ze sobą
nic wspólnego.  Można stosować obie równocześnie, do nadania wartości
zmiennej @code{FS} @emph{i} pobrania programu @code{awk} z pliku.

Wartość użyta jako argument opcji @samp{-F} przetwarzana jest w dokładnie
taki sam sposób, jak przypisania do zmiennej wbudowanej @code{FS}.  To
znaczy, że jeżeli separator pól zawiera znaki specjalne, to muszą one być
we właściwy sposób cytowane.  Na przykład, chcąc jako separator pól
zastosować @samp{\}, musielibyśmy wpisać:

@example
# to samo, co FS = "\\"
awk -F\\\\ '@dots{}' pliki @dots{}
@end example

@noindent
Ponieważ @samp{\} służy w powłoce do cytowania znaków, @code{awk} zobaczy
@samp{-F\\}.  Następnie @code{awk} przetwarza @samp{\\} używając znaków
specjalnych (@pxref{Sekwencje specjalne}), ostatecznie dając pojedynczy
@samp{\} stosowany jako separator rekordów.

@cindex cechy historyczne
Przypadkiem specjalnym jest to, że w trybie zgodności
(@pxref{Opcje, ,Opcje wiersza poleceń}), jeżeli argumentem @samp{-F}
jest @samp{t}, to @code{FS} otrzymuje wartość znaku tabulacji.  Jest to
spowodowane tym, że jeśli wpiszemy w powłoce @samp{-F\t}, bez
żadnych cudzysłowów, to @samp{\} zostanie usunięty, więc @code{awk}
stwierdza, że naprawdę chcieliśmy, by pola były rozdzielane
tabulacjami, a nie literami @samp{t}.  Jeżeli rzeczywiście chcemy rozdzielać
pola literami @samp{t}, to w wierszu poleceń powinniśmy użyć @samp{-v FS="t"}
(@pxref{Opcje, ,Opcje wiersza poleceń}).

Na przykład, skorzystajmy z pliku programu @code{awk} o nazwie
@file{baud.awk}, zawierającego wzorzec @code{/300/} i akcję @samp{print $1}.
Oto ten program:

@example
/300/   @{ print $1 @}
@end example

Ustalimy też wartość @code{FS} na znak @samp{-}, i uruchomimy program
z plikiem danych @file{BBS-list}.  Poniższe polecenie wypisuje nazwy
BBS-ów, które działają z prędkością 300 baud, z pierwszymi trzema cyframi
numerów telefonów:

@c tweaked to make the tex output look better in @smallbook
@example
@group
$ awk -F- -f baud.awk BBS-list
@print{} aardvark     555
@print{} alpo
@print{} barfly       555
@dots{}
@end group
@ignore
@print{} bites        555
@print{} camelot      555
@print{} core         555
@print{} fooey        555
@print{} foot         555
@print{} macfoo       555
@print{} sdace        555
@print{} sabafoo      555
@end ignore
@end example

@noindent
Zwróć uwagę na pierwszy wiersz wynikowy.  W pierwotnym pliku
(@pxref{Przykładowe pliki danych, , Pliki danych do przykładów}), drugi wiersz
wygląda tak:

@example
alpo-net     555-3412     2400/1200/300     A
@end example

Zamiast @samp{-} w numerze telefonu, jak to było zamierzone, jako separator
rekordów został zastosowany znak @samp{-} będący częścią nazwy systemu.
Pokazuje to, dlaczego powinniśmy być rozważni przy wyborze separatorów
pól i rekordów.

Na wielu systemach uniksowych każdy z użytkowników ma osobny wpis
w pliku haseł, po jednym wierszu na użytkownika.  Dane w tych wierszach są
rozdzielane dwukropkami.  Pierwsze pole jest nazwą zgłoszeniową użytkownika
(login), a drugie jego zaszyfrowanym hasłem.  Pozycja w pliku haseł może
wyglądać tak:

@example
arnold:xyzzy:2076:10:Arnold Robbins:/home/arnold:/bin/sh
@end example

Poniższy program przeszukuje systemowy plik haseł i wypisuje pozycje
użytkowników nie mających haseł:

@example
awk -F: '$2 == ""' /etc/passwd
@end example

@node Podsumowanie podziału na pola,  , Separator pól w wierszu poleceń, Separatory pól
@subsection Podsumowanie podziału na pola

@cindex @code{awk} język, wersja POSIX
@cindex POSIX @code{awk}
Zgodnie ze standardem POSIX, @code{awk} powinien zachowywać się tak, jakby
każdy rekord był dzielony na pola w momencie jego odczytu.  W szczególności
oznacza to, że możemy zmienić wartość @code{FS} po przeczytaniu rekordu,
a wartości pól (tj.@: sposób, w jaki są podzielone) powinny odzwierciedlać
starą wartość @code{FS}, a nie nową.

@cindex ciemny kąt
@cindex @code{sed}, narzędzie
@cindex narzędzie @code{sed}
@cindex edytor strumieniowy
Jednak wiele implementacji @code{awk} nie działa w ten sposób.  Zamiast
tego, odkładają podział na pola do momentu, gdy wystąpi faktyczne
odwołanie się pola.  Pola zostaną rozdzielone przy zastosowaniu
@emph{bieżącej} wartości @code{FS}! (c.k.)  Zachowanie takie może być trudne
do rozpoznania.  Poniższy przykład ilustruje różnicę pomiędzy tymi dwoma
metodami.  (Polecenie @code{sed}@footnote{Narzędzie @code{sed} jest
``edytorem strumieniowym''. Jego zachowanie się jest również zdefiniowane
standardem POSIX.} wypisuje tylko pierwszy wiersz @file{/etc/passwd}.)

@example
sed 1q /etc/passwd | awk '@{ FS = ":" ; print $1 @}'
@end example

@noindent
zwykle wypisze

@example
root
@end example

@noindent
w niepoprawnej implementacji @code{awk}, podczas gdy @code{gawk} wypisze
coś w rodzaju

@example
root:nSijPlPhZZwgE:0:0:Root:/:
@end example

Poniższa tabela podsumowuje sposoby podziału na pola, w zależności od
wartości @code{FS}.  (@samp{==} oznacza ``jest równe''.)

@c @cartouche
@table @code
@item FS == " "
Pola oddzielane są ciągami białych znaków.  Początkowe i końcowe białe znaki
są ignorowane.  Jest to ustawienie domyślne.

@item FS == @var{inny pojedynczy znak}
Pola rozdzielane są każdym wystąpieniem zadanego znaku.  Wielokrotne
sąsiednie wystąpienia rozgraniczają puste pola, tak samo jak wystąpienia
na początku i na końcu rekordu.  Znak separujący może być nawet metaznakiem
wyrażeń regularnych; nie musi być cytowany.

@item FS == @var{regexp}
Pola oddzielane są wystąpieniami znaków pasujących do @var{regexp}.
Początkowe i końcowe dopasowania @var{regexp} rozdzielają puste pola.

@item FS == ""
Każdy poszczególny znak rekordu staje się pojedynczym polem.
@end table
@c @end cartouche

@node Stały rozmiar, Wiele wierszy, Separatory pól, Czytanie plików
@section Czytanie danych o stałej szerokości

(Niniejsza sekcja opisuje cechę rozszerzoną, eksperymentalną.  Początkujący
użytkownicy @code{awk} mogą ją pominąć przy pierwszym czytaniu.)

W wersji 2.13 @code{gawk} wprowadzono nową funkcję do obsługi pól o stałych
szerokościach, bez wyróżnialnego separatora pól.
Dane tego rodzaju pojawiają się, na przykład, jako wejście starych programów
w FORTRAN-ie, gdzie liczby następują bezpośrednio po sobie; albo jako
wyjście programów nie przewidujących zastosowania go jako wejścia dla innych
programów.

Przykładem tego ostatniego jest tabela, gdzie wszystkie kolumny wyrównano
za pomocą zmiennej liczby spacji a @emph{puste pola są po prostu
spacjami}.  Jasne jest, że w tym przypadku normalny podział na pola oparty
na @code{FS} nie zadziała dobrze.  Mimo, że przenośny program @code{awk}
może stosować serie wywołań @code{substr} w odniesieniu do @code{$0}
(@pxref{Funkcje łańcuchowe, ,Funkcje wbudowane działające na łańcuchach}),
jest to niewygodne i nieefektywne przy większej liczbie pól.

Podział rekordu wejściowego na pola o stałej szerokości wyszczególniany jest
przez przypisanie zmiennej wbudowanej @code{FIELDWIDTHS} łańcucha
zawierającego rozdzielone spacjami liczby.  Każda z nich określa szerokość
pola @emph{łącznie} z kolumnami pomiędzy polami.  Chcąc pominąć kolumny
pomiędzy polami, podajemy ich szerokości jako odrębne pola, później
ignorowane.

Poniższe dane są wyjściem z uniksowego narzędzia @code{w}.
Przydadzą się jako ilustracja zastosowania @code{FIELDWIDTHS}.

@example
@group
 10:06pm  up 21 days, 14:04,  23 users
User     tty       login@  idle   JCPU   PCPU  what
hzuo     ttyV0     8:58pm            9      5  vi p24.tex
hzang    ttyV3     6:37pm    50                -csh
eklye    ttyV5     9:53pm            7      1  em thes.tex
dportein ttyV6     8:17pm  1:47                -csh
gierd    ttyD3    10:00pm     1                elm
dave     ttyD4     9:47pm            4      4  w
brent    ttyp0    26Jun91  4:46  26:46   4:41  bash
dave     ttyq4    26Jun9115days     46     46  wnewmail
@end group
@end example

Pokazany niżej program pobiera powyższe wejście, przekształca czas
nieaktywności (iddle time) na liczbę sekund i wypisuje pierwsze dwa pola
oraz wyliczony czas nieaktywności.  (Program wykorzystuje kilka cech
@code{awk}, o których jeszcze nie mówiono.)

@example

BEGIN  @{ FIELDWIDTHS = "9 6 10 6 7 7 35" @}
NR > 2 @{
    idle = $4
    sub(/^  */, "", idle)   # obcina początkowe spacje
    if (idle == "")
        idle = 0
@group
    if (idle ~ /:/) @{
        split(idle, t, ":")
        idle = t[1] * 60 + t[2]
    @}
@end group
@group
    if (idle ~ /days/)
        idle *= 24 * 60 * 60

    print $1, $2, idle
@}
@end group
@end example

Oto wyniki działania programu z naszymi danymi:

@example
hzuo      ttyV0  0
hzang     ttyV3  50
eklye     ttyV5  0
dportein  ttyV6  107
gierd     ttyD3  1
dave      ttyD4  0
brent     ttyp0  286
dave      ttyq4  1296000
@end example

Innym (zapewne bardziej praktycznym) przykładem danych wejściowych o stałej
szerokości byłoby wejście ze sterty kart do głosowania.
W niektórych częściach Stanów Zjednoczonych głosujący zaznaczają swój wybór
robiąc dziurki w kartach komputerowych.  Następnie karty są przetwarzane,
w celu zliczenia głosów na konkretnego kandydata czy jakąś sporną kwestię.
Ponieważ uprawniony może zdecydować o nieoddaniu głosu w jakiejś sprawie,
każda kolumna karty może być pusta.  Program @code{awk} do przetwarzania
takich danych mógłby wykorzystać funkcję @code{FIELDWIDTHS} do uproszczenia
czytania.  (Oczywiście, znalezienie @code{gawk} działającego na systemie
z czytnikami kart jest osobną sprawą!)

@ignore
Exercise: Write a ballot card reading program
@end ignore

Przypisanie wartości do @code{FS} powoduje, że @code{gawk} powraca do
stosowania @code{FS} do podziału na pola.  By to spowodować wystarczy użyć
@samp{FS = FS}, bez potrzeby znajomości aktualnej wartości @code{FS}.

Funkcja ta jest wciąż eksperymentalna i może się z czasem zmieniać.
Zauważ, że w szczególności, @code{gawk} nie usiłuje zweryfikować
poprawności wartości użytych w @code{FIELDWIDTHS}.

@node Wiele wierszy, Getline, Stały rozmiar, Czytanie plików
@section Rekordy wielowierszowe

@cindex rekordy wielowierszowe
@cindex wejście, rekordy wielowierszowe
@cindex odczyt plików, rekordy wielowierszowe
@cindex rekordy, rekordy wielowierszowe
W niektórych bazach danych pojedynczy wiersz nie może w wygodny sposób
przechować całości informacji o jednej pozycji.  W takich przypadkach
możemy  użyć rekordów wielowierszowych.

Pierwszym krokiem do tego jest wybór formatu danych:  skoro rekordy nie są
zdefiniowane jako pojedyncze wiersze, to jak chcemy je zdefiniować?
Co powinno rozdzielać rekordy?

Jedną z technik jest użycie do rozdzielania rekordów jakiegoś niecodziennego
znaku czy łańcucha.  Na przykład, możemy wykorzystać do tego znak wysuwu
strony (w @code{awk}, podobnie jak w C, zapisywany jako @samp{\f}),
robiąc rekordem każdą stronę pliku.  Równie dobrze może być zastosowany
każdy inny znak, pod warunkiem, że nie będzie on częścią danych rekordu.

Inną techniką jest rozdzielanie rekordów pustymi wierszami.  Na zasadzie
specjalnego wyjątku pusty
łańcuch jako wartość @code{RS} wskazuje, że rekordy są oddzielane jednym lub
wieloma pustymi wierszami.  Następny rekord zaś nie rozpoczyna się aż do
napotkania pierwszego po nich niepustego wiersza -- bez względu na to, ile
wystąpi kolejnych pustych wierszy, są one uważane za jeden separator
rekordu.

@cindex lewe najdłuższe dopasowanie
@cindex dopasowanie, lewe najdłuższe
Ten sam efekt, co przy @samp{RS = ""}, można osiągnąć przypisując @code{RS}
wartość @code{"\n\n+"}.  To wyrażenie regularne dopasowuje znak nowej linii
na końcu rekordu, i jednej lub więcej pustych wierszy po rekordzie.
Dodatkowo, wyrażenia regularne, jeśli jest wybór, zawsze dopasowują pierwszą
z lewej najdłuższą sekwencję
(@pxref{Lewe najdłuższe, ,Jak bardzo pasuje tekst?}).
Zatem następny rekord nie rozpocznie się aż do napotkania występującego
po bieżącym niepustego wiersza -- bez względu na to, ile wystąpi kolejnych
pustych wierszy, są one uważane za jeden separator rekordu.

@cindex ciemny kąt
Istnieje istotna różnica pomiędzy @samp{RS = ""} a @samp{RS = "\n\n+"}.
W pierwszym przypadku, początkowe znaki nowej linii z pliku wejściowego są
ignorowane, a jeśli plik kończy się dodatkowymi pustymi wierszami po
ostatnim rekordzie, to ostatni znak nowej linii jest z rekordu usuwany.
W drugim przypadku, to specjalne przetwarzanie nie jest wykonywane (c.k.).

Teraz, gdy wejście jest już podzielone na rekordy, drugim krokiem jest
rozdzielenie pól rekordu.  Jedną z metod jest podział każdego z wierszy
na pola w zwykły sposób.  Dzieje się tak domyślnie w wyniku specjalnej
cechy: gdy @code{RS} jest łańcuchem pustym, znak nowej linii @emph{zawsze}
działa jako separator pól.  Jest to wykonywane dodatkowo oprócz
podziałów na pola wynikających z @code{FS}.

Pierwotnym powodem tego specjalnego wyjątku było prawdopodobnie zapewnienie
przydatnego zachowania się programu w przypadku domyślnym (tj.@: @code{FS}
jest równe @w{@code{" "}}).  Cecha ta może być kłopotliwa, jeżeli faktycznie
nie chcemy rozdzielania rekordów przez znak nowej linii, gdyż nie ma sposobu
by tego uniknąć.  Jednak można to obejść wykorzystując funkcję @code{split}
do ręcznego podziału rekordu
(@pxref{Funkcje łańcuchowe, ,Funkcje wbudowane działające na łańcuchach}).

Inną metodą podziału na pola jest umieszczenie każdego pola w osobnym
wierszu: do jej wykorzystania wystarczy przypisać zmiennej @code{FS} łańcuch
@code{"\n"}.  (To proste wyrażenie regularne dopasowuje pojedynczy znak
nowej linii.)

Praktycznym przykładem pliku danych zorganizowanego w ten sposób może być
lista adresowa, gdzie każda pozycja oddzielona jest pustymi wierszami.
Załóżmy, że mamy taką listę w pliku @file{addresses}:

@c POTRZEBNE
@page
@example
Jane Doe
123 Main Street
Anywhere, SE 12345-6789

John Smith
456 Tree-lined Avenue
Smallville, MW 98765-4321
@dots{}
@end example

@noindent
Prosty program do przetwarzania tych danych może być taki:

@example
@group
# addrs.awk --- prosty program listy adresowej

# Rekordy oddzielone są pustymi wierszami
# każdy wiersz jest jednym polem.
BEGIN @{ RS = "" ; FS = "\n" @}

@{
      print "Name is:", $1
      print "Address is:", $2
      print "City and State are:", $3
      print ""
@}
@end group
@end example

Uruchomienie programu daje następujące wyjście:

@example
@group
$ awk -f addrs.awk addresses
@print{} Name is: Jane Doe
@print{} Address is: 123 Main Street
@print{} City and State are: Anywhere, SE 12345-6789
@print{}
@end group
@group
@print{} Name is: John Smith
@print{} Address is: 456 Tree-lined Avenue
@print{} City and State are: Smallville, MW 98765-4321
@print{}
@dots{}
@end group
@end example

@xref{Program labels, ,Wypisywanie etykiet adresowych}, gdzie umieszczono
bardziej realistyczny program zajmujący się listami adresowymi.

Poniższa tabela podsumowuje sposoby podziału na rekordy, w zależności
od wartości @code{RS}. (@samp{==} oznacza ``jest równe''.)

@c @cartouche
@table @code
@item RS == "\n"
Rekordy rozdzielane są znakiem nowej linii (@samp{\n}).  W wyniku tego,
każdy wiersz pliku danych, także pusty, jest osobnym rekordem.  Jest
to ustawienie domyślne.

@item RS == @var{inny pojedynczy znak}
Rekordy są oddzielane każdym wystąpieniem zadanego znaku. Wielokrotne
sąsiednie wystąpienia rozgraniczają puste rekordy.

@item RS == ""
Rekordy są rozdzielane ciągami pustych wierszy.  Znak nowej linii zawsze
służy jako separator rekordu, dodatkowo, oprócz wartości @code{FS}.
Początkowe i końcowe znaki nowej linii w pliku są ignorowane.

@item RS == @var{regexp}
Rekordy rozdzielane są wystąpieniami znaków pasujących do @var{regexp}.
Początkowe i końcowe dopasowania @var{regexp} oddzielają puste rekordy.
@end table
@c @end cartouche

@vindex RT
We wszystkich przypadkach @code{gawk} przypisuje zmiennej @code{RT} tekst
wejściowy, jaki pasował do wartości podanej przez @code{RS}.

@node Getline, , Wiele wierszy, Czytanie plików
@section Odczyt bezpośredni przez @code{getline}

@findex getline
@cindex wejście, bezpośrednie
@cindex bezpośrednie wejście
@cindex wejście, polecenie @code{getline}
@cindex odczyt plików, polecenie @code{getline}
Do tej pory pobieraliśmy dane wejściowe z głównego strumienia wejściowego
@code{awk} -- albo standardowego wejścia (zwykle terminala, czasami
wyjścia innego programu) albo z plików wyszczególnionych w wierszu poleceń.
Język @code{awk} ma specjalne polecenie wbudowane o nazwie
@code{getline}, które stosuje się czytania wejścia pod bezpośrednią kontrolą
programisty.

@menu
* Wstęp do getline::            Wprowadzenie do funkcji @code{getline}.
* Zwykłe getline::              Użycie @code{getline} bez argumentów.
* Getline/Zmienna::             Użycie @code{getline} do zmiennej.
* Getline/Plik::                Użycie @code{getline} z pliku.
* Getline/Zmienna/Plik::        Użycie @code{getline} z pliku do zmiennej.
* Getline/Potok::               Użycie @code{getline} z potoku.
* Getline/Zmienna/Potok::       Użycie @code{getline} z potoku do zmiennej.
* Podsumowanie getline::        Podsumowanie wariantów @code{getline}.
@end menu

@node Wstęp do getline, Zwykłe getline, Getline, Getline
@subsection Wprowadzenie do @code{getline}

Polecenie to stosowane jest na kilka różnych sposobów i @emph{nie} powinno
być używane przez początkujących.  Jest opisane tutaj, gdyż rozdział
traktuje o wejściu.  Przykłady występujące po objaśnieniu polecenia
@code{getline} zawierają jeszcze nie omawiany materiał.  Z tego powodu,
powinieneś powrócić do tej części i przestudiować polecenie @code{getline}
@emph{po} przeglądnięciu reszty książki i nabraniu dobrej znajomości
sposobu działania @code{awk}.

@vindex ERRNO
@cindex różnice między @code{gawk} a @code{awk}
@cindex @code{getline}, zwracane wartości
@code{getline} zwraca jeden jeśli znajdzie rekord, a zero jeśli napotkano
koniec pliku.  Jeżeli podczas pobierania rekordu pojawi się błąd, jak wtedy,
gdy plik nie może zostać otwarty, to @code{getline} zwraca @minus{}1.
W tym przypadku @code{gawk} przypisuje zmiennej @code{ERRNO} łańcuch
opisujący zaistniały błąd.

W kolejnych przykładach, @var{polecenie} oznacza wartość łańcuchową
reprezentującą polecenie powłoki.

@node Zwykłe getline, Getline/Zmienna, Wstęp do getline, Getline
@subsection Użycie @code{getline} bez argumentów

Polecenie @code{getline} bez argumentów służy do czytania wejścia
z bieżącego pliku wejściowego.  W tym przypadku odczytuje ono tylko kolejny
rekord wejściowy i rozbija go na pola.  Przydatne, gdy zakończyliśmy
przetwarzanie bieżącego rekordu, ale chcemy @emph{od razu} wykonać
specjalne przetwarzanie następnego.  Oto przykład:

@example
@group
awk '@{
     if ((t = index($0, "/*")) != 0) @{
          # wartością będzie "" jeśli t jest 1
          tmp = substr($0, 1, t - 1)
          u = index(substr($0, t + 2), "*/")
          while (u == 0) @{
               if (getline <= 0) @{
                    m = "unexpected EOF or error"
                    m = (m ": " ERRNO)
                    print m > "/dev/stderr"
                    exit
               @}
               t = -1
               u = index($0, "*/")
          @}
@end group
@group
          # wyrażenie będzie równe "" jeśli */
          # pojawiło się na końcu wiersza
          $0 = tmp substr($0, t + u + 3)
     @}
     print $0
@}'
@end group
@end example

Ten program @code{awk} usuwa z wejścia wszystkie komentarze typu używanego
w C, @samp{/* @dots{} */}.  Zastępując @samp{print $0} innymi instrukcjami,
można wykonywać bardziej skomplikowane przetwarzanie odkomentowanego
wejścia, na przykład, wyszukiwanie dopasowań wyrażenia regularnego.
Program ma drobny feler -- nie działa jeśli w tym samym wierszu kończy
się jeden z komentarzy a zaczyna inny.

@ignore
Exercise,
write a program that does handle multiple comments on the line.
@end ignore

Taka postać polecenia @code{getline} ustala nowe wartości @code{NF}
(liczba pól; @pxref{Pola, ,Badanie pól}),
@code{NR} (liczba dotychczas odczytanych
rekordów; @pxref{Rekordy, ,Jak wejście dzielone jest na rekordy}),
@code{FNR} (liczba rekordów przeczytanych z tego pliku wejściowego)
oraz @code{$0}.

@cindex ciemny kąt
@strong{Zauważ:} nowa wartość @code{$0} jest używana przy sprawdzaniu
wzorców ewentualnych kolejnych reguł.  Pierwotna wartość @code{$0}, jaka
wywołała regułę, w której wykonano @code{getline} jest tracona (c.k.).
Natomiast instrukcja @code{next} postępuje inaczej: czyta nowy rekord, lecz
natychmiast rozpoczyna jego normalne przetwarzanie, poczynając od pierwszej
reguły programu.
@xref{Instrukcja next, ,Instrukcja @code{next}}.

@node Getline/Zmienna, Getline/Plik, Zwykłe getline, Getline
@subsection Użycie @code{getline} do zmiennej

Konstrukcję @samp{getline @var{zmn}} wykorzystujemy do wczytania następnego
rekordu z wejścia @code{awk} do zmiennej @var{zmn}. Nie jest dokonywane
żadne inne przetwarzanie.

Załóżmy na przykład, że następny wiersz jest komentarzem lub łańcuchem
specjalnym, i chcemy go przeczytać bez wyzwalania żadnej z reguł.  Ta postać
@code{getline} pozwala na odczyt wiersza i zachowanie go w zmiennej, tak że
główna pętla @code{awk}, czytaj-wiersz-i-sprawdź-każdą-regułę, nigdy go nie
zauważy.

Poniższy przykład zamienia miejscami każde dwa wiersze wejścia. Na
przykład, przy podanych:

@example
wan
tew
free
phore
@end example

@noindent
wypisuje:

@example
tew
wan
phore
free
@end example

@noindent
Oto program:

@example
@group
awk '@{
     if ((getline tmp) > 0) @{
          print tmp
          print $0
     @} else
          print $0
@}'
@end group
@end example

Polecenie @code{getline} użyte w ten sposób nadaje jedynie wartości
zmiennym @code{NR} i @code{FNR} (i oczywiście, @var{zmn}).  Rekord nie
jest dzielony na pola, więc wartości pól (łącznie z @code{$0}) i wartość
@code{NF} nie zmieniają się.

@node Getline/Plik, Getline/Zmienna/Plik, Getline/Zmienna, Getline
@subsection Użycie @code{getline} z pliku

@cindex przekierowanie wejścia
@cindex wejście, przekierowanie
Konstrukcję @samp{getline < @var{plik}} stosujemy do odczytu następnego
rekordu z pliku @var{plik}.  @var{plik} jest tu określającym nazwę pliku
wyrażeniem o wartości łańcuchowej.  @samp{< @var{plik}} jest zwane
@dfn{przekierowaniem}, gdyż skierowuje wejście tak, by pochodziło z innego
miejsca.

Na przykład, poniższy program napotkając pierwsze pole o wartości 10
w bieżącym pliku wejściowym czyta rekord wejściowy z pliku
@file{secondary.input}.

@example
@group
awk '@{
    if ($1 == 10) @{
         getline < "secondary.input"
         print
    @} else
         print
@}'
@end group
@end example

Ponieważ nie jest używany główny strumień wejściowy, wartości @code{NR}
i @code{FNR} pozostają bez zmian.  Rekord jest jednak dzielony na pola
w normalny sposób, więc zmieniają się wartości @code{$0} i pozostałych pól.
Także wartość @code{NF}.

@c Thanks to Paul Eggert for initial wording here
Zgodnie ze standardem POSIX, @samp{getline < @var{wyrażenie}} jest
niejednoznaczne jeśli @var{wyrażenie} zawiera nieujęte w nawiasy operatory
inne niż @samp{$}.  Na przykład, @samp{getline < katalog "/" plik} jest
niejednoznaczne, bo operator konkatenacji nie został umieszczony
w nawiasach, i powinno być zapisane jako @samp{getline < (katalog "/"
plik)} jeśli chcemy, by program był przenośny na inne implementacje
@code{awk}.

@node Getline/Zmienna/Plik, Getline/Potok, Getline/Plik, Getline
@subsection Użycie @code{getline} z pliku do zmiennej

Konstrukcja @samp{getline @var{zmn} < @var{plik}} służy do odczytu wejścia
z pliku @var{plik} i umieszczenia go w zmiennej @var{zmn}.  Jak powyżej,
@var{plik} jest wyrażeniem o wartości łańcuchowej określającym nazwę pliku,
z którego ma nastąpić czytanie.

W tej wersji @code{getline}, nie jest zmieniana żadna ze zmiennych
wbudowanych, a rekord nie jest dzielony na pola.  Jedyną zmienianą zmienną
jest @var{zmn}.

@ifinfo
@c Thanks to Paul Eggert for initial wording here
Zgodnie ze standardem POSIX, @samp{getline @var{zmn} < @var{wyrażenie}} jest
niejednoznaczne jeśli @var{wyrażenie} zawiera nieujęte w nawiasy operatory
inne niż @samp{$}.  Na przykład, @samp{getline @var{zmn} < katalog "/" plik}
jest niejednoznaczne, bo operator konkatenacji nie został umieszczony
w nawiasach, i powinno być zapisane jako
@samp{getline @var{zmn} < (katalog "/" plik)} jeśli chcemy, by program był
przenośny na inne implementacje @code{awk}.
@end ifinfo

Na przykład, poniższy program kopiuje wszystkie pliki wejściowe na wyjście,
z wyjątkiem rekordów zawierających @w{@samp{@@include @var{nazwapliku}}}.
Taki rekord zastępowany jest zawartością pliku @var{nazwapliku}.

@example
@group
awk '@{
     if (NF == 2 && $1 == "@@include") @{
          while ((getline line < $2) > 0)
               print line
          close($2)
     @} else
          print
@}'
@end group
@end example

Zauważ tu, że nazwa dodatkowego pliku wejścia nie jest wbudowana
w program.  Brana jest wprost z danych, z drugiego pola wiersza
@samp{@@include}.

Funkcja @code{close} wywoływana jest w celu zagwarantowania, że jeżeli
w wejściu pojawią się dwa identyczne wiersze @samp{@@include}, to cały
wyszczególniony przez nie plik będzie włączony dwukrotnie.
@xref{Zamykanie plików i potoków, ,Zamykanie potoków oraz plików wejściowych i wyjściowych}.

Jednym z braków tego programu jest to, że nie przetwarza on
zagnieżdżonych instrukcji @samp{@@include} (instrukcji @samp{@@include}
w dołączanych plikach), jak robiłby to prawdziwy preprocesor makr.
@xref{Program igawk, ,Łatwa metoda korzystania z funkcji bibliotecznych}, gdzie podano
program obsługujący zagnieżdżone instrukcje @samp{@@include}.

@node Getline/Potok, Getline/Zmienna/Potok, Getline/Zmienna/Plik, Getline
@subsection Użycie @code{getline} z potoku

@cindex potok wejściowy
@cindex wejście, potok
Do @code{getline} można przekazać potokiem wyjście dowolnego polecenia,
korzystając ze składni @samp{@var{polecenie} | getline}.  W takim przypadku,
łańcuch @var{polecenie} uruchamiany jest jako polecenie powłoki, a jego
wyjście przekazywane jest potokiem do @code{awk}, gdzie będzie użyte jako
wejście.  Ta postać @code{getline} czyta z potoku po jednym rekordzie
naraz.

Na przykład, poniższy program kopiuje swoje wejście na wyjście, z wyjątkiem
wierszy rozpoczynających się od @samp{@@execute}, które są zastępowane
wyjściem utworzonym przez uruchomienie pozostałej części wiersza jako
polecenia powłoki:

@example
@group
awk '@{
     if ($1 == "@@execute") @{
          tmp = substr($0, 10)
          while ((tmp | getline) > 0)
               print
          close(tmp)
     @} else
          print
@}'
@end group
@end example

@noindent
Funkcja @code{close} jest wywoływana w celu zagwarantowania, że jeśli
w wejściu pojawią się dwa identyczne wiersze @samp{@@execute}, to polecenie
zostanie wykonane dla każdego z nich.
@xref{Zamykanie plików i potoków, ,Zamykanie potoków oraz plików wejściowych i wyjściowych}.
@c Exercise!!
@c This example is unrealistic, since you could just use system

Przy podanym wejściu:

@example
@group
foo
bar
baz
@@execute who
bletch
@end group
@end example

@noindent
program ten może utworzyć:

@example
@group
foo
bar
baz
arnold     ttyv0   Jul 13 14:22
miriam     ttyp0   Jul 13 14:23     (murphy:0)
bill       ttyp1   Jul 13 14:23     (murphy:0)
bletch
@end group
@end example

@noindent
Zwróć uwagę, że program uruchomił polecenie @code{who} i wypisał wynik.
(Jeśli wypróbujesz go we własnym systemie, otrzymasz oczywiście inne
rezultat, pokazujący, kto jest zalogowany w twoim systemie.)

Ta odmiana @code{getline} dokonuje podziału rekordu na pola, nadaje
wartość @code{NF} i przelicza wartość @code{$0}.  Wartości @code{NR}
i @code{FNR} nie są zmieniane.

@c Thanks to Paul Eggert for initial wording here
Zgodnie ze standardem POSIX, @samp{@var{wyrażenie} | getline} jest
niejednoznaczne jeśli @var{wyrażenie} zawiera nieujęte w nawiasy operatory
inne niż @samp{$}.  Na przykład, @samp{"echo " "date" | getline}
jest niejednoznaczne, bo operator konkatenacji nie został umieszczony
w nawiasach, i powinno być zapisane jako
@samp{("echo " "date") | getline} jeśli chcemy, by program był
przenośny na inne implementacje @code{awk}.
(Zdarza się, że @code{gawk} pojmuje to prawidłowo, ale nie powinieneś
na tym polegać.  Tak czy owak, nawiasy ułatwiają czytanie.)

@node Getline/Zmienna/Potok, Podsumowanie getline, Getline/Potok, Getline
@subsection Użycie @code{getline} z potoku do zmiennej

Gdy użyjemy @samp{@var{polecenie} | getline @var{zmn}}, wyjście polecenia
@var{polecenie} przekazywane jest potokiem do @code{getline} i w zmienną
@var{zmn}.  Na przykład, poniższy program, wykorzystując narzędzie
@code{date}, czyta bieżącą datę i czas do zmiennej @code{current_time}
a następnie ją wypisuje.

@example
@group
awk 'BEGIN @{
     "date" | getline current_time
     close("date")
     print "Raport utworzono: " current_time
@}'
@end group
@end example

W tej wersji @code{getline}, nie jest zmieniana żadna ze zmiennych
wbudowanych.  Rekord nie jest dzielony na pola.

@ifinfo
@c Thanks to Paul Eggert for initial wording here
Zgodnie ze standardem POSIX, @samp{@var{wyrażenie} | getline @var{zmn}} jest
niejednoznaczne jeśli @var{wyrażenie} zawiera nieujęte w nawiasy operatory
inne niż @samp{$}.  Na przykład, @samp{"echo " "date" | getline @var{zmn}}
jest niejednoznaczne, bo operator konkatenacji nie został umieszczony
w nawiasach, i powinno być zapisane jako
@samp{("echo " "date") | getline @var{zmn}} jeśli chcemy, by program był
przenośny na inne implementacje @code{awk}.
(Zdarza się, że @code{gawk} pojmuje to prawidłowo, ale nie powinieneś
na tym polegać.  Tak czy owak, nawiasy ułatwiają czytanie.)
@end ifinfo

@node Podsumowanie getline,  , Getline/Zmienna/Potok, Getline
@subsection Podsumowanie wariantów @code{getline}

We wszystkich postaciach @code{getline}, nawet tych, gdzie może być
aktualizowane @code{$0} i @code{NF}, rekord nie będzie sprawdzany ze
wszystkimi wzorcami programu @code{awk}, tak jak działoby się to,
gdyby był on normalnie czytany przez główną pętlę przetwarzania @code{awk}.
Jednakże nowy rekord jest sprawdzany z ewentualnymi następnymi
regułami.

@cindex różnice między @code{gawk} a @code{awk}
@cindex ograniczenia
@cindex implementacje, ograniczenia
Wiele z implementacji @code{awk} ogranicza ilość potoków, jakie program
@code{awk} może mieć otwarte, do tylko jednego!  W @code{gawk} nie ma
takiego ograniczenia.  Można otworzyć tyle potoków, na ile zezwoli
stosowany system operacyjny.

@vindex FILENAME
@cindex ciemny kąt
@cindex @code{getline}, nadawanie wartości @code{FILENAME}
@cindex @code{FILENAME}, ustawiane przez @code{getline}
Przy korzystaniu z @code{getline} (bez przekierowania) wewnątrz reguły
@code{BEGIN} pojawia się interesujący efekt uboczny.  Ponieważ
nieprzekierowane @code{getline} czyta z plików wiersza poleceń, pierwsze
polecenie @code{getline} powoduje, że @code{awk} nadaje wartość zmiennej
@code{FILENAME}.  Normalnie @code{FILENAME} nie posiada wartości
wewnątrz reguł @code{BEGIN}, ponieważ nie rozpoczęliśmy jeszcze
przetwarzania plików z wiersza poleceń (c.k.).
(@xref{BEGIN/END, , Wzorce specjalne @code{BEGIN} i @code{END}},
również @pxref{Auto-ustalane, , Zmienne wbudowane niosące informacje}.)

Poniższa tabela podsumowuje sześć wariantów @code{getline},
podając, które zmienne wbudowane każdy z nich zmienia.

@c @cartouche
@table @code
@item getline
Nadaje wartość @code{$0}, @code{NF}, @code{FNR} i @code{NR}.

@item getline @var{zmn}
Nadaje wartość @var{zmn}, @code{FNR} i @code{NR}.

@item getline < @var{plik}
Nadaje wartość @code{$0} i @code{NF}.

@item getline @var{zmn} < @var{plik}
Nadaje wartość @var{zmn}.

@item @var{polecenie} | getline
Nadaje wartość @code{$0} i @code{NF}.

@item @var{polecenie} | getline @var{zmn}
Nadaje wartość @var{zmn}.
@end table
@c @end cartouche

@node Wypisywanie, Wyrażenia, Czytanie plików, Top
@chapter Wypisywanie wyjścia

@cindex drukowanie
@cindex wypisywanie
@cindex wyjście
@cindex wyniki
Jedną z najczęstszych akcji jest @dfn{wypisanie}, wydruk (print) części
lub całości danych wejściowych.  Do zrobienia prostego wydruku (wyjścia)
używamy instrukcji @code{print}.  Instrukcja @code{printf} daje możliwość
bardziej wyszukanego formatowania.  Obie opisano w tym rozdziale.

@menu
* Print::                       Instrukcja @code{print}.
* Przykłady print::             Proste przykłady instrukcji @code{print}.
* Separatory wyjścia::          Separatory wyjścia. Jak je zmieniać.
* OFMT::                        Sterowanie wyjściem numerycznym przez @code{print}.
* Printf::                      Instrukcja @code{printf}.
* Przekierowanie::              Jak przekierowywać wyjście do wielu plików
                                czy potoków.
* Pliki specjalne::             Interpretacja nazw plików przez @code{gawk}.
                                @code{gawk} pozwala na dostęp
                                do odziedziczonych deskryptorów plików.
* Zamykanie plików i potoków::  Zamykanie potoków oraz plików wejściowych
                                i wyjściowych.
@end menu

@node Print, Przykłady print, Wypisywanie, Wypisywanie
@section Instrukcja @code{print}
@cindex @code{print}, instrukcja

Instrukcja @code{print} wykonuje wydruk za pomocą prostego,
standaryzowanego formatowania.  Określamy tylko, w postaci listy separowanej
przecinkami, łańcuchy lub liczby do wypisania.  Przy drukowaniu są
one rozdzielane pojedynczymi spacjami, a na końcu dołączany jest znak nowej
linii.  Instrukcja ta wygląda tak:

@example
print @var{elem1}, @var{elem2}, @dots{}
@end example

@noindent
Całość listy elementów może opcjonalnie być ujęta w nawiasy.  Nawiasy są
niezbędne jeśli któryś z elementów jest wyrażeniem z operatorem
relacyjnym.  Inaczej mogłoby ono być pomylone z przekierowaniem
(@pxref{Przekierowanie, ,Przekierowanie wyjścia @code{print} i @code{printf}}).

Elementy do wypisania mogą być stałymi łańcuchami lub liczbami, polami
bieżącego rekordu (jak @code{$1}), zmiennymi, czy wreszcie dowolnymi
wyrażeniami @code{awk}.  Wartości numeryczne są przekształcane na łańcuchy,
a następnie wypisywane.

Instrukcja @code{print} jest całkowicie ogólna, jeśli chodzi o to,
@emph{jakie} wartości wypisać.  Jednak, z dwoma wyjątkami, nie można
wyszczególnić @emph{jak} mają one zostać wypisane -- w ilu kolumnach, czy
stosować notację wykładniczą czy nie, i tak dalej.
(Opis wyjątków, @pxref{Separatory wyjścia}
i @ref{OFMT, ,Sterowanie wyjściem numerycznym przez @code{print}}.)
W tym celu potrzebujemy instrukcji @code{printf}
(@pxref{Printf, ,Using @code{printf} Statements for Fancier Printing}).

Zwykłe polecenie @samp{print}, bez żadnych elementów, jest równoważnikiem
@samp{print $0}: wypisuje cały bieżący rekord.
Do wypisania pustego wiersza stosujemy @samp{print ""}, gdzie @code{""}
jest łańcuchem pustym.

Do wypisania stałego kawałka tekstu stosujemy stałą łańcuchową, jak np.
@w{@code{"Nie panikuj"}}, jako jeden element.  Jeżeli zapomnimy o znakach
cudzysłowu, to tekst zostanie potraktowany jako wyrażenie @code{awk}
i prawdopodobnie otrzymamy błąd.  Należy pamiętać, że pomiędzy każdymi
dwoma elementami wypisywana jest spacja.

Każda z instrukcji @code{print} generuje co najmniej jeden wiersz wyjścia.
Ale nie jest ograniczona do jednego wiersza.  Jeżeli wartością któregoś z
łańcuchów jest łańcuch zawierający znak nowej linii, to znak ten jest
wypisywany razem z resztą łańcucha.  Pojedyncze @code{print} może w ten
sposób stworzyć dowolną liczbę wierszy.

@node Przykłady print, Separatory wyjścia, Print, Wypisywanie
@section Przykłady instrukcji @code{print}

Oto przykład wypisywania łańcucha, który zawiera wbudowane znaki nowej
linii (@samp{\n} jest sekwencją specjalną, służącą do przedstawiania znaku
nowej linii, @pxref{Sekwencje specjalne}):

@example
@group
$ awk 'BEGIN @{ print "wiersz jeden\wiersz dwa\nwiersz trzy" @}'
@print{} wiersz jeden
@print{} wiersz dwa
@print{} wiersz trzy
@end group
@end example

Oto przykład wypisujący pierwsze dwa pola każdego rekordu wejściowego,
ze spacją między nimi:

@example
@group
$ awk '@{ print $1, $2 @}' inventory-shipped
@print{} Jan 13
@print{} Feb 15
@print{} Mar 15
@dots{}
@end group
@end example

@cindex częste pomyłki
@cindex pomyłki, częste
@cindex błędy, częste
Typową pomyłką przy stosowaniu instrukcji @code{print} jest pominięcie
przecinka między dwoma elementami.  Często w wyniku na wyjściu elementy są
zestawione razem, bez spacji.  Przyczyną jest to, że
postawienie obok siebie dwu wyrażeń łańcuchowych oznacza w @code{awk}
ich konkatenację.  Oto ten sam program bez przecinka:

@example
@group
$ awk '@{ print $1 $2 @}' inventory-shipped
@print{} Jan13
@print{} Feb15
@print{} Mar15
@dots{}
@end group
@end example

Dla osoby nie znającej pliku @file{inventory-shipped}, żaden z powyższych
przykładów wyjścia nie ma zbyt dużego sensu.  Wiersz nagłówka na
początku nadałby mu jasności.  Dodajmy nagłówek do naszej tabeli miesięcy
(@code{$1}) i wysłanych zielonych paczek (@code{$2}).  Zrobimy to
wykorzystując wzorzec @code{BEGIN}
(@pxref{BEGIN/END, ,Wzorce specjalne @code{BEGIN} i @code{END}}) do
wymuszenia jednokrotnego wypisania nagłówka:

@example
awk 'BEGIN @{  print "Mies. Paczki"
              print "----- ------" @}
           @{  print $1, $2 @}' inventory-shipped
@end example

@noindent
Odgadłeś już, co się stanie?  Po uruchomieniu program wypisze:

@example
@group
Mies. Paczki
----- ------
Jan 13
Feb 15
Mar 15
@dots{}
@end group
@end example

@noindent
Nagłówki i dane tabeli nie są wyrównane!  Możemy to poprawić wypisując
trochę spacji między naszymi dwoma polami:

@example
awk 'BEGIN @{ print "Mies. Paczki"
             print "----- ------" @}
           @{ print $1, "     ", $2 @}' inventory-shipped
@end example

Można sobie wyobrazić, że taka metoda wyrównywania kolumn może stać się dość
skomplikowana, jeśli do poprawienia mamy wiele kolumn.  Zliczanie spacji dla
dwóch czy trzech kolumn może być proste, lecz przy większej liczbie łatwo
się pogubić.  Z tego powodu stworzono instrukcję @code{printf}
(@pxref{Printf, ,Wymyślne wyjście dzięki instrukcji @code{printf}});
jedną z jej specjalności jest wyrównywanie kolumn danych.

@cindex kontynuacja linii
@cindex linia, kontynuacja
Nawiasem mówiąc, można kontynuować instrukcję @code{print} czy
@code{printf} po prostu stawiając znak nowej linii po przecinku
(@pxref{Instrukcje/wiersze, ,Instrukcje @code{awk} a wiersze}).

@node Separatory wyjścia, OFMT, Przykłady print, Wypisywanie
@section Separatory wyjścia

@cindex separator pól wyjściowych, @code{OFS}
@cindex separator rekordów wyjściowych, @code{ORS}
@vindex OFS
@vindex ORS
Jak uprzednio wspomniano, instrukcja @code{print} zawiera listę
rozdzielonych przecinkami elementów.  Na wyjściu elementy te są normalnie
oddzielane spacjami.  Tak jednak być nie musi -- pojedyncza spacja jest
tylko domyślna.  Można podać dowolny łańcuch znaków, który będzie
stosowany jako @dfn{separator pól wyjściowych} (output field separator).
Robi się to przez przypisanie go zmiennej wbudowanej @code{OFS}.
Początkową jej wartością jest łańcuch @w{@code{" "}}, czyli pojedyncza
spacja.

Wyjście z całej instrukcji @code{print} nazywamy @dfn{rekordem wyjściowym}
(output record). Każda instrukcja @code{print} wypisuje jeden rekord
wyjściowy a następnie łańcuch zwany @dfn{separatorem rekordów wyjściowych}
(output record separator).  Łańcuch ten jest określany przez zmienną
wbudowaną @code{ORS}.  Początkową wartością @code{ORS} jest łańcuch
@code{"\n"}, tj. znak nowej linii. Zatem, normalnie, każda zwykła instrukcja
@code{print} tworzy osobny wiersz.

Sposób, w jaki rozdzielane są pola i rekordy wyjściowe, może być zmieniany
przez przypisanie nowych wartości zmiennym @code{OFS} i/lub @code{ORS}.
Zwyczajowym miejscem takiego przypisania jest wnętrze reguły @code{BEGIN}
(@pxref{BEGIN/END, ,Wzorce specjalne @code{BEGIN} i @code{END}}), tak
by odbyło się ono przed przetworzeniem czegokolwiek z wejścia.  Można to
również zrobić za pomocą przypisań w wierszu poleceń, przed nazwami
plików wejściowych, lub stosując opcję @samp{-v} wiersza poleceń
(@pxref{Opcje, ,Opcje wiersza poleceń}).

@ignore
Exercise,
Napisz na nowo program
@example
awk 'BEGIN @{ print "Mies. Paczki"
             print "----- ------" @}
           @{ print $1, "     ", $2 @}' inventory-shipped
@end example
stosując nową wartość @code{OFS}.
@end ignore

Poniższy przykład wypisuje pierwsze i ostatnie pole każdego rekordu
wejściowego, rozdzielając je średnikami, z pustym wierszem dodanym po każdym
wierszu:

@example
@group
$ awk 'BEGIN @{ OFS = ";"; ORS = "\n\n" @}
>            @{ print $1, $2 @}' BBS-list
@print{} aardvark;555-5553
@print{}
@print{} alpo-net;555-3412
@print{}
@print{} barfly;555-7685
@dots{}
@end group
@end example

Jeżeli wartość @code{ORS} nie zawiera znaku nowej linii, to całość wyjścia
programu będzie połączona w jednym wierszu, chyba że wyemitujemy znaki nowej
linii w jakiś inny sposób.

@node OFMT, Printf, Separatory wyjścia, Wypisywanie
@section Sterowanie wyjściem numerycznym przez @code{print}
@vindex OFMT
@cindex numeryczny format wyjścia
@cindex format, wyjście numeryczne
@cindex specyfikator formatu wyjściowego, @code{OFMT}
Gdy stosujemy instrukcję @code{print} to wypisania wartości numerycznych,
@code{awk} wewnętrznie przekształca liczbę na łańcuch znaków i wypisuje
ten łańcuch.  Do wykonania tej konwersji @code{awk} wykorzystuje funkcję
@code{sprintf}
(@pxref{Funkcje łańcuchowe, ,Funkcje wbudowane działające na łańcuchach}).
Na razie wystarczy powiedzieć, iż funkcja @code{sprintf} akceptuje
@dfn{specyfikację formatu}, która mówi jej jak formatować liczby (lub
łańcuchy), i że istnieje wiele różnych sposobów, na jakie można
formatować liczby.  Rozmaite specyfikacje formatu omawiane są pełniej
w @ref{Litery sterujące, , Litery sterujące formatem}.

Zmienna wbudowana @code{OFMT} zawiera domyślną specyfikację formatu, który
@code{print} używa z @code{sprintf} gdy chce przekształcić liczbę na
łańcuch do wypisania.  Domyślną wartością @code{OFMT} jest @code{"%.6g"}.
Podając jako wartość @code{OFMT} inne specyfikatory formatu zmieniamy
sposób, w jaki @code{print} będzie wypisywał liczby.  Jako krótki przykład:

@example
@group
$ awk 'BEGIN @{
>   OFMT = "%.0f"  # wypisz liczby jako całkowite (zaokrągla)
>   print 17.23 @}'
@print{} 17
@end group
@end example

@noindent
@cindex ciemny kąt
@cindex język @code{awk}, wersja POSIX
@cindex POSIX @code{awk}
Zgodnie ze standardem POSIX, zachowanie się @code{awk} będzie
niezdefiniowane, jeśli @code{OFMT} zawiera coś innego niż specyfikację
konwersji zmiennoprzecinkowej (c.k.).

@node Printf, Przekierowanie, OFMT, Wypisywanie
@section Wymyślne wyjście dzięki instrukcji @code{printf}
@cindex formatowane wyjście
@cindex sformatowane wyjście
@cindex wyjście, sformatowane

Jeżeli potrzebujemy dokładniejszej kontroli nad formatem wyjściowym niż to
daje @code{print}, wykorzystajmy @code{printf}.  Za pomocą @code{printf}
można określać szerokość, jaką ma mieć każda z pozycji, i rozmaite opcje
formatowania liczb (jak podstawa do stosowania, liczba cyfr do wypisania po
kropce dziesiętnej).  Robi się to podając łańcuch, zwany @dfn{łańcuchem
formatu}, który steruje sposobem i miejscem wypisania pozostałych
argumentów.

@menu
* Podstawy printf::             Składnia instrukcji @code{printf}.
* Litery sterujące::            Litery sterujące formatem.
* Modyfikatory formatu::        Modyfikatory w specyfikacji formatu.
* Przykłady printf::            Kilka przykładów.
@end menu

@node Podstawy printf, Litery sterujące, Printf, Printf
@subsection Wprowadzenie do instrukcji @code{printf}

@cindex instrukcja @code{printf}, składnia
@cindex @code{printf} instrukcja, składnia
Instrukcja @code{printf} wygląda tak:

@example
printf @var{format}, @var{elem1}, @var{elem2}, @dots{}
@end example

@noindent
Całość listy argumentów może być opcjonalnie ujęta w nawiasy.  Nawiasy są
konieczne jeśli któryś z elementów jest wyrażeniem używa operatora
relacyjnego @samp{>}.  W przeciwnym razie mogłoby ono zostać
pomylone z przekierowaniem
(@pxref{Przekierowanie, ,Przekierowanie wyjścia @code{print} i @code{printf}}).

@cindex łańcuch formatu
Różnicę pomiędzy @code{printf} a @code{print} stanowi argument @var{format}.
Jest to wyrażenie, którego wartość jest brana jako łańcuch; określa w jaki
sposób wypisać każdy z pozostałych argumentów.  Nazywa się je
@dfn{łańcuchem formatu}.

Łańcuch formatu jest bardzo podobny do stosowanego w funkcji bibliotecznej
ANSI C @code{printf}.  Większość @var{formatu} to tekst, jaki ma być
wypisany dosłownie.  W tekście rozsiane są @dfn{specyfikatory formatu}, po
jednym na element.  Każdy specyfikator formatu określa sposób wypisania
argumentu mającego tę samą pozycję na liście argumentów, co specyfikator
w łańcuchu formatu.

Instrukcja @code{printf} nie dołącza samoczynnie znaku nowej linii
do tworzonego wyjścia.  Wypisuje tylko to, co wyszczególnia łańcuch formatu.
Zatem, jeżeli chcemy znaku nowej linii, to musimy go zawrzeć w łańcuchu
formatu.  Zmienne separatorów wyjścia @code{OFS} and @code{ORS} nie mają
wpływu na instrukcje @code{printf}.  Na przykład:

@example
@group
BEGIN @{
   ORS = "\nAU!\n"; OFS = "!"
   msg = "Nie panikuj!"; printf "%s\n", msg
@}
@end group
@end example

Ten program nadal wypisuje przyjazny komunikat @samp{Nie panikuj!}.

@node Litery sterujące, Modyfikatory formatu, Podstawy printf, Printf
@subsection Litery sterujące formatem
@cindex @code{printf}, znaki sterujące formatem
@cindex specyfikator formatu

Specyfikator formatu rozpoczyna się znakiem @samp{%} a kończy
@dfn{literą sterująca formatem}; mówi ona instrukcji @code{printf}, jak
powinien zostać wypisany pojedynczy element.  (Chcąc faktycznie uzyskać
wypisanie znaku @samp{%}, piszemy @samp{%%}.)  Litera sterująca formatem
określa, jaki rodzaj wartości wypisać.  Reszta specyfikatora formatu
zbudowana jest z opcjonalnych @dfn{modyfikatorów}, będących parametrami,
jakie mają zostać użyte, jak np. szerokość pola.

Oto lista liter sterujących formatem:

@table @code
@item c
Wypisuje liczbę jako znak ASCII.  Zatem, @samp{printf "%c", 65}
wypisuje literę @samp{A}.  Dla wartości łańcuchowej wypisywany jest
pierwszy znak łańcucha.

@item d
@itemx i
Są sobie równoważne.  Obie wypisują dziesiętną liczbę całkowitą.
Specyfikacja @samp{%i} istnieje dla zgodności z ANSI C.

@item e
@itemx E
Wypisuje liczbę w notacji naukowej (wykładniczej).
Na przykład,

@example
printf "%4.3e\n", 1950
@end example

@noindent
wypisze @samp{1.950e+03}, o ogółem czterech cyfrach znaczących, z których
trzy są po kropce dziesiętnej.  The @samp{4.3} są modyfikatorami, omówionymi
poniżej.  @samp{%E} używa @samp{E} zamiast @samp{e} w wyjściu.

@item f
Wypisuje liczbę w notacji zmiennoprzecinkowej.
Na przykład,

@example
printf "%4.3f", 1950
@end example

@noindent
wypisze @samp{1950.000}, z czterema cyfrach znaczących, z których
trzy są po kropce dziesiętnej.  The @samp{4.3} są modyfikatorami, omówionymi
poniżej.

@item g
@itemx G
Wypisuje liczbę albo w notacji naukowej albo zmiennoprzecinkowej, zależnie
od tego, która zużyje mniej znaków.  Jeśli wynik wypisywany jest w notacji
naukowej, to @samp{%G} stosuje @samp{E} zamiast @samp{e}.

@item o
Wypisuje ósemkową liczbę całkowitą bez znaku (unsigned octal integer).
(W notacji ósemkowej, o podstawie osiem, cyfry biegną od @samp{0}
do @samp{7}; dziesiętna liczba osiem jest reprezentowana jako @samp{10}
ósemkowo.)

@item s
Wypisuje łańcuch.

@item u
Wypisuje liczbę dziesiętną bez znaku (unsigned decimal).
(Format ten ma znaczenie marginalne, gdyż wszystkie liczby w @code{awk}
są zmiennoprzecinkowe.  Obsługiwany głównie dla zgodności z C.)

@item x
@itemx X
Wypisuje szesnastkową liczbę całkowitą bez znaku (unsigned hexadecimal
integer).
W zapisie szesnastkowym (heksadecymalnym), o podstawie 16, cyframi są
@samp{0} do @samp{9} oraz @samp{a} do @samp{f}.  Szesnastkowa cyfra @samp{f}
reprezentuje dziesiętną liczbę 15.)   @samp{%X} stosuje litery @samp{A}
do @samp{F} zamiast @samp{a} do @samp{f}.

@item %
Nie jest to faktycznie litera sterująca formatem, ale ma znaczenie użyta
po @samp{%}: sekwencja @samp{%%} wypisuje pojedynczy @samp{%}.  Nie
pobiera argumentu i ignoruje wszelkie modyfikatory.
@end table

@cindex ciemny kąt
Przy stosowaniu liter sterujących formatem liczb całkowitych do wartości
spoza zakresu długich całkowitych w C (@code{long} integer), @code{gawk}
przełączy się na specyfikator formatu @samp{%g}.  Inne wersje @code{awk}
mogą wypisywać niepoprawne wartości lub robić coś całkiem innego (c.k.).

@node Modyfikatory formatu, Przykłady printf, Litery sterujące, Printf
@subsection Modyfikatory formatu w @code{printf}

@cindex @code{printf}, modyfikatory
@cindex modyfikatory (w specyfikatorach formatu)
Specyfikacja formatu może zawierać także @dfn{modyfikatory}, decydujące o
tym, jaka część wartości elementu będzie wypisana i ile miejsca zajmie.
Modyfikatory mogą wystąpić pomiędzy znakiem @samp{%} a literą sterującą
formatem.  W przykładach niżej zastosowano symbol wyliczenia ``@bullet{}''
do przedstawienia spacji w wyjściu.  Oto możliwe modyfikatory, w kolejności,
w jakiej mogą się pojawić:

@table @code
@item -
Znak minus, użyty przed modyfikatorem szerokości (patrz niżej) nakazuje,
by argument wyrównać do lewej na podanej szerokości.  Normalnie argument
jest wypisywany w zadanej szerokości z wyrównaniem do prawej.  Zatem,

@example
printf "%-4s", "foo"
@end example

@noindent
wypisuje @samp{foo@bullet{}}.

@item @var{spacja}
W konwersjach numerycznych, poprzedza wartości dodatnie spacją, a ujemne
znakiem minus.

@item +
Znak plus, używany przed modyfikatorem szerokości (patrz niżej)
stanowi, by przy konwersjach numerycznych zawsze podany był znak, nawet
jeśli dane do sformatowania są dodatnie.  @samp{+} przesłania modyfikator
spacji.

@item #
Stosuje ``alternatywną postać'' dla niektórych liter sterujących.
Przy @samp{%o}, zapewnia początkowe zero.
Przy @samp{%x} i @samp{%X} zapewnia początkowe @samp{0x} lub @samp{0X} dla
wyniku niezerowego.
Przy @samp{%e}, @samp{%E} i @samp{%f} wynik będzie zawsze zawierał kropkę
dziesiętną.
Przy @samp{%g} i @samp{%G}, końcowe zera nie są usuwane z wyniku.

@cindex ciemny kąt
@item 0
Początkowe @samp{0} (zero) działa jak flaga, wskazująca, że wyjście
powinno być dopełnione zerami zamiast spacjami.  Odnosi się to także do
nienumerycznych formatów wyjściowych (c.k.).  Flaga ta ma znaczenie tylko
gdy pole jest szersze niż wartość do wypisania.

@item @var{szer}
Jest to liczba określająca pożądaną minimalną szerokość pola.  Wstawienie
dowolnej liczby pomiędzy znak @samp{%} a znak sterujący formatem wymusza
rozszerzenie pola na taką długość.  Domyślną metodą poszerzenia jest
dopełnienie spacjami po lewej.  Na przykład,

@example
printf "%4s", "foo"
@end example

@noindent
wypisuje @samp{@bullet{}foo}.

Wartość @var{szer} jest szerokością minimalną, nie maksymalną.  Jeżeli
wartość elementu wymaga więcej niż @var{szer} znaków, może być tak
szeroka, jak to jest niezbędne.  Zatem,

@example
printf "%4s", "foobar"
@end example

@noindent
wypisuje @samp{foobar}.

Poprzedzenie @var{szer} znakiem minus powoduje, że wyjście będzie dopełniane
spacjami z prawej, zamiast z lewej.

@item .@var{dokł}
Jest to liczba określająca dokładność, jaka ma być użyta zastosowana
przy wypisywaniu.  Przy formatach @samp{e}, @samp{E} i @samp{f} podaje
liczbę cyfr, jakie mają być wypisane na prawo od kropki dziesiętnej. Przy
formatach @samp{g} i @samp{G}, określa maksymalną ilość cyfr znaczących.
Przy formatach @samp{d}, @samp{o}, @samp{i}, @samp{u}, @samp{x} i @samp{X}
określa minimalną liczbę cyfr do wypisania.  Dla łańcucha podaje maksymalną
liczbę znaków łańcucha, jakie winny zostać wypisane.  Stąd,

@example
printf "%.4s", "foobar"
@end example

@noindent
wypisuje @samp{foob}.
@end table

Obsługiwana jest możliwość dynamicznych @var{szer} i @var{dokł} (na przykład,
@code{"%*.*s"}) zapewniana przez @code{printf} z biblioteki C.  Zamiast
podawania w łańcuchu formatu wartości @var{szer} i/lub @var{dokł} wprost,
można je przekazać w liście argumentów.  Na przykład:

@example
w = 5
p = 3
s = "abcdefg"
printf "%*.*s\n", w, p, s
@end example

@noindent
jest ściśle równoważne temu:

@example
s = "abcdefg"
printf "%5.3s\n", s
@end example

@noindent
Oba programy wypisują @samp{@w{@bullet{}@bullet{}abc}}.

Wcześniejsze wersje @code{awk} nie obsługują powyższej własności.
Jeżeli musimy użyć takiej wersji, można zasymulować tę cechę wykorzystując
do budowy łańcucha formatu konkatenację, jak tu:

@example
w = 5
p = 3
s = "abcdefg"
printf "%" w "." p "s\n", s
@end example

@noindent
Nie jest do szczególne łatwe w czytaniu, ale działa.

@cindex język @code{awk}, wersja POSIX
@cindex POSIX @code{awk}
Programiści C mogą być przyzwyczajeni do używania dodatkowych flag
@samp{l} i @samp{h} w łańcuchach formatu @code{printf}.  Nie są one poprawne
w @code{awk}.  Większość implementacji @code{awk} milcząco ignoruje te
flagi.  Jeżeli w wierszu poleceń podano @samp{--lint}
(@pxref{Opcje, ,Opcje wiersza poleceń}), @code{gawk} będzie ostrzegał o ich
użyciu.  Jeżeli podano @samp{--posix}, ich użycie jest błędem krytycznym.

@node Przykłady printf,  , Modyfikatory formatu, Printf
@subsection Przykłady użycia @code{printf}

A oto, w jaki sposób wykorzystać @code{printf} do utworzenia wyrównanej
tabeli:

@example
awk '@{ printf "%-10s %s\n", $1, $2 @}' BBS-list
@end example

@noindent
powyższe wypisuje nazwy BBS-ów (@code{$1}) z pliku @file{BBS-list} w postaci
łańcucha 10 znaków, wyrównanego do lewej.  Za nimi, w tym samym
wierszu, wypisuje też numery telefonów (@code{$2}).  Tworzy to wyrównaną
dwukolumnową tabelę nazw i numerów telefonicznych:

@example
@group
$ awk '@{ printf "%-10s %s\n", $1, $2 @}' BBS-list
@print{} aardvark   555-5553
@print{} alpo-net   555-3412
@print{} barfly     555-7685
@print{} bites      555-1675
@print{} camelot    555-0542
@print{} core       555-2912
@print{} fooey      555-1234
@print{} foot       555-6699
@print{} macfoo     555-6480
@print{} sdace      555-3430
@print{} sabafoo    555-2127
@end group
@end example

Zauważyłeś, że nie określiliśmy, że numery telefonów mają być wypisane jako
liczby?  Musiały być wypisane jako łańcuchy, gdyż są rozdzielane kreską.
Jeśli spróbowalibyśmy wypisać je jako liczby, to wszystkim, co byśmy
otrzymali, byłyby pierwsze trzy cyfry, @samp{555}.  Wprowadziłoby to
niezłe zamieszanie.

Nie podawaliśmy szerokości numerów telefonicznych, ponieważ występują
jako ostatnie w wierszach. Nie musimy po nich stawiać spacji.

Można by nawet upiększyć naszą tabelę dodając nagłówki nad kolumnami.
Zastosujemy do tego wzorzec @code{BEGIN}
(@pxref{BEGIN/END, ,Wzorce specjalne @code{BEGIN} i @code{END}}),
wymuszając tylko jednorazowe wypisanie nagłówka, na początku programu
@code{awk}:

@example
@group
awk 'BEGIN @{ print "Nazwa     Numer"
             print "-----     -----" @}
     @{ printf "%-10s %s\n", $1, $2 @}' BBS-list
@end group
@end example

Zauważyłeś, że w powyższym przykładzie wymieszaliśmy instrukcje @code{print}
i @code{printf}?  Mogliśmy użyć wyłącznie instrukcji @code{printf}
do uzyskania tych samych rezultatów:

@example
@group
awk 'BEGIN @{ printf "%-10s %s\n", "Nazwa", "Numer"
             printf "%-10s %s\n", "-----", "-----" @}
     @{ printf "%-10s %s\n", $1, $2 @}' BBS-list
@end group
@end example

@noindent
Wypisując nagłówek każdej z kolumn za pomocą takiej samej specyfikacji
formatu, co zastosowana dla elementów tej kolumny, upewniliśmy się, że
nagłówki zostaną wyrównane dokładnie tak samo jak kolumny.

Fakt, iż ta sama specyfikacja formatu jest używana trzykrotnie, można
uwypuklić przechowując ją w zmiennej, w ten sposób:

@example
@group
awk 'BEGIN @{ format = "%-10s %s\n"
             printf format, "Nazwa", "Numer"
             printf format, "-----", "-----" @}
     @{ printf format, $1, $2 @}' BBS-list
@end group
@end example

@c !!! exercise
Sprawdź, czy potrafisz użyć instrukcji @code{printf} do wyrównania nagłówków
i danych tabeli dla naszego przykładu z plikiem @file{inventory-shipped},
omawianego wcześniej w sekcji o instrukcji @code{print}
(@pxref{Print, ,Instrukcja @code{print}}).

@node Przekierowanie, Pliki specjalne, Printf, Wypisywanie
@section Przekierowanie wyjścia @code{print} i @code{printf}

@cindex wyjście, przekierowanie
@cindex przekierowanie wyjścia
Do tej pory zajmowaliśmy się tylko wyjściem piszącym na standardowe wyjście,
zwykle terminal.  Zarówno @code{print} jak i @code{printf} potrafią również
wysyłać swoje wyjście w inne miejsca.  Nazywamy to @dfn{przekierowaniem}
(redirection).

Przekierowanie występuje po instrukcji @code{print} lub @code{printf} .
Przekierowania w @code{awk} zapisywane są tak samo jak w poleceniach
powłoki, z wyjątkiem tego, że są zapisane wewnątrz programu @code{awk}.

Mamy trzy postacie przekierowania wyjścia: wyjście do pliku,
wyjście dopisywane do pliku i wyjście poprzez potok do innego polecenia.
Wszystkie pokazano dla instrukcji @code{print}, ale działają identycznie
dla @code{printf}.

@table @code
@item print @var{elementy} > @var{plik-wyj}
Ten rodzaj przekierowania wypisuje elementy do pliku wyjściowego
@var{plik-wyj}.  Nazwa pliku @var{plik-wyj} może być dowolnym wyrażeniem.
Jego wartość jest zmieniana na łańcuch a następnie używana jako nazwa pliku
(@pxref{Wyrażenia}).

Przy stosowaniu tego rodzaju przekierowania, @var{plik-wyj} jest wymazywany
przed zapisaniem do niego pierwszego elementu wyjścia.  Kolejne zapisy
do tego samego @var{pliku-wyj} nie wymazują go, lecz są do niego dołączane.
Jeżeli @var{plik-wyj} nie istnieje, to jest tworzony.

Na przykład, oto jak program @code{awk} może zapisać listę BBS-ów do pliku
@file{name-list} a listę numerów telefonów do pliku @file{phone-list}.
Oba pliki wyjściowe zawierają po jednej nazwie lub numerze na wiersz.

@example
@group
$ awk '@{ print $2 > "phone-list"
>        print $1 > "name-list" @}' BBS-list
@end group
@group
$ cat phone-list
@print{} 555-5553
@print{} 555-3412
@dots{}
@end group
@group
$ cat name-list
@print{} aardvark
@print{} alpo-net
@dots{}
@end group
@end example

@item print @var{elementy} >> @var{plik-wyj}
Ten rodzaj przekierowania wpisuje elementy do wcześniej istniejącego pliku
wynikowego @var{plik-wyj}.   Różnica pomiędzy tym przekierowaniem a
przekierowaniem z pojedynczym @samp{>} jest taka, że stara zawartość (jeśli
istnieje) @var{pliku-wyj} nie jest wymazywana.  Zamiast tego wyjście
@code{awk} jest dołączane na koniec pliku.
Jeżeli @var{plik-wyj} nie istnieje, to jest tworzony.

@cindex potoki dla wyjścia
@cindex wyjście, potokowanie
@item print @var{elementy} | @var{polecenie}
Możliwe jest także wysłanie wyjścia do innego programu przez potok
zamiast do pliku.  Ten typ przekierowania otwiera potok do @var{polecenia}
i wpisuje @var{elementy} przez ten potok, do innego procesu utworzonego
w celu wykonania @var{polecenia}.

Argument @var{polecenie} przekierowania jest faktycznie wyrażeniem
@code{awk}.  Jego wartość jest przekształcana na łańcuch, którego zawartość
daje polecenie powłoki, jakie ma być uruchomione.

Na przykład, poniższe tworzy dwa pliki, listę niesortowanych nazw BBS-ów i
listę posortowaną w odwrotnym porządku alfabetycznym:

@example
awk '@{ print $1 > "names.unsorted"
       command = "sort -r > names.sorted"
       print $1 | command @}' BBS-list
@end example

Tutaj lista niesortowana jest zapisywana zwykłym przekierowaniem, podczas
gdy lista posortowana zapisywana jest za pomocą potokowania przez
narzędzie @code{sort}.

Kolejny przykład korzysta z przekierowania do wysłania wiadomości na listę
pocztową @samp{bug-system}.  Może to być przydatne gdy w pojawiły się
kłopoty w skrypcie @code{awk} uruchamianym okresowo do konserwacji systemu.

@example
report = "mail bug-system"
print "Awk script failed:", $0 | report
m = ("at record number " FNR " of " FILENAME)
print m | report
close(report)
@end example

Wiadomość budowana jest za pomocą konkatenacji (złączenia łańcuchów)
i zapisywana w zmiennej @code{m}.  Następnie jest wysyłana potokiem do
programu @code{mail}.

Wywołujemy tu funkcję @code{close}, gdyż dobrym nawykiem jest zamykać potok
zaraz po przesłaniu do niego zamierzonego wyjścia.
@xref{Zamykanie plików i potoków, ,Zamykanie potoków oraz plików wejściowych i wyjściowych},
gdzie jest o tym więcej napisane.  Ten przykład ilustruje również
zastosowanie zmiennej do reprezentacji @var{pliku} lub @var{polecenia}:
nie jest konieczne używanie zawsze stałej łańcuchowej.  Stosowanie zmiennej
jest na ogół dobrym rozwiązaniem, ponieważ @code{awk} wymaga, by wartość
łańcucha była za każdym razem zapisana tak samo.
@end table

Przekierowanie wyjścia przy użyciu @samp{>}, @samp{>>} lub @samp{|} prosi
system o otwarcie pliku lub potoku tylko jeśli do konkretnego @var{pliku}
lub @var{polecenia}, które podaliśmy, nasz program jeszcze nie pisał, albo
jeśli je zamknięto po ostatnim zapisie.

@cindex różnice między @code{gawk} a @code{awk}
@cindex ograniczenia
@cindex ograniczenia implementacji
@iftex
Jak wspomniano wcześniej
(@pxref{Podsumowanie getline,  , Podsumowanie wariantów @code{getline}}),
wiele
@end iftex
@ifinfo
Wiele
@end ifinfo
implementacji @code{awk} ogranicza ilość potoków, jakie program
@code{awk} może mieć otwarte, do tylko jednego!  W @code{gawk} nie ma
takiego ograniczenia.  Można otworzyć tyle potoków, na ile zezwoli
stosowany system operacyjny.

@node Pliki specjalne, Zamykanie plików i potoków, Przekierowanie, Wypisywanie
@section Specjalne nazwy plików w @code{gawk}
@cindex standardowe wejście
@cindex standardowe wyjście
@cindex standardowe wyjście błędów
@cindex standardowe wyjście diagnostyczne
@cindex pliki, deskryptory
@cindex deskryptory plików

Zgodnie z konwencją, pracujące programy mają trzy strumienie
wejścia/wyjścia już dostępne dla nich do odczytu i zapisu.  Są one znane
jako @dfn{standardowe wejście}, @dfn{standardowe wyjście} i @dfn{standardowe
wyjście błędów}.  Strumienie te domyślnie są połączone z naszym terminalem,
ale często są przekierowywane za pomocą powłoki, poprzez operatory
@samp{<}, @samp{<<}, @samp{>}, @samp{>>}, @samp{>&} i @samp{|}.
Standardowe wyjście błędów jest na ogół używane do zapisywania komunikatów
o błędach.  Powodem, dla którego mamy dwa odrębne strumienie, standardowe
wyjście i standardowe wyjście błędów, jest to, że można je wówczas osobno
przekierowywać.

@cindex różnice między @code{gawk} a @code{awk}
W innych implementacjach @code{awk}, jedyną metodą zapisania komunikatu
o błędzie na standardowym wyjściu błędów w programie @code{awk} jest:

@example
print "Wykryto poważny błąd!" | "cat 1>&2"
@end example

@noindent
Działa to dzięki otwarciu potoku do polecenia powłoki, które ma
dostęp do standardowego strumienia błędów, jaki dziedziczy po procesie
@code{awk}.  Jest to wysoce nieeleganckie. Jest też nieefektywne, gdyż
wymaga odrębnego procesu.  Ludzie piszący programy @code{awk} często
tego nie robią.
Zamiast tego, wysyłają komunikaty o błędach na terminal, tak:

@example
@group
print "Wykryto poważny błąd!" > "/dev/tty"
@end group
@end example

@noindent
Zwykle na to ten sam efekt, ale nie zawsze: chociaż standardowym strumieniem
błędów jest na ogół terminal, to może ono zostać przekierowane, i gdy się
tak dzieje, pisanie na terminal nie jest poprawne.  W rzeczywistości, jeżeli
@code{awk} uruchamiany jest z zadania tle, możemy w ogóle nie mieć
terminala.  Wówczas otwarcie @file{/dev/tty} się nie powiedzie.

@code{gawk} udostępnia specjalne nazwy plików do dostępu do trzech
standardowych strumieni.  Przy przekierowaniu wejścia lub wyjścia
w @code{gawk} jeśli nazwa pliku pasuje do jednej z tych nazw specjalnych,
to @code{gawk} używa wprost strumienia, który ona oznacza.

@cindex @file{/dev/stdin}
@cindex @file{/dev/stdout}
@cindex @file{/dev/stderr}
@cindex @file{/dev/fd}
@c @cartouche
@table @file
@item /dev/stdin
Standardowe wejście (deskryptor pliku 0).

@item /dev/stdout
Standardowe wyjście (deskryptor pliku 1).

@item /dev/stderr
Standardowe wejście błędów (deskryptor pliku 2).

@item /dev/fd/@var{N}
Plik skojarzony z deskryptorem pliku @var{N}.  Plik taki musi być otwarty
przez program inicjujący wykonanie @code{awk} (na ogół powłokę).
Dopóki nie podejmujemy specjalnych starań w powłoce, z której wołamy
@code{awk}, dostępne są tylko deskryptory 0, 1 i 2.
@end table
@c @end cartouche

Nazwy plików @file{/dev/stdin}, @file{/dev/stdout} i @file{/dev/stderr}
są synonimami (aliasami) dla, odpowiednio,  @file{/dev/fd/0},
@file{/dev/fd/1} i @file{/dev/fd/2}, ale są bardziej zrozumiałe.
@c self-explanatory.

Prawidłowym sposobem wypisywania komunikatów o błędach w programie
@code{gawk} jest użycie @file{/dev/stderr}, jak tu:

@example
print "Wykryto poważny błąd!" > "/dev/stderr"
@end example

@code{gawk} udostępnia też specjalne nazwy plików dające dostęp do
informacji o pracującym procesie @code{gawk}.  Każdy z tych ``plików''
udostępnia jeden rekord danych.  Chcąc odczytać je więcej niż raz, musimy
je zamknąć funkcją @code{close}
(@pxref{Zamykanie plików i potoków, ,Zamykanie potoków oraz plików wejściowych i wyjściowych}).
Tymi nazwami są:

@cindex informacje o procesie
@cindex proces, informacje
@cindex @file{/dev/pid}
@cindex @file{/dev/pgrpid}
@cindex @file{/dev/ppid}
@cindex @file{/dev/user}
@c @cartouche
@table @file
@item /dev/pid
Odczyt tego pliku zwraca identyfikator (ID) procesu dla
bieżącego procesu, dziesiętnie, zakończony znakiem nowej linii.

@item  /dev/ppid
Odczyt tego pliku zwraca identyfikator procesu macierzystego dla bieżącego
procesu, dziesiętnie, zakończony znakiem nowej linii.

@item  /dev/pgrpid
Odczyt tego pliku zwraca identyfikator grupy procesu dla bieżącego procesu,
dziesiętnie, zakończony znakiem nowej linii.

@item /dev/user
Odczyt tego pliku zwraca pojedynczy rekord zakończony znakiem nowej linii.
Pola rozdzielone są spacjami.  Pola reprezentują następujące informacje:

@table @code
@item $1
Wartość zwrócona przez funkcję systemową @code{getuid} (rzeczywisty
identyfikator numeryczny użytkownika).

@item $2
Wartość zwrócona przez funkcję systemową @code{geteuid} (efektywny
identyfikator numeryczny użytkownika).

@item $3
Wartość zwrócona przez funkcję systemową @code{getgid} (rzeczywisty
identyfikator numeryczny grupy).

@item $4
Wartość zwrócona przez funkcję systemową @code{getegid} (efektywny
identyfikator numeryczny grupy).
@end table

Jeśli istnieją jakieś dodatkowe pola, to są one identyfikatorami grup
zwróconymi przez funkcję systemową @code{getgroups}.
(Nie wszystkie systemy obsługują przynależność do wielu grup.)
@end table
@c @end cartouche

Powyższe specjalne nazwy plików mogą być stosowane w wierszu poleceń jako
pliki danych, jak i do przekierowań wejścia/wyjścia w programie @code{awk}.
Nie można ich stosować jako plików źródłowych opcji @samp{-f}.

Rozpoznawanie powyższych specjalnych nazw plików jest wyłączone jeśli
@code{gawk} jest w trybie zgodności (@pxref{Opcje, ,Opcje wiersza poleceń}).

@strong{Uwaga!}:  Interpretacja tych nazw plików wykonywana jest przez
sam @code{gawk}, chyba że nasz system faktycznie posiada katalog
@file{/dev/fd} (lub dowolny inny z podanych wyżej specjalnych plików).
Na przykład, zastosowanie @samp{/dev/fd/4} jako wyjścia w rzeczywistości
będzie pisać do pliku o deskryptorze 4, a nie do nowego deskryptora pliku,
który został zduplikowany (przez @code{dup}) z deskryptora 4.  W większości
przypadków nie ma to znaczenia; jednak, istotne jest by @emph{nie} zamykać
plików związanych z deskryptorami 0, 1 i 2.  Jeżeli zamkniemy jeden z nich,
spowoduje to nieprzewidywalne zachowanie.

Pliki specjalne dające dostęp do informacji związanej z procesem znikną
w przyszłych wersjach @code{gawk}.
@xref{Przyszłe rozszerzenia, ,Prawdopodobne przyszłe rozszerzenia}.

@node Zamykanie plików i potoków, , Pliki specjalne, Wypisywanie
@section Zamykanie potoków oraz plików wejściowych i wyjściowych
@cindex zamykanie plików wejściowych i potoków
@cindex zamykanie plików wyjściowych i potoków
@findex close

Jeśli podczas wykonania programu @code{awk} ta sama nazwa pliku lub
polecenia powłoki użyta jest
z @code{getline} (@pxref{Getline, ,Odczyt bezpośredni przez @code{getline}})
więcej niż raz, plik jest otwierany (lub polecenie wykonywane) tylko
za pierwszym razem.  W tym momencie z pliku czy polecenia czytany jest
pierwszy rekord wejścia.  Przy następnym użyciu tego samego pliku lub
polecenia z @code{getline}, czytany jest z niego kolejny rekord, i tak dalej.

Podobnie, gdy plik lub potok jest otwierany do wyprowadzenia wyników,
nazwa z nim skojarzona jest zapamiętywana przez @code{awk}, a kolejne zapisy
do tego samego pliku czy polecenia są dołączane do poprzednich.  Plik lub
potok pozostaje otwarty aż do zakończenia pracy @code{awk}.

Wynika stąd, że jeśli chcemy zacząć czytanie tego samego pliku od początku
albo powtórnie uruchomić polecenie powłoki (zamiast czytania dalszego ciągu
jego wyjścia), to musimy podjąć specjalne kroki.
To, co musimy zrobić, to użycie funkcji @code{close}, jak niżej:

@example
close(@var{nazwapliku})
@end example

@noindent
lub

@example
close(@var{polecenie})
@end example

Argumentem @var{nazwapliku} lub @var{polecenie} może być dowolne wyrażenie.
Jego wartość musi @emph{dokładnie} odpowiadać łańcuchowi, jaki był użyty
do otwarcia pliku lub uruchomienia polecenia (łącznie ze spacjami i innymi
``nieistotnymi'' znakami).  Na przykład, jeżeli otwieramy potok za pomocą:

@example
"sort -r names" | getline foo
@end example

@noindent
to musimy go zamknąć tak:

@example
close("sort -r names")
@end example

Po wykonaniu wywołania tej funkcji następne @code{getline} z tego pliku czy
polecenia, albo następne @code{print} lub @code{printf} do tego pliku czy
polecenia, ponownie otworzy plik lub uruchomi polecenie.

Ponieważ wyrażenie użyte do zamknięcia pliku lub potoku musi dokładnie
odpowiadać wyrażeniu użytemu do jego otwarcia (uruchomienia), dobrą praktyką
jest stosowanie zmiennej do przechowania nazwy pliku (polecenia).
Poprzedni przykład miałby postać

@example
sortcom = "sort -r names"
sortcom | getline foo
@dots{}
close(sortcom)
@end example

@noindent
Pomaga to uniknąć trudnych do znalezienia błędów typograficznych
w programach @code{awk}.

Oto kilka powodów, dla których może zachodzić potrzeba zamknięcia pliku
wyjściowego:

@itemize @bullet
@item
Do pisania do pliku i późniejszego czytania go w tym samym programie
@code{awk}.  Zamknij plik gdy tylko skończysz do niego pisać; następnie
możesz zacząć odczyt za pomocą @code{getline}.

@item
Do zapisu wielu plików, kolejno, w tym samym programie @code{awk}.
Jeżeli nie zamkniemy plików, możemy ostatecznie wyczerpać systemowy limit
plików otwartych w jednym procesie.  Zatem zamknij każdy z nich gdy
skończysz do niego pisać.

@item
Do zakończenia polecenia.  Przy przekierowaniu wyjścia przez potok polecenie
czytające z potoku normalnie kontynuuje próby czytania wejścia tak długo,
jak długo potok jest otwarty.  Często znaczy to, że polecenie nie może
faktycznie wykonać swojego zadania póki potok nie zostanie zamknięty.
Na przykład, jeśli przekierujemy wyjście do programu @code{mail},
komunikat nie jest faktycznie wysyłany aż do zamknięcia potoku.

@c NEEDED
@page
@item
Do uruchomienia tego samego programu po raz drugi, z tymi samymi
argumentami.  To nie jest to samo, co podanie kolejnych danych
wejściu pierwszego uruchomienia!

Na przykład, załóżmy, że potokujemy wyjście do programu @code{mail}.
Jeśli wypiszemy kilka wierszy przekierowanych do tego potoku bez jego
zamykania, utworzą pojedynczą wiadomość z kilku wierszy.  Natomiast jeśli
zamkniemy potok po każdym wierszu wyjścia, to każdy wiersz będzie tworzył
odrębną wiadomość.
@end itemize

@vindex ERRNO
@cindex różnice między @code{gawk} a @code{awk}
@code{close} zwraca wartość zerową jeśli zamknięcie się powiodło.
W przeciwnym razie wartość jest niezerowa.  W tym przypadku @code{gawk}
przypisuje zmiennej @code{ERRNO} łańcuch opisujący błąd, jaki wystąpił.

@cindex różnice między @code{gawk} a @code{awk}
@cindex przenośność
Jeśli używamy więcej plików niż system pozwala na posiadanie otwartych,
@code{gawk} będzie usiłował multipleksować dostępne otwarte pliki
między nasze pliki danych.  Jego zdolność do wykonania tego zadania zależy
od udogodnień systemu operacyjnego: może nie zawsze działać.  Z tego powodu
dobra praktyka i dobra przenośność doradzają, by zawsze stosować
@code{close} w stosunku do plików, z którymi skończono pracę.

@node Wyrażenia, Wzorce i akcje, Wypisywanie, Top
@chapter Wyrażenia
@cindex wyrażenie

Wyrażenia są podstawowymi elementami konstrukcyjnymi wzorców i akcji
@code{awk}.  Wyrażenie rozwija się w wartość, którą można wypisać,
porównywać, przechować w zmiennej czy przesłać do funkcji.  Dodatkowo,
wyrażenie, za pomocą operatora przypisania, może przypisać nową wartość
zmiennej lub polu.

Wyrażenie może służyć jako samodzielny wzorzec lub instrukcja akcji.
Większość pozostałych rodzajów instrukcji zawiera jedno lub więcej wyrażeń,
określających dane na których mają działać.  Jak w innych językach,
wyrażenia w @code{awk} zawierają zmienne, odwołania do tablic, stałe
i wywołania funkcji, jak również ich kombinacje z rozmaitymi operatorami.

@menu
* Stałe::                       Stałe łańcuchowe, numeryczne i regexp.
* Używanie stałych regexp::     Kiedy i stosować stałe regexp.
* Zmienne::                     Zmienne dają nazwy wartościom do późniejszego
* Konwersja::                   Przekształcanie łańcuchów na liczby
                                i odwrotnie.
* Operatory arytmetyczne::      Operacje arytmetyczne (@samp{+}, @samp{-}, itd.)
* Konkatenacja::                Sklejanie łańcuchów.
* Operatory przypisania::       Zmienianie wartości zmiennej lub pola.
* Operatory inkrementacji::     Zwiększanie numerycznej wartości zmiennej.
* Wartości prawdy::             Co jest ``prawdziwe'' a co ``fałszywe''.
* Typy i porównania::           Jak zmienne otrzymują typy. Jak to wpływa na
                                porównania liczb i łańcuchów przez @samp{<},
                                itd.
* Operatory logiczne::          Łącznie wyrażeń porównania za pomocą
                                operatorów logicznych @samp{||} (``or''),
                                @samp{&&} (``and'') i @samp{!} (``not'').
* Wyrażenia warunkowe::         Wyrażenia warunkowe wybierają między dwoma
                                podwyrażeniami pod kontrolą trzeciego.
* Wywołania funkcji::           Wywołanie funkcji jest wyrażeniem.
* Priorytet::                   Jak łączą się różne operatory.
@end menu

@node Stałe, Używanie stałych regexp, Wyrażenia, Wyrażenia
@section Wyrażenia stałe
@cindex stałe, typy
@cindex stałe łańcuchowe
@cindex łańcuchy, stałe

Najprostszym rodzajem wyrażenia jest  @dfn{stała}, która ma zawsze tę samą
wartość.  Są trzy typy stałych: stałe numeryczne (liczbowe), stałe
łańcuchowe i stałe wyrażenia regularne.

@menu
* Stałe skalarne::              Stałe numeryczne i łańcuchowe.
* Stałe regexp::                Wyrażenia regularne stałe.
@end menu

@node Stałe skalarne, Stałe regexp, Stałe, Stałe
@subsection Stałe numeryczne i łańcuchowe

@cindex stała numeryczna
@cindex wartość numeryczna
@dfn{Stała numeryczna} oznacza liczbę.  Może to być liczba całkowita,
ułamek dziesiętny lub liczba w notacji naukowej
(wykładniczej).@footnote{Wewnętrzna reprezentacja stosuje liczby
zmiennoprzecinkowe o podwójnej precyzji.  Nie przejmuj się jeżeli nie wiesz,
co to znaczy.} Oto kilka przykładów stałych numerycznych, wszystkich
o tej samej wartości:

@example
105
1.05e+2
1050e-1
@end example

Stała łańcuchowa składa się z ciągu znaków ujętego w cudzysłowy.
Na przykład:

@example
"papuga"
@end example

@noindent
@cindex różnica między @code{gawk} a @code{awk}
reprezentuje łańcuch, którego zawartością jest @samp{papuga}.  Łańcuchy
w @code{gawk} mogą mieć dowolną długość i mogą zawierać dowolny z możliwych
ośmiobitowych znaków ASCII, łącznie z ASCII NUL (znak o kodzie zero).
Inne implementacje @code{awk} mogą mieć pewne trudności z niektórymi kodami
znaków.

@node Stałe regexp,  , Stałe skalarne, Stałe
@subsection Stałe regexp

@cindex @code{~} operator
@cindex @code{!~} operator
Stałe wyrażenie regularne (stała regexp) jest opisem wyrażenia regularnego
ujętym między ukośniki, jak @code{@w{/^początek i koniec$/}}.  Większość
wyrażeń regularnych wykorzystywanych w programach @code{awk} jest stałymi,
ale operatory dopasowania @samp{~} i @samp{!~} mogą też dopasowywać
wyliczane lub ``dynamiczne'' wyrażenia regularne (które są po prostu
zwykłymi łańcuchami czy zmiennymi, zawierającymi wyrażenie regularne).

@node Używanie stałych regexp, Zmienne, Stałe, Wyrażenia
@section Używanie stałych regexp

Użyte po prawej stronie operatorów @samp{~} lub @samp{!~} wyrażenie regularne
stałe oznacza po prostu wyrażenie regularne jakie ma zostać dopasowane.

@cindex ciemny kąt
Stałe wyrażenia regularne (jak @code{/foo/}) mogą być stosowane jako
wyrażenia proste.
Gdy pojawia się samo wyrażenie regularne stałe, ma ono to samo znaczenie
jakby pojawiło się we wzorcu, tj.@: @samp{($0 ~ /foo/)}
(c.k.)
(@pxref{Wyrażenia wzorcami, ,Wyrażenia jako wzorce}).
Oznacza to, że te dwa fragmenty kodu,

@example
if ($0 ~ /barfly/ || $0 ~ /camelot/)
    print "znaleziono"
@end example

@noindent
i

@example
if (/barfly/ || /camelot/)
    print "znaleziono"
@end example

@noindent
są dokładnie równoważne.

Pewną dość dziwaczną konsekwencją tej zasady jest to, że poniższe wyrażenie
logiczne jest poprawne, choć nie robi tego, co prawdopodobnie miał na myśli
użytkownik:

@example
# zauważ, że /foo/ jest po lewej stronie ~
if (/foo/ ~ $1) print "znaleziono foo"
@end example

@noindent
Ten kod ``oczywiście'' sprawdza, czy @code{$1} pasuje do wyrażenia
regularnego @code{/foo/}.  W rzeczywistości jednak, wyrażenie
@samp{/foo/ ~ $1} oznacza faktycznie @samp{($0 ~ /foo/) ~ $1}.
Inaczej mówiąc, najpierw dopasowuje rekord wejściowy do wyrażenia regularnego
@code{/foo/}.  Wynikiem będzie albo zero albo jeden, zależnie od powodzenia
lub porażki dopasowania.  Następnie zostanie wykonane dopasowanie tego wyniku
do pierwszego pola rekordu.

Ponieważ jest mało prawdopodobne, byśmy kiedykolwiek chcieli robić taki
rodzaj sprawdzenia, @code{gawk} wyśle ostrzeżenie widząc taką konstrukcję
w programie.

Inną konsekwencją omawianej zasady jest to, że instrukcja przypisania

@example
pasuje = /foo/
@end example

@noindent
nada zmiennej @code{pasuje} wartość zero albo jeden, zależnie od zawartości
bieżącego rekordu wejściowego.

Ta cecha języka nie była nigdy dobrze udokumentowana aż do specyfikacji POSIX.

@cindex różnice między @code{gawk} a @code{awk}
@cindex ciemny kąt
Wyrażenia regularne stałe są też wykorzystywane jako pierwszy argument funkcji
@code{gensub}, @code{sub} i @code{gsub}, i jako drugi argument
funkcji @code{match}
(@pxref{Funkcje łańcuchowe, ,Funkcje wbudowane działające na łańcuchach}).
Współczesne implementacje @code{awk}, łącznie z @code{gawk}, pozwalają, by
trzecim argumentem @code{split} było stałe wyrażenie regularne, podczas gdy
niektóre starsze implementacje na to nie pozwalają (c.k.).

Próba użycia stałego wyrażenia regularnego jako argumentu funkcji
zdefiniowanej przez użytkownika może prowadzić do zamieszania.
(@pxref{Użytkownika, ,Funkcje użytkownika}).
Na przykład:

@example
@group
function mysub(pat, repl, str, global)
@{
    if (global)
        gsub(pat, repl, str)
    else
        sub(pat, repl, str)
    return str
@}
@end group

@group
@{
    @dots{}
    tekst = "cześć! cześć do siebie!"
    mysub(/cześć/, "sie ma", tekst, 1)
    @dots{}
@}
@end group
@end example

W tym przykładzie programista chce przekazać stałe wyrażenie regularne
do funkcji użytkownika @code{mysub}, która z kolei prześle je @code{sub}
lub @code{gsub}. Jednak faktycznie parametr @code{pat} będzie albo jedynką
albo zerem, w zależności od tego czy @code{$0} pasuje do @code{/cześć/}
czy nie.

Ponieważ to nieprawdopodobne, byśmy kiedykolwiek chcieli przekazać wartość
prawdy w ten sposób, @code{gawk} widząc stałe wyrażenie regularne użyte jako
parametr funkcji użytkownika wyśle ostrzeżenia.

@node Zmienne, Konwersja, Używanie stałych regexp, Wyrażenia
@section Zmienne

Zmienne stanowią metodę przechowywania wartości w pewnym punkcie programu
do późniejszego użytku w innym miejscu programu.  Można nimi manipulować
wewnątrz całego tekstu programu, można im też przypisać wartości w wierszu
poleceń @code{awk}.

@menu
* Używanie zmiennych::          Stosowanie zmiennych we własnych programach.
* Opcje przypisywania::         Nadawanie wartości zmiennym w wierszu
                                poleceń. Podsumowanie składni wiersza
                                poleceń. To zaawansowana metoda wprowadzania.
@end menu

@node Używanie zmiennych, Opcje przypisywania, Zmienne, Zmienne
@subsection Używanie zmiennych w programie

@cindex zmienne, definiowane przez użytkownika
Zmienne umożliwiają nadanie nazw wartościom i późniejsze się do nich
odwoływanie.  Widzieliśmy je już w wielu przykładach.  Nazwa zmiennej musi
być ciągiem liter, cyfr i znaków podkreślenia, ale nie może zaczynać się
od cyfry.  W nazwach zmiennych wielkość liter jest znacząca:  @code{a}
i @code{A} to różne zmienne.

Sama nazwa zmiennej jest poprawnym wyrażeniem.  Reprezentuje aktualną wartość
zmiennej.  Nowa wartości nadawane są zmiennym za pomocą @dfn{operatorów
przypisania}, @dfn{operatorów inkrementacji} i @dfn{operatorów dekrementacji}.
@xref{Operatory przypisania, ,Wyrażenia przypisania}.

Kilka zmiennych ma specjalne, wbudowane znaczenie, tak jak @code{FS}, separator
pól, czy @code{NF}, liczba pól w bieżącym rekordzie wejściowym.
@xref{Zmienne wbudowane}, gdzie podano ich listę.  Zmienne wbudowane mogą być
używane jak wszystkie inne zmienne, i jak innym zmiennym można im przypisywać
wartości.  Jednak wartości tych zmiennych są także wykorzystywane i zmieniane
automatycznie przez @code{awk}.  Nazwy wszystkich zmiennych wbudowanych są
w całości zbudowane z dużych liter.

Zmiennym można przypisywać wartości numeryczne lub łańcuchowe.
Domyślnie, zmienne inicjowane są łańcuchem pustym, który po konwersji
na liczbę jest zerem.  W @code{awk} nie ma potrzeby jawnego ``inicjowania''
każdej ze zmiennych, w sposób, jaki robi się to w C i większości innych
tradycyjnych języków.

@node Opcje przypisywania,  , Używanie zmiennych, Zmienne
@subsection Przypisywanie zmiennych w wierszu poleceń

Zmiennej można nadać wartość dołączając przy wywoływaniu @code{awk}
@dfn{przypisanie zmiennej} do argumentów wiersza poleceń.
(@pxref{Inne argumenty, ,Inne argumenty wiersza poleceń}).  Takie przypisanie
ma następującą postać:

@example
@var{zmienna}=@var{tekst}
@end example

@noindent
W ten sposób można nadać wartość zmiennej albo na początku pracy @code{awk}
albo pomiędzy plikami wejściowymi.

Przypisanie można poprzedzić opcją @samp{-v}, w ten sposób:

@example
-v @var{zmienna}=@var{tekst}
@end example

@noindent
wówczas zmienna ma nadawaną wartość na samym początku, nawet przed
wykonaniem reguł @code{BEGIN}.  Opcja @samp{-v} i jej przypisanie muszą
poprzedzać zarówno wszystkie argumenty podające nazwy plików jak i tekst
programu.
(@xref{Opcje, ,Opcje wiersza poleceń}, gdzie jest więcej o opcji
@samp{-v}.)

W przeciwnym razie, przypisanie do zmiennej wykonywane jest w momencie
określonym jego pozycją wśród argumentów plików wejściowych: po przetworzeniu
pliku wejściowego będącego poprzednim argumentem.  Na przykład:

@example
awk '@{ print $n @}' n=4 inventory-shipped n=2 BBS-list
@end example

@noindent
wypisuje wartość pola numer @code{n} dla wszystkich rekordów wejściowych.
Przed odczytem pierwszego pliku wiersz poleceń nadaje zmiennej @code{n}
wartość cztery.  Powoduje to, że z każdego wiersza pliku
@file{inventory-shipped} wypisane będzie czwarte pole.  Po zakończeniu
pierwszego pliku, ale przed rozpoczęciem drugiego, @code{n} jest przypisywane
dwa, więc z wierszy @file{BBS-list} jest wypisywane drugie pole.

@example
@group
$ awk '@{ print $n @}' n=4 inventory-shipped n=2 BBS-list
@print{} 15
@print{} 24
@dots{}
@print{} 555-5553
@print{} 555-3412
@dots{}
@end group
@end example

Argumenty wiersza poleceń są w tablicy o nazwie @code{ARGV} udostępniane
programowi @code{awk} do bezpośredniego zbadania
(@pxref{ARGC i ARGV, ,Używanie @code{ARGC} i @code{ARGV}}).

@cindex ciemny kąt
@code{awk} przetwarza wartości przypisań z wiersza poleceń wykorzystując
sekwencje specjalne (c.k.) (@pxref{Sekwencje specjalne}).

@node Konwersja, Operatory arytmetyczne, Zmienne, Wyrażenia
@section Konwersja łańcuchów i liczb

@cindex konwersja łańcuchów i liczb
Jeżeli kontekst programu @code{awk} tego wymaga, łańcuchy są przekształcane
na liczby, a liczby na łańcuchy.  Na przykład, jeżeli okaże się, że
w wyrażeniu @samp{foo + bar} wartość @samp{foo} lub @samp{bar} jest łańcuchem,
to przed wykonaniem dodawania będzie ona konwertowana na liczbę.  Jeśli
w konkatenacji łańcuchów pojawią się liczby, to zostaną przekształcone
na łańcuchy.  Rozważmy poniższe:

@example
dwa = 2; trzy = 3
print (dwa trzy) + 4
@end example

@noindent
Wypisze to wartość (numeryczną) 27.  Liczbowe wartości zmiennych @code{dwa}
i @code{trzy} są przekształcane na łańcuchy i sklejane, a łańcuch wynikowy
przekształcany z powrotem na liczbę (23), do której jest następnie dodawane
cztery.

@cindex łańcuch pusty
@cindex łańcuch zerowy
@cindex konwersja typów
Jeżeli z jakiegoś powodu trzeba wymusić konwersję liczby na łańcuch,
sklejamy z nią pusty łańcuch, @code{""}.  W celu wymuszenia konwersji łańcucha
na liczbę, dodajemy do niego zero.

Łańcuch jest przekształcany na liczbę przez interpretację jego ewentualnego
numerycznego przedrostka jako liczby:
@code{"2.5"} konwertowane jest na 2.5, @code{"1e3"} na 1000, a @code{"25fix"}
ma numeryczną wartość 25.
Łańcuchy, których nie mogą być zinterpretowane jako poprawne liczby są
konwertowane na zero.

@vindex CONVFMT
Dokładny sposób, w jaki liczby przekształcane są na łańcuchy zależy od
zmiennej wbudowanej @code{awk} o nazwie @code{CONVFMT}
(@pxref{Zmienne wbudowane}).
Liczby konwertowane są za pomocą funkcji @code{sprintf}
(@pxref{Funkcje łańcuchowe, ,Funkcje wbudowane działające na łańcuchach})
z @code{CONVFMT} jako specyfikatorem formatu.

Domyślną wartością @code{CONVFMT} jest @code{"%.6g"}, co wypisuje wartość
z co najmniej sześcioma cyframi znaczącymi.  W niektórych zastosowaniach
zechcemy ją zmienić, by określić większą dokładność.  Na większości
współczesnych maszyn trzeba wypisać 17 cyfr by uchwycić dokładnie wartość
liczby podwójnej precyzji.

Jeżeli @code{CONVFMT} przypiszemy łańcuch nie mówiący @code{sprintf} jak
w użyteczny sposób sformatować liczby zmiennoprzecinkowe, to mogą pojawić
się dziwne wyniki.  Na przykład, jeżeli zapomnimy znaku @samp{%} w formacie,
to wszystkie liczby będą konwertowane na ten sam stały łańcuch.

@cindex ciemny kąt
Jako przypadek szczególny, jeśli liczba jest całkowitą, to wynik jej
przekształcenia na łańcuch jest @emph{zawsze} całkowitą, bez względu na to,
jaka jest wartość @code{CONVFMT}.  Przy poniższym fragmencie kodu:

@example
CONVFMT = "%2.2f"
a = 12
b = a ""
@end example

@noindent
@code{b} ma wartość @code{"12"}, nie @code{"12.00"} (c.k.).

@cindex język @code{awk}, wersja POSIX
@cindex POSIX @code{awk}
@vindex OFMT
Przed standardem POSIX, @code{awk} podawał, że do konwersji liczb na łańcuchy
jest wykorzystywana wartość @code{OFMT}.  @code{OFMT} określa format wyjściowy
stosowany przy wypisywaniu liczb za pomocą @code{print}.
W celu oddzielenia semantyki konwersji od semantyki wypisywania wprowadzono
zmienną @code{CONVFMT}.  @code{CONVFMT} i @code{OFMT} mają tę samą wartość
domyślną: @code{"%.6g"}.  W ogromnej większości przypadków stare programy
@code{awk} nie zmienią swego zachowania.
Jednak takie zastosowanie @code{OFMT} jest czymś, o czym warto pamiętać, jeśli
chcemy przenosić programy na inne implementacje @code{awk}.  Zalecamy, by
zamiast zmieniać własne programy, po prostu przenieść sam @code{gawk}!
@xref{Print, ,Instrukcja @code{print}},
gdzie jest więcej o instrukcji @code{print}.

@node Operatory arytmetyczne, Konkatenacja, Konwersja, Wyrażenia
@section Operatory arytmetyczne
@cindex operatory arytmetyczne
@cindex arytmetyczne, operatory
@cindex dodawanie
@cindex odejmowanie
@cindex mnożenie
@cindex dzielenie
@cindex reszta z dzielenia
@cindex iloraz
@cindex potęgowanie

Język @code{awk} przy obliczaniu wyrażeń stosuje standardowe operatory
arytmetyczne.  Wszystkie z nich podlegają normalnym regułom priorytetu
i działają tak, jak jakbyśmy tego oczekiwali.
Operacje arytmetyczne wykonywane są z wykorzystaniem zmiennopozycyjnej
podwójnej precyzji, co rodzi zwykłe kłopoty z niedokładnością
i wyjątkami.@footnote{David Goldberg,
@uref{http://www.validgh.com/goldberg/paper.ps, @cite{What Every Computer Scientist Should Know About Floating-point Arithmetic}},
@cite{ACM Computing Surveys} @strong{23}, 1 (1991-03), 5-48.}

Oto plik @file{grades} zawierający listę nazw studentów i ich wyniki z trzech
testów (to mała klasa):

@example
Pat   100 97 58
Sandy  84 72 93
Chris  72 92 89
@end example

@noindent
Ten program bierze plik @file{grades} i wypisuje średnią punktów.

@example
$ awk '@{ sum = $2 + $3 + $4 ; avg = sum / 3
>        print $1, avg @}' grades
@print{} Pat 85
@print{} Sandy 83
@print{} Chris 84.3333
@end example

Poniższa tabela wyszczególnia operatory arytmetyczne w języku @code{awk},
od najwyższego do najniższego priorytetu:

@c @cartouche
@table @code
@item - @var{x}
Negacja.

@item + @var{x}
Jednoargumentowy plus.  Wyrażenie jest konwertowane na liczbę.

@cindex język @code{awk}, wersja POSIX
@cindex POSIX @code{awk}
@item @var{x} ^ @var{y}
@itemx @var{x} ** @var{y}
Potęgowanie: @var{x} podniesione do potęgi @var{y}.  @samp{2 ^ 3} ma wartość
osiem.  Ciąg znaków @samp{**} jest równoważny @samp{^}.  (Standard POSIX
dla potęgowania podaje tylko używanie @samp{^}.)

@item @var{x} * @var{y}
Mnożenie.

@item @var{x} / @var{y}
Dzielenie.  Ponieważ wszystkie liczby w @code{awk} są liczbami
zmiennoprzecinkowymi,
wynik nie jest zaokrąglany do całkowitej: @samp{3 / 4} ma wartość 0.75.

@item @var{x} % @var{y}
@cindex różnice między @code{gawk} a @code{awk}
Reszta z dzielenia.  Iloraz jest zaokrąglany w dół do całkowitej, mnożony
przez @var{y} i ten wynik jest odejmowany od @var{x}.  Operacja ta jest czasem
nazywana ``obcięcie-modulo''.  Poniższa relacja jest zawsze zachowana:

@example
b * int(a / b) + (a % b) == a
@end example

Pewnym, być może niepożądanym, efektem tej definicji reszty z dzielenia jest
to, że @code{@var{x} % @var{y}} jest ujemne jeśli @var{x} jest ujemne.  Zatem,

@example
-17 % 8 = -1
@end example

W innych implementacjach @code{awk}, uzyskiwany znak reszty z dzielenia może
być zależny od architektury komputera.
@c !!! what does posix say?

@item @var{x} + @var{y}
Dodawanie.

@item @var{x} - @var{y}
Odejmowanie.
@end table
@c @end cartouche

W celu zachowania maksymalnej przenośności, nie należy stosować
operatora @samp{**}.

Jednoargumentowy plus i minus mają ten sam priorytet, operatory multiplikatywne
mają wszystkie ten sam priorytet, dodawanie i odejmowanie mają ten sam
priorytet.

@node Konkatenacja, Operatory przypisania, Operatory arytmetyczne, Wyrażenia
@section Konkatenacja łańcuchów
@cindex Kernighan, Brian
@display
@i{Wtedy wyglądało to na dobry pomysł.}
Brian Kernighan
@end display
@sp 1

@cindex operatory łańcuchowe
@cindex łańcuchy, operatory
@cindex konkatenacja
Istnieje tylko jedna operacja łańcuchowa: konkatenacja (złączenie).
Nie ma ona żadnego konkretnego operatora, który by ją reprezentował.
Zamiast tego, sklejanie łańcuchów wykonywane jest przez zapisanie jednego
wyrażenia obok drugiego, bez żadnego operatora.  Na przykład:

@example
@group
$ awk '@{ print "Pole numer jeden: " $1 @}' BBS-list
@print{} Pole numer jeden: aardvark
@print{} Pole numer jeden: alpo-net
@dots{}
@end group
@end example

Bez spacji po @samp{:} w stałej łańcuchowej, składowe wiersza nie
byłyby rozdzielone.  Na przykład:

@example
@group
$ awk '@{ print "Pole numer jeden::" $1 @}' BBS-list
@print{} Pole numer jeden::aardvark
@print{} Pole numer jeden::alpo-net
@dots{}
@end group
@end example

Ponieważ konkatenacja łańcuchów nie ma jawnego operatora, często konieczne
jest upewnienie się, że dzieje się to czego chcemy.  Można je uzyskać
otaczając złączane elementy nawiasami.  Na przykład, poniższy fragment kodu
nie zlepia @code{file} i @code{name} jak moglibyśmy się spodziewać:

@example
@group
file = "file"
name = "name"
print "coś istotnego" > file name
@end group
@end example

@noindent
Konieczne jest wykorzystanie poniższego:

@example
print "coś istotnego" > (file name)
@end example

Zalecamy użycie nawiasów wokół konkatenacji we wszystkich kontekstach
oprócz najpowszechniejszych (jak po prawej stronie @samp{=}).

@node Operatory przypisania, Operatory inkrementacji, Konkatenacja, Wyrażenia
@section Wyrażenia przypisania
@cindex operatory przypisania
@cindex przypisanie, operatory
@cindex wyrażenie, przypisanie

@dfn{Przypisanie} jest wyrażeniem, które zapisuje w zmiennej nową wartość.
Na przykład, przypiszmy zmiennej @code{z} wartość jeden:

@example
z = 1
@end example

Po wykonaniu tego wyrażenia zmienna @code{z} ma wartość jeden.  Jakakolwiek
była stara wartość zmiennej @code{z} przed przypisaniem, jest ona
zapominana.

Przypisania składują też wartości łańcuchowe.
Na przykład to zapamięta wartość @code{"this food is good"} w zmiennej
@code{message}:

@example
thing = "food"
predicate = "good"
message = "this " thing " is " predicate
@end example

@noindent
(Ilustruje to również konkatenację łańcuchów.)

Znak @samp{=} nazywamy @dfn{operatorem przypisania}.  Jest to najprostszy
operator przypisania, gdyż wartość operandu po prawej stronie jest
składowana bez zmian.

@cindex skutek uboczny
Większość operatorów (dodawanie, konkatenacja, i tak dalej) nie daje żadnych
skutków poza obliczeniem wartości.  Jeżeli zignorujemy tę wartość, to równie
dobrze moglibyśmy nie stosować operatora.  Operator przypisania jest inny:
tworzy wartość, lecz nawet  jeśli ją ignorujemy, to przypisanie nadal
daje znać o sobie zmieniając zawartość zmiennej.
Nazywamy to @dfn{skutkiem ubocznym}.

@cindex lwartość
@cindex rwartość
Lewostronny operand przypisania nie musi być zmienną
(@pxref{Zmienne}); może być również polem
(@pxref{Zmiana pól, ,Zmiana zawartości pól}) lub
elementem tablicy (@pxref{Tablice, ,Tablice w @code{awk}}).
Wszystkie one zwane są @dfn{lwartościami}, co znaczy że mogą pojawić się po
lewej stronie operatora przypisania.
Operand prawostronny może być dowolnym wyrażeniem.  Tworzy ono nową wartość,
którą przypisanie zapamiętuje w zadanej zmiennej, polu czy elemencie
tablicy.  (Wartości takie są zwane @dfn{rwartościami},
od ang.``right-hand'', prawostronny.)

@cindex typy zmiennych
Należy pamiętać, że zmienne @emph{nie} mają stałego typu.
Typ zmiennej jest po prostu typem wartości, jaką ona w danej chwili akurat
przechowuje.  W poniższym fragmencie programu zmienna @code{foo} ma
najpierw wartość numeryczną, a potem łańcuchową:

@example
@group
foo = 1
print foo
foo = "bar"
print foo
@end group
@end example

@noindent
W chwili, gdy drugie przypisanie nadaje @code{foo} wartość łańcuchową,
to, że uprzednio miała ona wartość numeryczną jest zapominane.

Wartości łańcuchowe nierozpoczynające się cyfrą mają numeryczną wartość
zero.  Po wykonaniu tego kodu, wartością @code{foo} jest pięć:

@example
foo = "a string"
foo = foo + 5
@end example

@noindent
(Zwróć uwagę, że używanie zmiennej jako liczby a później jako łańcucha
jest mylące i świadczy o kiepskim stylu programowania.  Powyższe przykłady
pokazują jak działa @code{awk}, a @emph{nie} jak powinno się pisać
programy!)

Przypisanie jest wyrażeniem, zatem posiada wartość: tę samą wartość, która
jest przypisywana.  Stąd też, @samp{z = 1} jako wyrażenie ma wartość
jeden.  Skutkiem tego jest fakt, że można zapisać razem kilka przypisań:

@example
x = y = z = 0
@end example

@noindent
zapamiętuje wartość zero we wszystkich trzech zmiennych.  Dzieje się tak
dlatego, że wartość @samp{z = 0}, która jest zerem, jest zapamiętywana
w @code{y}, a następnie wartość @samp{y = z = 0}, która jest zerem,
zapamiętywana jest w @code{x}.

Przypisania można użyć w każdym miejscu, gdzie oczekiwane jest wyrażenie.
Na przykład, poprawne jest napisanie @samp{x != (y = 1)} w celu nadania
@code{y} wartości jeden i sprawdzenia czy @code{x} jest równe jeden.
Ten styl prowadzi jednak do tego, że programy są trudne do czytania.
Nie powinno się używać takich zagnieżdżonych przypisań, poza programami
do jednorazowego wykorzystania.

Oprócz @samp{=}, istnieje kilka innych operatorów przypisania,
wykonujących działania arytmetyczne na starej wartości zmiennej.
Na przykład, operator @samp{+=} oblicza nową wartość przez dodanie
prawostronnej wartości do starej wartości zmiennej.  Poniższe przypisanie,
zatem, dodaje pięć do wartości @code{foo}:

@example
foo += 5
@end example

@noindent
Jest to równoważne poniższemu:

@example
foo = foo + 5
@end example

@noindent
Stosujemy to rozwiązanie, przy którym sens programu jest klarowniejszy.

Istnieją sytuacje, w których stosowanie @samp{+=} (lub innego operatora
przypisania) @emph{nie} jest tym samym, co zwykłe powtórzenie lewego
operandu w wyrażeniu prawostronnym.  Na przykład:

@cindex Rankin, Pat
@example
@group
# Dzięki Pat Rankin za przykład
BEGIN  @{
    foo[rand()] += 5
    for (x in foo)
       print x, foo[x]

    bar[rand()] = bar[rand()] + 5
    for (x in bar)
       print x, bar[x]
@}
@end group
@end example

@noindent
Indeksy @code{bar} są na pewno różne, ponieważ @code{rand} zwróci różne
wartości przy każdym jej wywołaniu.  (Tablice i funkcja @code{rand}
nie były jeszcze omawiane.  @xref{Tablice, ,Tablice w @code{awk}}, i
zobacz @ref{Funkcje numeryczne, ,Wbudowane funkcje numeryczne}).  Ten przykład
ilustruje ważny fakt dotyczący operatorów przypisania:  lewostronne
wyrażenie jest wyliczane tylko @emph{raz}.

To, czy obliczane jest najpierw wyrażenie lewostronne czy też prawostronne,
zależy od implementacji.  Rozważmy przykład:

@example
i = 1
a[i += 2] = i + 1
@end example

@noindent
Wartością @code{a[3]} może być albo dwa albo cztery.

Oto tabela operatorów przypisania arytmetycznego.  W każdym przypadku
prawostronny operand jest wyrażeniem, którego wartość jest przekształcana
na liczbę:

@c @cartouche
@table @code
@item @var{lwartość} += @var{inkrement}
Dodaje @var{inkrement} do wartości @var{lwartości} tworząc nową wartość
@var{lwartości}.

@item @var{lwartość} -= @var{dekrement}
Odejmuje @var{dekrement} od wartości @var{lwartości}.

@item @var{lwartość} *= @var{współczynnik}
Mnoży wartość @var{lwartości} przez @var{współczynnik}.

@item @var{lwartość} /= @var{dzielnik}
Dzieli wartość @var{lwartości} przez @var{dzielnik}.

@item @var{lwartość} %= @var{współczynnik}
Przypisuje @var{lwartości} resztę z dzielenia jej przez @var{współczynnik}.

@cindex język @code{awk}, wersja POSIX
@cindex POSIX @code{awk}
@item @var{lwartość} ^= @var{potęga}
@itemx @var{lwartość} **= @var{potęga}
Podnosi @var{lwartość} do potęgi @var{potęga}.
(POSIX podaje tylko operator @samp{^=}.)
@end table
@c @end cartouche

W celu zachowania maksymalnej przenośności nie należy stosować
operatora @samp{**=}.

@node Operatory inkrementacji, Wartości prawdy, Operatory przypisania, Wyrażenia
@section Operatory inkrementacji i dekrementacji

@cindex operatory, inkrementacja
@cindex inkrementacja, operator
@dfn{Operatory inkrementacji} i @dfn{dekrementacji} powiększają lub
pomniejszają wartość zmiennej o jeden.  Można zrobić to samo wykorzystując
operator przypisania, więc operatory inkrementacji nie dodają językowi
@code{awk} żadnej dodatkowej zdolności.  Są jednak wygodnymi skrótami dla
bardzo typowych operacji.

Operator dodający jeden zapisujemy @samp{++}.  Może służyć do powiększania
wartości zmiennej zarówno przed jak i po pobraniu jej wartości.

Powiększenie wartości zmiennej @var{v} przed zwróceniem wyniku
(pre-inkrementację) zapisujemy @samp{++@var{v}}.  Dodaje to jeden do
wartości @var{v} i ta nowa wartość jest równocześnie wartością wyrażenia.
Przypisanie @samp{@var{v} += 1} jest całkowicie równoważne.

Zapis @samp{++} po zmiennej określa post-inkrementację.  Powiększa ona tak
samo wartość zmiennej; różnicą jest to, że wartością samego wyrażenia
inkrementacji jest @emph{stara} wartość zmiennej.
Zatem, jeśli @code{foo} ma wartość cztery, to wyrażenie @samp{foo++} ma
wartość cztery, ale zmienia ono wartość @code{foo} na pięć.

Post-inkrementacja @samp{foo++} jest prawie równoważna zapisowi
@samp{(foo += 1) - 1}.  Nie jest dokładnie równoważna, gdyż wszystkie
liczby w @code{awk} są zmiennoprzecinkowe: w arytmetyce zmiennoprzecinkowej
@samp{foo + 1 - 1} niekoniecznie równa się @code{foo}.  Różnica jest jednak
znikoma dopóki ograniczamy się do liczb, które są dość małe (mniejsze
niż 10e12).

Inkrementowana może być dowolna lwartość.  Pola i elementy tablic są
inkrementowane tak samo jak zmienne.  (Jeżeli chcemy równocześnie odwołać
się do pola i powiększyć zmienną, możemy zastosować @samp{$(i++)}.  Nawiasy
są niezbędne z powodu priorytetu operatora wskazania pola, @samp{$}.)

@cindex operatory dekrementacji
@cindex dekrementacja, operatory
Operator dekrementacji @samp{--} działa tak samo jak @samp{++}, z wyjątkiem
tego, że odejmuje jeden zamiast dodawać.  Podobnie jak @samp{++}, może być
stosowany przed lwartością do pre-dekrementacji lub po niej do
post-dekrementacji.

A oto podsumowanie wyrażeń inkrementacji i dekrementacji.

@c @cartouche
@table @code
@item ++@var{lwartość}
To wyrażenie inkrementuje @var{lwartość} a nowa wartość staje się wartością
wyrażenia.

@item @var{lwartość}++
To wyrażenie inkrementuje @var{lwartość}, lecz wartością wyrażenia jest
@emph{stara} wartość @var{lwartości}.

@item --@var{lwartość}
Podobne do @samp{++@var{lwartość}}, ale zamiast dodawania, odejmuje.
Dekrementuje @var{lwartość} i jako wynik dostarcza uzyskaną wartość.

@item @var{lwartość}--
Podobne do @samp{@var{lwartość}++}, ale zamiast dodawania, odejmuje.
Dekrementuje @var{lwartość}.  Wartością wyrażenia jest @emph{stara}
wartość @var{lwartości}.
@end table
@c @end cartouche

@node Wartości prawdy, Typy i porównania, Operatory inkrementacji, Wyrażenia
@section Prawda i fałsz w @code{awk}
@cindex wartości prawdziwe
@cindex logiczna prawda
@cindex logiczny fałsz

Wiele języków programowania ma specjalną reprezentację pojęć ``prawdy''
i ``fałszu''.  Języki takie korzystają zwykle ze specjalnych stałych
@code{true} i @code{false}, lub, być może, ich równoważników pisanych dużymi
literami.

@cindex łańcuch zerowy
@cindex łańcuch pusty
@code{awk} jest inny.  Zapożycza z C bardzo prostą koncepcję wartości prawdy
i fałszu.  W @code{awk}, dowolna niezerowa wartość numeryczna, @emph{lub}
niepusty łańcuch są prawdziwe.  Każda inna wartość (zero lub łańcuch zerowej
długości, @code{""}) jest fałszywa.  Poniższy program wypisze trzykrotnie
@samp{Dziwna wartość prawdziwa}:

@example
@group
BEGIN @{
   if (3.1415927)
       print "Dziwna wartość prawdziwa"
   if ("Four Score And Seven Years Ago")
       print "Dziwna wartość prawdziwa"
   if (j = 57)
       print "Dziwna wartość prawdziwa"
@}
@end group
@end example

@cindex ciemny kąt
Zaskakująca jest konsekwencja reguły ``niezerowe lub niepuste'':
stała łańcuchowa @code{"0"} jest w rzeczywistości prawdziwa, bo jest
niepusta (c.k.).

@node Typy i porównania, Operatory logiczne, Wartości prawdy, Wyrażenia
@section Typy zmiennych i wyrażenia porównania
@cindex wyrażenia porównania
@cindex wyrażenia, porównywanie
@cindex wyrażenia, dopasowywanie
@cindex relacje, operatory
@cindex operatory relacji
@cindex operatory dopasowania/niedopasowania wyrażeń regularnych
@cindex kontrola typów zmiennych
@cindex typy zmiennych
@c 2e: consider splitting this section into subsections
@display
@i{Ten przewodnik jest rozstrzygający. Rzeczywistość często jest nieścisła.}
@c {The Guide is definitive. Reality is frequently inaccurate.}
Autostopem przez Galaktykę
@end display
@sp 1

Inaczej niż w innych językach programowania, zmienne @code{awk} nie
mają stałego typu.  Mogą, zamiast tego, być liczbą albo łańcuchem,
zależnie od wartości, jaka jest do nich przypisana.

@cindex łańcuch liczbowy
Standard POSIX z roku 1992 wprowadził pojęcie @dfn{łańcucha liczbowego},
który jest po prostu łańcuchem wyglądającym jak liczba, na przykład,
@code{@w{" +2"}}.  Pojęcie to jest wykorzystywane do wyznaczania typu
zmiennej.

Typ zmiennej jest istotny, gdyż typy dwu zmiennych decydują o sposobie,
w jaki są one porównywane.

W @code{gawk} kontrola typu zmiennej następuje według poniższych reguł.

@enumerate 1
@item
Literał numeryczny lub wynik operacji numerycznej ma atrybut @var{numeryczny}.

@item
Literał łańcuchowy lub wynik operacji łańcuchowej ma atrybut
@var{łańcuchowy}.

@item
Pola, wejście @code{getline}, @code{FILENAME}, elementy @code{ARGV},
elementy @code{ENVIRON} oraz elementy tablicy utworzonej przez @code{split},
które są łańcuchami liczbowymi mają atrybut @var{łańcucha liczbowego}
(strnum).  W przeciwnym przypadku mają atrybut @var{łańcuchowy}.
Niezainicjowane zmienne mają również atrybut @var{łańcucha liczbowego}.

@item
Atrybuty przenoszą się poprzez przypisania, ale nie są zmieniane
przez żadne użycie.
@c  (Although a use may cause the entity to acquire an additional
@c value such that it has both a numeric and string value -- this leaves the
@c attribute unchanged.)
@c This is important but not relevant
@end enumerate

Ostatnia reguła jest szczególnie ważna.  W poniższym programie, @code{a}
ma typ numeryczny, nawet mimo tego, że jest później używana w operacji
łańcuchowej.

@example
BEGIN @{
         a = 12.345
         b = a " jest ładną liczbą"
         print b
@}
@end example

Przy porównywaniu dwu argumentów może być użyte albo porównanie łańcuchowe
albo numeryczne, zależnie od ich typu.  Wykonywane jest ono zgodnie
z poniższą, symetryczną macierzą:

@c thanks to Karl Berry, kb@cs.umb.edu, for major help with TeX tables
@tex
\centerline{
\vbox{\bigskip % space above the table (about 1 linespace)
% Because we have vertical rules, we can't let TeX insert interline space
% in its usual way.
\offinterlineskip
%
% Define the table template. & separates columns, and \cr ends the
% template (and each row). # is replaced by the text of that entry on
% each row. The template for the first column breaks down like this:
%   \strut -- a way to make each line have the height and depth
%             of a normal line of type, since we turned off interline spacing.
%   \hfil -- infinite glue; has the effect of right-justifying in this case.
%   #     -- replaced by the text (for instance, `STRNUM', in the last row).
%   \quad -- about the width of an `M'. Just separates the columns.
%
% The second column (\vrule#) is what generates the vertical rule that
% spans table rows.
%
% The doubled && before the next entry means `repeat the following
% template as many times as necessary on each line' -- in our case, twice.
%
% The template itself, \quad#\hfil, left-justifies with a little space before.
%
\halign{\strut\hfil#\quad&\vrule#&&\quad#\hfil\cr
	&&STRING	&NUMERIC	&STRNUM\cr
% The \omit tells TeX to skip inserting the template for this column on
% this particular row. In this case, we only want a little extra space
% to separate the heading row from the rule below it.  the depth 2pt --
% `\vrule depth 2pt' is that little space.
\omit	&depth 2pt\cr
% This is the horizontal rule below the heading. Since it has nothing to
% do with the columns of the table, we use \noalign to get it in there.
\noalign{\hrule}
% Like above, this time a little more space.
\omit	&depth 4pt\cr
% The remaining rows have nothing special about them.
STRING	&&string	&string		&string\cr
NUMERIC	&&string	&numeric	&numeric\cr
STRNUM  &&string        &numeric        &numeric\cr
}}}
@end tex
@ifinfo
@display
	+----------------------------------------------
	|	STRING		NUMERIC		STRNUM
--------+----------------------------------------------
	|
STRING	|	string		string		string
	|
NUMERIC	|	string		numeric		numeric
	|
STRNUM	|	string		numeric		numeric
--------+----------------------------------------------
@end display
@end ifinfo

Najprościej rzecz biorąc, wejście użytkownika wyglądające na numeryczne,
i @emph{tylko} wejście, powinno być traktowane jako numeryczne, nawet jeśli
faktycznie jest zbudowane ze znaków, i z tego powodu jest też łańcuchem.

@dfn{Wyrażenia porównania} porównują łańcuchy lub liczby co do relacji
między nimi, jak np. równość.
Są one zapisywane przy użyciu @dfn{operatorów relacji}, będących
nadzbiorem analogicznych operatorów występujących w C.  Oto ich tabela:

@cindex operatory relacji
@cindex relacje, operatory
@cindex @code{<} operator
@cindex @code{<=} operator
@cindex @code{>} operator
@cindex @code{>=} operator
@cindex @code{==} operator
@cindex @code{!=} operator
@cindex @code{~} operator
@cindex @code{!~} operator
@cindex @code{in} operator
@c @cartouche
@table @code
@item @var{x} < @var{y}
Prawda jeśli @var{x} jest mniejsze od @var{y}.

@item @var{x} <= @var{y}
Prawda jeśli @var{x} jest mniejsze lub równe @var{y}.

@item @var{x} > @var{y}
Prawda jeśli @var{x} jest większe od @var{y}.

@item @var{x} >= @var{y}
Prawda jeśli @var{x} jest większe lub równe @var{y}.

@item @var{x} == @var{y}
Prawda jeśli @var{x} jest równe @var{y}.

@item @var{x} != @var{y}
Prawda jeśli @var{x} jest nie jest równe @var{y}.

@item @var{x} ~ @var{y}
Prawda jeśli łańcuch @var{x} pasuje do wyrażenia regularnego oznaczanego
przez @var{y}.

@item @var{x} !~ @var{y}
Prawda jeśli łańcuch @var{x} nie pasuje do wyrażenia regularnego oznaczanego
przez @var{y}.

@item @var{indeks} in @var{tabl}
Prawda jeśli tablica @var{tabl} posiada element o indeksie @var{indeks}.
@end table
@c @end cartouche

Wyrażenia porównania mają wartość jeden jeśli dają prawdę i zero jeśli
fałsz.

Przy porównywaniu operandów różnych typów operandy numeryczne przekształcane
są na łańcuchy przy wykorzystaniu wartości @code{CONVFMT}
(@pxref{Konwersja, ,Konwersja łańcuchów i liczb}).

Łańcuchy porównywane są przez porównanie pierwszego znaku każdego z nich,
następnie drugiego znaku w każdym i tak dalej.  Zatem @code{"10"} jest
mniejsze niż @code{"9"}.  Jeżeli mamy dwa łańcuchy, z których jeden jest
przedrostkiem drugiego, to krótszy jest mniejszy od dłuższego. Stąd też,
@code{"abc"} jest mniejsze niż @code{"abcd"}.

@cindex częste pomyłki
@cindex pomyłki, częste
@cindex błędy, częste
Bardzo łatwo jest przypadkowo błędnie napisać operator @samp{==}, i ominąć
jeden ze znaków równości @samp{=}.  Wynik jest nadal poprawnym kodem
@code{awk}, ale program nie będzie robił tego, co mieliśmy na myśli:

@example
if (a = b)   # oops! powinno być a == b
   @dots{}
else
   @dots{}
@end example

@noindent
Test @code{if} powiedzie się zawsze, chyba że @code{b} będzie akurat zerem
lub łańcuchem pustym. Ponieważ oba operatory są podobne, ten rodzaj
błędu jest bardzo trudny do zauważenia przy sprawdzaniu kodu źródłowego.

Pokażemy kilka przykładowych wyrażeń, jak @code{awk} je porównuje, i jaki
jest wynik porównania.

@table @code
@item 1.5 <= 2.0
porównanie numeryczne (prawda)

@item "abc" >= "xyz"
porównanie łańcuchowe (fałsz)

@item 1.5 != " +2"
porównanie łańcuchowe (prawda)

@item "1e2" < "3"
porównanie łańcuchowe (prawda)

@item a = 2; b = "2"
@itemx a == b
porównanie łańcuchowe (prawda)

@item a = 2; b = " +2"
@itemx a == b
porównanie łańcuchowe (fałsz)
@end table

W tym przykładzie,

@example
@group
$ echo 1e2 3 | awk '@{ print ($1 < $2) ? "prawda" : "fałsz" @}'
@print{} fałsz
@end group
@end example

@noindent
wynikiem jest @samp{fałsz}, ponieważ @code{$1} i @code{$2} są łańcuchami
liczbowymi, a zatem oba mają atrybut @var{strnum}, narzucający porównanie
numeryczne.

Celem reguł porównywania i stosowania łańcuchów liczbowych jest próba
uzyskania zachowania, które będzie ``najmniej zaskakujące'', w dalszym ciągu
jednak ``robiące poprawnie to, o co chodzi''.

@cindex porównania, łańcuch a wyrażenie regularne
@cindex porównanie łańcuchowe a porównanie wyrażeń regularnych
@cindex porównanie wyrażeń regularnych a porównanie łańcuchowe
Porównania łańcuchów i porównania wyrażeń regularnych są całkiem odmienne.
Na przykład,

@example
x == "foo"
@end example

@noindent
ma wartość jeden (jest prawdziwe) jeśli zmienna @code{x} równa się
dokładnie @samp{foo}.  W przeciwieństwie do tego

@example
x ~ /foo/
@end example

@noindent
ma wartość jeden jeśli @code{x} zawiera @samp{foo}, jak np.
@code{"Oh, what a fool am I!"}.

Prawostronny operand operatorów @samp{~} i @samp{!~} może być albo
wyrażeniem regularnym stałym (@code{/@dots{}/}), albo zwykłym wyrażeniem,
wówczas wartość tego wyrażenia jako łańcucha jest używana jako dynamiczne
wyrażenie regularne (@pxref{Używanie regexp, , Jak stosować wyrażenia regularne};
także @pxref{Regexp obliczane, ,Stosowanie dynamicznych wyrażeń regularnych}).

@cindex wyrażenie regularne jako wyrażenie
W ostatnich implementacjach @code{awk}, wyrażenie regularne stałe w
ukośnikach jest samo również wyrażeniem (zwykłym).  Wyrażenie regularne
@code{/@var{regexp}/} stanowi skrót dla tego wyrażenia porównującego:

@example
$0 ~ /@var{regexp}/
@end example

Istnieje specjalne miejsce, w którym @code{/foo/} @emph{nie} stanowi skrótu
dla @samp{$0 ~ /foo/}: wówczas, gdy jest ono prawostronnym  operandem
operatora @samp{~} lub @samp{!~}!
@xref{Używanie stałych regexp,  ,Używanie stałych regexp},
gdzie omówiono szczegóły.

@c This paragraph has been here since day 1, and has always bothered
@c me, especially since the expression doesn't really make a lot of
@c sense. So, just take it out.
@ignore
In some contexts it may be necessary to write parentheses around the
regexp to avoid confusing the @code{gawk} parser.  For example,
@samp{(/x/ - /y/) > threshold} is not allowed, but @samp{((/x/) - (/y/))
> threshold} parses properly.
@end ignore

@node Operatory logiczne, Wyrażenia warunkowe, Typy i porównania, Wyrażenia
@section Wyrażenia logiczne
@cindex wyrażenie logiczne
@cindex logiczne wyrażenie
@cindex boole'owskie wyrażenie
@cindex operatory, boolowskie
@cindex operatory, logiczne
@cindex logiczne operatory
@cindex boole'owskie operatory
@cindex operacje, logiczne
@cindex operatory skrócone
@cindex and operator
@cindex or operator
@cindex not operator
@cindex @code{&&} operator
@cindex @code{||} operator
@cindex @code{!} operator

@dfn{Wyrażenie logiczne} jest połączeniem wyrażeń porównania
lub wyrażeń dopasowania, przy użyciu operatorów logicznych ``or''
(@samp{||}), ``and'' (@samp{&&}) i ``not'' (@samp{!}), razem z
nawiasami do sterowania zagnieżdżaniem.  Prawdziwość wyrażenia
logicznego jest obliczana jako kombinacja prawdziwości wyrażeń
składowych.  Wyrażenia logiczne są też nazywane
@dfn{wyrażeniami boole'owskimi}.  Oba terminy są równoważne.

Wyrażenia logiczne mogą być używane wszędzie tam, gdzie wyrażenia
porównania lub dopasowania.  Wykorzystuje się je w instrukcjach @code{if},
@code{while}, @code{do} i @code{for}
(@pxref{Instrukcje, ,Instrukcje sterujące w akcjach}).  Posiadają wartości
numeryczne (jeden jeśli prawda, zero jeśli fałsz), co ma znaczenie przy
przypisywaniu wyniku wyrażenia logicznego zmiennej lub przy
wykorzystywaniu go w działaniach arytmetycznych.

Dodatkowo, każde wyrażenie logiczne jest także poprawnym wzorcem, więc można
go użyć jako wzorca do sterowania wykonaniem reguł.

Oto opis, z przykładami, trzech operatorów logicznych.

@c @cartouche
@table @code
@item @var{logiczne1} && @var{logiczne2}
Prawda, jeśli zarówno @var{logiczna1} jak i @var{logiczna2} są prawdziwe.
Na przykład, poniższa instrukcja wypisuje bieżący rekord wejściowy jeśli
zawiera on zarówno @samp{2400} jak i @samp{foo}.

@example
if ($0 ~ /2400/ && $0 ~ /foo/) print
@end example

Podwyrażenie @var{logiczne2} jest obliczane tylko wtedy, gdy @var{logiczne1}
jest prawdziwe.  Może to mieć znaczenie gdy @var{logiczne2} zawiera wyrażenia
dające skutki uboczne: w przypadku @samp{$0 ~ /foo/ && ($2 == bar++)},
jeśli w rekordzie nie ma @samp{foo}, to zmienna @code{bar} nie jest
inkrementowana.

@item @var{logiczne1} || @var{logiczne2}
Prawda jeśli co najmniej jedno z wyrażeń @var{logiczne1} lub
@var{logiczne2} jest prawdziwe.  Na przykład, poniższa instrukcja wypisuje
wszystkie rekordy wejścia zawierające @emph{albo} @samp{2400} albo
@samp{foo}, lub oba.

@example
if ($0 ~ /2400/ || $0 ~ /foo/) print
@end example

Podwyrażenie @var{logiczne2} jest obliczane tylko wtedy, gdy @var{logiczne1}
jest fałszywe.   Może to mieć znaczenie gdy @var{logiczne2} zawiera wyrażenia
dające skutki uboczne.

@item ! @var{logiczne}
Prawda jeśli @var{logiczne} jest fałszywe.  Na przykład, poniższy program
wypisuje wszystkie rekordy pliku wejściowego @file{BBS-list}, które
@emph{nie} zawierają łańcucha @samp{foo}.

@c A better example would be `if (! (subscript in array)) ...' but we
@c haven't done anything with arrays or `in' yet. Sigh.
@example
awk '@{ if (! ($0 ~ /foo/)) print @}' BBS-list
@end example
@end table
@c @end cartouche

Operatory @samp{&&} i @samp{||} z powodu sposobu, w jaki działają, nazywane
są operatorami @dfn{skróconymi} (short-circuit).
Obliczenia pełnego wyrażenia są ``skracane'', przerywane, jeżeli wynik można
określić już po obliczeniu części wyrażenia.

@cindex kontynuacja linii
Instrukcję wykorzystującą @samp{&&} lub @samp{||} kontynuujemy po prostu
stawiając po nich znak nowej linii.  Nie można jednak stawiać znaku nowej
linii przed tymi operatorami bez użycia kontynuacji odwróconym ukośnikiem.
(@pxref{Instrukcje/wiersze, ,Instrukcje @code{awk} a wiersze}).

Faktyczną wartością wyrażenia wykorzystującego operator @samp{!} będzie jeden
lub zero, w zależności od prawdziwości wyrażenia, do którego go zastosowano.

Operator @samp{!} przydaje się często do zmiany stanu zmiennej flagowej z
fałszu na prawdę i z powrotem.  Na przykład, poniższy program jest jednym
ze sposobów wypisania wierszy umieszczonych między specjalnymi wierszami
grupującymi:

@example
$1 == "START"   @{ interested = ! interested @}
interested == 1 @{ print @}
$1 == "END"     @{ interested = ! interested @}
@end example

@noindent
Zmienna @code{interested}, jak wszystkie zmienne @code{awk}, startuje
zainicjowana na zero, które jest również fałszem.  Gdy zostanie spostrzeżony
wiersz, którego pierwszym polem jest @samp{START}, wartość @code{interested}
za pomocą @samp{!} przełączana jest na prawdę.  Następna reguła wypisuje
wiersze dopóki @code{interested} jest prawdziwe.  Gdy zostanie spostrzeżony
wiersz, którego pierwszym polem jest @samp{END}, @code{interested}
przełączane jest z powrotem na fałsz.
@ignore
We should discuss using `next' in the two rules that toggle the
variable, to avoid printing the bracketing lines, but that's more
distraction than really needed.
@end ignore

@node Wyrażenia warunkowe, Wywołania funkcji, Operatory logiczne, Wyrażenia
@section Wyrażenia warunkowe
@cindex wyrażenie warunkowe

@dfn{Wyrażenie warunkowe} jest specjalnym rodzajem wyrażenia z trzema
operandami.  Pozwala na wykorzystanie wartości jednego z wyrażeń do wyboru
jednego z dwu pozostałych wyrażeń.

Wyrażenie warunkowe jest takie samo jak w języku C:

@example
@var{selektor} ? @var{wyr-jeśli-prawda} : @var{wyr-jeśli-fałsz}
@end example

@noindent
Mamy tu trzy podwyrażenia.  Pierwsze, @var{selektor}, jest zawsze obliczane
jako pierwsze.  Jeżeli jest ono ``prawdziwe'' (nie zero i nie puste), to
następnie obliczane jest @var{wyr-jeśli-prawda} a jego wartość staje się
wartością całego wyrażenia.  W przeciwnym razie, jako następne jest obliczane
@var{wyr-jeśli-fałsz} a jego wartość staje się wartością całego wyrażenia.

Na przykład, to wyrażenie tworzy wartość bezwzględną @code{x}:

@example
x > 0 ? x : -x
@end example

Przy każdym wyliczaniu wyrażenia warunkowego używane jest dokładnie
jedno z @var{wyr-jeśli-prawda} i @var{wyr-jeśli-fałsz}; drugie jest
ignorowane.  Jest to istotne gdy wyrażenia mają skutki uboczne.
Na przykład, to wyrażenie warunkowe bada element @code{i} albo tablicy
@code{a} albo tablicy @code{b}, i inkrementuje @code{i}.

@example
x == y ? a[i++] : b[i++]
@end example

@noindent
Jest pewne, że inkrementacja @code{i} nastąpi dokładnie raz, gdyż
zawsze wykonywane jest tylko jedno z dwu wyrażeń inkrementujących,
drugie nie.  @xref{Tablice, ,Tablice w @code{awk}}, gdzie napisano
więcej o tablicach.

@cindex różnice między @code{gawk} a @code{awk}
@cindex kontynuacja linii
Drobnym rozszerzeniem w @code{gawk} jest możliwość kontynuacji instrukcji
wykorzystującej @samp{?:} przez zwykłe postawienie znaku nowej linii po
jednym z tych znaków.  Nie można jednak stawiać znaku nowej linii przed
którymś z nich bez zastosowania kontynuacji odwrotnym ukośnikiem
(@pxref{Instrukcje/wiersze, ,Instrukcje @code{awk} a wiersze}).  Jeżeli
podano opcję @samp{--posix} (@pxref{Opcje, , Opcje wiersza poleceń}),
to rozszerzenie to jest wyłączane.

@node Wywołania funkcji, Priorytet, Wyrażenia warunkowe, Wyrażenia
@section Wywołania funkcji
@cindex wywołanie funkcji
@cindex funkcja, wywołanie

@dfn{Funkcja} jest nazwą nadaną konkretnym obliczeniom.  Ponieważ mają one
nazwę, można ich zażądać w dowolnym miejscu programu posługując się tą
nazwą.  Na przykład, funkcja @code{sqrt} oblicza pierwiastek kwadratowy
z liczby.

Istnieje stały zestaw funkcji @dfn{wbudowanych}, co znaczy, że są one
dostępne w każdym programie @code{awk}.  Funkcja @code{sqrt} jest
jedną z nich.
@xref{Wbudowane, ,Funkcje wbudowane}, gdzie znajduje się lista funkcji
wbudowanych i ich opisy.  Dodatkowo, można definiować własne funkcje, do
wykorzystania w swoim programie.
@xref{Użytkownika, ,Funkcje użytkownika}, gdzie opisano, jak to
zrobić.

@cindex argumenty w wywołaniu funkcji
Funkcje wykorzystuje się za pomocą wyrażenia @dfn{wywołania funkcji},
składającego się z nazwy funkcji, bezpośrednio po której następuje lista
@dfn{argumentów} w nawiasach.  Argumenty są wyrażeniami dostarczającymi
surowców do obliczeń przeprowadzanych przez funkcję.  Jeżeli występuje więcej
niż jeden argument, to są one oddzielane przecinkami.  Jeżeli brak
argumentów, po nazwie funkcji piszemy same nawiasy @samp{()}.
Oto kilka przykładów:

@example
sqrt(x^2 + y^2)        @i{jeden argument}
atan2(y, x)            @i{dwa argumenty}
rand()                 @i{bez argumentów}
@end example

@strong{Nie należy stawiać spacji między nazwą funkcji a nawiasem
otwierającym!}  Nazwa funkcji zdefiniowanej przez użytkownika wygląda tak
jak nazwa zmiennej, i spacja spowodowałaby, że całe wyrażenie wyglądałoby
jak konkatenacja zmiennej z wyrażeniem wewnątrz nawiasów.  Spacja przed
nawiasami jest nieszkodliwa przy funkcjach wbudowanych, ale najlepiej nie
nabierać nawyku wtrącania spacji, by uniknąć pomyłek przy funkcjach
definiowanych przez użytkownika.

Każda funkcja oczekuje konkretnej liczby argumentów.  Na przykład,
funkcja @code{sqrt} musi być wywołana z pojedynczym argumentem, liczbą,
z której ma wyciągnąć pierwiastek:

@example
sqrt(@var{argument})
@end example

Niektóre z funkcji wbudowanych pozwalają na pominięcie ostatniego argumentu.
Jeśli tak postąpimy, to użyją rozsądnej wartości domyślnej.
@xref{Wbudowane, ,Funkcje wbudowane}, gdzie podano szczegóły.
Jeżeli pominięto argumenty w wywołaniu funkcji definiowanej przez
użytkownika, to są one traktowane jak zmienne lokalne, inicjowane łańcuchem
pustym
(@pxref{Użytkownika, ,Funkcje użytkownika}).

Jak każde inne wyrażenie, wywołanie funkcji posiada wartość, obliczaną
przez funkcję w oparciu o przekazane jej przez nas argumenty.  W tym
przykładzie, wartością @samp{sqrt(@var{argument})} jest pierwiastek
kwadratowy @var{argumentu}.  Funkcja może też mieć skutki uboczne, takie
jak np. przypisanie wartości do pewnych zmiennych czy wykonanie operacji
wejścia/wyjścia.

Oto polecenie do czytania liczb, po jednej w wierszu, i wypisywania
pierwiastka kwadratowego każdej z nich:

@example
@group
$ awk '@{ print "Pierwiastkiem kwadratowym z", $1, "jest", sqrt($1) @}'
1
@print{} Pierwiastkiem kwadratowym z 1 jest 1
3
@print{} Pierwiastkiem kwadratowym z 3 jest 1.73205
5
@print{} Pierwiastkiem kwadratowym z 5 jest 2.23607
@kbd{Control-d}
@end group
@end example

@node Priorytet,  , Wywołania funkcji, Wyrażenia
@section Priorytet operatorów (Jak łączą się różne operatory)
@cindex priorytet operatorów
@cindex operatory, priorytet

@dfn{Priorytet operatorów} określa sposób, w jaki są grupowane operatory
gdy pojawiają się tuż obok siebie w jednym wyrażeniu.  Na przykład, @samp{*}
ma wyższy priorytet niż @samp{+}; zatem, @samp{a + b * c} oznacza
przemnożenie @code{b} i @code{c}, a następnie dodanie @code{a} do iloczynu
(tj.@:  @samp{a + (b * c)}).

Nad priorytetem operatorów nadrzędna jest kolejność narzucona zastosowanymi
nawiasami.  Można myśleć o regułach priorytetów tak, jakby stwierdzały one,
gdzie przyjęte zostanie położenie nawiasów, jeżeli sami ich nie postawimy.
W rzeczywistości, rozsądnie jest przy nietypowej kombinacji operatorów
zawsze stosować nawiasy, gdyż inni czytający program mogą nie pamiętać, jaki
jest priorytet w tym przypadku.  Możemy o tym również zapomnieć sami lub
też popełnić pomyłkę.  Jawne nawiasy pomogą uniknąć podobnych błędów.

Kiedy operatory o równym priorytecie są użyte razem, to jako pierwszy
grupuje operator występujący po lewej, z wyjątkiem przypisania,
operatorów warunkowych i potęgowania, gdzie grupowanie odbywa się
w odwrotnej kolejności.  Zatem, @samp{a - b + c} grupuje jak
@samp{(a - b) + c}, a @samp{a = b = c} grupuje jak @samp{a = (b = c)}.

Priorytet jednoargumentowych operatorów przedrostkowych nie ma znaczenia
póki zaangażowane są tylko operatory jednoargumentowe, gdyż jest tylko jeden
sposób ich interpretacji -- poczynając od najbardziej wewnętrznego.
Zatem, @samp{$++i} oznacza @samp{$(++i)} a @samp{++$x} znaczy @samp{++($x)}.
Jeżeli jednak po operandzie występuje inny operator, to priorytet operatorów
jednoargumentowych może mieć znaczenie.  Zatem, @samp{$x^2} oznacza
@samp{($x)^2}, ale @samp{-x^2} oznacza @samp{-(x^2)}, gdyż @samp{-}
ma niższy priorytet niż @samp{^}, podczas gdy @samp{$} ma wyższy.

Oto tabela operatorów występujących w @code{awk}, w kolejności
od najwyższego priorytetu do najniższego:

@c use @code in the items, looks better in TeX w/o all the quotes
@table @code
@item (@dots{})
Grupowanie.

@item $
Pole.

@item ++ --
Inkrementacja, dekrementacja.

@cindex język @code{awk}, wersja POSIX
@cindex POSIX @code{awk}
@item ^ **
Potęgowanie. Operatory te grupują od prawej do lewej.
(POSIX nie wymienia operatora @samp{**}.)

@item + - !
Jednoargumentowy plus, minus, negacja logiczna (``not'').

@item * / %
Mnożenie, dzielenie, reszta z dzielenia (modulo).

@item + -
Dodawanie, odejmowanie.

@item @r{Konkatenacja}
Do wskazania konkatenacji nie jest wykorzystywany żaden specjalny znacznik.
Operandy są po prostu zapisywane jeden obok drugiego.

@item < <= == !=
@itemx > >= >> |
Relacje i przekierowania.
Operatory relacji i przekierowania mają ten sam poziom priorytetu.  Znaki
takie jak @samp{>} służą zarówno do zapisu relacji jak i przekierowań.
Oba znaczenia są odróżniane po kontekście.

Zwróć uwagę, że operatory przekierowania wejścia/wyjścia w instrukcjach
@code{print} i @code{printf} należą do poziomu instrukcji, nie do wyrażeń.
Przekierowanie nie tworzy wyrażenia, które mogłoby być operandem innego
operatora.  Wskutek tego, nie ma sensu stosowanie operatora przekierowania
w pobliżu innego operatora o niższym priorytecie, bez użycia nawiasów.
Takie kombinacje, na przykład @samp{print foo > a ? b : c}, powodują błędy
składniowe.  Poprawnym sposobem zapisania tej instrukcji jest
@samp{print foo > (a ? b : c)}.

@item ~ !~
Dopasowanie, nie-dopasowanie.

@item in
Przynależność do tablicy.

@item &&
Koniunkcja logiczna (``and'').

@item ||
Alternatywa logiczna (``or'').

@item ?:
Operator warunkowy.  Grupuje od prawej do lewej.

@cindex język @code{awk}, wersja POSIX
@cindex POSIX @code{awk}
@item = += -= *=
@itemx /= %= ^= **=
Przypisanie.  Te operatory grupują od prawej do lewej.
(POSIX nie wymienia operatora @samp{**}.)
@end table

@node Wzorce i akcje, Instrukcje, Wyrażenia, Top
@chapter Wzorce i akcje
@cindex wzorzec, definicja

Jak już widzieliśmy, każda instrukcja @code{awk} składa się ze wzorca
i skojarzonej z nim akcji.  W tym rozdziale opisano w jaki sposób
konstruuje się wzorce i akcje.

@menu
* Przegląd wzorców::            Co wchodzi w skład wzorca.
* Przegląd akcji::              Co wchodzi w skład akcji.
@end menu

@node Przegląd wzorców, Przegląd akcji, Wzorce i akcje, Wzorce i akcje
@section Elementy wzorców

Wzorce w @code{awk} sterują wykonywaniem reguł: reguła jest wykonywana
gdy jej wzorzec pasuje do bieżącego rekordu wejściowego.  W tej sekcji
zajmujemy się tym, jak pisać wzorce.

@menu
* Rodzaje wzorców::             Lista wszystkich rodzajów wzorców.
* Wzorce regexp::               Używanie wyrażeń regularnych jako wzorców.
* Wyrażenia wzorcami::          Jako wzorzec może być użyte dowolne wyrażenie.
* Zakresy::                     Para wzorców określa zakres rekordów.
* BEGIN/END::                   Podawanie reguł inicjujących i kończących.
* Pusty::                       Pusty wzorzec, który dopasowuje każdy rekord.
@end menu

@node Rodzaje wzorców, Wzorce regexp, Przegląd wzorców, Przegląd wzorców
@subsection Rodzaje wzorców
@cindex wzorce, typy

Oto podsumowanie typów wzorców obsługiwanych w @code{awk}.

@table @code
@item /@var{wyrażenie regularne}/
Wyrażenie regularne jako wzorzec.  Pasuje gdy tekst bieżącego rekordu
wejściowego pasuje do wyrażenia regularnego.
(@xref{Regexp, ,Regular Expressions}.)

@item @var{wyrażenie}
Pojedyncze wyrażenie.  Pasuje gdy jego wartość jest niezerowa (jeśli to
liczba) lub niepusta (jeśli łańcuch).
(@xref{Wyrażenia wzorcami, ,Wyrażenia jako wzorce}.)

@item @var{wz1}, @var{wz2}
Para wzorców rozdzielona przecinkiem, określająca zakres rekordów.  Zakres
zawiera zarówno rekord początkowy, który pasuje do @var{wz1}, jak i rekord
końcowy, pasujący do @var{wz2}.
(@xref{Zakresy, ,Określanie zakresów rekordów za pomocą wzorców}.)

@item BEGIN
@itemx END
Wzorce specjalne umożliwiające podanie akcji początkowych, wykonywanych
przy rozpoczęciu pracy programu @code{awk}, lub końcowych,
porządkowych przed jej zakończeniem.
(@xref{BEGIN/END, ,Wzorce specjalne @code{BEGIN} i @code{END}}.)

@item @var{pusty}
Wzorzec pusty. Pasuje do niego każdy rekord wejściowy.
(@xref{Pusty, ,Wzorzec pusty}.)
@end table

@node Wzorce regexp, Wyrażenia wzorcami, Rodzaje wzorców, Przegląd wzorców
@subsection Wyrażenia regularne jako wzorce

Już od pierwszych przykładów używaliśmy wyrażeń regularnych jako wzorców.
Ten rodzaj wzorca jest po prostu stałym wyrażeniem regularnym w części
reguły opisującej wzorzec.  Znaczy ono @samp{$0 ~ /@var{wzorzec}/}.
Taki wzorzec pasuje gdy rekord wejściowy pasuje do wyrażenia regularnego.
Na przykład:

@example
/foo|bar|baz/  @{ belkot++ @}
END            @{ print "Wyłapano", belkot, "słów tech-bełkotu" @}
@end example

@node Wyrażenia wzorcami, Zakresy, Wzorce regexp, Przegląd wzorców
@subsection Wyrażenia jako wzorce

Dowolne wyrażenie @code{awk} jest poprawnym wzorcem.
Wzorzec ten pasuje jeśli wartość wyrażenia jest niezerowa (jeśli to liczba)
lub niepusta (jeśli łańcuch).

Wyrażenie jest przeliczane przy każdorazowym testowaniu reguły z nowym
rekordem wejściowym.  Jeżeli wykorzystuje ono pola, jak np. @code{$1}, to
jego wartość zależy wprost od tekstu nowego rekordu.  W przeciwnym razie,
zależy tylko od tego, co zdarzyło się do tej pory podczas wykonywania
programu @code{awk}, lecz nadal może być użyteczne.

Bardzo często występującym rodzajem wyrażenia stosowanym jako wzorzec jest
wyrażenie porównania, korzystające z operatorów porównania opisanych w
@ref{Typy i porównania, ,Typy zmiennych i wyrażenia porównania}.

Bardzo często stosowanymi wyrażeniami są także dopasowanie i nie-dopasowanie
wyrażenia regularnego.  Lewym operandem operatorów @samp{~} i @samp{!~} jest
łańcuch.  Prawy operand jest albo stałym wyrażeniem regularnym ujętym
w ukośniki (@code{/@var{regexp}/}) albo dowolnym innym wyrażeniem, którego
wartość łańcuchowa wykorzystywana jest jako dynamiczne wyrażenie regularne
(@pxref{Regexp obliczane, , Stosowanie dynamicznych wyrażeń regularnych}).

Poniższy przykład wypisuje drugie pole każdego rekordu wejściowego, którego
pierwszym polem jest dokładnie @samp{foo}.

@example
$ awk '$1 == "foo" @{ print $2 @}' BBS-list
@end example

@noindent
(Nie otrzymamy żadnego wyjścia, ponieważ nie ma BBS-u o nazwie ``foo''.)
Inaczej będzie przy poniższym dopasowaniu wyrażenia regularnego, które
akceptuje dowolny rekord z pierwszym polem zawierającym @samp{foo}:

@example
@group
$ awk '$1 ~ /foo/ @{ print $2 @}' BBS-list
@print{} 555-1234
@print{} 555-6699
@print{} 555-6480
@print{} 555-2127
@end group
@end example

Jako wzorce są również powszechnie wykorzystywane wyrażenia logiczne.
To, czy rekord pasuje do wzorca, zależy od dopasowania jego podwyrażeń.

Na przykład, poniższe polecenie wypisuje wszystkie rekordy z
@file{BBS-list}, które zawierają zarówno @samp{2400} jak i @samp{foo}.

@example
$ awk '/2400/ && /foo/' BBS-list
@print{} fooey        555-1234     2400/1200/300     B
@end example

Poniższe polecenie wypisuje wszystkie rekordy z @file{BBS-list}, które
zawierają @samp{2400} @emph{lub} @samp{foo}, lub oba.

@example
@group
$ awk '/2400/ || /foo/' BBS-list
@print{} alpo-net     555-3412     2400/1200/300     A
@print{} bites        555-1675     2400/1200/300     A
@print{} fooey        555-1234     2400/1200/300     B
@print{} foot         555-6699     1200/300          B
@print{} macfoo       555-6480     1200/300          A
@print{} sdace        555-3430     2400/1200/300     A
@print{} sabafoo      555-2127     1200/300          C
@end group
@end example

Poniższe polecenie wypisuje wszystkie rekordy z @file{BBS-list}, które
@emph{nie} zawierają łańcucha @samp{foo}.

@example
@group
$ awk '! /foo/' BBS-list
@print{} aardvark     555-5553     1200/300          B
@print{} alpo-net     555-3412     2400/1200/300     A
@print{} barfly       555-7685     1200/300          A
@print{} bites        555-1675     2400/1200/300     A
@print{} camelot      555-0542     300               C
@print{} core         555-2912     1200/300          C
@print{} sdace        555-3430     2400/1200/300     A
@end group
@end example

Podwyrażenia operatora logicznego we wzorcu mogą być wyrażeniami
regularnymi, porównaniami, czy dowolnymi innymi wyrażeniami @code{awk}.
Wzorce zakresu nie są wyrażeniami, więc nie mogą pojawić się wewnątrz
wzorców logicznych.  Podobnie, nie są wyrażeniami i nie mogą pojawić się
wewnątrz wzorców logicznych wzorce specjalne @code{BEGIN} i @code{END},
które nigdy nie dopasowują żadnego rekordu wejściowego.

Specjalnym przypadkiem wyrażenia będącego wzorcem wzorca jest też stałe
wyrażenie regularne.  @code{/foo/} jako wyrażenie ma wartość jeden jeśli w
rekordzie wejściowym pojawia się @samp{foo}.  Zatem, jako wzorzec,
@code{/foo/} dopasowuje dowolny rekord zawierający @samp{foo}.

@node Zakresy, BEGIN/END, Wyrażenia wzorcami, Przegląd wzorców
@subsection Określanie zakresów rekordów za pomocą wzorców

@cindex zakres, wzorzec
@cindex wzorzec, zakresu
@cindex dopasowanie zakresu wierszy
@dfn{Wzorzec zakresu} tworzą dwa wzorce rozdzielone przecinkiem:
ma on postać @samp{@var{wzpocz}, @var{wzkońc}}.  Dopasowuje zakres kolejnych
wierszy wejściowych.  Pierwszy wzorzec, @var{wzpocz}, decyduje o tym, gdzie
zaczyna się zakres, a drugi,  @var{wzkońc}, gdzie się on kończy.
Na przykład,

@example
awk '$1 == "on", $1 == "off"'
@end example

@noindent
wypisuje każdy rekord wejściowy pomiędzy parami @samp{on}/@samp{off},
z nimi włącznie.

Wzorzec zakresu zaczyna pracę od dopasowywania do @var{wzpocz} każdego
rekordu wejściowego.  Kiedy rekord pasuje do @var{wzpocz}, zakres rekordów
staje się @dfn{włączony}.  Ten rekord pasuje do zakresu rekordów.
Dopóki zakres pozostaje włączony, automatycznie pasuje do niego każdy
przeczytany rekord wejściowy.  Równocześnie każdy z nich jest dopasowywany
do @var{wzkońc}; gdy dopasowanie się powiedzie, wzorzec zakresu jest
ponownie wyłączany przed następnym rekordem.  Następnie powraca do
sprawdzania każdego rekordu z @var{wzpocz}.

Zarówno rekord, który włączył wzorzec, jak i rekord, który go wyłączył
pasują do wzorca zakresu.  Jeżeli nie chcemy działać na tych rekordach,
możemy w akcji danej reguły napisać instrukcje @code{if}, odróżniające
je od rekordów, którymi jesteśmy zainteresowani.

Możliwe jest, że wzorzec zostanie włączony i wyłączony przez ten sam
rekord, jeżeli spełnia on oba warunki.  Wówczas skojarzona ze wzorcem akcja
wykonywana jest tylko dla tego rekordu.

Na przykład, załóżmy, że mamy tekst między dwoma identycznymi znacznikami
(powiedzmy, symbolami @samp{%}), który chcemy zignorować.  Można usiłować
połączyć wzorzec zakresu, opisujący ograniczany tekst, z instrukcją
@code{next} (jeszcze nie omawianą,
@pxref{Instrukcja next, , Instrukcja @code{next}}),
co spowoduje, że @code{awk} pominie dalsze przetwarzanie bieżącego rekordu
i rozpocznie od nowa z nowym rekordem wejściowym.  Program taki mógłby
wyglądać tak:

@example
/^%$/,/^%$/    @{ next @}
               @{ print @}
@end example

@noindent
@cindex pomijanie wierszy między znacznikami
Ten program nie działa poprawnie, gdyż wzorzec zakresu jest zarówno włączany
jak i wyłączany przez pierwszy wiersz z samym znakiem @samp{%}.
Do realizacji naszego zadania musimy napisać program w taki sposób,
korzystając z flagi:

@example
/^%$/     @{ skok = ! skok; next @}
skok == 1 @{ next @} # przeskocz wiersze gdy ustawiony `skok'
@end example

Zauważ, że przecinek @samp{,} we wzorcu zakresu ma najniższy priorytet
(jest obliczany ostatni) ze wszystkich operatorów.  Zatem, na przykład,
poniższy program usiłuje połączyć wzorzec zakresu z innym, prostszym testem.

@example
echo Tak | awk '/1/,/2/ || /Tak/'
@end example

Autor programu chciał, by znaczyło to @samp{(/1/,/2/) || /Tak/}.
Jednak @code{awk} interpretuje je jako @samp{/1/, (/2/ || /Tak/)}.
Zachowania tego nie można zmienić lub obejść; wzorce zakresu nie łączą się
z innymi wzorcami.

@node BEGIN/END, Pusty, Zakresy, Przegląd wzorców
@subsection Wzorce specjalne @code{BEGIN} i @code{END}

@cindex @code{BEGIN}, wzorzec specjalny
@cindex wzorzec, @code{BEGIN}
@cindex @code{END}, wzorzec specjalny
@cindex wzorzec, @code{END}
@code{BEGIN} i @code{END} są wzorcami specjalnymi.  Nie są używane do
dopasowania rekordów wejściowych.  Zamiast tego, umożliwiają podanie
akcji startowych lub końcowych dla własnego skryptu @code{awk}.

@menu
* Używanie BEGIN/END::          Jak i dlaczego korzystać z reguł BEGIN/END.
* I/O i BEGIN/END::             Kwestie I/O w regułach BEGIN/END.
@end menu

@node Używanie BEGIN/END, I/O i BEGIN/END, BEGIN/END, BEGIN/END
@subsubsection Akcje początkowe i końcowe

Reguła @code{BEGIN} wykonywana jest, jednokrotnie, przed odczytaniem
pierwszego rekordu wejściowego.  Reguła @code{END} wykonywana jest,
jednokrotnie, po przeczytaniu całości wejścia.  Na przykład:

@example
@group
$ awk '
> BEGIN @{ print "Analiza \"foo\"" @}
> /foo/ @{ ++n @}
> END   @{ print "\"foo\" występuje " n " razy." @}' BBS-list
@print{} Analiza "foo"
@print{} "foo" występuje 4 razy.
@end group
@end example

Ten program znajduje liczbę rekordów pliku wejściowego @file{BBS-list}
zawierających łańcuch @samp{foo}.  Reguła @code{BEGIN} wypisuje tytuł
raportu. Nie ma potrzeby wykorzystywania reguły @code{BEGIN} do inicjowania
licznika @code{n} na zero, gdyż @code{awk} robi to automatycznie
(@pxref{Zmienne}).

Druga reguła zwiększa zmienną @code{n} za każdym razem, gdy zostanie
przeczytany rekord zawierający wzorzec @samp{foo}.  Reguła @code{END}
na koniec pracy programu wypisuje wartość @code{n}.

Wzorce specjalne @code{BEGIN} i @code{END} nie mogą być stosowane
w zakresach ani z operatorami logicznymi (faktycznie nie mogą być używane
z żadnymi operatorami).

Program @code{awk} może mieć wiele reguł @code{BEGIN} i/lub @code{END}.
Są one wykonywane w kolejności występowania, wszystkie reguły @code{BEGIN}
przy rozpoczęciu pracy a wszystkie reguły @code{END} przy zakończeniu.
Reguły @code{BEGIN} i @code{END} mogą być przeplatane z innymi regułami.
Własność tę dodano w @code{awk} w wersji z roku 1987 i jest zawarta
w standardzie POSIX.  Pierwotna wersja @code{awk} (z 1978 roku) wymagała
umieszczania reguły @code{BEGIN} na samym początku programu a @code{END}
na końcu i zezwalała tylko na jedną regułą @code{BEGIN} i jedną @code{END}.
Nie jest to już wymagane, ale jest dobrym rozwiązaniem jeśli chodzi o
organizację programu i jego czytelność.

Wielokrotne reguły @code{BEGIN} i @code{END} są przydatne przy pisaniu
funkcji bibliotecznych, gdyż każdy plik biblioteczny może mieć swoją
własną regułę @code{BEGIN} i/lub @code{END} do wykonania własnej
inicjalizacji i/lub porządkowania.  Warto zauważyć, że kolejność, w jakiej
wymieniane są funkcje biblioteczne w wierszu poleceń wyznacza kolejność,
w jakiej zostaną wykonane ich reguły @code{BEGIN} i @code{END}.  Z tego
powodu reguły te w plikach bibliotecznych muszą być pisane tak, by kolejność
ich wykonywania nie miała znaczenia.
@xref{Opcje, ,Opcje wiersza poleceń}, gdzie jest więcej o stosowaniu
funkcji bibliotecznych.
@xref{Funkcje biblioteczne, ,Biblioteczka funkcji @code{awk}}, o wielu
przydatnych funkcjach bibliotecznych.

@cindex ciemny kąt
Jeżeli program @code{awk} ma tylko jedną regułę @code{BEGIN}
i żadnych innych reguł, to program kończy pracę po wykonaniu reguły
@code{BEGIN}.  (Pierwotna wersja @code{awk} kontynuowała czytanie
i ignorowanie wejścia aż do osiągnięcia końca pliku.)  Jeśli jednak istnieje
reguła @code{END}, to wejście będzie czytane, nawet jeżeli w programie nie
ma żadnych innych reguł.  Jest to konieczne na wypadek, gdyby reguła
@code{END} sprawdzała zmienne @code{FNR} i @code{NR} (c.k.).

Reguły @code{BEGIN} i @code{END} muszą mieć akcje.  Nie istnieje dla
nich żadna akcja domyślna, gdyż podczas ich pracy nie ma żadnego rekordu
bieżącego.

@node I/O i BEGIN/END, , Używanie BEGIN/END, BEGIN/END
@subsubsection Wejście/wyjście z reguł @code{BEGIN} i @code{END}

@cindex I/O z @code{BEGIN} i @code{END}
@cindex wejście/wyjście z @code{BEGIN} i @code{END}
Istnieje kilka (czasem trudno uchwytnych) kwestii związanych z wykonywaniem
operacji wejścia/wyjścia w regule @code{BEGIN} lub @code{END}.

Pierwsza ma związek z wartością @code{$0} w regule @code{BEGIN}.  Ponieważ
reguły @code{BEGIN} są wykonywane przed odczytem jakiegokolwiek wejścia,
to podczas ich wykonywania po prostu ma żadnego rekordu wejściowego,
a więc i żadnych pól.  Odwołania do @code{$0} i pól zwracają łańcuch pusty
lub zero, zależnie od kontekstu.  Jedną z metod nadania @code{$0}
rzeczywistej wartości jest wykonanie polecenia @code{getline} bez zmiennej
(@pxref{Getline, ,Odczyt bezpośredni przez @code{getline}}).  Inną metodą jest
po prostu przypisanie jej wartości.

@cindex różnice między @code{gawk} a @code{awk}
Druga istotna sprawa jest zbliżona do pierwszej, tylko dotyczy
odwrotnego kierunku.  Jakie są wartości @code{$0} i @code{NF} wewnątrz
reguły @code{END}?  Tradycyjnie, z powodu głównie kwestii implementacyjnych,
@code{$0} i @code{NF} wewnątrz reguły @code{END} były
@emph{niezdefiniowane}.  Standard POSIX określił, że @code{NF} jest dostępne
w regule @code{END}, i zawiera liczbę pól z ostatniego rekordu wejściowego.
Najprawdopodobniej wskutek przeoczenia, standard nie mówi, że zachowywane
jest również @code{$0}, choć logicznie myśląc tak powinno być.
Faktycznie, @code{gawk} zachowuje wartość @code{$0} do wykorzystania
w regułach @code{END}.  Należy jednak być świadomym, że uniksowy @code{awk},
i być może inne implementacje, tego nie robią.

Trzecia kwestia wynika z dwu pierwszych. Jak należy rozumieć @samp{print}
wewnątrz reguły @code{BEGIN} lub @code{END}?  Znaczy ono zawsze to samo,
@samp{print $0}.  Jeżeli @code{$0} jest łańcuchem pustym, to wypisze pusty
wiersz.  Wielu z dawna piszących w @code{awk} programistów stosuje
@samp{print} w regułach @code{BEGIN} i @code{END} w znaczeniu
@samp{@w{print ""}}, polegając na tym, że @code{$0} jest puste.
Mimo, że ogólnie można tego uniknąć w regułach @code{BEGIN}, przynajmniej
w @code{gawk}, to jest to bardzo złym rozwiązaniem w regułach @code{END}.
Świadczy też o kiepskim stylu programowania, ponieważ jeżeli chcemy
pustego wiersza na wyjściu, powinniśmy w programie zapisać to wprost.

@node Pusty,  , BEGIN/END, Przegląd wzorców
@subsection Wzorzec pusty

@cindex pusty wzorzec
@cindex wzorzec pusty
Pusty (tj.@: nieistniejący) wzorzec jest uważany za dopasowujący
@emph{każdy} rekord wejściowy.  Na przykład, program:

@example
awk '@{ print $1 @}' BBS-list
@end example

@noindent
wypisuje pierwsze pole każdego rekordu.

@node Przegląd akcji,  , Przegląd wzorców, Wzorce i akcje
@section Przegląd akcji
@cindex akcja, definicja
@cindex nawiasy klamrowe
@cindex akcja, nawiasy klamrowe
@cindex akcja, oddzielanie instrukcji

Program lub skrypt @code{awk} składa się z szeregu przeplecionych reguł
i definicji funkcji.
(Funkcje są opisane dalej.  @xref{Użytkownika, ,Funkcje użytkownika}.)

Reguła zawiera wzorzec i akcję, z których każde (ale nie oba równocześnie)
może być pominięte.  Celem @dfn{akcji} jest przekazanie @code{awk}, co ma
zrobić po znalezieniu dopasowania do wzorca.  Zatem, w zarysie, program
@code{awk} ogólnie wygląda tak:

@example
@r{[}@var{wzorzec}@r{]} @r{[}@{ @var{akcja} @}@r{]}
@r{[}@var{wzorzec}@r{]} @r{[}@{ @var{akcja} @}@r{]}
@dots{}
function @var{nazwa}(@var{argumenty}) @{ @dots{} @}
@dots{}
@end example

Akcja składa się z jednej lub więcej @dfn{instrukcji} @code{awk}, zawartych
w nawiasach klamrowych (@samp{@{} i @samp{@}}).  Każda instrukcja określa
jedną rzecz do wykonania.  Instrukcje oddzielane są znakami nowej linii
lub średnikami.

Nawiasy klamrowe wokół akcji muszą być użyte nawet jeśli akcja zawiera
tylko jedną instrukcję, a nawet jeśli w ogóle nie zawiera instrukcji.
Jednak, jeżeli całkowicie pomijamy akcję, należy również pominąć
nawiasy klamrowe.  Pominięta akcja jest równoważna @samp{@{ print $0 @}}.

@example
/foo/  @{ @}  # dopasowuje foo, nic nie robi - akcja pusta
/foo/       # dopasowuje foo, wypisuje rekord - pominięta akcja
@end example

A oto rodzaje instrukcji obsługiwane przez @code{awk}:

@itemize @bullet
@item
Wyrażenia, które mogą wywoływać funkcje lub przypisywać wartości zmiennym
(@pxref{Wyrażenia}).  Wykonanie tego rodzaju instrukcji oblicza po prostu
wartość wyrażenia.
Przydatne gdy wyrażenie ma skutki uboczne.
(@pxref{Operatory przypisania, ,Wyrażenia przypisania}).

@item
Instrukcje sterujące, określające przebieg sterowania programów @code{awk}.
Język @code{awk} udostępnia konstrukty C-podobne
(@code{if}, @code{for}, @code{while} i @code{do}), jak i kilka specjalnych
(@pxref{Instrukcje, ,Instrukcje sterujące w akcjach}).

@item
Instrukcje złożone, składające się z jednej lub więcej instrukcji ujętych
w nawiasy klamrowe.  Instrukcję złożoną stosuje się w celu umieszczenia
w ciele instrukcji @code{if}, @code{while}, @code{do} lub @code{for}
kilku instrukcji razem.

@item
Instrukcje wejścia, korzystające z polecenia
@code{getline} (@pxref{Getline, ,Odczyt bezpośredni przez @code{getline}}),
instrukcji @code{next} (@pxref{Instrukcja next, ,Instrukcja @code{next}}),
i instrukcji
@code{nextfile} (@pxref{Instrukcja nextfile, ,Instrukcja @code{nextfile}}).

@item
Instrukcje wyjścia, @code{print} i @code{printf}.
@xref{Wypisywanie, ,Wypisywanie wyników}.

@item
Instrukcje usuwania, do usuwania elementów tablic.
@xref{Delete, ,Instrukcja @code{delete}}.
@end itemize

@iftex
Następny rozdział omawia szczegółowo instrukcje sterujące.
@end iftex

@node Instrukcje, Zmienne wbudowane, Wzorce i akcje, Top
@chapter Instrukcje sterujące w akcjach
@cindex instrukcja sterująca

@dfn{Instrukcje sterujące} jak @code{if}, @code{while}, i tak dalej sterują
przebiegiem wykonania programów @code{awk}.  Większość instrukcji
sterujących w @code{awk} wzorowana jest na podobnych instrukcjach z C.

Wszystkie instrukcje sterujące zaczynają się specjalnym słowem kluczowym,
jak np. @code{if} czy @code{while}, które odróżnia je od wyrażeń prostych.

@cindex instrukcja złożona
@cindex złożona, instrukcja
Wiele instrukcji sterujących zawiera inne instrukcje. Na przykład,
instrukcja @code{if} zawiera inną instrukcję, która może być wykonana
bądź nie.  Taka zawarta instrukcja zwana jest @dfn{ciałem} (body) instrukcji
sterującej.  Jeżeli w ciele instrukcji sterującej chcemy zawrzeć więcej
niż jedną instrukcję, to grupujemy je, za pomocą nawiasów klamrowych,
w pojedynczą @dfn{instrukcję złożoną}, oddzielając je od siebie znakami
nowej linii lub średnikami.

@menu
* Instrukcja if::               Warunkowe wykonanie pewnych instrukcji @code{awk}.
* Instrukcja while::            Pętla dopóki jest spełniony warunek.
* Instrukcja do::               Wykonywanie w pętli zadanej akcji aż do
                                spełnienia pewnego warunku.
* Instrukcja for::              Inna instrukcja pętli, która zapewnia
                                klauzule inicjalizacji i inkrementacji.
* Instrukcja break::            Natychmiastowe opuszczenie najbardziej
                                wewnętrznej obejmującej pętli.
* Instrukcja continue::         Skok na koniec najbardziej wewnętrznej
                                obejmującej pętli.
* Instrukcja next::             Zakończenie przetwarzania bieżącego
                                rekordu wejściowego.
* Instrukcja nextfile::         Zakończenie przetwarzania bieżącego pliku.
* Instrukcja exit::             Zakończenie wykonywania @code{awk}.
@end menu

@node Instrukcja if, Instrukcja while, Instrukcje, Instrukcje
@section Instrukcja @code{if}-@code{else}

@cindex @code{if}-@code{else} instrukcja
Instrukcja @code{if}-@code{else} jest w @code{awk} instrukcją ``podejmowania
decyzji''. Wygląda tak:

@example
if (@var{warunek}) @var{ciało-if} @r{[}else @var{ciało-else}@r{]}
@end example

@noindent
@var{Warunek} jest wyrażeniem, które decyduje o tym, co zrobi reszta
instrukcji.  Jeżeli @var{warunek} jest prawdziwy, to wykonywane jest
@var{ciało-if}; w przeciwnym razie, wykonywane jest @var{ciało-else}.
Część @code{else} instrukcji jest opcjonalna.  Warunek jest uważany za
fałszywy jeśli jego wartością jest zero lub łańcuch pusty, w przeciwnym
wypadku za prawdziwy.

Oto przykład:

@example
if (x % 2 == 0)
    print "x jest parzyste"
else
    print "x jest nieparzyste"
@end example

W tym przykładzie, jeśli wyrażenie @samp{x % 2 == 0} jest prawdziwe (to
jest, wartość @code{x} dzieli się przez dwa bez reszty), to wykonywana jest
pierwsza instrukcja @code{print}, w przeciwnym razie wykonywana jest druga
instrukcja @code{print}.

Jeśli @code{else} pojawia się w tym samym wierszu, co @var{ciało-if},
a @var{ciało-if} nie jest instrukcją złożoną (tj.@: nie jest otoczone
nawiasami klamrowymi), to @var{ciało-if} musi być oddzielone od @code{else}
średnikiem.  Dla ilustracji, napiszmy na nowo poprzedni przykład:

@example
if (x % 2 == 0) print "x jest parzyste"; else
        print "x jest nieparzyste"
@end example

@noindent
Jeżeli zapomnimy średnika @samp{;}, to @code{awk} nie będzie w stanie
zinterpretować instrukcji i otrzymamy błąd składniowy.

W rzeczywistości powyższego przykładu nie napisalibyśmy w ten sposób,
gdyż czytelnik mógłby nie zauważyć @code{else} gdyby nie było pierwszą
rzeczą w wierszu.

@node Instrukcja while, Instrukcja do, Instrukcja if, Instrukcje
@section Instrukcja @code{while}
@cindex @code{while} instrukcja
@cindex pętla
@cindex ciało pętli

W programowaniu słowo @dfn{pętla} (loop) oznacza część programu, która może
być wykonana kolejno dwa lub więcej razy z rzędu.

Instrukcja @code{while} jest najprostszą instrukcją pętli w @code{awk}.
Powtarza wykonywanie instrukcji dopóki warunek jest prawdziwy.  Wygląda tak:

@example
while (@var{warunek})
  @var{ciało}
@end example

@noindent
gdzie @var{ciało} jest instrukcją, którą nazywamy @dfn{ciałem} pętli, zaś
@var{warunek} jest wyrażeniem decydującym o tym, jak długo ma działać pętla.

Pierwszą rzeczą, jaką robi instrukcja @code{while} jest sprawdzenie
@var{warunku}.  Jeżeli jest prawdziwy, to wykonuje ona instrukcję
@var{ciało}.
@ifinfo
(@var{Warunek} jest prawdziwy gdy ma wartość niezerową i nie jest łańcuchem
pustym.)
@end ifinfo
Po wykonaniu @var{ciała} pętli @var{warunek} jest testowany ponownie
i jeżeli nadal jest prawdziwy, powtórnie wykonywane jest @var{ciało}.
Proces ten powtarza się aż @var{warunek} przestanie być prawdziwy.
Jeżeli @var{warunek} jest początkowo fałszywy, to ciało funkcji nie
jest nigdy wykonywane, a @code{awk} kontynuuje pracę używając kolejnej
po pętli instrukcji.

Ten przykład wypisuje pierwsze trzy pola każdego rekordu, po jednym
w wierszu.

@example
awk '@{ i = 1
       while (i <= 3) @{
           print $i
           i++
       @}
@}' inventory-shipped
@end example

@noindent
Tu ciałem pętli jest ujęta w nawiasy klamrowe instrukcja złożona,
zawierająca dwie instrukcje.

Nasza pętla działa tak: najpierw do @code{i} przypisywane jest jeden.
Następnie, @code{while} sprawdza, czy @code{i} jest mniejsze lub równe trzy.
Jest to prawdą gdy @code{i} równa się jeden, więc wypisywane jest @code{i}-te
pole.  Potem @samp{i++} zwiększa wartość @code{i} o jeden i pętla się
powtarza.  Pętla kończy pracę, gdy @code{i} dojdzie do czterech.

Jak widać, pomiędzy warunkiem a ciałem nie jest wymagany znak nowej linii,
ale zastosowanie go czyni program czytelniejszym,
chyba że ciało jest instrukcją złożoną lub jest bardzo proste.  Znak nowej
linii po otwierającym nawiasie klamrowym, który rozpoczyna instrukcję
złożoną, także nie jest konieczny, ale bez niego program byłby trudniejszy
do czytania.

@node Instrukcja do, Instrukcja for, Instrukcja while, Instrukcje
@section Instrukcja @code{do}-@code{while}

Pętla @code{do} jest odmianą instrukcji pętli @code{while}.
Instrukcja @code{do} wykonuje jednokrotnie @var{ciało}, a następnie
powtarza jego wykonywanie dopóki @var{warunek} jest prawdziwy. Wygląda tak:

@example
@group
do
  @var{ciało}
while (@var{warunek})
@end group
@end example

Nawet jeżeli @var{warunek} jest fałszywy na starcie, @var{ciało} zostanie
wykonane co najmniej raz (i tylko raz, chyba że wykonanie go spowoduje, że
@var{warunek} stanie się prawdziwy).  Inaczej jest z odpowiednią instrukcją
@code{while}:

@example
while (@var{warunek})
  @var{ciało}
@end example

@noindent
Ta instrukcja nie wykona @var{ciała} ani razu jeśli @var{warunek}, z którym
rozpoczyna jest fałszywy.

Oto przykład instrukcji @code{do}:

@example
awk '@{ i = 1
       do @{
          print $0
          i++
       @} while (i <= 10)
@}'
@end example

@noindent
Ten program wypisuje każdy rekord dziesięć razy.  Nie jest to zbyt
realistyczny przykład, gdyż w tym przypadku równie dobrze wystarczyłoby
zwykłe @code{while}.
Odzwierciedla to rzeczywistą praktykę: faktyczna potrzeba użycia
@code{do} występuje tylko sporadycznie.

@node Instrukcja for, Instrukcja break, Instrukcja do, Instrukcje
@section Instrukcja @code{for}
@cindex @code{for} instrukcja

Instrukcja @code{for} ułatwia zliczanie iteracji pętli.  Ogólna postać
instrukcji @code{for} wygląda tak:

@example
for (@var{inicjalizacja}; @var{warunek}; @var{inkrement})
  @var{ciało}
@end example

@noindent
Części @var{inicjalizacja}, @var{warunek} i @var{inkrement} są dowolnymi
wyrażeniami @code{awk}, zaś @var{ciało} oznacza dowolną instrukcję
@code{awk}.

Instrukcja @code{for} zaczyna pracę od wykonania @var{inicjalizacji}.
Następnie, dopóki @var{warunek} jest prawdziwy, powtarza wykonywanie
@var{ciała} a potem @var{inkrementu}.  Typowo @var{inicjalizacja} nadaje
pewnej zmiennej wartość zero lub jeden,  @var{inkrement} dodaje do niej
jeden, a @var{warunek} porównuje ją z pożądaną liczbą iteracji.

Oto przykład instrukcji @code{for}:

@example
@group
awk '@{ for (i = 1; i <= 3; i++)
          print $i
@}' inventory-shipped
@end group
@end example

@noindent
Wypisuje on pierwsze trzy pola każdego rekordu wejściowego, po jednym polu
w wierszu.

W części @var{inicjalizacja} nie można nadać wartości więcej niż jednej
zmiennej, chyba że posłużymy się przypisaniem wielokrotnym, jak np.
@samp{x = y = 0}, które jest możliwe tylko gdy wszystkie wartości
początkowe są równe.  (Można jednak zainicjować dodatkowe zmienne pisząc
przypisania do nich jako osobne instrukcje przed pętlą @code{for}.)

Obowiązuje to także dla części @var{inkrement}; chcąc zwiększać dodatkowe
zmienne, musimy napisać osobne instrukcje na końcu pętli.  W tym kontekście
przydatne byłoby wyrażenie złożone z C, używające separatora przecinkowego,
ale nie jest ono rozpoznawane w @code{awk}.

Najczęściej @var{inkrement} jest wyrażeniem inkrementującym, jak w
przykładzie powyżej.  Nie jest to jednak wymagane; może to być jakiekolwiek
wyrażenie dowolnego typu.  Na przykład, ta instrukcja wypisuje wszystkie
potęgi dwójki między jeden a 100:

@example
for (i = 1; i <= 100; i *= 2)
  print i
@end example

Można pominąć dowolne z trzech wyrażeń występujących w nawiasach
po @code{for} jeśli ma ono nic nie robić.  Zatem, @w{@samp{for (; x > 0;)}}
jest równoważne @w{@samp{while (x > 0)}}.  Jeżeli pominięto @var{warunek},
jest on traktowany jak @var{prawda} (true), w rezultacie powodując
@dfn{nieskończoną pętlę} (tj.@: pętlę, która nigdy nie zakończy pracy).

W większości przypadków pętla @code{for} jest skrótem pętli @code{while},
jak pokazano tutaj:

@example
@var{inicjalizacja}
while (@var{warunek}) @{
  @var{ciało}
  @var{inkrement}
@}
@end example

@noindent
Jedyny wyjątek stanowi sytuacja, gdy wewnątrz pętli zastosowano instrukcję
@code{continue}
(@pxref{Instrukcja continue, ,Instrukcja @code{continue}}).
Zmiana w podany sposób instrukcji @code{for} na @code{while} może
zmienić skutki instrukcji @code{continue} wewnątrz pętli.

Istnieje alternatywna wersja pętli @code{loop} przeznaczona do przechodzenia
kolejno po wszystkich indeksach tablicy:

@example
for (i in tablica)
    @var{zrób coś z} tablica[i]
@end example

@noindent
@xref{Przeglądanie tablic, ,Przeglądanie wszystkich elementów tablicy},
gdzie jest więcej o tej wersji pętli @code{for}.

Język @code{awk} oprócz instrukcji @code{while} ma instrukcję
@code{for}, ponieważ często pętla @code{for} jest mniej pracochłonna przy
wpisywaniu i bardziej naturalna w myśleniu o niej.
W pętlach zliczanie liczby iteracji jest bardzo częste.  Łatwiej jest
myśleć o zliczaniu jako o części pętli niż jako o czymś, co ma być zrobione
wewnątrz niej.

Następna sekcja zawiera bardziej skomplikowane przykłady pętli @code{for}.

@node Instrukcja break, Instrukcja continue, Instrukcja for, Instrukcje
@section Instrukcja @code{break}
@cindex @code{break} instrukcja
@cindex pętle, wychodzenie z

Instrukcja @code{break} wyskakuje z najbardziej wewnętrznej obejmującej ją
pętli @code{for}, @code{while} lub @code{do}.  Poniższy program znajduje
najmniejszy dzielnik liczby całkowitej, rozpoznaje też liczby pierwsze:

@example
awk '# znajdź najmniejszy dzielnik liczby num
     @{ num = $1
@group
       for (div = 2; div*div <= num; div++)
         if (num % div == 0)
           break
@end group
       if (num % div == 0)
         printf "Najmniejszym dzielnikiem %d jest %d\n", num, div
       else
         printf "%d jest liczbą pierwszą\n", num
     @}'
@end example

Gdy resztą z dzielenia w pierwszej instrukcji @code{if} jest zero,
@code{awk} natychmiast @dfn{przerywa} (breaks out) działanie
zawierającej ją pętli @code{for}.  Oznacza to, że @code{awk} przechodzi
bezzwłocznie do instrukcji następującej po pętli i kontynuuje przetwarzanie.
(Jest to całkiem inne niż instrukcja @code{exit}, która zatrzymuje cały
program @code{awk}.
@xref{Instrukcja exit, ,Instrukcja @code{exit}}.)

Oto inny program równoważny poprzedniemu.  Ilustruje sposób, w jaki
@code{warunek} pętli @code{for} lub @code{while} może być równie dobrze
zastąpiony przez @code{break} wewnątrz @code{if}:

@example
@group
awk '# znajdź najmniejszy dzielnik liczby num
     @{ num = $1
       for (div = 2; ; div++) @{
         if (num % div == 0) @{
           printf "Najmniejszym dzielnikiem %d jest %d\n", num, div
           break
         @}
         if (div*div > num) @{
           printf "%d jest liczbą pierwszą\n", num
           break
         @}
       @}
@}'
@end group
@end example

@cindex @code{break}, poza pętlami
@cindex cechy historyczne
@cindex język @code{awk}, wersja POSIX
@cindex POSIX @code{awk}
@cindex ciemny kąt
Jak opisano powyżej, instrukcja @code{break} nie ma żadnego znaczenia, jeśli
użyta jest poza ciałem pętli. Jednak, mimo iż nigdy tego nie
udokumentowano, historyczne implementacje @code{awk} traktowały @code{break}
poza pętlą tak, jakby była to instrukcja @code{next}
(@pxref{Instrukcja next, ,Instrukcja @code{next}}).
Najnowsze wersje uniksowego @code{awk} nie pozwalają już na taki sposób
użycia.  @code{gawk} obsługuje takie użycie @code{break} tylko jeśli
w wierszu poleceń podano opcję @samp{--traditional}
(@pxref{Opcje, ,Opcje wiersza poleceń}).
W przeciwnym wypadku, zostanie ono potraktowane jako błąd, gdyż standard
POSIX określa, że @code{break} powinno być stosowane wyłącznie wewnątrz
ciała pętli (c.k.).

@node Instrukcja continue, Instrukcja next, Instrukcja break, Instrukcje
@section Instrukcja @code{continue}

@cindex @code{continue} instrukcja
Instrukcja @code{continue}, podobnie jak @code{break}, używana jest tylko
wewnątrz pętli @code{for}, @code{while} i @code{do}.  Pomija ona resztę
ciała pętli, powodując natychmiastowe rozpoczęcie kolejnego cyklu pętli.
Zwróć uwagę na różnicę w stosunku do @code{break}, które całkowicie
wyskakuje z pętli.

@c The point of this program was to illustrate the use of continue with
@c a while loop. But Karl Berry points out that that is done adequately
@c below, and that this example is very un-awk-like. So for now, we'll
@c omit it.
@ignore
In Texinfo source files, text that the author wishes to ignore can be
enclosed between lines that start with @samp{@@ignore} and end with
@samp{@atend ignore}.  Here is a program that strips out lines between
@samp{@@ignore} and @samp{@atend ignore} pairs.

@example
BEGIN @{
    while (getline > 0) @{
       if (/^@@ignore/)
           ignoring = 1
       else if (/^@@end[ \t]+ignore/) @{
           ignoring = 0
           continue
       @}
       if (ignoring)
           continue
       print
    @}
@}
@end example

When an @samp{@@ignore} is seen, the @code{ignoring} flag is set to one (true).
When @samp{@atend ignore} is seen, the flag is reset to zero (false). As long
as the flag is true, the input record is not printed, because the
@code{continue} restarts the @code{while} loop, skipping over the @code{print}
statement.

@c Exercise!!!
@c How could this program be written to make better use of the awk language?
@end ignore

Instrukcja @code{continue} w pętli @code{for} nakazuje @code{awk}
przeskoczenie reszty ciała pętli i wznowienie jej wykonywania od
wyrażenia inkrementacji instrukcji @code{for}.
Ten fakt ilustruje poniższy program:

@example
awk 'BEGIN @{
     for (x = 0; x <= 20; x++) @{
         if (x == 5)
             continue
         printf "%d ", x
     @}
     print ""
@}'
@end example

@noindent
Program wypisuje wszystkie liczby od zera do 20, z wyjątkiem piątki,
dla której @code{printf} jest pomijane.  Ponieważ nie jest pomijany
inkrement @samp{x++}, @code{x} nie pozostanie zaklinowane na pięciu.
Inaczej niż w pętli @code{loop} powyżej jest w tej pętli @code{while}:

@example
awk 'BEGIN @{
     x = 0
     while (x <= 20) @{
         if (x == 5)
             continue
         printf "%d ", x
         x++
     @}
     print ""
@}'
@end example

@noindent
Ten program od momentu, gdy @code{x} otrzyma wartość pięć, będzie wykonywał
wieczną pętlę.

@cindex @code{continue}, poza pętlami
@cindex cechy historyczne
@cindex język @code{awk}, wersja POSIX
@cindex POSIX @code{awk}
@cindex ciemny kąt
Jak opisano powyżej, instrukcja @code{continue} nie ma żadnego znaczenia,
jeśli użyta jest poza ciałem pętli. Jednak, mimo iż nigdy tego nie
udokumentowano, historyczne implementacje @code{awk} traktowały
@code{continue} poza pętlą tak, jakby była to instrukcja @code{next}
(@pxref{Instrukcja next, ,Instrukcja @code{next}}).
Najnowsze wersje uniksowego @code{awk} nie pozwalają już na taki sposób
użycia.  @code{gawk} obsługuje takie użycie @code{continue} tylko jeśli
w wierszu poleceń podano opcję @samp{--traditional}
(@pxref{Opcje, ,Opcje wiersza poleceń}).
W przeciwnym wypadku, zostanie ono potraktowane jako błąd, gdyż standard
POSIX określa, że @code{continue} powinno być stosowane wyłącznie wewnątrz
ciała pętli (c.k.).

@node Instrukcja next, Instrukcja nextfile, Instrukcja continue, Instrukcje
@section Instrukcja @code{next}
@cindex @code{next} instrukcja

Instrukcja @code{next} wymusza na @code{awk} natychmiastowe przerwanie
przetwarzania bieżącego rekordu i przejście do następnego.  Znaczy to, że
dla bieżącego rekordu nie będą wykonywane żadne dalsze reguły.
Nie będzie też wykonywana reszta akcji aktualnej reguły.

Różni się to od skutków funkcji @code{getline}
(@pxref{Getline, ,Odczyt bezpośredni przez @code{getline}}).
@code{getline} również powoduje, że @code{awk} odczytuje natychmiast kolejny
rekord, ale nie zmienia w żaden sposób przebiegu sterowania.  Tak więc,
z nowym rekordem wejściowym wykonywana jest dalsza część bieżącej akcji.

Na najwyższym poziomie wykonanie programu @code{awk} jest pętlą, która
czyta rekord wejściowy i sprawdza go ze wzorcem każdej reguły.
Jeśli myślimy o tej pętli jak o instrukcji @code{for}, której ciało zawiera
reguły, to instrukcja @code{next} jest analogiczna do @code{continue}:
przeskakuje na koniec ciała tej niejawnej pętli i wykonuje inkrementację
(która czyta kolejny rekord).

Na przykład, jeżeli program @code{awk} działa tylko na rekordach
o czterech polach, i nie chcemy by pracował błędnie gdy otrzyma złe
wejście, możemy wykorzystać taką regułę blisko początku programu:

@example
@group
NF != 4 @{
  err = sprintf("%s:%d: pominięty: NF != 4\n", FILENAME, FNR)
  print err > "/dev/stderr"
  next
@}
@end group
@end example

@noindent
tak, że kolejne reguły nie otrzymają nieprawidłowego rekordu.  Komunikat o
błędzie przekierowywany jest do standardowego strumienia błędów,
tak jak powinny być kierowane komunikaty o błędach.
@xref{Pliki specjalne, ,Specjalne nazwy plików w @code{gawk}}.

@cindex język @code{awk}, wersja POSIX
@cindex POSIX @code{awk}
Zgodnie ze standardem POSIX, jeśli instrukcja @code{next} jest użyta
w regule @code{BEGIN} lub @code{END} to zachowanie się programu jest
niezdefiniowane.
@code{gawk} będzie traktował taką sytuację jako błąd składniowy.
Mimo, że POSIX na to zezwala, niektóre inne implementacje @code{awk}
nie pozwalają na umieszczanie instrukcji @code{next} wewnątrz ciała funkcji
(@pxref{Użytkownika, ,Funkcje użytkownika}).
Tak jak każda inna instrukcja @code{next},  @code{next} we wnętrzu
ciała funkcji czyta następny rekord i rozpoczyna jego przetwarzanie
za pomocą pierwszej reguły programu.

Jeżeli instrukcja @code{next} spowoduje osiągnięcie końca wejścia,
to zostanie wykonany kod z ewentualnych reguł @code{END}.
@xref{BEGIN/END, ,Wzorce specjalne @code{BEGIN} i @code{END}}.

@cindex @code{next}, wewnątrz funkcji definiowanych przez użytkownika
@strong{Uwaga!} Niektóre implementacje @code{awk} generują błąd
wykonania jeśli użyjemy instrukcji @code{next} wewnątrz funkcji
zdefiniowanej przez użytkownika
(@pxref{Użytkownika, ,Funkcje użytkownika}).
@code{gawk} nie ma takiego problemu.

@node Instrukcja nextfile, Instrukcja exit, Instrukcja next, Instrukcje
@section Instrukcja @code{nextfile}
@cindex @code{nextfile} instrukcja
@cindex różnice między @code{gawk} a @code{awk}

@code{gawk} udostępnia instrukcję @code{nextfile}, która jest zbliżona do
instrukcji @code{next}.  Jednak, zamiast zaprzestania przetwarzania bieżącego
rekordu, instrukcja @code{nextfile} rozkazuje @code{gawk} przerwanie
przetwarzania bieżącego pliku danych.

Podczas wykonania instrukcji @code{nextfile}, @code{FILENAME} aktualizowane
jest nazwą następnego podanego w wierszu poleceń pliku danych, @code{FNR}
ponownie otrzymuje początkową wartość jeden, zwiększane jest @code{ARGIND},
a przetwarzanie rozpoczyna się od nowa od pierwszej reguły programu.
@xref{Zmienne wbudowane}.

Jeżeli @code{nextfile} spowoduje osiągnięcie końca wejścia,
to zostanie wykonany kod ewentualnych reguł @code{END}.
@xref{BEGIN/END, ,Wzorce specjalne @code{BEGIN} i @code{END}}.

Instrukcja @code{nextfile} jest rozszerzeniem @code{gawk}; nie jest ona
(obecnie) dostępna w żadnej innej implementacji @code{awk}.
@xref{Funkcja nextfile, ,Implementacja @code{nextfile} jako funkcji},
gdzie podano funkcję definiowaną przez użytkownika, jaką można wykorzystać
do symulacji instrukcji @code{nextfile}.

Instrukcja @code{nextfile} może być użyteczna jeśli mamy do przetworzenia
wiele plików danych, a spodziewamy się, że nie będziemy chcieć
przetwarzać każdego rekordu w każdym pliku.  Normalnie, w celu przejścia do
następnego pliku danych, musielibyśmy kontynuować przeglądanie niepożądanych
rekordów.  Instrukcja @code{nextfile} realizuje to znacznie efektywniej.

@cindex @code{next file} instrukcja
@strong{Uwaga!}  Wersje @code{gawk} wcześniejsze niż 3.0 używały dwu
słów (@samp{next file}) do zapisania instrukcji @code{nextfile}.
W wersji 3.0 zmieniono to na jedno słowo, gdyż traktowanie słowa @samp{file}
było niespójne.  Gdy pojawiało się po @code{next}, było słowem kluczowym.
W przeciwnym razie, było zwykłym identyfikatorem.  Stara składnia jest nadal
akceptowana.  @code{gawk} wygeneruje jednak komunikat ostrzegawczy,
a obsługa @code{next file} ostatecznie przestanie być kontynuowana
w przyszłych wersjach @code{awk}.

@node Instrukcja exit,  , Instrukcja nextfile, Instrukcje
@section Instrukcja @code{exit}

@cindex @code{exit} instrukcja
Instrukcja @code{exit} powoduje, że @code{awk} natychmiast przestaje
wykonywać bieżącą regułę i przestaje przetwarzać dane wejściowe; wszelkie
pozostałe wejście jest ignorowane.  Wygląda tak:

@example
exit @r{[}@var{kod powrotu}@r{]}
@end example

Jeśli instrukcja @code{exit} zostanie wykonana z reguły @code{BEGIN},
to program natychmiast wstrzymuje wszelkie przetwarzanie.  Nie są czytane
żadne rekordy wejściowe.  Jednak, jeśli istnieje reguła @code{END},
to jest ona wykonywana.
(@pxref{BEGIN/END, ,Wzorce specjalne @code{BEGIN} i @code{END}}).

Jeżeli @code{exit} użyte jest jako część reguły @code{END}, powoduje
natychmiastowe zatrzymanie programu.

Instrukcja @code{exit} nie będąca częścią ani reguły @code{BEGIN} ani
@code{END} wstrzymuje wykonywanie ewentualnych dalszych automatycznych
reguł dla bieżącego rekordu, pomija odczyt pozostałych rekordów wejściowych,
i wykonuje regułę @code{END}, jeśli taka istnieje.

Jeżeli nie chcemy, by w takim przypadku reguła @code{END} wykonała swe
zadanie, możemy przed instrukcją @code{exit} przypisać jakiejś zmiennej
wartość niezerową i sprawdzić tę zmienną w regule @code{END}.
@xref{Funkcja assert, ,Asercje}, gdzie jest przykład, który to robi.

@cindex ciemny kąt
Jeżeli podano argument instrukcji @code{exit}, to jego wartość jest
wykorzystywana jako kod zakończenia procesu @code{awk}.  Jeśli nie podano
argumentu, @code{exit} zwraca kod zero (powodzenie).  W przypadku, gdy
podano argument pierwszej instrukcji @code{exit}, a następnie wywołano
@code{exit} po raz drugi bez argumentu, używana jest poprzednio podana
wartość zakończenia (c.k.).

Na przykład, powiedzmy, że wykryliśmy warunek wystąpienia błędu, który
naprawdę nie wiemy jak obsłużyć.  Zwyczajowo programy zgłaszają
taką sytuację kończąc pracę z niezerowym kodem.  Nasz program @code{awk}
może to robić korzystając z instrukcji @code{exit} z niezerowym argumentem.
Oto przykład:

@example
@group
BEGIN @{
       if (("date" | getline date_now) <= 0) @{
         print "Nie mogę pobrać daty systemowej" > "/dev/stderr"
         exit 1
       @}
       print "bieżąca data to", date_now
       close("date")
@}
@end group
@end example

@node Zmienne wbudowane, Tablice, Instrukcje, Top
@chapter Zmienne wbudowane
@cindex zmienne wbudowane

Większość zmiennych @code{awk} możemy wykorzystywać do własnych
celów.  Nie są one nigdy zmieniane, poza sytuacjami, gdy nasz program
przypisuje im wartości, i nigdy na nic nie wpływają, poza sytuacjami
gdy bada je nasz program.  Jednak kilka zmiennych w @code{awk} ma specjalne,
wbudowane znaczenie.  Niektóre z nich @code{awk} sprawdza automatycznie,
więc umożliwiają nam wskazanie @code{awk} jak ma wykonywać pewne rzeczy.
Inne są automatycznie przypisywane przez @code{awk}, więc dostarczają
naszemu programowi informacje o wewnętrznych działaniach @code{awk}.

Niniejszy rozdział dokumentuje wszystkie zmienne wbudowane @code{gawk}.
Większość z nich jest także omówiona w rozdziałach opisujących ich zakresy
działania.

@menu
* Modyfikowalne::               Zmienne wbudowane, którymi sterujemy
                                pracą @code{awk}.
* Auto-ustalane::               Zmienne wbudowane, w których @code{awk}
                                udostępnia różne informacje.
* ARGC i ARGV::                 Metody korzystania z @code{ARGC} i @code{ARGV}.
@end menu

@node Modyfikowalne, Auto-ustalane, Zmienne wbudowane, Zmienne wbudowane
@section Zmienne wbudowane sterujące pracą @code{awk}
@cindex zmienne wbudowane, modyfikowalne przez użytkownika

Poniżej podano alfabetyczną listę zmiennych, które można zmieniać
sterując w ten sposób metodami wykonywania przez @code{awk} różnych
rzeczy.  Zmienne specyficzne dla @code{gawk} oznaczono gwiazdką, @samp{*}.

@table @code
@vindex CONVFMT
@cindex język @code{awk}, wersja POSIX
@cindex POSIX @code{awk}
@item CONVFMT
Ten łańcuch steruje konwersją liczb na łańcuchy
(@pxref{Konwersja, ,Konwersja łańcuchów i liczb}).
W praktyce, działa dzięki temu, że jest przekazywany jako pierwszy argument
funkcji @code{sprintf}
(@pxref{Funkcje łańcuchowe, ,Funkcje wbudowane działające na łańcuchach}).
Jego domyślną wartością jest @code{"%.6g"}.
@code{CONVFMT} zostało wprowadzone przez standard POSIX.

@vindex FIELDWIDTHS
@item FIELDWIDTHS *
Jest to lista rozdzielonych spacjami kolumn, mówiąca @code{gawk} jak
podzielić wejście o stałych, kolumnowych granicach pól.  Jest to cecha
eksperymentalna.  Przypisanie do @code{FIELDWIDTHS} przesłania użycie
do podziału na pola zmiennej @code{FS}.
@xref{Stały rozmiar, ,Czytanie danych o stałej szerokości}, gdzie opisano ją szerzej.

Jeżeli @code{gawk} jest w trybie zgodności
(@pxref{Opcje, ,Opcje wiersza poleceń}), to @code{FIELDWIDTHS} nie ma
znaczenia specjalnego, a operacje podziału na pola są wykonywane wyłącznie
w oparciu o wartość @code{FS}.

@vindex FS
@item FS
@code{FS} jest separatorem pól wejściowych
(@pxref{Separatory pól, ,Jak rozdzielać pola}).
Jego wartość jest jednoznakowym łańcuchem lub wieloznakowym wyrażeniem
regularnym dopasowującym oddzielenia między polami rekordu wejściowego.
Jeżeli wartością jest łańcuch pusty (@code{""}), to każdy znak rekordu
staje się osobnym polem.

Domyślną wartością jest @w{@code{" "}}, łańcuch składający się z pojedynczej
spacji.  Jako specjalny wyjątek, wartość ta oznacza, że jednym separatorem
jest dowolny ciąg spacji, tabulacji i/lub znaków nowej linii. @footnote{W
POSIX-owym @code{awk}, znak nowej linii nie jest uważany za biały znak.}
Powoduje ona również, że będą ignorowane wszelkie spacje, tabulacje i znaki
nowej linii na początku i końcu rekordu.

@code{FS} można nadać wartość w wierszu poleceń stosując opcję @samp{-F}:

@example
awk -F, '@var{program}' @var{pliki-wejściowe}
@end example

Jeśli @code{gawk} do podziału na pola wykorzystuje @code{FIELDWIDTHS},
przypisanie wartości do @code{FS} spowoduje, że powróci on do zwykłego,
opartego na @code{FS}, podziału na pola.  Można to łatwo zrobić pisząc
po prostu @samp{FS = FS}, być może z komentarzem objaśniającym.

@vindex IGNORECASE
@item IGNORECASE *
Jeżeli @code{IGNORECASE} jest niezerowe lub niepuste, to wszystkie
porównania łańcuchów i dopasowania wyrażeń regularnych są niewrażliwe
na wielkość liter.  Zatem, wszystkie wyrażenia regularne z @samp{~}
i @samp{!~}, funkcje @code{gensub}, @code{gsub}, @code{index}, @code{match},
@code{split} i @code{sub}, zakończenia rekordów za pomocą @code{RS}
oraz podział na pola przez @code{FS} ignorują wielkość liter przy
wykonywaniu odpowiednich działań na wyrażeniach regularnych.
Wartość @code{IGNORECASE} @emph{nie} wpływa na indeksowanie tablic.
@xref{Wielkość liter, ,Wielkość liter w dopasowaniach}.
Jeżeli @code{gawk} pracuje w trybie zgodności
(@pxref{Opcje, ,Opcje wiersza poleceń}),
to @code{IGNORECASE} nie posiada żadnego szczególnego znaczenia,
a działania na łańcuchach i wyrażeniach regularnych zawsze rozróżniają małe
i duże litery.

@vindex OFMT
@item OFMT
Łańcuch ten steruje konwersją liczb na łańcuchy
(@pxref{Konwersja, ,Konwersja łańcuchów i liczb}) przy
wypisywaniu ich za pomocą instrukcji @code{print}.
W praktyce, działa dzięki temu, że jest przekazywany jako pierwszy argument
funkcji @code{sprintf}
(@pxref{Funkcje łańcuchowe, ,Funkcje wbudowane działające na łańcuchach}).
Jego domyślną wartością jest @code{"%.6g"}.  Wcześniejsze wersje @code{awk}
wykorzystywały też @code{OFMT} do określenia uniwersalnego formatu konwersji
liczb na łańcuchy we wszelkich wyrażeniach.  Obecnie jest to wykonywane
przez @code{CONVFMT}.

@vindex OFS
@item OFS
Jest to separator pól wyjściowych (@pxref{Separatory wyjścia}),
wypisywany pomiędzy polami wypisywanymi przez instrukcję @code{print}.
Jego wartość domyślna to @w{@code{" "}}, łańcuch składający się
z pojedynczej spacji.

@vindex ORS
@item ORS
Jest to separator rekordów wyjściowych, wypisywany na końcu każdej
instrukcji @code{print}.  Jego wartością domyślną jest @code{"\n"}.
(@xref{Separatory wyjścia}.)

@vindex RS
@item RS
W @code{awk} jest separatorem rekordów wejściowych.  Jego wartością domyślną
jest łańcuch zawierający pojedynczy znak nowej linii, co znaczy, że rekordy
wejściowe składają się z pojedynczego wiersza tekstu.  Może być też
łańcuchem pustym, wówczas rekordy rozdzielane są ciągami pustych wierszy,
albo wyrażeniem regularnym, wówczas rekordy rozdzielane są dopasowaniami
tego wyrażenia w tekście wejściowym.
(@xref{Rekordy, ,Jak wejście dzielone jest na rekordy}.)

@vindex SUBSEP
@item SUBSEP
@code{SUBSEP} jest separatorem indeksów.  Ma wartość domyślną @code{"\034"}
i jest wykorzystywany do podziału na części indeksów tablicy wielowymiarowej.
Zatem, wyrażenie @code{@w{foo["A", "B"]}} odwołuje się do
@code{foo["A\034B"]} (@pxref{Wielowymiarowe, ,Tablice wielowymiarowe}).
@end table

@node Auto-ustalane, ARGC i ARGV, Modyfikowalne, Zmienne wbudowane
@section Zmienne wbudowane niosące informacje
@cindex zmienne wbudowane, niosące informacje

Niżej podano alfabetyczną listę zmiennych, którym w różnych okolicznościach
@code{awk} automatycznie nadaje wartość w celu dostarczenia informacji
programowi użytkownika.
Zmienne specyficzne dla @code{gawk} oznaczono gwiazdką, @samp{*}.

@table @code
@vindex ARGC
@vindex ARGV
@item ARGC
@itemx ARGV
Argumenty wiersza poleceń dostępne dla programów @code{awk} przechowywane
są w tablicy o nazwie @code{ARGV}.  @code{ARGC} jest liczbą argumentów
obecnych w wierszu poleceń.
@xref{Inne argumenty, ,Inne argumenty wiersza poleceń}.
Inaczej niż większość tablic @code{awk}, @code{ARGV} jest indeksowana
od zera do @code{ARGC} @minus{} 1.  Na przykład:

@example
@group
$ awk 'BEGIN @{
>        for (i = 0; i < ARGC; i++)
>            print ARGV[i]
>      @}' inventory-shipped BBS-list
@print{} awk
@print{} inventory-shipped
@print{} BBS-list
@end group
@end example

@noindent
W tym przykładzie @code{ARGV[0]} zawiera @code{"awk"}, @code{ARGV[1]}
zawiera @code{"inventory-shipped"}, zaś @code{ARGV[2]} zawiera
@code{"BBS-list"}.  Wartość @code{ARGC} wynosi trzy, o jeden więcej niż
indeks ostatniego elementu w @code{ARGV}, gdyż elementy są numerowane
od zera.

Nazwy @code{ARGC} i @code{ARGV}, jak i konwencja indeksowania tablicy od
zera do @code{ARGC} @minus{} 1, pochodzą od metody dostępu do argumentów
wiersza poleceń występującej w języku C.
@xref{ARGC i ARGV, , Używanie @code{ARGC} i @code{ARGV}}, gdzie opisano,
jak @code{awk} używa tych zmiennych.

@vindex ARGIND
@item ARGIND *
Indeks w @code{ARGV} aktualnie przetwarzanego pliku.  Za każdym razem, gdy
@code{gawk} otwiera do przetworzenia nowy plik danych, przypisuje
@code{ARGIND} indeks wskazujący na nazwę pliku w @code{ARGV}.  Podczas
przetwarzania przez @code{gawk} plików wejściowych, zawsze prawdziwe
jest @samp{FILENAME == ARGV[ARGIND]}.

Zmienna przydaje się przy przetwarzaniu plików wejściowych.  Umożliwia
stwierdzenie, jak daleko na liście plików danych jesteśmy, i rozróżnienie
kolejnych wystąpień tej samej nazwy pliku w wierszu poleceń.

Mimo, iż wartość @code{ARGIND} wewnątrz programu można zmieniać, to
@code{gawk} automatycznie nada jej nową wartość przy otwieraniu
następnego pliku.

Zmienna ta jest rozszerzeniem @code{gawk}.  W innych implementacjach
@code{awk}, lub gdy @code{gawk} działa w trybie zgodności
(@pxref{Opcje, ,Opcje wiersza poleceń}), nie jest specjalna.

@vindex ENVIRON
@item ENVIRON
Tablica asocjacyjna (przyporządkowująca) zawierająca wartości środowiska.
Indeksy tablicy są nazwami zmiennych środowiska, wartości są wartościami
odpowiednich zmiennych środowiska.  Na przykład, @code{ENVIRON["HOME"]} może
zawierać @file{/home/arnold}.  Zmiana tej tablicy nie wpływa na środowisko
przekazywane programom, które @code{awk} wywołuje za pośrednictwem
przekierowań czy funkcji @code{system}.  (W przyszłych wersjach
@code{gawk} może to robić.)

Niektóre systemy operacyjne mogą nie mieć zmiennych środowiska.
Na takich systemach tablica @code{ENVIRON} jest pusta (z wyjątkiem
@w{@code{ENVIRON["AWKPATH"]}}).

@vindex ERRNO
@item ERRNO *
Jeżeli podczas wykonywania przekierowania @code{getline}, odczytu
@code{getline}, czy działania @code{close} pojawi się błąd systemu,
to @code{ERRNO} będzie zawierać łańcuch opisujący ten błąd.

Zmienna ta jest rozszerzeniem @code{gawk}.  W innych implementacjach
@code{awk}, lub jeśli @code{gawk} działa w trybie zgodności
(@pxref{Opcje, ,Opcje wiersza poleceń}), nie jest specjalna.

@cindex ciemny kąt
@vindex FILENAME
@item FILENAME
To jest nazwa pliku aktualnie czytanego przez @code{awk}.  Jeżeli
w wierszu poleceń nie podano żadnych plików danych, @code{awk} czyta
ze standardowego wejścia, a @code{FILENAME} otrzymuje wartość @code{"-"}.
Za każdym razem, gdy czytany jest nowy plik, zmienia się @code{FILENAME}
(@pxref{Czytanie plików, ,Czytanie plików wejściowych}).
Wewnątrz reguły @code{BEGIN} @code{FILENAME} ma wartość @code{""}, gdyż
nie ma jeszcze żadnych plików w trakcie przetwarzania.@footnote{Niektóre
wczesne uniksowe implementacje @code{awk} inicjowały @code{FILENAME} na
@code{"-"}, nawet jeśli istniały pliki danych do przetworzenia.
Zachowanie to było nieprawidłowe i nie powinno się na nim polegać w
swoich programach.} (c.k.)

@vindex FNR
@item FNR
@code{FNR} jest numerem bieżącego rekordu w bieżącym pliku. Każdorazowo
gdy czytany jest nowy rekord @code{FNR} zwiększa się o jeden
(@pxref{Getline, ,Odczyt bezpośredni przez @code{getline}}).
Jest ponownie inicjowane zerem przy każdym rozpoczęciu nowego pliku.

@vindex NF
@item NF
@code{NF} jest liczbą pól bieżącego rekordu wejściowego.  Wartość @code{NF}
nadawana jest przy każdym odczycie nowego rekordu, tworzeniu nowego
pola lub zmianie @code{$0} (@pxref{Pola, ,Badanie pól}).

@vindex NR
@item NR
To jest liczba rekordów wejściowych, które przetworzył @code{awk} od momentu
rozpoczęcia wykonywania programu
(@pxref{Rekordy, ,Jak wejście dzielone jest na rekordy}).
@code{NR} zmieniane jest każdorazowo przy odczycie nowego rekordu.

@vindex RLENGTH
@item RLENGTH
@code{RLENGTH} jest długością podłańcucha dopasowanego funkcją @code{match}
(@pxref{Funkcje łańcuchowe, ,Funkcje wbudowane działające na łańcuchach}).
Wartość @code{RLENGTH} przypisywana jest przez wywołanie funkcji
@code{match}.  Jest to długość dopasowanego łańcucha, lub @minus{}1 jeżeli
nie znaleziono dopasowania.

@vindex RSTART
@item RSTART
@code{RSTART} jest początkowym indeksem, w znakach, podłańcucha dopasowanego
funkcją @code{match}
(@pxref{Funkcje łańcuchowe, ,Funkcje wbudowane działające na łańcuchach}).
Wartość @code{RLENGTH} przypisywana jest przez wywołanie funkcji
@code{match}.  Jest to pozycja łańcucha, od której rozpoczyna się dopasowany
podłańcuch, lub zero jeżeli nie znaleziono dopasowania.

@vindex RT
@item RT *
@code{RT} ustalane jest za każdym razem, gdy czytany jest rekord.
Zawiera tekst wejściowy, który pasował do tekstu wyznaczonego przez
@code{RS}, separator rekordów.

Zmienna ta jest rozszerzeniem @code{gawk}.  W innych implementacjach
@code{awk} lub jeśli @code{gawk} działa w trybie zgodności
(@pxref{Opcje, ,Opcje wiersza poleceń}), nie jest specjalna.
@end table

@cindex ciemny kąt
Dygresja na temat @code{NR} i @code{FNR}.
@code{awk} zamiast nadawać im bezwzględne wartości liczby przeczytanych
rekordów, za każdym razem, gdy czyta rekord po prostu zwiększa wartości
obu tych zmiennych.
Oznacza to, że nasz program może zmienić te zmienne, a dla każdego nowego
rekordu będą zwiększane ich nowe wartości (c.k.).  Na przykład:

@example
@group
$ echo '1
> 2
> 3
> 4' | awk 'NR == 2 @{ NR = 17 @}
> @{ print NR @}'
@print{} 1
@print{} 17
@print{} 18
@print{} 19
@end group
@end example

@noindent
Zanim do języka @code{awk} dodano @code{FNR}
(@pxref{V7/SVR3.1, ,Główne różnice między V7 a SVR3.1}),
wiele programów @code{awk} wykorzystywało te własność do śledzenia liczby
rekordów w pliku przez zerowanie @code{NR} przy zmianie @code{FILENAME}.

@node ARGC i ARGV, , Auto-ustalane, Zmienne wbudowane
@section Używanie @code{ARGC} i @code{ARGV}

W @ref{Auto-ustalane,  , Zmienne wbudowane niosące informacje},
widzieliśmy program opisujący informacje zawarte w @code{ARGC} i @code{ARGV}:

@example
@group
$ awk 'BEGIN @{
>        for (i = 0; i < ARGC; i++)
>            print ARGV[i]
>      @}' inventory-shipped BBS-list
@print{} awk
@print{} inventory-shipped
@print{} BBS-list
@end group
@end example

@noindent
W tym przykładzie @code{ARGV[0]} zawiera @code{"awk"}, @code{ARGV[1]}
zawiera @code{"inventory-shipped"}, zaś @code{ARGV[2]} zawiera
@code{"BBS-list"}.

Zwróć uwagę, że program @code{awk} nie jest wpisany w @code{ARGV}.
Do @code{ARGV} nie są też wprowadzone specjalne opcje wiersza poleceń
i ich argumenty.  Obejmuje to przypisania zmiennych wykonane za pomocą opcji
@samp{-v} (@pxref{Opcje, ,Opcje wiersza poleceń}).  Zwykłe przypisania
zmiennych w wierszu poleceń @emph{są} traktowane jak argumenty i pojawiają
się w tablicy @code{ARGV}.

@example
$ cat showargs.awk
@print{} BEGIN @{
@print{}     printf "A=%d, B=%d\n", A, B
@print{}     for (i = 0; i < ARGC; i++)
@print{}         printf "\tARGV[%d] = %s\n", i, ARGV[i]
@print{} @}
@print{} END   @{ printf "A=%d, B=%d\n", A, B @}
$ awk -v A=1 -f showargs.awk B=2 /dev/null
@print{} A=1, B=0
@print{} 	ARGV[0] = awk
@print{} 	ARGV[1] = B=2
@print{} 	ARGV[2] = /dev/null
@print{} A=1, B=2
@end example

Programy mogą zmieniać @code{ARGC} i elementy @code{ARGV}.
Za każdym razem, gdy @code{awk} osiąga koniec pliku wejściowego, używa
następnego elementu @code{ARGV} jako nazwy następnego pliku wejściowego.
Składując w nim inny łańcuch nasz program zmienia listę wyznaczającą,
jakie pliki mają być czytane.  Do określenia standardowego wejścia
używa się @code{"-"}.  Wpisując dodatkowe elementy i zwiększając
@code{ARGC} spowodujemy odczyt dodatkowych plików.

Zmniejszenie wartości @code{ARGC} usuwa pliki wejściowe z końca listy.
Zapisując w innym miejscu stare wartości @code{ARGC}, program może
traktować usunięte argumenty jako coś innego niż nazwy plików.

W celu usunięcia pliku ze środka listy należy zamiast jego nazwy
w @code{ARGV} umieścić łańcuch pusty (@code{""}).  Cechą specjalną
@code{awk} jest ignorowanie nazw plików zastąpionych łańcuchem pustym.
Do usunięcia elementów z @code{ARGV} można też wykorzystać instrukcję
@code{delete} (@pxref{Delete, ,Instrukcja @code{delete}}).

Wszystkie powyższe działania zwykle wykonuje się w regule @code{BEGIN},
przed rozpoczęciem przetwarzania wejścia.
@xref{Program split, ,Dzielenie dużego pliku na kawałki}, i zob.
@ref{Program tee, ,Powielanie wyjścia do wielu plików}, gdzie jest
przykład każdej z metod usuwania elementów z @code{ARGV}.

Poniższy fragment przetwarza @code{ARGV} w celu przeanalizowania,
a następnie usunięcia opcji wiersza poleceń.

@example
@group
BEGIN @{
    for (i = 1; i < ARGC; i++) @{
        if (ARGV[i] == "-v")
            verbose = 1
        else if (ARGV[i] == "-d")
            debug = 1
@end group
@group
        else if (ARGV[i] ~ /^-?/) @{
            e = sprintf("%s: nierozpoznana opcja -- %c",
                    ARGV[0], substr(ARGV[i], 1, ,1))
            print e > "/dev/stderr"
        @} else
            break
        delete ARGV[i]
    @}
@}
@end group
@end example

Aby faktycznie pobrać opcje do programu @code{awk}, musimy zakończyć
opcje @code{awk} za pomocą @samp{--}, a następnie podać własne opcje,
jak tu:

@example
awk -f myprog -- -v -d file1 file2 @dots{}
@end example

@cindex różnice między @code{gawk} a @code{awk}
W @code{gawk} nie jest to konieczne: jeśli nie podano opcji @samp{--posix},
@code{gawk} milcząco umieszcza wszystkie nierozpoznane opcje w @code{ARGV},
by mógł się nimi zająć program @code{awk}.

W momencie zauważenia nieznanej opcji @code{gawk} przestaje szukać innych
opcji, które w przeciwnym przypadku mógłby rozpoznać.  Powyższy program
napisany dla @code{gawk} mógłby wyglądać tak:

@example
gawk -f myprog -d -v file1 file2 @dots{}
@end example

@noindent
Ponieważ @samp{-d} nie jest poprawną opcją @code{gawk}, występujące po niej
@samp{-v} jest przekazywane do programu @code{awk}.

@node Tablice, Wbudowane, Zmienne wbudowane, Top
@chapter Tablice w @code{awk}

@dfn{Tablica} (array) jest tabelą wartości, zwanych @dfn{elementami}.
Elementy tablicy rozróżniane są poprzez swoje indeksy.  @dfn{Indeksy} mogą
być liczbami lub łańcuchami.  @code{awk} przechowuje jeden zbiór nazw,
które mogą być wykorzystywane przy nazywaniu zmiennych, tablic i funkcji
(@pxref{Użytkownika, ,Funkcje użytkownika}).  Zatem, w jednym
programie @code{awk} nie można mieć zmiennej i tablicy o tej samej nazwie.

@menu
* Wprowadzenie do tablic::      Wprowadzenie do tablic.
* Odwołania do elementów::      Jak zbadać pojedynczy element tablicy.
* Przypisania do elementów::    Jak zmienić element tablicy.
* Przykład tablicy::            Prosty przykład tablicy.
* Przeglądanie tablic::         Odmiana instrukcji @code{for}. Wykonuje
                                pętlę po indeksach elementów tablicy.
* Delete::                      Instrukcja @code{delete} usuwa element z tablicy.
* Numeryczne indeksy tablic::   Jak w @code{awk} wykorzystywać liczby
                                jako indeksy.
* Niezainicjowane indeksy::     Stosowanie niezainicjowanych zmiennych
                                jako indeksów.
* Wielowymiarowe::              Emulacja tablic wielowymiarowych w @code{awk}.
* Przeglądanie wielowymiarowych:: Przeglądanie tablic wielowymiarowych.
* Efektywność tablic::          Specjalne wskazówki dotyczące @code{gawk}.
@end menu

@node Wprowadzenie do tablic, Odwołania do elementów, Tablice, Tablice
@section Wprowadzenie do tablic

@cindex tablice
Język @code{awk} do przechowywania grup powiązanych ze sobą łańcuchów czy
liczb zapewnia jednowymiarowe @dfn{tablice}.

Każda tablica w @code{awk} musi mieć nazwę.  Nazwy tablic mają tę samą
składnię, co nazwy zmiennych; każda poprawna nazwa zmiennej byłaby także
poprawną nazwą tablicy.  Nie można jednak w jednym programie @code{awk}
stosować jednej nazwy na oba sposoby (jako tablicy i jako zmiennej).

Tablice w @code{awk} pozornie przypominają tablice w innych językach
programowania.  Istnieją jednak zasadnicze różnice.  W @code{awk} nie ma
konieczności podawania rozmiaru tablicy przed rozpoczęciem korzystania z
niej.  Dodatkowo, jako indeks tablicy może być wykorzystana dowolna liczba
czy łańcuch, a nie wyłącznie kolejne liczby całkowite.

W większości innych języków istnieje obowiązek @dfn{zadeklarowania} tablicy
i określenia, ile zawiera ona elementów czy składowych.  W takich językach
deklaracja powoduje zaalokowanie ciągłego bloku pamięci dla wskazanej liczby
elementów.  Indeks tablicy zwykle musi być dodatnią liczbą całkowitą, na
przykład, indeks zero określa pierwszy element tablicy, który faktycznie
jest przechowywany na samym początku bloku pamięci.  Indeks jeden określa
drugi element, przechowywany w pamięci zaraz za pierwszym, i tak dalej.
Dodanie kolejnych elementów do tablicy jest niemożliwe gdyż ma ona
miejsce tylko na tyle elementów, ile zadeklarowano.  (Niektóre języki
zezwalają na dowolne indeksy początkowe i końcowe, np. @samp{15 .. 27},
ale rozmiar tablicy jest nadal wyznaczany na stałe przy jej deklaracji.)

Ciągła tablica czterech elementów mogłaby, pojęciowo, wyglądać jak niżej,
jeśli wartościami elementów są osiem, @code{"foo"}, @code{""} i 30:

@iftex
@c from Karl Berry, much thanks for the help.
@tex
\bigskip % space above the table (about 1 linespace)
\offinterlineskip
\newdimen\width \width = 1.5cm
\newdimen\hwidth \hwidth = 4\width \advance\hwidth by 2pt % 5 * 0.4pt
\centerline{\vbox{
\halign{\strut\hfil\ignorespaces#&&\vrule#&\hbox to\width{\hfil#\unskip\hfil}\cr
\noalign{\hrule width\hwidth}
        &&{\tt 8} &&{\tt "foo"} &&{\tt ""} &&{\tt 30} &&\quad wartość\cr
\noalign{\hrule width\hwidth}
\noalign{\smallskip}
        &\omit&0&\omit &1   &\omit&2 &\omit&3 &\omit&\quad indeks\cr
}
}}
@end tex
@end iftex
@ifinfo
@example
+---------+---------+--------+---------+
|    8    |  "foo"  |   ""   |    30   |    @r{wartość}
+---------+---------+--------+---------+
     0         1         2         3        @r{indeks}
@end example
@end ifinfo

@noindent
Przechowywane są tylko wartości, indeksy wynikają z kolejności tych wartości.
Osiem jest wartością o indeksie zero, gdyż osiem stoi na pozycji,
przed którą jest zero elementów.

@cindex tablice, definicja
@cindex tablice asocjacyjne
@cindex asocjacyjne, tablice
Tablice w @code{awk} są inne: są one @dfn{asocjacyjne} (przyporządkowujące).
Oznacza to, że każda tablica jest zbiorem par: indeks, i odpowiadająca mu
wartość elementu tablicy:

@example
@r{Element} 4     @r{Wartość} 30
@r{Element} 2     @r{Wartość} "foo"
@r{Element} 1     @r{Wartość} 8
@r{Element} 3     @r{Wartość} ""
@end example

@noindent
Pokazaliśmy pary w wymieszanej kolejności, gdyż ich kolejność jest
nieistotna.

Jedną z zalet tablic asocjacyjnych jest to, że w dowolnym momencie można
dodawać nowe pary.  Na przykład, załóżmy, że do powyższej tablicy dodamy
dziesiąty element, o wartości @w{@code{"numer dziesięć"}}.  Wynikiem jest:

@example
@r{Element} 10    @r{Wartość} "numer dziesięć"
@r{Element} 4     @r{Wartość} 30
@r{Element} 2     @r{Wartość} "foo"
@r{Element} 1     @r{Wartość} 8
@r{Element} 3     @r{Wartość} ""
@end example

@noindent
@cindex tablice rzadkie
@cindex rzadkie, tablice
Teraz tablica jest @dfn{rzadka} (sparse), co oznacza po prostu, że brakuje
niektórych indeksów: ma elementy 1--4 i 10, ale nie ma elementów
5, 6, 7, 8, czy 9.
@c ok, I should spell out the above, but ...

Innym skutkiem tablic asocjacyjnych jest fakt, że indeksy nie muszą być
dodatnimi liczbami całkowitymi.  Indeksem może być dowolna liczba, a nawet
łańcuch.  Na przykład, oto tablica tłumacząca słowa z polskiego na
angielski:

@example
@r{Element} "pies"  @r{Wartość} "dog"
@r{Element} "kot"   @r{Wartość} "cat"
@r{Element} "jeden" @r{Wartość} "one"
@r{Element} 1       @r{Wartość} "one"
@end example

@noindent
Zdecydowaliśmy się tu tłumaczyć liczbę jeden zarówno napisaną słownie jak
i w postaci numerycznej -- pokazując w ten sposób, że pojedyncza tablica
może zawierać jako indeksy jednocześnie liczby i łańcuchy.
(W rzeczywistości indeksy tablicy są zawsze łańcuchami; omówiono to
szczegółowo w
@ref{Numeryczne indeksy tablic, ,Stosowanie liczb do indeksowania tablic}.)

@cindex tablice, indeksy a @code{IGNORECASE}
@cindex indeksy tablic a @code{IGNORECASE}
@cindex @code{IGNORECASE} a indeksy tablic
@vindex IGNORECASE
Wartość @code{IGNORECASE} nie wpływa na indeksowanie tablic.  Do pobrania
elementu tablicy musimy użyć dokładnie tej samej wartości łańcuchowej, która
posłużyła do jego zapamiętania.

Gdy tablicę tworzy dla nas sam @code{awk}, np. funkcją wbudowaną
@code{split}, to jej indeksy są kolejnymi liczbami całkowitymi poczynając
od jeden.
(@xref{Funkcje łańcuchowe, ,Funkcje wbudowane działające na łańcuchach}.)

@node Odwołania do elementów, Przypisania do elementów, Wprowadzenie do tablic, Tablice
@section Odwoływanie się do elementów tablicy
@cindex tablice, odwołanie do
@cindex element tablicy
@cindex odwołanie do tablicy

Głównym sposobem korzystania z tablic jest odwoływanie się do któregoś z jej
elementów.  Odwołanie do tablicy jest wyrażeniem wyglądającym tak:

@example
@var{tablica}[@var{indeks}]
@end example

@noindent
Gdzie @var{tablica} jest nazwą tablicy.  Wyrażenie @var{indeks} jest
indeksem elementu tablicy, o który nam chodzi.

Wartością odwołania do tablicy jest bieżąca wartość tego elementu tablicy.
Na przykład, @code{foo[4.3]} jest wyrażeniem dla elementu tablicy @code{foo}
o indeksie @samp{4.3}.

Jeżeli odwołamy się do elementu tablicy, który nie ma wpisanej wartości,
to wartością odwołania będzie @code{""}, łańcuch pusty.  Dotyczy to
elementów, którym jeszcze nie przypisano wartości, jak i elementów, które
zostały usunięte (@pxref{Delete, ,Instrukcja @code{delete}}).  Odwołanie
takie automatycznie tworzy element tablicy, z łańcuchem pustym jako jego
wartością.  (W niektórych przypadkach nie jest to zbyt szczęśliwe, gdyż
może marnować pamięć wewnątrz @code{awk}.)

@cindex tablice, istnienie elementów
@cindex tablice, operator @code{in}
Czy w tablicy istnieje element o danym indeksie można sprawdzić za pomocą
wyrażenia:

@example
@var{indeks} in @var{tablica}
@end example

@noindent
Powyższe wyrażenie testuje czy istnieje konkretny indeks, czy nie, bez skutku
ubocznego w postaci tworzenia elementu jeśli ma indeksu.
Ma ono wartość jeden (prawda) jeśli @code{@var{tablica}[@var{indeks}]}
istnieje, a zero (fałsz) jeśli nie istnieje.

Na przykład, do sprawdzenia czy tablica @code{czestosci} zawiera indeks
@samp{2}, moglibyśmy napisać tę instrukcję:

@example
if (2 in czestosci)
    print "Indeks 2 istnieje."
@end example

Zwróć uwagę, że powyższe @emph{nie} sprawdza, czy tablica
@code{czestosci} zawiera element, którego @emph{wartością} jest dwa.
(Nie ma innej metody, by to zrobić, niż zbadanie wszystkich elementów.)
@emph{Nie} tworzy to także @code{czestosci[2]}, choć poniższa (niepoprawna)
alternatywa by to robiła:

@example
if (czestosci[2] != "")
    print "Indeks 2 istnieje."
@end example

@node Przypisania do elementów, Przykład tablicy, Odwołania do elementów, Tablice
@section Przypisanie do elementów tablicy
@cindex przypisanie do tablicy
@cindex przypisanie do elementu
@cindex tablice, przypisanie
@cindex elementy, przypisanie

Elementy tablic są lwartościami: można im przypisywać wartości dokładnie
tak samo jak zmiennym @code{awk}:

@example
@var{tablica}[@var{indeks}] = @var{wartość}
@end example

@noindent
Gdzie @var{tablica} jest nazwą naszej tablicy.  Wyrażenie @var{indeks} jest
indeksem elementu tablicy, do któremu chcemy przypisać wartość. Wyrażenie
@var{wartość} jest wartością, którą przypisujemy temu elementowi tablicy.

@node Przykład tablicy, Przeglądanie tablic, Przypisania do elementów, Tablice
@section Prosty przykład tablicy

Poniższy program pobiera listę wierszy, każdy zaczynający się numerem
wiersza, i wypisuje je w kolejności tych numerów.  Numery wierszy nie są
jednak uporządkowane podczas odczytu -- są wymieszane.  Program sortuje
wiersze tworząc tablicę z wykorzystującą numery wierszy jako indeksy.
Następnie wypisuje wiersze w kolejności ich posortowanych numerów.
To bardzo prosty program, i wprawia go w zakłopotanie napotkanie
powtórzonych numerów, luk, czy wierszy, które nie rozpoczynają się numerem.

@example
@group
@c file eg/misc/arraymax.awk
@{
  if ($1 > max)
    max = $1
  arr[$1] = $0
@}
@end group

END @{
  for (x = 1; x <= max; x++)
    print arr[x]
@}
@c endfile
@end example

Pierwsza reguła śledzi największy numer wiersza, jaki do tej pory napotkano.
Zapisuje też każdy wiersz do tablicy @code{arr}, pod indeksem będącym
numerem wiersza.

Druga reguła pracuje po przeczytaniu całości wejścia, wypisując wszystkie
wiersze.

Gdy uruchomimy ten program z poniższymi danymi wejściowymi:

@example
@group
@c file eg/misc/arraymax.data
5  I am the Five man
2  Who are you?  The new number two!
4  . . . And four on the floor
1  Who is number one?
3  I three you.
@c endfile
@end group
@end example

@noindent
jego wyjściem będzie:

@example
1  Who is number one?
2  Who are you?  The new number two!
3  I three you.
4  . . . And four on the floor
5  I am the Five man
@end example

Jeśli jakiś numer wiersza powtarza się, to ostatni wiersz z tym numerem
zastępuje poprzednie.

Luki w numerach wierszy można łatwo obsłużyć usprawnieniem reguły @code{END}:

@example
END @{
  for (x = 1; x <= max; x++)
    if (x in arr)
      print arr[x]
@}
@end example

@node Przeglądanie tablic, Delete, Przykład tablicy, Tablice
@section Przeglądanie wszystkich elementów tablicy
@cindex @code{for (x in @dots{})}
@cindex tablice, specjalna instrukcja @code{for}
@cindex przeglądanie tablicy

W programach używającym tablic często potrzebujemy pętli, która wykonuje
się po jednym razie dla każdego elementu tablicy.  W innych językach,
gdzie tablice są ciągłe a indeksy ograniczone do dodatnich liczb
całkowitych, jest to łatwe: Można znaleźć wszystkie poprawne indeksy
zliczając od najniższego indeksu do najwyższego.  Ta technika nie
sprawdzi się w @code{awk}, gdyż indeksem tablicy może być dowolna liczba lub
łańcuch.  Stąd też @code{awk} posiada specjalny rodzaj instrukcji @code{for}
służący do przeglądania tablic:

@example
for (@var{zmn} in @var{tablica})
  @var{ciało}
@end example

@noindent
Pętla ta wykonuje @var{ciało} jeden raz dla każdego indeksu @var{tablicy},
którą uprzednio stworzył program, z przypisaniem tego indeksu do zmiennej
@var{zmn}.

Oto program korzystający z tej postaci instrukcji @code{for}.  Pierwsza jego
reguła bada rekordy wejściowe i odnotowuje, jakie słowa (co najmniej jedno)
pojawiły się w wejściu, zapisując jedynkę w tablicy @code{used} z danym
słowem jako indeksem.  Druga reguła przeszukuje elementy tablicy
@code{used}, w celu znalezienia wszystkich różnych słów, jakie pojawiły się
w danych wejściowych.  Wypisuje każde słowo dłuższe niż 10 znaków, wypisuje
też liczbę takich słów.
@xref{Funkcje łańcuchowe, ,Funkcje wbudowane działające na łańcuchach},
gdzie szerzej opisano funkcję wbudowaną @code{length}.

@example
# zapisz 1 dla każdego choć raz użytego słowa.
@{
    for (i = 1; i <= NF; i++)
        used[$i] = 1
@}

# znajdź liczbę różnych słów dłuższych niż 10 znaków.
END @{
    for (x in used)
        if (length(x) > 10) @{
            ++num_long_words
            print x
        @}
    print num_long_words, "słów dłuższych niż 10 znaków"
@}
@end example

@noindent
@xref{Sortowanie wyrazów, ,Tworzenie statystyk użycia wyrazów},
gdzie podano bardziej szczegółowy przykład tego typu.

Kolejność, w jakiej instrukcja @code{for} sięga do elementów tablicy,
wyznaczona jest
wewnętrznym układem tych elementów w @code{awk} i nie daje się sterować czy
zmieniać.  Może to prowadzić do kłopotów jeśli instrukcje w ciele pętli
dodadzą do @var{tablicy} nowe elementy.  Nie da się przewidzieć, czy pętla
@code{for} sięgnie po nie, czy też nie.  Podobnie, zmiana @var{zmn} wewnątrz
pętli może dać dziwne skutki.  Najlepiej unikać takich rzeczy.

@node Delete, Numeryczne indeksy tablic, Przeglądanie tablic, Tablice
@section Instrukcja @code{delete}
@cindex @code{delete} instrukcja
@cindex usuwanie elementów tablicy
@cindex kasowanie elementów tablicy
@cindex tablice, usuwanie elementu

Pojedynczy element tablicy usuwa się instrukcją @code{delete}:

@example
delete @var{tablica}[@var{indeks}]
@end example

Po usunięciu elementu tablicy, nie można już otrzymać wartości, jaką miał
on uprzednio.  Jest tak, jakby nigdy nie odwoływano się do tego elementu
i nigdy nie nadawano mu żadnej wartości.

Oto przykład usuwania elementów tablicy:

@example
for (i in czestosci)
  delete czestosci[i]
@end example

@noindent
Ten przykład usuwa wszystkie elementy z tablicy @code{czestosci}.

Jeśli usuniemy element, to następująca potem instrukcja @code{for}
przeglądająca tablicę nie zgłosi go, a operator @code{in} sprawdzający
istnienie tego elementu zwróci zero (tj.@: fałsz):

@example
delete foo[4]
if (4 in foo)
    print "To nigdy nie zostanie wypisane"
@end example

Należy pamiętać, że usunięcie elementu @emph{nie} jest tym samym, co
przypisanie mu pustej wartości (łańcucha pustego, @code{""}).

@example
foo[4] = ""
if (4 in foo)
  print "To jest wypisane, mimo że foo[4] jest puste"
@end example

Nie jest błędem usuwanie elementu, który nie istnieje.

@cindex tablice, usuwanie całej zawartości
@cindex usuwanie całych tablic
@cindex różnice między @code{gawk} a @code{awk}
Można usunąć wszystkie elementy tablicy jedną instrukcją, pomijając indeks
w instrukcji @code{delete}.

@example
delete @var{tablica}
@end example

Możliwość ta stanowi rozszerzenie @code{gawk}.  Nie jest dostępna w trybie
zgodności (@pxref{Opcje, ,Opcje wiersza poleceń}).

Stosowanie tej wersji instrukcji @code{delete} jest około trzech razy
bardziej efektywne niż równoważna jej pętla usuwająca po jednym
elemencie naraz.

@cindex przenośność
Poniższa instrukcja zapewnia przenośną, ale nie oczywistą metodę
wyczyszczenia tablicy.

@cindex Brennan, Michael
@example
@group
# dzięki Michaelowi Brennananowi za wskazanie tego
split("", tablica)
@end group
@end example

Funkcja @code{split}
(@pxref{Funkcje łańcuchowe, ,Funkcje wbudowane działające na łańcuchach})
czyści najpierw tablicę docelową.  Wywołanie to żąda od niej rozbicia
na części łańcucha pustego.  Ponieważ brak jest danych do podziału, funkcja
po prostu czyści tablicę a następnie wraca.

@strong{Uwaga!} Usunięcie tablicy nie zmienia jej typu; nie można
usunąć tablicy a następnie wykorzystać jej nazwy jako skalara.
Na przykład, to nie zadziała:

@example
a[1] = 3; delete a; a = 3
@end example

@node Numeryczne indeksy tablic, Niezainicjowane indeksy, Delete, Tablice
@section Stosowanie liczb do indeksowania tablic

Istotnym aspektem tablic, o którym należy pamiętać, jest to, że
@emph{indeksy tablicy są zawsze łańcuchami}.  Jeśli jako indeks zastosujemy
wartość numeryczną, zostanie ona przekształcona na wartość łańcuchową
przed wykorzystaniem do indeksowania
(@pxref{Konwersja, ,Konwersja łańcuchów i liczb}).

@cindex konwersje, podczas indeksowania
@cindex liczby, użyte jako indeksy
@vindex CONVFMT
Oznacza to, że wartość zmiennej wbudowanej @code{CONVFMT} może
potencjalnie wpływać na sposób, w jaki program sięga do elementów tablicy.
Na przykład:

@example
xyz = 12.153
dane[xyz] = 1
CONVFMT = "%2.2f"
@group
if (xyz in dane)
    printf "%s jest w tabl. dane\n", xyz
else
    printf "%s nie ma w tabl. dane\n", xyz
@end group
@end example

@noindent
Powyższe wypisze @samp{12.15 nie ma w tabl. dane}.  Pierwsza instrukcja
nadaje @code{xyz} wartość numeryczną.  Przypisanie do @code{dane[xyz]}
indeksuje @code{dane} wartością łańcuchową @code{"12.153"} (wykorzystując
domyślną wartość konwersji @code{CONVFMT}, @code{"%.6g"}), i nadaje
@code{data["12.153"]} wartość jeden.  Następnie program zmienia wartość
@code{CONVFMT}.  Test @samp{(xyz in dane)} tworzy nową wartość łańcuchową
z @code{xyz}, tym razem @code{"12.15"}, gdyż wartość @code{CONVFMT} pozwala
tylko na dwie cyfry znaczące.  Test zwraca porażkę, gdyż @code{"12.15"} jest
łańcuchem różnym od @code{"12.153"}.

Zgodnie z regułami konwersji
(@pxref{Konwersja, ,Konwersja łańcuchów i liczb}), wartości całkowite
są zawsze przekształcane na łańcuchy jako całkowite, bez względu na to, jaka
jest wartość @code{CONVFMT}.  Zatem zwyczajny przypadek:

@example
for (i = 1; i <= maxind; i++)
    @i{zrób coś z} tablica[i]
@end example

@noindent
będzie działał, bez względu na wartość @code{CONVFMT}.

Jak wiele rzeczy w @code{awk}, przeważnie rzeczy działają tak, jak się tego
spodziewamy.  Przydaje się jednak dokładna wiedzę o faktycznych
zasadach, gdyż mogą one czasem mieć trudno uchwytny wpływ na nasze programy.

@node Niezainicjowane indeksy, Wielowymiarowe, Numeryczne indeksy tablic, Tablice
@section Stosowanie niezainicjowanych zmiennych jako indeksów

@cindex niezainicjowane zmienne, jako indeksy tablicy
@cindex indeksy tablicy, niezainicjowane zmienne
@cindex tablice, niezainicjowane zmienne jako indeksy
Załóżmy, że chcemy wypisać jakieś dane wejściowe w odwróconej kolejności.
Sensowny program próbny, który by to robił (na pewnych danych testowych)
wygląda tak:

@example
@group
$ echo 'wiersz 1
> wiersz 2
> wiersz 3' | awk '@{ w[wiersze] = $0; ++wiersze @}
> END @{
>     for (i = wiersze-1; i >= 0; --i)
>        print w[i]
> @}'
@print{} wiersz 3
@print{} wiersz 2
@end group
@end example

Niestety, pierwszy wiersz danych wejściowych nie pojawił się na wyjściu!

Na pierwszy rzut oka, program powinien działać.  Zmienna @code{wiersze} jest
niezainicjowana, a niezainicjowane zmienne mają numeryczną wartość zero.
Zatem, @code{awk} powinien wypisać wartość elementu @code{w[0]}.

Problemem jest tu fakt, że indeksy tablic @code{awk} są @strong{zawsze}
łańcuchami.  A niezainicjowane zmienne, użyte jako łańcuchy, mają
wartość @code{""}, a nie zero.  Zatem, @samp{wiersz 1} został ostatecznie
zapisany w @code{w[""]}.

Poniższa wersja programu działa poprawnie:

@example
@{ w[wiersze++] = $0 @}
END @{
    for (i = wiersze - 1; i >= 0; --i)
       print w[i]
@}
@end example

Tutaj, @samp{++} wymusza, by @code{wiersze} było numeryczne, w ten sposób
czyniąc ``starą wartość'' numerycznym zerem, które z kolei jest
przekształcane na @code{"0"} jako indeks tablicy.

@cindex łańcuch pusty, jako indeks tablicy
@cindex ciemny kąt
Jak właśnie widzieliśmy, mimo tego, że jest to nieco niezwykłe, łańcuch
pusty (@code{""}) jest poprawnym indeksem tablicy (c.k.).  Jeśli w wierszu
poleceń podano opcję @samp{--lint}
(@pxref{Opcje, ,Opcje wiersza poleceń}), @code{gawk} będzie ostrzegał
o  użyciu łańcucha pustego jako indeksu.

@node Wielowymiarowe, Przeglądanie wielowymiarowych, Niezainicjowane indeksy, Tablice
@section Tablice wielowymiarowe

@cindex indeksy tablic
@cindex tablice, indeksy wielowymiarowe
@cindex wielowymiarowe indeksy
Tablica wielowymiarowa jest tablicą, w której element jest identyfikowany
przez ciąg indeksów, a nie przez pojedynczy indeks.  Na przykład, tablica
dwuwymiarowa wymaga dwu indeksów.  Zwyczajowym sposobem (w większości
języków, łącznie z @code{awk}) odwoływania się do elementu tablicy
dwuwymiarowej o nazwie @code{siatka} jest @code{siatka[@var{x},@var{y}]}.

@vindex SUBSEP
Tablice wielowymiarowe obsługiwane są w @code{awk} dzięki konkatenacji
indeksów w jeden łańcuch.  Działa to tak, że @code{awk} przekształca indeksy
na łańcuchy
(@pxref{Konwersja, ,Konwersja łańcuchów i liczb}) i skleja je razem,
z separatorem między nimi.  Tworzy to pojedynczy łańcuch opisujący wartości
poszczególnych indeksów.  Połączony łańcuch służy jako pojedynczy indeks
zwykłej, jednowymiarowej tablicy.  Wykorzystywanym separatorem jest wartość
zmiennej wbudowanej @code{SUBSEP}.

Na przykład, załóżmy, że obliczamy wyrażenie @samp{foo[5,12] = "wartość"}
gdy wartością @code{SUBSEP} jest @code{"@@"}.  Liczby pięć i 12 są
przekształcane na łańcuchy i łączone ze sobą z @samp{@@} między nimi,
dając @code{"5@@12"}.  Zatem, element @code{foo["5@@12"]} otrzymuje wartość
@code{"wartość"}.

Po zapamiętaniu wartości elementu @code{awk} nie ma żadnego zapisu o tym,
czy był on zapamiętany z pojedynczym indeksem, czy ciągiem indeksów.
Wyrażenia @samp{foo[5,12]} i @w{@samp{foo[5 SUBSEP 12]}} są zawsze
równoważne.

Domyślną wartością @code{SUBSEP} jest łańcuch @code{"\034"},
zawierający znak niedrukowalny, którego pojawienie się w programie
@code{awk} lub większości danych wejściowych jest mało prawdopodobne.

Użyteczność wyboru nieprawdopodobnego znaku pochodzi stąd, iż wartości
indeksów zawierające łańcuch pasujący do @code{SUBSEP} prowadzą do łączonych
łańcuchów, które są niejednoznaczne.  Załóżmy, że @code{SUBSEP} byłoby
@code{"@@"}. Wówczas @w{@samp{foo["a@@b", "c"]}}
i @w{@samp{foo["a", "b@@c"]}} byłyby nieodróżnialne, gdyż oba zostały by
w rzeczywistości zapamiętane jako @samp{foo["a@@b@@c"]}.

Możemy sprawdzać czy w tablicy ``wielowymiarowej'' istnieje konkretna
sekwencja-indeksów za pomocą tego samego operatora @samp{in}, używanego dla
tablic jednowymiarowych.  Zamiast pojedynczego indeksu jako
lewostronnego operatora, piszemy w nawiasach cały ciąg indeksów
rozdzielonych przecinkami:

@example
(@var{indeks1}, @var{indeks2}, @dots{}) in @var{tablica}
@end example

Poniższy przykład traktuje swoje wejście jak dwuwymiarową tablicę pól.
Obraca tę tablicę o 90 stopni zgodnie z ruchem wskazówek zegara i wypisuje
wynik.  Zakłada, że wszystkie wiersze mają tę samą ilość elementów.

@example
@group
awk '@{
     if (max_nf < NF)
          max_nf = NF
     max_nr = NR
     for (x = 1; x <= NF; x++)
          wektor[x, NR] = $x
@}
@end group

@group
END @{
     for (x = 1; x <= max_nf; x++) @{
          for (y = max_nr; y >= 1; --y)
               printf("%s ", wektor[x, y])
          printf("\n")
     @}
@}'
@end group
@end example

@noindent
Przy podaniu mu jako wejścia:

@example
@group
1 2 3 4 5 6
2 3 4 5 6 1
3 4 5 6 1 2
4 5 6 1 2 3
@end group
@end example

@noindent
daje:

@example
@group
4 3 2 1
5 4 3 2
6 5 4 3
1 6 5 4
2 1 6 5
3 2 1 6
@end group
@end example

@node Przeglądanie wielowymiarowych, Efektywność tablic, Wielowymiarowe, Tablice
@section Przeglądanie tablic wielowymiarowych

Nie istnieje żadna specjalna instrukcja @code{for} do przeglądania tablic
``wielowymiarowych''.  Nie może istnieć, gdyż naprawdę nie ma
wielowymiarowych tablic czy elementów.  Jest tylko wielowymiarowa
@emph{metoda dostępu} do tablicy.

Jeśli jednak w naszym programie jest tablica, do której zawsze odwołujemy
się wielowymiarowo, można uzyskać efekt jej przeglądania dzięki połączeniu
instrukcji @code{for}
(@pxref{Przeglądanie tablic, ,Przeglądanie wszystkich elementów tablicy})
z funkcją wbudowaną @code{split}
(@pxref{Funkcje łańcuchowe, ,Funkcje wbudowane działające na łańcuchach}).
Działa to tak:

@example
for (laczony in tablica) @{
  split(laczony, poszczegolne, SUBSEP)
  @dots{}
@}
@end example

@noindent
Nadaje to zmiennej @code{laczony} kolejne wartości skonkatenowanych,
połączonych indeksów tablicy, i dzieli ją na poszczególne indeksy
przez cięcia w miejscach, gdzie występuje wartość @code{SUBSEP}.
Powstałe z podziału indeksy stają się elementami tablicy @code{poszczegolne}.

Zatem załóżmy, że w @code{tablica[1, "foo"]} mamy uprzednio zapamiętaną
wartość.  Wówczas w tablicy @code{array} istnieje element o indeksie
@code{"1\034foo"}.  (Przypominamy, że domyślną wartością @code{SUBSEP} jest
znak o kodzie 034.)  Wcześniej czy później instrukcja @code{for} znajdzie
ten indeks i wykona iterację ze zmienną @code{laczony} o nadanej
wartości @code{"1\034foo"}.  Następnie wywoływana jest funkcja @code{split}
jak niżej:

@example
split("1\034foo", poszczegolne, "\034")
@end example

@noindent
Wynikiem jest przypisanie @code{poszczegolne[1]} wartości @code{"1"}, a
@code{poszczegolne[2]} wartości @code{"foo"}.  Presto, została odtworzona
pierwotna sekwencja indeksów.

@node Efektywność tablic, , Przeglądanie wielowymiarowych, Tablice
@section Efektywne wykorzystywanie tablic

Ta sekcja odnosi się tylko do @code{gawk}.

Często przydaje się stosować tę samą daną jako indeks w wielu tablicach.
Z powodu metody implementacji tablic asocjacyjnych przez
@code{gawk}, gdy potrzebujemy użyć danych wejściowych jako indeksu w wielu
tablicach, znacznie efektywniej jest przypisać pole wejściowe do osobnej
zmiennej, a następnie zastosować jako indeks tę zmienną.

@example
@{
      imie = $1
      skladka = $2
      ndz = $3
      @dots{}
      starsi[imie]++       # lepiej niż starsi[$1]++
      dzieci[imie] = ndz   # lepiej niż dzieci[$1] = ndz
@}
@end example

W każdym razie, stosowanie do pól wejściowych odrębnych zmiennych
o mnemonicznych nazwach czyni program czytelniejszym. Ostatecznym
celem jest uzyskanie możliwie dużej efektywności indeksowania tablic
@code{gawk}, bez względu na źródło wartości indeksu.

@node Wbudowane, Użytkownika, Tablice, Top
@chapter Funkcje wbudowane

@c 2e: USE TEXINFO-2 FUNCTION DEFINITION STUFF!!!!!!!!!!!!!
@cindex funkcje wbudowane
Funkcje @dfn{wbudowane} to funkcje, które są zawsze dostępne do wywołania w
programie @code{awk}.  Ten rozdział opisuje wszystkie funkcje wbudowane
występujące w @code{awk}.  O niektórych z nich wspomniano w innych sekcjach,
ale tu dla wygody zestawiono je wszystkie.
(Możliwe jest też samodzielne definiowanie nowych funkcji.
@xref{Użytkownika, ,Funkcje użytkownika}.)

@menu
* Wywoływanie wbudowanych::     Jak wywoływać funkcje wbudowane.
* Funkcje numeryczne::          Funkcje działające na liczbach, m.in.
                                @code{int}, @code{sin} i @code{rand}.
* Funkcje łańcuchowe::          Funkcje do działań na łańcuchach, jak
                                @code{split}, @code{match} i @code{sprintf}.
* Funkcje I/O::                 Funkcje obsługi plików i poleceń powłoki.
* Funkcje czasu::               Funkcje do pracy ze znacznikami czasu.
@end menu

@node Wywoływanie wbudowanych, Funkcje numeryczne, Wbudowane, Wbudowane
@section Wywoływanie funkcji wbudowanych

Aby wywołać funkcję wbudowaną należy napisać nazwę funkcji, po której
w nawiasach wystąpią argumenty.  Na przykład, @samp{atan2(y + z, 1)} jest
wywołaniem funkcji @code{atan2}, z dwoma argumentami.

Biały znak między nazwą funkcji wbudowanej a nawiasem otwierającym jest
ignorowany, ale zaleca się unikanie stosowania go w tym miejscu.
Funkcje definiowane przez użytkownika nie zezwalają na używanie w ten sposób
białego znaku, a łatwiej jest uniknąć pomyłek przestrzegając prostej
konwencji, która zawsze działa: żadnych białych znaków po nazwie funkcji.

@cindex różnice między @code{gawk} a @code{awk}
Każda z funkcji wbudowanych przyjmuje pewną liczbę argumentów.  W niektórych
przypadkach argumenty mogą być pomijane.  Domyślne wartości pominiętych
argumentów są różne, w zależności od funkcji.  Opisano je przy omówieniach
poszczególnych funkcji.  W niektórych implementacjach @code{awk} dodatkowe
argumenty przekazywane funkcjom wbudowanym są ignorowane.
Jednak w @code{gawk} jest to błąd krytyczny.

Przy wywoływaniu funkcji wyrażenia tworzące jej parametry faktyczne są
obliczane przed wykonaniem wywołania.  Na przykład, w tym fragmencie kodu:

@example
i = 4
j = sqrt(i++)
@end example

@noindent
zmienna @code{i} otrzymuje wartość pięć przed wywołaniem @code{sqrt}
z wartością cztery jako jej aktualnym parametrem.

@cindex obliczenia, kolejność
@cindex kolejność obliczeń
Kolejność obliczanie wyrażeń stosowanych jako argumenty funkcji jest
niezdefiniowana.  Zatem, nie powinno się pisać programów, które zakładają,
że argumenty są obliczane od lewej do prawej czy od prawej do lewej.
Na przykład,

@example
i = 5
j = atan2(i++, i *= 2)
@end example

Jeżeli kolejność obliczeń będzie od lewej do prawej, to @code{i} najpierw
stanie się równe 6, potem 12, a @code{atan2} zostanie wywołane z tymi dwoma
argumentami: 6 i 12.  Ale jeśli obliczenia będą wykonywane od prawej do
lewej, to @code{i} najpierw stanie się równe 10, następnie 11, a @code{atan2}
wywołane zostanie z argumentami 11 i 10.

@node Funkcje numeryczne, Funkcje łańcuchowe, Wywoływanie wbudowanych, Wbudowane
@section Wbudowane funkcje numeryczne

Oto pełna lista funkcji wbudowanych działających na liczbach.  Parametry
opcjonalne umieszczono w nawiasach kwadratowych (``['' i ``]'').

@table @code
@item int(@var{x})
@findex int
Tworzy najbliższą liczbę całkowitą w stosunku do @var{x}, położoną pomiędzy
@var{x} a zerem, obciętą w stronę zera.

Na przykład, @code{int(3)} jest trzy, @code{int(3.9)} jest trzy,
@code{int(-3.9)} jest @minus{}3, a @code{int(-3)} jest także @minus{}3.

@item sqrt(@var{x})
@findex sqrt
Podaje pierwiastek kwadratowy z @var{x}.  Zgłasza błąd gdy @var{x} jest
ujemne.  Zatem, @code{sqrt(4)} wynosi dwa.

@item exp(@var{x})
@findex exp
Daje potęgę naturalną o wykładniku @var{x} (@code{e ^ @var{x}}), lub zgłasza
błąd jeśli @var{x} jest poza dopuszczalnym zakresem.  Zakres wartości, jakie
może przyjmować @var{x} zależy od reprezentacji zmiennoprzecinkowej danej
architektury.

@item log(@var{x})
@findex log
Podaje logarytm naturalny z @var{x}, jeśli @var{x} jest dodatnie;
w przeciwnym razie, zgłasza błąd.

@item sin(@var{x})
@findex sin
Daje sinus z @var{x}, gdzie @var{x} jest w radianach.

@item cos(@var{x})
@findex cos
Daje cosinus z @var{x}, gdzie @var{x} jest w radianach.

@item atan2(@var{y}, @var{x})
@findex atan2
Podaje arcus tangens z @code{@var{y} / @var{x}} w radianach.

@item rand()
@findex rand
Daje liczbę losową.  Wartości @code{rand} są równomiernie rozłożone między
zerem a jeden.  Wartość nigdy nie wynosi zero ani jeden.

Często zamiast tego potrzebujemy losowych liczb całkowitych.  Oto funkcja
użytkownika, która można wykorzystać do uzyskiwania
nieujemnych liczb całkowitych mniejszych niż @var{n}:

@example
function randint(n) @{
     return int(n * rand())
@}
@end example

@noindent
Mnożenie tworzy losową liczbę większą od zera a mniejszą od @code{n}.
Następnie robimy z niej całkowitą (za pomocą @code{int}) pomiędzy
zero a @code{n} @minus{} 1, włącznie.

Oto przykład, w którym podobną funkcję zastosowano do tworzenia liczb
pseudolosowych między jeden a @var{n}.  Program ten wypisuje nową liczbę
losową dla każdego rekordu wejściowego.

@example
@group
awk '
# funkcja rzucająca symulowaną kostką.
function roll(n) @{ return 1 + int(rand() * n) @}
@end group

@group
# Rzuć trzema 6-bocznymi kostkami i
# wypisz całkowitą liczbę punktów.
@{
      printf("%d punktów\n",
             roll(6)+roll(6)+roll(6))
@}'
@end group
@end example

@cindex ziarno dla liczb losowych
@cindex liczby losowe, ziarno
@comment MAWK uses a different seed each time.
@strong{Uwaga:} W większości implementacji @code{awk}, łącznie z @code{gawk},
@code{rand} zaczyna tworzenie liczb losowych od tej samej liczby
początkowej (czyli @dfn{ziarna}) przy każdym uruchomieniu @code{awk}.
Zatem, dany program będzie przy każdym uruchomieniu generował te same
wyniki.  Liczby te są losowe w pojedynczym przebiegu @code{awk}, ale
przewidywalne między uruchomieniami.  Jest to przydatne przy debugowania,
ale jeśli chcemy, by przy każdym użyciu program robił inne rzeczy, musimy
zmienić ziarno na wartość, która przy każdym przebiegu będzie inna.
W tym celu należy skorzystać z @code{srand}.

@item srand(@r{[}@var{x}@r{]})
@findex srand
Funkcja @code{srand} nadaje punktowi startowemu, ziarnu, tworzenia liczb
losowych wartość @var{x}.

Każda wartość ziarna prowadzi do konkretnego ciągu liczb
losowych.@footnote{Tworzone przez komputer liczby losowe nie są naprawdę
losowe.  Techniczne znane są jako ``pseudo-losowe''.  Oznacza to, że
mimo, iż liczby w sekwencji wyglądają na losowe, to w rzeczywistości można
wciąż od nowa tworzyć tę samą sekwencję liczb losowych.}
Zatem, jeżeli kolejnym razem przypiszemy ziarnu tę samą wartość,
otrzymamy ponownie ten sam ciąg liczb losowych.

Jeżeli argument @var{x} zostanie pominięty, jak w @code{srand()}, to jako
ziarno zostaną użyte bieżąca data i czas.  Jest to sposób uzyskiwania
liczb losowych, które naprawdę są nieprzewidywalne.

Wartością zwracaną przez @code{srand} jest poprzednie ziarno.
Ułatwia to śledzenie ziaren przy konsekwentnym odtwarzaniu sekwencji liczb
losowych.
@end table

@node Funkcje łańcuchowe, Funkcje I/O, Funkcje numeryczne, Wbudowane
@section Funkcje wbudowane działające na łańcuchach

Funkcje w tej sekcji badają lub zmieniają tekst jednego lub więcej
łańcuchów.   Parametry opcjonalne umieszczono w nawiasach
kwadratowych (``['' i ``]'').

@table @code
@item index(@var{gdzie}, @var{co})
@findex index
Szuka w łańcuchu @var{gdzie} pierwszego wystąpienia łańcucha @var{co}
i zwraca pozycję, w znakach, na której pojawia się w @var{gdzie} to
wystąpienie.  Na przykład:

@example
$ awk 'BEGIN @{ print index("peanut", "an") @}'
@print{} 3
@end example

@noindent
Jeżeli nie znaleziono @var{co}, to @code{index} zwraca zero.
(Należy pamiętać, że w @code{awk} indeksy w łańcuchach zaczynają się
od jeden.)

@item length(@r{[}@var{łańcuch}@r{]})
@findex length
Podaje liczbę znaków w @var{łańcuchu}.  Jeżeli @var{łańcuch} jest liczbą,
zwracana jest długość łańcucha numerycznego reprezentującego tę liczbę.
Na przykład, @code{length("abcde")} wynosi pięć.  W przeciwieństwie do tego,
@code{length(15 * 35)} wynosi trzy.  W jaki sposób?  Cóż, 15 * 35 = 525, a
525 jest zamieniane na łańcuch @code{"525"}, który ma trzy znaki.

Jeżeli nie podano argumentu, @code{length} zwraca długość @code{$0}.

@cindex cechy historyczne
@cindex przenośność
@cindex język @code{awk}, wersja POSIX
@cindex POSIX @code{awk}
W starszych wersjach @code{awk}, można było wywoływać funkcję @code{length}
bez żadnych nawiasów.  Robienie tego w standardzie POSIX oznaczono jako
``niezalecane''.  To znaczy, że mimo, iż można tak robić we własnych
programach, jest to cecha, która ostatecznie zostanie usunięta z przyszłych
wersji standardu.  Z tego powodu, dla maksymalnej przenośności programów
@code{awk}, powinno się zawsze podawać nawiasy.

@item match(@var{łańcuch}, @var{regexp})
@findex match
Funkcja @code{match} szuka w łańcuchu @var{łańcuch} najdłuższego lewego
podłańcucha pasującego do wyrażenia regularnego @var{regexp}.  Zwraca
pozycję znaku, @dfn{indeks}, gdzie rozpoczyna się ten podłańcuch
(jeden, jeśli zaczyna się na początku @var{łańcucha}).  Jeżeli nie
znaleziono dopasowania zwracane jest zero.

@vindex RSTART
@vindex RLENGTH
Funkcja @code{match} nadaje zmiennej wbudowanej @code{RSTART} wartość
znalezionego indeksu.  Przypisuje też zmiennej wbudowanej @code{RLENGTH}
długość, w znakach, pasującego podłańcucha.  Jeżeli nie znaleziono
dopasowania, @code{RSTART} jest zerowane, a @code{RLENGTH} otrzymuje
wartość @minus{}1.

Na przykład:

@example
@group
@c file eg/misc/findpat.sh
awk '@{
       if ($1 == "FIND")
         regex = $2
       else @{
         gdzie = match($0, regex)
         if (gdzie != 0)
           print "Dopasowanie", regex,        \
                    "znaleziono na pozycji", \
                    gdzie, "w", $0
       @}
@}'
@c endfile
@end group
@end example

@noindent
Powyższy program szuka wierszy pasujących do wyrażenia regularnego
zapamiętanego w zmiennej @code{regex}.  To wyrażenie regularne można
zmienić.  Jeśli pierwszym słowem wiersza jest @samp{FIND}, to @code{regex}
zmieniane jest na drugie słowo tego wiersza.  Stąd też, przy podanym:

@example
@c file eg/misc/findpat.data
FIND dzia+ła
Mój program działa
ale niezbyt szybko
FIND Melvin
JF+KM
Ta linijka jest własnością Reality Engineering Co.
Melvin był tutaj.
@c endfile
@end example

@noindent
@code{awk} wypisze:

@example
Dopasowanie dzia+ła znaleziono na pozycji 12 w Mój program działa
Dopasowanie Melvin znaleziono na pozycji 1 w Melvin był tutaj.
@end example

@item split(@var{łańcuch}, @var{tablica} @r{[}, @var{sep-pól}@r{]})
@findex split
Dzieli @var{łańcuch} na kawałki rozdzielane przez @var{sep-pól} i
zapamiętuje je w @var{tablicy}.  Pierwszy z nich zapamiętywany jest w
@code{@var{array}[1]}, drugi w @code{@var{array}[2]}, i tak dalej.
Wartość łańcuchowa trzeciego argumentu, @var{sep-pól}, jest wyrażeniem
regularnym opisującym, w którym miejscach dzielić @var{łańcuch}
(choć jak @code{FS} może być wyrażeniem regularnym opisującym, w których
miejscach dzielić rekordy wejściowe).  Jeżeli pominięto @var{sep-pól},
stosowana jest wartość @code{FS}.
@code{split} zwraca liczbę utworzonych elementów.

Funkcja @code{split} dzieli łańcuchy na części w sposób podobny do tego,
w jaki wiersze wejściowe dzielone są na pola.  Na przykład:

@example
split("cul-de-sac", a, "-")
@end example

@noindent
rozbija łańcuch @samp{cul-de-sac} na trzy pola, wykorzystując @samp{-} jako
separator.  Nadaje tablicy @code{a} zawartość jak niżej:

@example
a[1] = "cul"
a[2] = "de"
a[3] = "sac"
@end example

@noindent
Wartością zwracaną przez to wywołanie @code{split} jest trzy.

Tak jak przy podziale na pola, gdy wartością @var{sep-pól} jest
@w{@code{" "}}, początkowe i końcowe białe znaki są ignorowane, a elementy
rozdzielane są przez ciągi białych znaków.

@cindex różnice między @code{gawk} a @code{awk}
Również tak jak przy podziale na pola, jeżeli @var{sep-pól} jest łańcuchem
pustym, każdy z poszczególnych znaków dzielonego łańcucha tworzy odrębny
element tablicy.  (Jest to rozszerzenie specyficzne dla @code{gawk}.)

@cindex ciemny kąt
W ostatnich implementacjach @code{awk}, łącznie z @code{gawk},
trzeci argument może być równie dobrze łańcuchem, jak i stałym wyrażeniem
regularnym (@code{/abc/}) (c.k.).  Standard POSIX również na to pozwala.

Przed podziałem łańcucha @code{split} usuwa wszelkie uprzednio istniejące
elementy tablicy @var{tablica} (c.k).

Jeżeli @var{łańcuch} w ogóle nie zawiera dopasowania do @var{sep-pól},
@var{tablica} będzie mieć jeden element.  Wartością tego elementu będzie
pierwotny @var{łańcuch}.

@item sprintf(@var{format}, @var{wyrażenie1},@dots{})
@findex sprintf
Zwraca (bez wypisywania) łańcuch jaki wypisałaby instrukcja @code{printf}
z tymi samymi argumentami
(@pxref{Printf, ,Wymyślne wyjście dzięki instrukcji @code{printf}}).
Na przykład:

@example
sprintf("pi = %.2f (w przybl.)", 22/7)
@end example

@noindent
zwraca łańcuch @w{@code{"pi = 3.14 (w przybl.)"}}.

@ignore
2e: For sub, gsub, and gensub, either here or in the "how much matches"
    section, we need some explanation that it is possible to match the
    null string when using closures like *.  E.g.,

         $ echo abc | awk '{ gsub(/m*/, "X"); print }'
         @print{} XaXbXcX

    Although this makes a certain amount of sense, it can be very
    suprising.
@end ignore

@item sub(@var{regexp}, @var{zastąpienie} @r{[}, @var{cel}@r{]})
@findex sub
Funkcja @code{sub} zmienia wartość @var{celu}.
Szuka w tej wartości, traktowanej jako łańcuch, lewego najdłuższego
podłańcucha pasującego do wyrażenia regularnego, @var{regexp}, rozszerzając
to dopasowanie, tak dalece, jak to możliwe.  Następnie cały łańcuch jest
zmieniany poprzez zastąpienie dopasowanego tekstu przez @var{zastąpienie}.
Zmodyfikowany łańcuch staje się nową wartością @var{celu}.

Jest to szczególna funkcja, gdyż @var{cel} nie jest używane po prostu
do obliczenia wartości, i nie wystarczy tu dowolne wyrażenie: musi to być
zmienna, pole lub element tablicy, tak by @code{sub} mogła w nim przechować
zmienioną wartość.  Jeżeli pominięto ten argument, to domyślnie
wykorzystywane i zmieniane jest @code{$0}.

Na przykład:

@example
str = "water, water, everywhere"
sub(/at/, "ith", str)
@end example

@noindent
Nadaje @code{str} wartość @w{@code{"wither, water, everywhere"}}, dzięki
zamianie lewego najdłuższego wystąpienia @samp{at} przez @samp{ith}.

Funkcja @code{sub} zwraca liczbę wykonanych zastąpień (albo jeden albo
zero).

Jeżeli w @var{zastąpieniu} pojawia się znak specjalny @samp{&}, to oznacza
on ten sam podłańcuch, który pasował do @var{regexp}.  (Jeżeli do danego
wyrażenia regularnego może pasować więcej niż jeden łańcuch, wówczas
pasujący w danym przypadku łańcuch może być różny.)  Na przykład:

@example
awk '@{ sub(/kandydat/, "& i jego żona"); print @}'
@end example

@noindent
zmienia w każdym wierszu wejściowym pierwsze wystąpienie słowa
@samp{kandydat} na @samp{kandydat i jego żona}.

Oto inny przykład:

@example
awk 'BEGIN @{
        str = "daabaaa"
        sub(/a*/, "C&C", str)
        print str
@}'
@print{} dCaaCbaaa
@end example

@noindent
Pokazuje on, jak @samp{&} może reprezentować łańcuch nie będący stałą.
Ilustruje też regułę ``lewe, najdłuższe'' w dopasowaniach wyrażeń
regularnych.  (@pxref{Lewe najdłuższe, ,Jak bardzo pasuje tekst?}).

Działanie tego znaku specjalnego (@samp{&}) można wyłączyć stawiając
przed nim w łańcuchu odwrotny ukośnik.  Jak zwykle, w celu wstawienia
odwrotnego ukośnika w łańcuchu, musimy napisać dwa odwrotne ukośniki.
Stąd też, aby w argumencie @var{zastąpienie} umieścić dosłowny @samp{&},
należy napisać @samp{\\&} w stałej łańcuchowej.
Na przykład, w ten sposób zastępujemy pierwszy znak @samp{|} w każdym wierszu
znakiem @samp{&}:

@example
awk '@{ sub(/\|/, "\\&"); print @}'
@end example

@cindex @code{sub}, jej trzeci argument
@cindex @code{gsub}, jej trzeci argument
@strong{Zauważ:} jak wspomniano wyżej, trzeci argument @code{sub} musi być
zmienną, polem lub odwołaniem do tablicy.  Niektóre z wersji @code{awk}
pozwalają, by argument ten był wyrażeniem nie będącym lwartością.  W takim
przypadku, @code{sub} nadal szuka wzorca i zwraca zero lub jeden, ale wynik
podstawienia (jeśli jest takowy) zostanie odrzucony, gdyż nie ma miejsca,
w którym możnaby go umieścić.  Te wersje @code{awk} akceptują wyrażenia
takie jak to:

@example
sub(/USA/, "United States", "USA i Canada")
@end example

@noindent
Z uwagi na zgodność historyczną, @code{gawk} przyjmie błędny kod, jak w
powyższym przykładzie.  Jednak użycie jakiegokolwiek innego nie dającego się
zmienić obiektu jako trzeciego parametru spowoduje błąd krytyczny, a program
nie uruchomi się.

Na koniec, jeśli @var{regexp} nie jest stałym wyrażeniem regularnym, to jest
przekształcane na łańcuch. Następnie wartość tego łańcucha traktowana jest
jak wyrażenie regularne do dopasowania.

@item gsub(@var{regexp}, @var{zastąpienie} @r{[}, @var{cel}@r{]})
@findex gsub
Podobna do funkcji @code{sub}, poza tym, że @code{gsub} zastępuje
@emph{wszystkie} najdłuższe, lewe, @emph{nie nakładające się} pasujące
podłańcuchy jakie znajdzie.  Litera @samp{g} w @code{gsub} znaczy
``globalnie'', czyli zastępowanie wszędzie.  Na przykład:

@example
awk '@{ gsub(/Britain/, "United Kingdom"); print @}'
@end example

@noindent
zastępuje we wszystkich rekordach wejściowych wszystkie wystąpienia łańcucha
@samp{Britain} przez @samp{United Kingdom}.

Funkcja @code{gsub} zwraca liczbę wykonanych podstawień.  Jeżeli pominięto
zmienną, jaka ma być przeszukana i zmieniona, @var{cel}, to używany jest
cały rekord wejściowy, @code{$0}.

Jak w @code{sub}, znaki @samp{&} i @samp{\} mają specjalne znaczenie,
a trzeci argument musi być lwartością.
@end table

@table @code
@item gensub(@var{regexp}, @var{zastąpienie}, @var{jak} @r{[}, @var{cel}@r{]})
@findex gensub
@code{gensub} jest ogólną funkcją podstawiania.  Podobnie jak @code{sub}
i @code{gsub}, przegląda łańcuch docelowy @var{cel} szukając dopasowań
wyrażenia regularnego @var{regexp}.  Inaczej niż w @code{sub} i @code{gsub},
zmodyfikowany łańcuch zwracany jest jako wynik działania funkcji, a pierwotny
łańcuch @emph{nie} jest zmieniany.  Jeżeli @var{jak} jest łańcuchem
zaczynającym się literą @samp{g} lub @samp{G}, to przez @var{zastąpienie}
zostaną zastąpione wszystkie dopasowania @var{regexp}.  W przeciwnym razie,
@var{how} jest liczbą wskazującą, które wystąpienie @var{regexp} ma zostać
wymienione.  Jeżeli nie podano @var{celu}, to zamiast niego wykorzystywane
jest @code{$0}.

@code{gensub} udostępnia dodatkową cechę, niedostępną w @code{sub} czy
@code{gsub}: możliwość określenia składowych wyrażenia regularnego
w zastępującym tekście.  Robimy to używając nawiasów do wskazania
składowych w dopasowywanym wyrażeniu regularnym, a następnie podanie
@samp{\@var{n}} w tekście zastępującym, gdzie @var{n} jest cyfrą od
jeden do dziewięć.  Na przykład:

@example
@group
$ gawk '
> BEGIN @{
>      a = "abc def"
>      b = gensub(/(.+) (.+)/, "\\2 \\1", "g", a)
>      print b
> @}'
@print{} def abc
@end group
@end example

@noindent
Jak opisano wyżej przy @code{sub}, musimy wpisać dwa odwrotne ukośniki,
by w łańcuchu uzyskać jeden.

W tekście zastępującym sekwencja @samp{\0} reprezentuje cały
dopasowany tekst, tak samo jak znak @samp{&}.

Ten przykład pokazuje, jak wykorzystać trzeci argument do wyboru
dopasowania, które ma zostać zmienione.

@example
$ echo a b c a b c |
> gawk '@{ print gensub(/a/, "AA", 2) @}'
@print{} a b c AA b c
@end example

W tym przypadku zastosowano @code{$0}, jako domyślny łańcuch docelowy.
@code{gensub} zwraca jako wynik nowy łańcuch, przekazywany bezpośrednio do
@code{print} w celu wypisania.

Jeśli argument @var{jak} jest łańcuchem nie rozpoczynającym się od @samp{g}
lub @samp{G}, lub jeśli jest liczbą mniejszą od zera, wykonywane jest tylko
jedno zastąpienie.

Jeżeli w @var{cel} nie ma dopasowania do @var{regexp}, wartością zwracaną
przez @code{gensub} jest pierwotna, niezmieniona wartość @var{celu}.

@cindex różnice między @code{gawk} a @code{awk}
@code{gensub} jest rozszerzeniem @code{gawk}; nie jest dostępne w trybie
zgodności (@pxref{Opcje, ,Opcje wiersza poleceń}).

@item substr(@var{łańcuch}, @var{start} @r{[}, @var{długość}@r{]})
@findex substr
Zwraca @var{długość}-znakowy podłańcuch @var{łańcucha}, poczynając od znaku
numer @var{start}.  Pierwszy znak każdego łańcucha jest znakiem numer
jeden.  Na przykład, @code{substr("washington", 5, 3)} zwraca @code{"ing"}.

Jeżeli nie podano @var{długości}, funkcja zwraca całą końcówkę
@var{łańcucha} rozpoczynającą się od znaku numer @var{start}.  Na przykład,
@code{substr("washington", 5)} zwraca @code{"ington"}.  Cała końcówka
zwracana jest także jeśli @var{długość} jest większa niż liczba znaków
pozostałych w danym łańcuchu, licząc od znaku numer @var{start}.

@strong{Zauważ:} Do łańcucha zwracanego przez @code{substr} @emph{nie można}
wykonać przypisania wartości.  A zatem błędem jest próba zmiany części
łańcucha w ten sposób:

@example
string = "abcdef"
# próba uzyskania "abCDEf", nie zadziała
substr(string, 3, 3) = "CDE"
@end example

@noindent
lub użycia @code{substr} jako trzeciego argumentu @code{sub} czy @code{gsub}:

@example
gsub(/xyz/, "pdq", substr($0, 5, 20))  # ŹLE
@end example

@cindex konwersja wielkości liter
@cindex wielkość liter, konwersja
@item tolower(@var{łańcuch})
@findex tolower
Zwraca kopię @var{łańcucha}, w której wszystkie duże litery zamieniono na
odpowiadające im małe litery.  Znaki niealfabetyczne są pozostawione bez
zmian.  Na przykład, @code{tolower("MiEsZaNe 123")} zwraca
@code{"mieszane 123"}.

@item toupper(@var{łańcuch})
@findex toupper
Zwraca kopię @var{łańcucha}, w której wszystkie małe litery zamieniono na
odpowiadające im duże litery.  Znaki niealfabetyczne są pozostawione bez
zmian.  Na przykład, @code{tolower("MiEsZaNe 123")} zwraca
@code{"MIESZANE 123"}.
@end table

@c fakenode --- for prepinfo
@subheading Więcej o @samp{\} i @samp{&} w @code{sub}, @code{gsub} i @code{gensub}

@cindex przetwarzanie znaków specjalnych, @code{sub} i in.
Przy stosowaniu @code{sub}, @code{gsub} lub @code{gensub}, i usiłowaniu
uzyskania dosłownych znaków odwrotnego ukośnika i ampersandu w tekście
zastępującym, należy pamiętać o istnieniu kilku poziomów @dfn{przetwarzania
sekwencji specjalnych}, jakie zostaną wykonane.

Po pierwsze, mamy poziom @dfn{leksykalny}, występujący wtedy, gdy @code{awk}
czyta nasz program i tworzy jego wewnętrzną kopię, nadającą się do wykonania.

Następny poziom pojawia się podczas wykonywania programu, gdy @code{awk}
rzeczywiście bada łańcuch zastępujący, by określić, co ma utworzyć.

Na obu tych poziomach @code{awk} szuka zdefiniowanego zestawu znaków, jakie
mogą pojawić się po odwrotnym ukośniku.  Na poziomie leksykalnym, szukane są
sekwencje specjalne wymienione w @ref{Sekwencje specjalne}.  Stąd też, dla
każdego @samp{\}, który @code{awk} ma przetworzyć na poziomie wykonania,
zapisujemy dwa @samp{\} na poziomie leksykalnym.  Gdy po @samp{\} występuje
znak nie tworzący z nim poprawnej sekwencji specjalnej, zarówno uniksowy
@code{awk} jak i @code{gawk} po prostu usuwają taki początkowy @samp{\},
i umieszczają następujący po nim znak w łańcuchu.  Zatem, na przykład,
@code{"a\qb"} traktowane jest jak @code{"aqb"}.

Na poziomie wykonania rozmaite funkcje różnie obsługują sekwencje @samp{\}
i @samp{&}.  Sytuacja jest (niestety) dość złożona.

Historycznie, funkcje @code{sub} i @code{gsub} traktowały w specjalny sposób
dwuznakową sekwencję @samp{\&}.  W tworzonym tekście była ona zastępowana
pojedynczym @samp{&}.  Wszystkie inne @samp{\} w łańcuchu @var{zastąpienia},
które nie poprzedzały znaku @samp{&} były przekazywane dalej bez zmian.
Ilustruje to tabela:

@c Thank to Karl Berry for help with the TeX stuff.
@tex
\vbox{\bigskip
% This table has lots of &'s and \'s, so unspecialize them.
\catcode`\& = \other \catcode`\\ = \other
% But then we need character for escape and tab.
@catcode`! = 4
@halign{@hfil#!@qquad@hfil#!@qquad#@hfil@cr
    Piszemy !@code{sub} widzi!@code{sub} tworzy@cr
@hrulefill!@hrulefill!@hrulefill@cr
   @code{\&}!       @code{&}!pasujący tekst@cr
  @code{\\&}!      @code{\&}!dosłowny @samp{&}@cr
 @code{\\\&}!      @code{\&}!dosłowny @samp{&}@cr
@code{\\\\&}!     @code{\\&}!dosłowne @samp{\&}@cr
@code{\\\\\&}!     @code{\\&}!dosłowne @samp{\&}@cr
@code{\\\\\\&}!     @code{\\\&}!dosłowne @samp{\\&}@cr
  @code{\\q}!      @code{\q}!dosłowne @samp{\q}@cr
}
@bigskip}
@end tex
@ifinfo
@display
 Piszemy          @code{sub} widzi         @code{sub} tworzy
 -------          ---------           ---------
     @code{\&}              @code{&}            pasujący tekst
    @code{\\&}             @code{\&}            dosłowny @samp{&}
   @code{\\\&}             @code{\&}            dosłowny @samp{&}
  @code{\\\\&}            @code{\\&}            dosłowne @samp{\&}
 @code{\\\\\&}            @code{\\&}            dosłowne @samp{\&}
@code{\\\\\\&}           @code{\\\&}            dosłowne @samp{\\&}
    @code{\\q}             @code{\q}            dosłowne @samp{\q}
@end display
@end ifinfo

@noindent
Tabela ta pokazuje zarówno przetwarzanie na poziomie leksykalnym, gdzie
nieparzysta liczba odwrotnych ukośników staje się parzystą liczbą
na poziomie wykonania, jak i wykonywane przez @code{sub} przetwarzanie
na poziomie wykonania.  (Dla uproszczenia, reszta tabel poniżej
pokazuje tylko przypadek wprowadzenia na poziomie leksykalnym parzystej
liczby odwrotnych ukośników @samp{\}.)

Kłopot przy podejściu historycznym stanowi to, że nie ma sposobu
na uzyskanie dosłownego @samp{\}, po którym następuje dopasowany przez
funkcję tekst.

@cindex język @code{awk}, wersja POSIX
@cindex POSIX @code{awk}
W 1992 standard POSIX usiłował rozwiązać ten problem.  Standard stwierdza,
że @code{sub} i @code{gsub} szukają po @samp{\} albo @samp{\} albo @samp{&}.
Jeżeli po @samp{\} występuje któryś z tych znaków, to jest on wypisywany
dosłownie.  Interpretacja @samp{\} i @samp{&} staje się więc taka:

@c thanks to Karl Berry for formatting this table
@tex
\vbox{\bigskip
% This table has lots of &'s and \'s, so unspecialize them.
\catcode`\& = \other \catcode`\\ = \other
% But then we need character for escape and tab.
@catcode`! = 4
@halign{@hfil#!@qquad@hfil#!@qquad#@hfil@cr
    Piszemy !@code{sub} widzi!@code{sub} tworzy@cr
@hrulefill!@hrulefill!@hrulefill@cr
    @code{&}!       @code{&}!dopasowany tekst@cr
  @code{\\&}!      @code{\&}!dosłowny @samp{&}@cr
@code{\\\\&}!     @code{\\&}!dosłowny @samp{\}, następnie dopasowany tekst@cr
@code{\\\\\\&}!  @code{\\\&}!dosłowne @samp{\&}@cr
}
@bigskip}
@end tex
@ifinfo
@display
 Piszemy          @code{sub} widzi         @code{sub} tworzy
 -------          ---------           ---------
      @code{&}              @code{&}            dopasowany tekst
    @code{\\&}             @code{\&}            dosłowny @samp{&}
  @code{\\\\&}            @code{\\&}            dosłowny @samp{\}, następnie dopasowany tekst
@code{\\\\\\&}           @code{\\\&}            dosłowne @samp{\&}
@end display
@end ifinfo

@noindent
Wyglądało na to, że to rozwiązuje problem.
Niestety, sposób wysławiania się standardu jest niecodzienny.
W rezultacie, twierdzi on, że @samp{\} wyłącza specjalne znaczenie każdego
następującego po nim znaku, że, oprócz @samp{\} i @samp{&}, takie specjalne
znaczenie jest niezdefiniowane.
Z takiego sformułowania wynikają dwa problemy.

@enumerate
@item
Odwrotne ukośniki w łańcuchu @var{zastąpienie} muszą być teraz podwojone,
co psuje historyczne programy @code{awk}.

@item
Aby mieć pewność, że program @code{awk} jest przenośny, @emph{każdy} znak
w @var{zastąpieniu} musi być poprzedzony odwrotnym ukośnikiem@footnote{Ten
skutek standardu był z pewnością niezamierzony.}
@c mogę to stwierdzić, bo byłem zangażowany w tę zmianę
@end enumerate

Standard POSIX jest w trakcie poprawek.@footnote{Według stanu na
@value{UPDATE-MONTH}, z ostateczną akceptacją i publikacją jako części
Austin Group Standards miejmy nadzieję gdzieś w 2001.}
Z powodu powyższych kłopotów, proponowany tekst dla
skorygowanego standardu powraca do zasad ściślej odpowiadających pierwotnie
istniejącej praktyce.  Proponowane zasady mają przypadki specjalne, co
umożliwia utworzenie @samp{\} poprzedzającego dopasowany tekst.

@tex
\vbox{\bigskip
% This table has lots of &'s and \'s, so unspecialize them.
\catcode`\& = \other \catcode`\\ = \other
% But then we need character for escape and tab.
@catcode`! = 4
@halign{@hfil#!@qquad@hfil#!@qquad#@hfil@cr
    Piszemy !@code{sub} widzi!@code{sub} tworzy@cr
@hrulefill!@hrulefill!@hrulefill@cr
@code{\\\\\\&}!     @code{\\\&}!dosłowne @samp{\&}@cr
@code{\\\\&}!     @code{\\&}!dosłowny @samp{\}, po którym następuje dopasowany tekst@cr
  @code{\\&}!      @code{\&}!dosłowny @samp{&}@cr
  @code{\\q}!      @code{\q}!dosłowne @samp{\q}@cr
}
@bigskip}
@end tex
@ifinfo
@display
 Piszemy          @code{sub} widzi         @code{sub} tworzy
 -------          ---------           ---------
@code{\\\\\\&}           @code{\\\&}            dosłowne @samp{\&}
  @code{\\\\&}            @code{\\&}            dosłowny @samp{\}, po którym następuje dopasowany tekst
    @code{\\&}             @code{\&}            dosłowny @samp{&}
    @code{\\q}             @code{\q}            dosłowne @samp{\q}
@end display
@end ifinfo

W skrócie, na poziomie wykonania istnieją teraz trzy specjalne sekwencje
znaków: @samp{\\\&}, @samp{\\&} i @samp{\&}, podczas gdy, historycznie,
była tu tylko jedna.  Jednak, jak w przypadku historycznym, każdy @samp{\},
który nie jest częścią jednej z tych sekwencji specjalnych, nie ma znaczenia
specjalnego i pojawia się na wyjściu dosłownie.

@code{gawk} 3.0 przestrzega tych, proponowanych przez POSIX, zasad
dla @code{sub} i @code{gsub}.
@c As much as we think it's a lousy idea. You win some, you lose some. Sigh.
Czy zaproponowane reguły faktycznie zostaną skodyfikowane w standardzie
w tym momencie nie wiadomo.  Następne wydania @code{gawk} będą śledzić
standard i wdrażać to, co określi jego ostateczna wersja.  Niniejsza
książka będzie także aktualizowana.

Reguły dla @code{gensub} są znacznie prostsze. Na poziomie wykonania,
gdy @code{awk} dostrzeże @samp{\}, jeśli następnym znakiem jest cyfra,
to w tworzonym wyjściu jest umieszczany tekst, który pasował do
odpowiadającego jej umieszczonego w nawiasach podwyrażenia.  W przeciwnym
razie, bez względu na to, jaki znak występuje po @samp{\}, znak ten pojawi
się w utworzonym tekście, a @samp{\} nie wystąpi.

@tex
\vbox{\bigskip
% This table has lots of &'s and \'s, so unspecialize them.
\catcode`\& = \other \catcode`\\ = \other
% But then we need character for escape and tab.
@catcode`! = 4
@halign{@hfil#!@qquad@hfil#!@qquad#@hfil@cr
    Piszemy !@code{gensub} widzi!@code{gensub} tworzy@cr
@hrulefill!@hrulefill!@hrulefill@cr
      @code{&}!           @code{&}!dopasowany tekst@cr
    @code{\\&}!          @code{\&}!dosłowny @samp{&}@cr
   @code{\\\\}!          @code{\\}!dosłowny @samp{\}@cr
  @code{\\\\&}!         @code{\\&}!dosłowny @samp{\}, następnie dopasowany tekst@cr
@code{\\\\\\&}!        @code{\\\&}!dosłowne @samp{\&}@cr
    @code{\\q}!          @code{\q}!dosłowne @samp{q}@cr
}
@bigskip}
@end tex
@ifinfo
@display
  Piszemy           @code{gensub} widzi        @code{gensub} tworzy
  -------           ------------          ------------
      @code{&}                    @code{&}            dopasowany tekst
    @code{\\&}                   @code{\&}            dosłowny @samp{&}
   @code{\\\\}                   @code{\\}            dosłowny @samp{\}
  @code{\\\\&}                  @code{\\&}            dosłowny @samp{\}, następnie dopasowany tekst
@code{\\\\\\&}                 @code{\\\&}            dosłowne @samp{\&}
    @code{\\q}                   @code{\q}            dosłowne @samp{q}
@end display
@end ifinfo

Z powodu złożoności przetwarzania na poziomie leksykalnym i wykonania
oraz przypadków specjalnych dla @code{sub} i @code{gsub}, zalecamy stosowanie
@code{gawk} i @code{gensub} w sytuacjach, gdy trzeba wykonać podstawienia.

@node Funkcje I/O, Funkcje czasu, Funkcje łańcuchowe, Wbudowane
@section Wbudowane funkcje wejścia/wyjścia

Poniższe funkcje związane są z wejściem/wyjściem (Input/Output (I/O).
Parametry opcjonalne umieszczono w nawiasach kwadratowych (``['' i ``]'').

@table @code
@item close(@var{nazwapliku})
@findex close
Zamyka plik @var{nazwapliku}, dla wejścia lub wyjścia.  Alternatywnie
argumentem może być polecenie powłoki, którego użyto do przekierowania do
lub z potoku; wówczas zamykany jest potok.
@xref{Zamykanie plików i potoków, ,Zamykanie potoków oraz plików wejściowych i wyjściowych},
gdzie podano szczegóły.

@item fflush(@r{[}@var{nazwapliku}@r{]})
@findex fflush
@cindex przenośność
@cindex opróżnianie buforów
@cindex bufory, opróżnianie
@cindex buforowanie wyjścia
@cindex wyjście, buforowanie
Opróżnia buforowane wyjście skojarzone z @var{nazwąpliku}, będącą
albo plikiem otwartym do zapisu, albo poleceniem powłoki przekierowującym
wyjście do potoku.

Wiele programów narzędziowych @dfn{buforuje} swoje wyjście. Przechowują one
w pamięci informacje, jakie mają zostać zapisane na dysku czy terminalu,
do czasu, aż będzie ich wystarczająco dużo, by warto było przesyłać dane na
urządzenie wyjściowe.
Jest to bardziej efektywne niż zapisywanie każdego kawałeczka danych od razu
gdy jest gotowy.  Czasami jednak konieczne jest wymuszenie na programie
@dfn{opróżnienia} (wymiecenia, flush) tych buforów; to jest, zapisania
informacji w miejscu ich przeznaczenia, nawet jeśli bufor nie jest
zapełniony.  Takie jest przeznaczenie funkcji @code{fflush}.  @code{gawk}
również buforuje swoje wyjście, a funkcji @code{fflush} można użyć do
wymuszenia na nim, by opróżnił swoje bufory.

@code{fflush} jest świeżym (1994) dodatkiem do wersji @code{awk} z Bell Labs
research.  Nie jest ona częścią standardu POSIX i nie będzie dostępna
jeśli w wierszu poleceń podano opcję
@samp{--posix} (@pxref{Opcje, ,Opcje wiersza poleceń}).

@code{gawk} poszerza funkcję @code{fflush} na dwa sposoby.  Pierwszym jest
pozwolenie na brak argumentu.  Opróżniany jest wówczas bufor standardowego
wyjścia.  Drugim jest zezwolenie na użycie jako argumentu łańcucha pustego
(@w{@code{""}}).  W tym przypadku opróżniane są bufory @emph{wszystkich}
otwartych plików wyjściowych i potoków.

@code{fflush} zwraca zero jeśli pomyślnie opróżniono bufor, a nie-zero
w przeciwnym razie.

@item system(@var{polecenie})
@findex system
@cindex interakcja, @code{awk} i innych programów
Funkcja @code{system} umożliwia użytkownikowi wykonywanie poleceń systemu
operacyjnego a następnie powrót do programu @code{awk}.  Funkcja
@code{system} wykonuje polecenie przekazane przez łańcuch @var{polecenie}.
Zwraca, jako swoją wartość, kod zakończenia polecenia, które wykonała.

Na przykład, jeśli w programie @code{awk} umieścimy poniższy fragment kodu:

@example
END @{
     system("date | mail -s 'koniec pracy awk' root")
@}
@end example

@noindent
do administratora systemu zostanie wysłana wiadomość w momencie gdy program
@code{awk} zakończy przetwarzanie wejścia i rozpocznie przetwarzanie obsługi
końca danych wejściowych.

Zauważ, że często do wykonania zadania wystarczy przekierowanie
@code{print} lub @code{printf} do potoku.  Jeżeli potrzebujemy uruchomić
wiele poleceń, efektywniejsze będzie po prostu wypisanie ich do potoku
prowadzącego do powłoki:

@example
while (@var{więcej rzeczy do zrobienia})
    print @var{polecenie} | "/bin/sh"
close("/bin/sh")
@end example

@noindent
Jeśli jednak program @code{awk} jest interaktywny, @code{system} przydaje
się do uruchamiania
dużych, niezależnych programów, jak powłoka czy edytor.

Niektóre systemy operacyjne nie potrafią zaimplementować funkcji
@code{system}.  Jeżeli nie jest obsługiwane, @code{system} powoduje błąd
krytyczny.
@end table

@c fakenode --- for prepinfo
@subheading Buforowanie interaktywne a nieinteraktywne
@cindex buforowanie, interaktywne a nieinteraktywne
@cindex buforowanie, nieinteraktywne a interaktywne
@cindex interaktywne buforowanie a nieinteraktywne
@cindex nieinteraktywne buforowanie a interaktywne

Nawiasem mówiąc, zagadnienia buforowania mogą być nawet bardziej
mylące w zależności od tego czy dany program jest @dfn{interaktywny}, tj.
komunikuje się z użytkownikiem siedzącym przy
klawiaturze.@footnote{Program jest interaktywny jeśli jego standardowe
wyjście jest przyłączone do urządzenia terminalowego.}

Programy interaktywne na ogół @dfn{buforują wierszami} swoje wyjście;
zapisują na urządzenie wyjściowe każdy wiersz.  Programy nieinteraktywne
czekają aż zapełni się bufor, który może zawierać wiele wierszy wyjścia.

@c Thanks to Walter.Mecky@dresdnerbank.de for this example, and for
@c motivating me to write this section.
Oto przykład pokazujący tę różnicę.

@example
$ awk '@{ print $1 + $2 @}'
1 1
@print{} 2
2 3
@print{} 5
@kbd{Control-d}
@end example

@noindent
Każdy wiersz wyjścia jest wypisywany natychmiast.  Porównajmy to zachowanie
z poniższym.

@example
$ awk '@{ print $1 + $2 @}' | cat
1 1
2 3
@kbd{Control-d}
@print{} 2
@print{} 5
@end example

@noindent
Tutaj, nie są wypisywane żadne wyniki aż do chwili, gdy zostanie
naciśnięte @kbd{Control-d}, gdyż całość wyjścia jest buforowana, i wysyłana
potokiem do @code{cat} w jednym kroku.

@c fakenode --- for prepinfo
@subheading Sterowanie buforowaniem wyjścia za pomocą @code{system}
@cindex opróżnianie buforów
@cindex bufory, opróżnianie
@cindex opróżnianie wyjścia
@cindex wyjście, opróżnianie

Funkcja @code{fflush} umożliwia bezpośrednie sterowanie buforowaniem wyjścia
poszczególnych plików i potoków.  Jednak wywołanie nie jest przenośne do
wielu innych implementacji @code{awk}.  Alternatywną metodą opróżniania
buforów wyjściowych jest wywołanie @code{system} z łańcuchem pustym jako
argumentem:

@example
system("")   # opróżnia wyjście
@end example

@noindent
@code{gawk} traktuje takie wykorzystanie funkcji @code{system} jako
przypadek specjalny, i jest wystarczająco sprytny, by nie uruchamiać powłoki
(czy innego interpretera poleceń) z pustym poleceniem.  Z tego powodu,
w @code{gawk} idiom ten jest nie tylko przydatny, ale i efektywny.  Mimo, że
metoda ta powinna działać z innymi implementacjami @code{awk}, niekoniecznie
uniknie wówczas zbędnego uruchamiania powłoki.  (Możliwe, że inne
implementacje opróżnią tylko bufor skojarzony ze standardowym wyjściem,
a niekoniecznie całe buforowane wyjście.)

Jeśli pomyślimy o tym, czego spodziewa się programista, to zrozumiałe
jest, że @code{system} powinno opróżniać całość oczekującego wyjścia.
Poniższy program:

@example
BEGIN @{
     print "pierwszy print"
     system("echo system echo")
     print "drugi print"
@}
@end example

@noindent
musi wypisać

@example
pierwszy print
system echo
drugi print
@end example

@noindent
a nie

@example
system echo
pierwszy print
drugi print
@end example

Jeśliby @code{awk} nie opróżniał buforów przed wywołaniem @code{system},
zobaczylibyśmy drugie (niepożądane) wyjście.

@node Funkcje czasu,  , Funkcje I/O, Wbudowane
@section Funkcje obsługi znaczników czasu

@cindex timestamps
@cindex czas
Typowym zastosowaniem programów @code{awk} jest przetwarzanie plików
dziennikowych zawierających znaczniki czasu, wskazujące kiedy zarejestrowano
konkretny wpis dziennika.  Wiele programów zapisuje znaczniki czasu
w postaci zwracanej przez funkcję systemową @code{time}, będącej liczbą
sekund od konkretnej daty (początku Epoki, Epoch).  Na systemach
POSIX-owych jest to liczba sekund od północy 1 stycznia 1970 czasu Greenwich
(UTC).

Dla ułatwienia przetwarzania takich plików rejestracyjnych i tworzenia
przydatnych zestawień, @code{gawk} udostępnia dwie funkcje przeznaczone
do pracy ze znacznikami czasu.  Obie są rozszerzeniami @code{gawk}; nie są
wyszczególnione w standardzie POSIX, ani nie istnieją w żadnej innej znanej
wersji @code{awk}.

Parametry opcjonalne umieszczono w nawiasach kwadratowych (``['' i ``]'').

@table @code
@item systime()
@findex systime
Funkcja ta zwraca bieżący czas jako liczbę sekund od daty początku Epoki
danego systemu.  Na systemach POSIX-owych jest to liczba sekund od północy 1
stycznia 1970 UTC.  Na innych systemach może to być odmienna liczba.

@item strftime(@r{[}@var{format} @r{[}, @var{timestamp}@r{]]})
@findex strftime
Funkcja ta zwraca łańcuch.  Jest podobna do funkcji o tej samej nazwie
występującej w ANSI C.  Czas określony przez @var{timestamp} wykorzystywany
jest do utworzenia łańcucha daty w oparciu o zawartość łańcucha @var{format}.
@var{timestamp} ma ten sam format, co wartość zwracana przez funkcję
@code{systime}.  Jeżeli nie podano argumentu @var{timestamp}, @code{gawk}
zastosuje jako znacznik czasu czas bieżący.  Jeżeli nie podano argumentu
@var{format}, @code{strftime} wykorzystuje
@code{@w{"%a %b %d %H:%M:%S %Z %Y"}}.  Taki łańcuch formatu tworzy wyjście
(prawie) równoważne temu, które daje narzędzie @code{date}.  (Wersje
@code{gawk} wcześniejsze niż 3.0 wymagają argumentu @var{format}.)
@end table

Funkcja @code{systime} umożliwia porównanie znacznika czasu z pliku
dziennika z bieżącym czasem.  W szczególności, łatwo jest stwierdzić, jak
dawno temu zarejestrowano dany wpis.  Pozwala też na tworzenie wpisów
wykorzystujących format ``liczby sekund od początku Epoki''.

Funkcja @code{strftime} umożliwia łatwe przekształcanie znacznika czasu
w dane czytelne dla człowieka.  W swej istocie podobna jest do funkcji
@code{sprintf}
(@pxref{Funkcje łańcuchowe, ,Funkcje wbudowane działające na łańcuchach}),
w tym, że znaki nie tworzące specyfikacji formatu kopiuje do zwracanego
łańcucha dosłownie, podczas gdy wartości daty i czasu zastępuje według
specyfikacji z łańcucha @var{format}.

Standard ANSI C gwarantuje @code{strftime} obsługę następujących
specyfikacji formatu daty:

@table @code
@item %a
Skrócona narodowa (locale) nazwa dnia tygodnia.

@item %A
Pełna narodowa nazwa dnia tygodnia.

@item %b
Skrócona narodowa nazwa miesiąca.

@item %B
Pełna narodowa nazwa miesiąca.

@item %c
``Właściwa'' narodowa reprezentacja daty i czasu.

@item %d
Dzień miesiąca jako liczba dziesiętna (01--31).

@item %H
Godzina (zegar 24-godzinny) jako liczba dziesiętna (00--23).

@item %I
Godzina (zegar 12-godzinny) jako liczba dziesiętna (01--12).

@item %j
Dzień roku jako liczba dziesiętna (001--366).

@item %m
Miesiąc jako liczba dziesiętna (01--12).

@item %M
Minuta jako liczba dziesiętna (00--59).

@item %p
Narodowy równoważnik oznaczeń AM/PM związanych z zegarem 12-godzinnym.

@item %S
Sekunda jako liczba dziesiętna (00--60).@footnote{Od czasu do czasu
występują w roku minuty o przestępnej sekundzie, z tego powodu sekundy
mogą dojść do 60.}

@item %U
Numer tygodnia w roku (pierwsza niedziela jako pierwszy dzień pierwszego
tygodnia) jako liczba dziesiętna (00--53).

@item %w
Dzień tygodnia jako liczba dziesiętna (0--6).  Niedziela to dzień zero.

@item %W
Numer tygodnia w roku (pierwszy poniedziałek jako pierwszy dzień pierwszego
tygodnia) jako liczba dziesiętna (00--53).

@item %x
``Właściwa'' narodowa reprezentacja daty.

@item %X
``Właściwa'' narodowa reprezentacja czasu.

@item %y
Rok bez stulecia jako liczba dziesiętna (00--99).

@item %Y
Rok ze stuleciem jako liczba dziesiętna (np., 1995).

@item %Z
Nazwa strefy czasowej lub jej skrót, albo brak znaków jeśli nie można
ustalić żadnej strefy.

@item %%
Dosłowny @samp{%}.
@end table

Jeżeli specyfikator konwersji nie jest jednym z powyższych, zachowanie jest
niezdefiniowane.@footnote{Jest tak, gdyż ANSI C pozostawia niezdefiniowanym
zachowanie się @code{strftime} wersji C, zaś @code{gawk} wykorzystuje
systemową wersję @code{strftime}, jeśli jest obecna.  Typowe jest albo
niepojawienie się specyfikatora konwersji w zwracanym łańcuchu, albo
pojawienie się dosłowne.}

@cindex locale, definicja
@cindex ustawienia narodowe, definicja
Nieformalnie, @dfn{locale} [tłum.: oddawane w przekładzie jako ustawienia
regionalne/narodowe] określa miejsce geograficzne, w którym mamy zamiar
uruchamiać program.  Na przykład, popularną metodą skracania daty 4 września
1991 w Stanach Zjednoczonych jest ``9/4/91''.  jednak W wielu krajach Europy
zapisanoby ją ``4.9.91''.  Zatem, specyfikacja @samp{%x} w ustawieniach
narodowych @code{"US"} może dawać @samp{9/4/91}, podczas gdy przy ustawieniu
@code{"EUROPE"} może dać @samp{4.9.91}.  Standard ANSI C definiuje
jako domyślne ustawienie regionalne @code{"C"}, będące typowym środowiskiem
jakiego używa większość programistów C.

Dla systemów, które nie są jeszcze w pełni zgodne z ANSI, razem z @code{gawk}
dostarczana jest na zasadach public-domain @code{strftime} w wersji C.
Jeżeli do kompilacji
@code{gawk} (@pxref{Instalacja, ,Instalowanie @code{gawk}})
zostanie użyta ta właśnie wersja,
to dostępne są następujące dodatkowe specyfikatory formatu:

@table @code
@item %D
Równoważne podaniu @samp{%m/%d/%y}.

@item %e
Dzień miesiąca, uzupełniony spacją jeśli jest jednocyfrowy.

@item %h
Równoważne @samp{%b}, powyżej.

@item %n
Znak nowej linii (ASCII LF).

@item %r
Równoważne podaniu @samp{%I:%M:%S %p}.

@item %R
Równoważne podaniu @samp{%H:%M}.

@item %T
Równoważne podaniu @samp{%H:%M:%S}.

@item %t
Znak tabulacji.

@item %k
Godzina (zegar 24-godzinny) jako liczba dziesiętna (0-23).  Liczby
jednocyfrowe uzupełniane są spacją.

@item %l
Godzina (zegar 12-godzinny) jako liczba dziesiętna (1-12).  Liczby
jednocyfrowe uzupełniane są spacją.

@item %C
Stulecie, jako liczba między 00 a 99.

@item %u
Dzień tygodnia jako liczba dziesiętna [1 (poniedziałek)--7].

@cindex ISO 8601
@item %V
Numer tygodnia w roku (pierwszy poniedziałek jako pierwszy dzień tygodnia
numer jeden) jako liczba dziesiętna (01--53).  Metoda wyznaczania numeru
tygodnia określona jest przez ISO 8601 (innymi słowy: jeśli tydzień
zawierający dzień 1 stycznia ma cztery lub więcej dni należące do nowego
roku, to jest on tygodniem numer jeden, w przeciwnym razie jest to tydzień
numer 53 roku poprzedniego a tygodniem numer jeden jest następny tydzień).

@item %G
Rok, ze stuleciem, numeru tygodnia wg ISO, jako liczba dziesiętna.

Na przykład, 1 stycznia 1993 jest w tygodniu 53 roku 1992.  Zatem,
rokiem jego numeru ISO tygodnia jest 1992, mimo że jego rokiem jest 1993.
Podobnie, 31 grudnia 1973 jest w tygodniu 1 roku 1974.  Zatem, rokiem jego
numeru ISO tygodnia jest 1974, mimo że jego rokiem jest 1973.

@item %g
Rok, bez stulecia, numeru ISO tygodnia, jako liczba dziesiętna (00--99).

@item %Ec %EC %Ex %Ey %EY %Od %Oe %OH %OI
@itemx %Om %OM %OS %Ou %OU %OV %Ow %OW %Oy
Są to ``alternatywne reprezentacje'' dla specyfikacji używających tylko
drugiej litery (@samp{%c}, @samp{%C}, i tak dalej).  Są rozpoznawane,
ale używana jest ich normalna reprezentacja.@footnote{Jeśli tego nie
rozumiesz, nie przejmuj się; zaplanowano je, by ułatwiały
``umiędzynarodowienie'' programów.}
(Funkcje te zapewniają zgodność z POSIX-owym narzędziem @code{date}.)

@item %v
Data w formacie VMS (np., 20-JUN-1991).

@cindex RFC-822
@cindex RFC-1036
@item %z
Przesunięcie strefy czasowej w formacie +HHHH (np. format niezbędny do
utworzenia nagłówków daty RFC-822/RFC-1036).
@end table

Poniższy przykład jest realizacją POSIX-owego narzędzia @code{date}
wykonaną w @code{awk}.  Normalnie @code{date} wypisuje bieżącą datę i czas
w dobrze znanym formacie.  Jeśli jednak podamy mu argument zaczynający się
od @samp{+}, to @code{date} skopiuje znaki nie tworzące specyfikatora
formatu na standardowe wyjście.  Bieżący czas natomiast zinterpretuje
zgodnie ze specyfikatorami formatu zawartymi w podanym łańcuchu.
Na przykład:

@example
$ date '+Dziś jest %A, %d %B %Y.'
@print{} Dziś jest czwartek, 11 lipiec 1991.
@end example

[tłum.: Cóż, powinno być ``11 lipca'', ale wartości locale nie uwzględniają
subtelności gramatyki]

Oto wykonana w @code{gawk} wersja narzędzia @code{date}.  Posiada otoczkę
(``wrapper'') powłoki, do obsługi opcji @samp{-u}, która wymaga by
@code{date} zostało uruchomione tak, jakby strefę czasową ustawiono na UTC.

@example
@group
#! /bin/sh
#
# date --- przybliżenie polecenia 'date' z P1003.2

case $1 in
-u)  TZ=GMT0     # użyj UTC
     export TZ
     shift ;;
esac
@end group

@group
gawk 'BEGIN  @{
    format = "%a %b %d %H:%M:%S %Z %Y"
    exitval = 0
@end group

@group
    if (ARGC > 2)
        exitval = 1
    else if (ARGC == 2) @{
        format = ARGV[1]
        if (format ~ /^\+/)
            format = substr(format, 2)   # usuń początkowy +
    @}
    print strftime(format)
    exit exitval
@}' "$@@"
@end group
@end example

@node Użytkownika, Wywołanie gawk, Wbudowane, Top
@chapter Funkcje definiowane przez użytkownika

@cindex funkcje, definiowane przez użytkownika
Skomplikowane programy @code{awk} można często uprościć definiując własne
funkcje.  Funkcje definiowane przez użytkownika wywołuje się tak samo
jak wbudowane (@pxref{Wywołania funkcji}), ale należy samodzielnie je
zdefiniować by wskazać @code{awk}, co powinny robić.

@menu
* Składnia definicji::          Jak pisać definicje i co one znaczą.
* Przykład definicji::          Przykład definicji funkcji i co ona robi.
* Pułapki funkcji::             Rzeczy, na które lepiej uważać.
* Instrukcja return::           Określanie wartości, jaką zwraca funkcja.
@end menu

@node Składnia definicji, Przykład definicji, Użytkownika, Użytkownika
@section Składnia definicji funkcji
@cindex definiowanie funkcji
@cindex funkcje, definicja

Definicje funkcji mogą wystąpić gdziekolwiek pomiędzy regułami programu
@code{awk}.  Zatem, ogólna postać programu @code{awk} jest poszerzona tak,
by obejmowała sekwencje reguł @emph{oraz} definicje funkcji użytkownika.
W @code{awk} nie ma potrzeby umieszczania definicji funkcji przed wszystkimi
miejscami, gdzie jest wykorzystywana.  Jest to spowodowane tym, że @code{awk}
czyta cały program zanim rozpocznie wykonywanie jakiejkolwiek jego części.

Definicja funkcji o nazwie @var{nazwa} wygląda tak:

@example
function @var{nazwa}(@var{lista-parametrów})
@{
     @var{ciało-funkcji}
@}
@end example

@cindex nazwy, użycie
@cindex przestrzenie nazw
@noindent
@var{nazwa} jest nazwą definiowanej funkcji.  Poprawna nazwa funkcji jest
taka jak poprawna nazwa zmiennej: ciąg liter, cyfr i znaków podkreślenia,
nie zaczynający się cyfrą.  W obrębie pojedynczego programu @code{awk} każda
z poszczególnych nazw może być użyta tylko albo jako zmienna albo
tablica albo funkcja.

@var{lista-parametrów} jest listą argumentów funkcji oraz nazw zmiennych
lokalnych, oddzielonych przecinkami.  Podczas wywołania funkcji nazwy
argumentów używane są do przechowywania wartości podanych w wywołaniu.
Zmienne lokalne inicjowane są łańcuchem pustym.  Funkcja nie może mieć
dwu parametrów o tej samej nazwie.

@var{ciało-funkcji} składa się z instrukcji @code{awk}.  Jest najważniejszą
częścią definicji, gdyż stwierdza, co faktycznie powinna @emph{robić}
funkcja.
Nazwy argumentów istnieją, by dać ciału metodę
rozmawiania o argumentach; zmienne lokalne, by zapewnić mu miejsca
na przechowywanie tymczasowych wartości.

Nazwy argumentów nie są składniowo odróżniane od nazw zmiennych lokalnych.
Zamiast tego, liczba argumentów podanych przy wywołaniu funkcji wyznacza
ile jest zmiennych argumentowych.  Zatem, jeśli podano trzy wartości
argumentów, to pierwsze trzy nazwy z @var{listy-parametrów} są argumentami,
a reszta jest zmiennymi lokalnymi.

W związku z tym, jeśli liczba argumentów we wszystkich wywołaniach funkcji
nie jest taka sama, to niektóre z nazw z @var{listy-parametrów} mogą
w niektórych przypadkach być argumentami, a w innych zmiennymi lokalnymi.
Można też ująć to tak, że pominięte argumenty są domyślnie
łańcuchami pustymi.

Zwykle pisząc funkcję wiemy, ile nazw zamierzamy wykorzystać na argumenty,
a ile jako zmienne lokalne.  Zwyczajowo pomiędzy argumentami a zmiennymi
lokalnymi umieszcza się dodatkowy odstęp, by udokumentować spodziewany
sposób korzystania z funkcji.

@cindex przesłanianie zmiennych
@cindex zmienne, przesłanianie
Podczas wykonywania ciała funkcji, wartości argumentów i zmiennych lokalnych
ukrywają lub @dfn{przesłaniają} ewentualne zmienne o tych samych nazwach
używane w pozostałej części programu.  Przesłonięte zmienne nie są dostępne
w definicji funkcji, gdyż nie ma sposobu ich nazwania dopóki ich nazwy
są zabrane dla zmiennych lokalnych.  Do wszystkich innych zmiennych
użytych w programie @code{awk} w ciele funkcji można normalnie się odwoływać
i nadawać im wartości.

Argumenty i zmienne lokalne trwają tylko dopóty, dopóki wykonywane jest
ciało funkcji.  Zaraz po jej zakończeniu można ponownie sięgać do zmiennych,
które były przesłonięte podczas działania funkcji.

@cindex rekurencyjna funkcja
@cindex funkcja rekurencyjna
Ciało funkcji może zawierać wyrażenia, które wywołują funkcje.  Mogą one
nawet wywoływać tę funkcję, albo wprost albo za pośrednictwem innej
funkcji.  Gdy się tak dzieje, mówimy, że funkcja jest @dfn{rekurencyjna}.

@cindex język @code{awk}, wersja POSIX
@cindex POSIX @code{awk}
W wielu implementacjach @code{awk}, łącznie z @code{gawk},
słowo kluczowe @code{function} można skrócić
do @code{func}.  Jednak POSIX podaje tylko stosowanie słowa
kluczowego @code{function}.  Ma to faktycznie pewne praktyczne
implikacje.  Jeśli @code{gawk} jest w trybie zgodności z POSIX
(@pxref{Opcje, ,Opcje wiersza poleceń}), to poniższa instrukcja @emph{nie}
definiuje funkcji:

@example
func foo() @{ a = sqrt($1) ; print a @}
@end example

@noindent
Zamiast tego, definiuje regułę, która, dla każdego rekordu, skleja wartość
zmiennej @samp{func} z wartością zwracaną przez funkcję @samp{foo}.
Jeśli powstały łańcuch jest niepusty, to wykonywana jest zadana akcja.
Raczej nie tego chciano.  (@code{awk} przyjmuje to wejście jako składniowo
poprawne, gdyż funkcje mogą być użyte przed ich zdefiniowaniem w programie.)

@cindex przenośność
Dla zapewnienia przenośności programów @code{awk} należy przy
definiowaniu funkcji zawsze stosować słowo kluczowe @code{function}.

@node Przykład definicji, Pułapki funkcji, Składnia definicji, Użytkownika
@section Przykłady definicji funkcji

Oto przykład funkcji użytkownika, o nazwie @code{myprint}, pobierającej
liczbę i wypisującej ją w konkretnym formacie.

@example
function myprint(num)
@{
     printf "%6.3g\n", num
@}
@end example

@noindent
Dla ilustracji, poniżej podamy regułę @code{awk} korzystającą z naszej
funkcji @code{myprint}:

@example
$3 > 0     @{ myprint($3) @}
@end example

@noindent
Program ten wypisuje, w naszym specjalnym formacie, wszystkie trzecie pola
wejścia zawierające liczbę dodatnią.  Stąd też, przy danych:

@example
@group
 1.2   3.4    5.6   7.8
 9.10 11.12 -13.14 15.16
17.18 19.20  21.22 23.24
@end group
@end example

@noindent
program, wykorzystując naszą funkcję formatującą wyniki, wypisze:

@example
   5.6
  21.2
@end example

Poniższa funkcja usuwa wszystkie elementy z tablicy.

@example
function delarray(a,    i)
@{
    for (i in a)
       delete a[i]
@}
@end example

Przy pracy z tablicami często konieczne jest usunięcie wszystkich elementów
tablicy i ponowne rozpoczęcie z nową listą elementów
(@pxref{Delete, ,Instrukcja @code{delete}}).
Zamiast konieczności powtarzania tej pętli w każdym miejscu programu,
w którym potrzebujemy wyczyścić tablicę, nasz program może po prostu
wywoływać @code{delarray}.
(Gwarantuje to przenośność.  Wykorzystanie @samp{delete @var{tablica}}
do usunięcia zawartości całej tablicy jest niestandardowym rozszerzeniem.)

A oto przykład funkcji rekurencyjnej.  Jako parametr wejściowy pobiera
łańcuch, a zwraca ten łańcuch w odwróconej kolejności.

@example
function rev(str, start)
@{
    if (start == 0)
        return ""

    return (substr(str, start, 1) rev(str, start - 1))
@}
@end example

Jeżeli funkcja ta znajduje się w pliku o nazwie @file{rev.awk}, możemy
przetestować ją tak:

@example
$ echo "Nie panikuj!" |
> gawk --source '@{ print rev($0, length($0)) @}' -f rev.awk
@print{} !jukinap eiN
@end example

Oto przykład wykorzystujący wbudowaną funkcję @code{strftime}.
(@xref{Funkcje czasu, ,Funkcje obsługi znaczników czasu},
gdzie bliżej opisano @code{strftime}.)
Funkcja @code{ctime} z C pobiera znacznik czasu i zwraca go
w łańcuchu, sformatowanym w dobrze znany sposób.  Oto jej wersja @code{awk}:

@example
@c file eg/lib/ctime.awk
# ctime.awk
#
# wersja awk funkcji ctime(3) z C

@group
function ctime(ts,    format)
@{
    format = "%a %b %d %H:%M:%S %Z %Y"
    if (ts == 0)
        ts = systime()    # użyj czasu bieżącego jako domyślnego
    return strftime(format, ts)
@}
@c endfile
@end group
@end example

@node Pułapki funkcji, Instrukcja return, Przykład definicji, Użytkownika
@section Wywoływanie funkcji użytkownika

@cindex wywołanie przez wartość
@cindex wywołanie przez odwołanie
@cindex wywoływanie funkcji
@cindex funkcja, wywoływanie
@dfn{Wywołanie funkcji} oznacza spowodowanie uruchomienia funkcji
i wykonania jej zadania.  Wywołanie funkcji jest wyrażeniem, a jego
wartością jest wartość zwracana przez funkcję.

Wywołanie funkcje składa się z nazwy funkcji z następującymi po niej
w nawiasach argumentami.  W miejscu argumentów wywołania wpisuje się
wyrażenia @code{awk}.  Wyrażenia te są obliczane za każdym razem, gdy
wykonywane jest wywołanie, a ich wartości stanowią parametry aktualne.
Na przykład, oto wywołanie @code{foo} z trzema argumentami (pierwszy
będący złożeniem łańcuchów):

@example
foo(x y, "strata", 4 * z)
@end example

@strong{Uwaga:} nie dopuszcza się białych znaków (spacji i tabulacji) między
nazwą funkcji a nawiasem otwierającym listy argumentów.  Jeśli przez pomyłkę
napisalibyśmy biały znak, @code{awk} mógłby pomyśleć, że mamy zamiar
konkatenować zmienną z wyrażeniem w nawiasach.  Zauważy jednak, że użyliśmy
nazwy funkcji a nie nazwy zmiennej, i zgłosi błąd.

@cindex wywołanie przez wartość
Gdy funkcja jest wołana, otrzymuje @emph{kopię} wartości swoich argumentów.
Jest to znane jako @dfn{wywołanie przez wartość}.  Wywołujący jako wyrażenia
argumentowego może użyć zmiennej, ale wywołująca funkcja tego nie wie:
wie tylko, jaką wartość miał argument.  Na przykład, jeśli napiszemy taki
kod:

@example
foo = "bar"
z = myfunc(foo)
@end example

@noindent
to nie powinniśmy myśleć o argumencie @code{myfunc}, że jest ``zmienną
@code{foo}''.  Zamiast tego, należy traktować go jako wartość łańcuchową,
@code{"bar"}.

Jeżeli funkcja @code{myfunc} zmienia wartości swoich zmiennych
lokalnych, to nie ma to żadnego wpływu na inne zmienne.  Zatem, jeśli
@code{myfunc} robi tak:

@example
@group
function myfunc(str)
@{
  print str
  str = "zzz"
  print str
@}
@end group
@end example

@noindent
aby zmienić swoją pierwszą zmienną argumentową @code{str}, to @emph{nie}
zmienia to wartości @code{foo} w miejscu wywołania.  Rola zmiennej
@code{foo} w wywoływaniu @code{myfunc} skończyła się w chwili, gdy została
obliczona jej wartość, @code{"bar"}.  Jeżeli @code{str} istnieje także poza
@code{myfunc}, to ciało funkcji nie może zmienić tej zewnętrznej wartości,
gdyż podczas wykonywania @code{myfunc} jest ona przesłonięta i nie może być
stąd widziana ani zmieniana.

@cindex wywołanie przez odwołanie
Jednak, gdy parametrami funkcji są tablice, @emph{nie} są one kopiowane.
Zamiast tego, do bezpośredniej na niej manipulacji udostępniana jest funkcji
sama tablica.  Zwykle nazywane jest to @dfn{wywołaniem przez odwołanie}.
Zmiany dokonane na parametrze tablicowym wewnątrz ciała funkcji
@emph{są} widoczne poza tą funkcją.
@ifinfo
Może to być @strong{bardzo} niebezpieczne jeżeli nie uważa się na to,
co się robi.
Na przykład:
@end ifinfo
@iftex
@emph{Może to być bardzo niebezpieczne jeżeli nie uważa się na to,
co się robi.}
Na przykład:
@end iftex

@example
@group
function zmiento(tabl, ind, nwart)
@{
     tabl[ind] = nwart
@}
@end group

BEGIN @{
    a[1] = 1; a[2] = 2; a[3] = 3
    zmiento(a, 2, "dwa")
    printf "a[1] = %s, a[2] = %s, a[3] = %s\n",
            a[1], a[2], a[3]
@}
@end example

@noindent
Program ten wypisuje @samp{a[1] = 1, a[2] = dwa, a[3] = 3}, ponieważ
@code{zmiento} umieszcza @code{"dwa"} w drugim elemencie @code{a}.

@cindex niezdefiniowane funkcje
@cindex funkcje, niezdefiniowane
Niektóre implementacje @code{awk} pozwalają na wywoływanie funkcji, która
nie została zdefiniowana, i zgłaszają problem tylko w czasie wykonania, gdy
program faktycznie usiłuje wywołać funkcję.  Na przykład:

@example
@group
BEGIN @{
    if (0)
        foo()
    else
        bar()
@}
function bar() @{ @dots{} @}
# zauważ, że `foo' nie jest zdefiniowane
@end group
@end example

@noindent
Ponieważ instrukcja @samp{if} nigdy nie będzie prawdziwa, to, że nie
zdefiniowano @code{foo}, nie stanowi rzeczywistego kłopotu.  Zwykle jednak
jeśli program wywołuje niezdefiniowaną funkcję, to jest to problem.

@ignore
At one point, I had gawk dieing on this, but later decided that this might
break old programs and/or test suites.
@end ignore

Jeżeli podano opcję @samp{--lint}
(@pxref{Opcje, ,Opcje wiersza poleceń}),
@code{gawk} będzie zawiadamiał o wywołaniach niezdefiniowanych funkcji.

Niektóre implementacje @code{awk} generują błąd wykonania jeśli użyje się
instrukcji @code{next}
(@pxref{Instrukcja next, , Instrukcja @code{next}})
wewnątrz funkcji definiowanej przez użytkownika.
@code{gawk} nie ma tego problemu.

@node Instrukcja return,  , Pułapki funkcji, Użytkownika
@section Instrukcja @code{return}
@cindex @code{return} instrukcja

Ciało funkcji definiowanej przez użytkownika może zawierać instrukcję
@code{return}.  Zwraca ona sterowanie do dalszej części programu @code{awk}.
Może być też wykorzystana do zwracania wartości do wykorzystania w dalszej
części programu.  Wygląda tak:

@example
return @r{[}@var{wyrażenie}@r{]}
@end example

Część @var{wyrażenie} jest opcjonalna.  Jeśli zostanie pominięta, to
zwracana wartość jest niezdefiniowana i, z tego powodu, nieprzewidywalna.

Na końcu każdej definicji funkcji zakłada się występowanie instrukcji
@code{return} bez wyrażenia zwracającego wartość.  Zatem jeśli sterowanie
osiągnie koniec ciała funkcji, to funkcja zwraca nieprzewidywalną wartość.
@code{awk} @emph{nie} będzie ostrzegał o użyciu przez nas wartości zwracanej
przez taką funkcję.

Czasami, chcemy napisać funkcję, gdyż potrzebujemy tego, co ona robi, a nie
co zwraca.  Funkcja taka odpowiada funkcji @code{void} znanej z C, czy
procedurze (@code{procedure}) Pascala.  Zatem, niezwracanie wartości może
być właściwe; powinno się po prostu pamiętać, że jeżeli wykorzystujemy
wartość takiej funkcji, to robimy to na własne ryzyko.

Oto przykład funkcji użytkownika zwracającej wartość największej liczby
występującej wśród elementów tablicy:

@example
@group
function maxelt(vec,   i, ret)
@{
     for (i in vec) @{
          if (ret == "" || vec[i] > ret)
               ret = vec[i]
     @}
     return ret
@}
@end group
@end example

@noindent
Wywołujemy @code{maxelt} z jednym argumentem, będącym nazwą tablicy.
Zmiennych lokalnych @code{i} i @code{ret} nie zaplanowano jako argumentów;
mimo, że nic nie może nas powstrzymać od przekazania do @code{maxelt} dwóch
lub trzech argumentów, to wyniki mogą być dziwne.  Dodatkowe odstępy przed
@code{i} w liście parametrów funkcji wskazują, że nie zakłada się by
@code{i} i @code{ret} były argumentami.  Jest to konwencja, której powinno
się przestrzegać przy definiowaniu własnych funkcji.

Oto program korzystający z naszej funkcji @code{maxelt}.  Wczytuje on
tablicę, wywołuje @code{maxelt} i zgłasza największą liczbę w tej tablicy:

@example
@group
awk '
function maxelt(vec,   i, ret)
@{
     for (i in vec) @{
          if (ret == "" || vec[i] > ret)
               ret = vec[i]
     @}
     return ret
@}
@end group

@group
# wczytaj wszystkie pola każdego rekordu do nums.
@{
     for(i = 1; i <= NF; i++)
          nums[NR, i] = $i
@}

END @{
     print maxelt(nums)
@}'
@end group
@end example

Otrzymując poniższe dane wejściowe:

@example
@group
 1 5 23 8 16
44 3 5 2 8 26
256 291 1396 2962 100
-6 467 998 1101
99385 11 0 225
@end group
@end example

@noindent
program nasz powie (zgodnie z oczekiwaniami), że największą liczbą w naszej
tablicy jest @code{99385}.

@node Wywołanie gawk, Funkcje biblioteczne, Użytkownika, Top
@chapter Uruchamianie @code{awk}
@cindex wiersz poleceń
@cindex wywołanie @code{gawk}
@cindex argumenty, wiersz poleceń
@cindex opcje, wiersz poleceń
@cindex długie opcje
@cindex opcje, długie

Istnieją dwie metody uruchamiania @code{awk}: z programem podanym wprost,
albo z jednym czy więcej plikami programów.  Oto szablony obu; elementy
zawarte w @samp{@r{[}@dots{}@r{]}} są w nich opcjonalne.

Oprócz tradycyjnych jednoliterowych opcji w stylu POSIX, @code{gawk}
rozpoznaje także długie opcje GNU.

@example
awk @r{[@var{opcje}]} -f plikprog @r{[@code{--}]} @var{plik} @dots{}
awk @r{[@var{opcje}]} @r{[@code{--}]} '@var{program}' @var{plik} @dots{}
@end example

@cindex pusty program
@cindex ciemny kąt
Możliwe jest wywołanie @code{awk} z pustym programem:

@example
$ awk '' plikdanych1 plikdanych2
@end example

@noindent
Nie ma to jednak większego sensu: @code{awk} po prostu milcząco zakończy
pracę gdy otrzyma pusty program (c.k.).  Jeżeli w wierszu poleceń podano
opcję @samp{--lint}, @code{gawk} wyśle ostrzeżenie, że program jest
pusty.

@menu
* Opcje::                       Opcje wiersza poleceń i ich znaczenie.
* Inne argumenty::              Nazwy plików wejściowych i przypisania
                                zmiennych.
* Zmienna AWKPATH::             Katalogi przeszukiwania dla programów @code{awk}.
* Przestarzałe::                Przestarzałe opcje i/lub cechy.
* Nieudokumentowane::           Nieudokumentowane opcje i cechy.
* Znane błędy::                 Znane błędy @code{gawk}.
@end menu

@node Opcje, Inne argumenty, Wywołanie gawk, Wywołanie gawk
@section Opcje wiersza poleceń

Opcje rozpoczynają się kreską, i składają się z pojedynczego znaku.
Długie opcje w stylu GNU składają się z dwu kresek i słowa kluczowego.
Słowa kluczowe można skracać, dopóki skrót pozwala na unikalną, jednoznaczną
identyfikację opcji.  Jeśli opcja pobiera argument, to albo bezpośrednio po
słowie kluczowym występuje znak równości (@samp{=}) i wartość argumentu,
albo słowo kluczowe i wartość oddzielone są białym znakiem.   W celu
zachowania zwięzłości, poniższe omówienie odnosi się tylko do tradycyjnych,
krótkich opcji; długie i krótkie opcje są jednak we wszystkich kontekstach
wzajemnie wymienne.

Każda z długich opcji @code{gawk} ma odpowiadającą jej opcję w stylu
POSIX.  Opcje i ich znaczenie są następujące:

@table @code
@item -F @var{fs}
@itemx --field-separator @var{fs}
@cindex @code{-F} opcja
@cindex @code{--field-separator} opcja
Nadaje zmiennej @code{FS} wartość @var{fs}
(@pxref{Separatory pól, ,Jak rozdzielać pola}).

@item -f @var{plik-źródłowy}
@itemx --file @var{plik-źródłowy}
@cindex @code{-f} opcja
@cindex @code{--file} opcja
Wskazuje, że programu @code{awk} należy szukać w @var{pliku-źródłowym}
zamiast w pierwszym nie-opcyjnym argumencie.

@item -v @var{zmn}=@var{wart}
@itemx --assign @var{zmn}=@var{wart}
@cindex @code{-v} opcja
@cindex @code{--assign} opcja
Nadaje zmiennej @var{zmn} wartość @var{wart} @strong{przed} rozpoczęciem
wykonywania programu.  Takie wartości zmiennych są dostępne w regule
@code{BEGIN} (@pxref{Inne argumenty, ,Inne argumenty wiersza poleceń}).

Opcja @samp{-v} może nadać wartość tylko jednej zmiennej, ale można ją
zastosować więcej niż raz, za każdym razem przypisując wartość innej
zmiennej, jak np.: @samp{awk @w{-v foo=1} @w{-v bar=2} @dots{}}.

@strong{Uwaga!}  Wykorzystanie @samp{-v} do nadania wartości zmiennym
wbudowanym może prowadzić do zaskakujących rezultatów.  @code{awk} ponownie
nada wartości tym zmiennym, gdy będzie tego potrzebował, prawdopodobnie
ignorując wszelkie predefiniowane wartości, jakie podaliśmy.

@item -mf @var{NNN}
@itemx -mr @var{NNN}
Przypisuje rozmaitym limitom pamięci wartość @var{NNN}.  Flaga @samp{f}
ustala maksymalną liczbę pól, a @samp{r} maksymalny rozmiar rekordu.
Te dwie flagi i opcja @samp{-m} pochodzą z @code{awk} w wersji
Bell Labs research.  Pozostawiono je w celu zachowania zgodności, ale
poza tym są przez @code{gawk} ignorowane, gdyż @code{gawk} nie ma żadnych
predefiniowanych ograniczeń.

@item -W @var{opcje-gawk}
@cindex @code{-W} opcja
Zgodnie ze standardem POSIX, opcje specyficzne dla danej implementacji
podawane są jako argumenty opcji @samp{-W}.  Opcje te również mają
odpowiedniki w postaci długich opcji w stylu GNU.
Zobacz niżej.

@item --
Sygnalizuje koniec opcji wiersza poleceń.  Następne argumenty nie są
traktowane jak opcje, nawet jeśli zaczynają się od @samp{-}.  Taka
interpretacja @samp{--} jest zgodna z POSIX-ową konwencją przetwarzania
argumentów.

Jest przydatna jeśli mamy pliki o nazwach zaczynających się od @samp{-},
albo w skryptach powłoki, jeśli mamy nazwy plików podawane przez
użytkownika, który może zacząć od @samp{-}.

@end table

Dostępne są następujące opcje specyficzne dla @code{gawk}:

@table @code
@item -W traditional
@itemx -W compat
@itemx --traditional
@itemx --compat
@cindex @code{--compat} opcja
@cindex @code{--traditional} opcja
@cindex tryb zgodności
@cindex zgodność, tryb
Określa @dfn{tryb zgodności}, w którym rozszerzenia GNU języka @code{awk}
są wyłączone, tak że @code{gawk} zachowuje się całkiem jak wersja uniksowego
z @code{awk} Bell Labs research.  Zalecaną postacią tej opcji jest
@samp{--traditional}.
@xref{POSIX/GNU, ,Rozszerzenia @code{gawk} poza POSIX @code{awk}},
podsumowujące rozszerzenia.  Zobacz także
@ref{Tryb zgodności, ,Zgodność w dół i debuggowanie}.

@item -W copyleft
@itemx -W copyright
@itemx --copyleft
@itemx --copyright
@cindex @code{--copyleft} opcja
@cindex @code{--copyright} opcja
Wypisuje krótką wersję Powszechnej Licencji Publicznej (General Public
License), a następnie kończy pracę.  Ta opcja może zniknąć w przyszłych
wersjach @code{gawk}.

@item -W help
@itemx -W usage
@itemx --help
@itemx --usage
@cindex @code{--help} opcja
@cindex @code{--usage} opcja
Wypisuje komunikat o ``sposobie użycia'', podsumowujący krótkie i długie
opcje akceptowane przez @code{gawk}, a następnie kończy pracę.

@item -W lint
@itemx --lint
@cindex @code{--lint} opcja
Ostrzega o konstrukcjach niepewnych czy nieprzenośnych do innych
implementacji @code{awk}.  Niektóre z ostrzeżeń emitowane są gdy @code{gawk}
po raz pierwszy czyta program.  Inne wysyłane są w czasie wykonania, podczas
działania programu.

@item -W lint-old
@itemx --lint-old
@cindex @code{--lint-old} opcja
Ostrzega o konstrukcjach, które nie są dostępne w pierwotnej wersji
@code{awk} z Version 7 Unix
(@pxref{V7/SVR3.1, , Główne różnice między V7 a SVR3.1}).

@item -W posix
@itemx --posix
@cindex @code{--posix} opcja
@cindex POSIX, tryb
@cindex tryb POSIX
Działa w trybie ścisłej zgodności z POSIX.  Wyłącza to wszystkie
rozszerzenia @code{gawk} (tak samo jak @samp{--traditional}), i nakłada
następujące dodatkowe ograniczenia:

@c IMPORTANT! Keep this list in sync with the one in node POSIX

@itemize @bullet
@item
Nie są rozpoznawane sekwencje specjalne @code{\x}
(@pxref{Sekwencje specjalne}).

@item
Znaki nowej linii nie działają jako białe znaki rozdzielające pola gdy
@code{FS} jest równe pojedynczej spacji.

@item
Nie jest rozpoznawane @code{func} jako synonim słowa kluczowego
@code{function} (@pxref{Składnia definicji, ,Składnia definicji funkcji}).

@item
Nie można stosować operatorów @samp{**} i @samp{**=} zamiast @samp{^}
i @samp{^=} (@pxref{Operatory arytmetyczne, ,Operatory arytmetyczne}, a także
@pxref{Operatory przypisania, ,Wyrażenia przypisania}).

@item
Podanie @samp{-Ft} w wierszu poleceń nie nadaje @code{FS} wartości
pojedynczego znaku tabulacji
(@pxref{Separatory pól, ,Jak rozdzielać pola}).

@item
Nie jest obsługiwana funkcja wbudowana @code{fflush}
(@pxref{Funkcje I/O, , Wbudowane funkcje wejścia/wyjścia}).
@end itemize

Jeżeli w wierszu poleceń zostanie podane zarówno @samp{--traditional}
jak i @samp{--posix}, to @samp{--posix} ma pierwszeństwo.  Jeśli podano
obie te opcje, @code{gawk} wyśle też ostrzeżenie.

@item -W re-interval
@itemx --re-interval
Dopuszcza wyrażenia przedziałowe (interval expressions)
(@pxref{Operatory regexp, , Operatory wyrażeń regularnych}),
w wyrażeniach regularnych.
Ponieważ wyrażenia przedziałowe tradycyjnie nie były dostępne w @code{awk},
@code{gawk} domyślnie ich nie zapewnia.  Chroni to stare programy @code{awk}
przed błędnym działaniem.

@item -W source @var{tekst-programu}
@itemx --source @var{tekst-programu}
@cindex @code{--source} opcja
Kod źródłowy pobierany jest z @var{tekst-programu}.  Opcja ta umożliwia
używanie kodu źródłowego z plików równocześnie z kodem wprowadzonym
w wierszu poleceń.  Jest to szczególnie użyteczne gdy mamy funkcje
biblioteczne, które chcielibyśmy wykorzystać w programach wpisanych
w wierszu poleceń
(@pxref{Zmienna AWKPATH, ,Zmienna środowiska @code{AWKPATH}}).

@item -W version
@itemx --version
@cindex @code{--version} opcja
Wypisuje informację o wersji tego konkretnego egzemplarza @code{gawk}.
Umożliwia to ustalenie, czy nasza kopia @code{gawk} jest aktualna
w stosunku do tego, co obecnie rozpowszechnia Free Software Foundation.
Przydatne także przy zgłoszeniach błędów
(@pxref{Błędy,  , Zgłaszanie problemów i błędów}).
@end table

Wszystkie inne opcje znakowane są jako niepoprawne i wysyłany jest
komunikat ostrzegawczy.  Poza tym są ignorowane.

W trybie zgodności, jeśli wartością @var{fs} przekazaną opcji @samp{-F}
jest @samp{t}, to traktowane jest to jako przypadek szczególny, i @code{FS}
zostaje nadana wartość znaku tabulacji (@code{"\t"}).  Jest to prawdziwe
tylko dla opcji @samp{--traditional}, ale nie dla @samp{--posix}
(@pxref{Separatory pól, ,Jak rozdzielać pola}).

Opcji @samp{-f} można użyć w wierszu poleceń więcej niż raz.  Jeżeli wystąpi
ona więcej niż raz, to, @code{awk} czyta źródło programu ze wszystkich
wymienionych plików, tak jakby były one złączone w jeden duży plik.
Przydaje się to do tworzenia bibliotek funkcji @code{awk}.  Użyteczne
funkcje można napisać raz, a następnie wczytywać ze standardowego miejsca,
zamiast konieczności włączania ich do każdego poszczególnego programu.

Można wpisywać program na terminalu i nadal używać funkcji bibliotecznych,
podając @samp{-f /dev/tty}.  @code{awk} będzie czytał z terminala plik,
który ma być użyty jako część programu @code{awk}.  W celu zakończenia
pisania programu, po wpisaniu treści naciskamy @kbd{Control-d} (znak końca
pliku).  (Można też wykorzystać @samp{-f -} do odczytu źródła programu ze
standardowego wejścia, ale wówczas nie będzie można równocześnie użyć
standardowego wejścia jako źródła danych.)

Ponieważ korzystanie ze standardowych mechanizmów @code{awk} do łączenia
programów @code{awk} z pliku źródłowego i z wiersza poleceń jest
nieporęczne, @code{gawk} udostępnia opcję @samp{--source}.  Nie wymaga ona
zawłaszczania standardowego wejścia dla kodu źródłowego i pozwala na łatwe
łączenie kodu źródłowego z wiersza poleceń i bibliotek.
(@pxref{Zmienna AWKPATH, ,Zmienna środowiska @code{AWKPATH}}).

Jeżeli nie podano @samp{-f} ani @samp{--source}, to @code{gawk} jako tekstem
kodu źródłowego programu posłuży się pierwszym nie będącym opcją argumentem
wiersza poleceń.

@cindex @code{POSIXLY_CORRECT}, zmienna środowiska
@cindex zmienna środowiska, @code{POSIXLY_CORRECT}
Jeśli istnieje zmienna środowiska @code{POSIXLY_CORRECT}, to @code{gawk}
będzie działać w trybie ścisłej zgodności z POSIX, dokładnie tak, jakby
w linii poleceń podano opcję @samp{--posix}.  Wiele programów GNU szuka
tej zmiennej środowiska, by włączyć tryb pełnej zgodności z POSIX.  Jeżeli
w wierszu poleceń podano @samp{--lint}, a @code{gawk} włącza tryb zgodności
z POSIX z powodu @code{POSIXLY_CORRECT}, to wypisze komunikat
ostrzegawczy wskazujący, że w rezultacie działa tryb POSIX.

Standardowo zmienną tę ustala się w prywatnym pliku uruchomieniowym powłoki.
Dla powłoki zgodnej z powłoka Bourne'a (jak Bash), do pliku @file{.profile}
w swoim katalogu domowym dopisuje się poniższe wiersze:

@example
@group
POSIXLY_CORRECT=true
export POSIXLY_CORRECT
@end group
@end example

Dla powłoki zgodnej z @code{csh},@footnote{Nie zalecane.}
do pliku @file{.login} w swoim katalogu domowym należy dodać taki wiersz:

@example
setenv POSIXLY_CORRECT true
@end example

@node Inne argumenty, Zmienna AWKPATH, Opcje, Wywołanie gawk
@section Inne argumenty wiersza poleceń

Ewentualne dodatkowe argumenty wiersza poleceń są normalnie traktowane jako
pliki wejściowe, które mają zostać przetworzone w podanej kolejności.
Jednak argument mający postać @code{@var{zmn}=@var{wart}}, przypisuje
wartość @var{wart} zmiennej @var{zmn} --- wcale nie określa pliku.

@vindex ARGIND
@vindex ARGV
Wszystkie te argumenty udostępniane są naszemu programowi @code{awk}
w tablicy @code{ARGV} (@pxref{Zmienne wbudowane}).  Opcje wiersza poleceń
i tekst programu (jeśli jest) są @code{ARGV} opuszczane.  Wszystkie inne
argumenty, łącznie z przypisaniami zmiennych są dołączane.
Podczas przetwarzania każdego elementu @code{ARGV}, @code{gawk} nadaje
zmiennej @code{ARGIND} wartość indeksu w @code{ARGV}, pod którym
umiejscowiony jest bieżący element.

Argumenty opisujące nazwy plików odróżniane są od argumentów przypisań
zmiennych gdy @code{awk} ma otworzyć następny plik wejściowy.  W tym
momencie wykonywania, sprawdza on ``nazwę pliku'', by stwierdzić czy nie
jest to faktycznie przypisanie do zmiennej. Jeśli tak, to @code{awk} nadaje
wartość zmiennej zamiast czytać plik.

Z tego powodu, zmienne w rzeczywistości otrzymują zadane wartości po
przeczytaniu wszystkich podanych przed nimi plików.  W szczególności,
wartości zmiennych przypisane w ten sposób @emph{nie} są dostępne w regule
@code{BEGIN} (@pxref{BEGIN/END, ,Wzorce specjalne @code{BEGIN} i @code{END}}),
gdyż reguły te są uruchamiane zanim @code{awk} zacznie badać listę
argumentów.

@cindex ciemny kąt
Wartości zmiennych podanych w wierszu poleceń są przetwarzane co do
występowania sekwencji specjalnych (c.k.) (@pxref{Sekwencje specjalne}).

W niektórych wcześniejszych implementacjach @code{awk}, gdy przypisanie
zmiennej wystąpiło przed wszystkimi nazwami plików, przypisanie to
następowało @emph{przed} wykonaniem reguły @code{BEGIN}.  Zachowanie się
@code{awk} było zatem niespójne; niektóre przypisania wiersza poleceń były
dostępne w regule @code{BEGIN}, podczas gdy inne nie.  Niektóre aplikacje
zaczęły jednak polegać na tej ``możliwości''.
@c     ``feature.''
Gdy zmieniano @code{awk} tak, by był bardziej spójny, w celu
przystosowania aplikacji zależnych od starego zachowania dodano opcję
@samp{-v}.

Funkcja przypisywania zmiennych jest najprzydatniejsza do nadawania
wartości takim zmiennym jak @code{RS}, @code{OFS} i @code{ORS},
sterujących formatami wejściowymi i wyjściowymi, przed przeglądaniem plików
wejściowych.  Jest też użyteczna przy sterowaniu stanem jeśli dla jakiegoś
pliku danych potrzebujemy wielu przebiegów.  Na przykład:

@cindex wielokrotne przebiegi po danych
@cindex przebiegi, wielokrotne
@example
awk 'przeb == 1  @{ @var{obsługa 1 przebiegu} @}
     przeb == 2  @{ @var{obsługa 2 przebiegu} @}'
       przeb=1 mojedane przeb=2 mojedane
@end example

Ponieważ mamy funkcję przypisywania zmiennych, do nadawania
wartości @code{FS} w ogóle nie jest konieczna opcja @samp{-F}.
Pozostaje w celu utrzymania historycznej zgodności.

@node Zmienna AWKPATH, Przestarzałe, Inne argumenty, Wywołanie gawk
@section Zmienna środowiska @code{AWKPATH}
@cindex @code{AWKPATH}, zmienna środowiska
@cindex zmienna środowiska, @code{AWKPATH}
@cindex ścieżka wyszukiwania
@cindex katalog wyszukiwania
@cindex wyszukiwanie, ścieżka
@cindex różnice między @code{gawk} a @code{awk}

Poprzednia sekcja opisywała, w jaki sposób opcją @samp{-f} można podawać
nazwy plików programów @code{awk} w wierszu poleceń.  W większości
implementacji @code{awk} musimy podać dokładną ścieżkę dla każdego pliku
z programem, chyba że jest on w katalogu bieżącym.

@cindex ścieżka wyszukiwania, dla plików źródłowych
Jednak w @code{gawk}, jeśli nazwa pliku dostarczona opcji @samp{-f}
nie zawiera @samp{/}, to @code{gawk} przegląda po kolei katalogi z listy
katalogów (zwanej @dfn{ścieżką wyszukiwania}), szukając w nich pliku o
podanej nazwie.

Ścieżka wyszukiwania jest łańcuchem składającym się z oddzielonych
dwukropkami nazw katalogów.  @code{gawk} bierze swoją ścieżkę wyszukiwania
ze zmiennej środowiska @code{AWKPATH}.  Jeżeli zmienna ta nie istnieje,
to stosuje ścieżkę domyślną, którą jest
@samp{.:/usr/local/share/awk}.@footnote{Twoja własna wersja @code{gawk} może
wykorzystywać inny katalog; zależy to od
tego, jak @code{gawk} został utworzony i zainstalowany. Faktyczny katalog
będzie wartością @samp{$(datadir)} utworzoną podczas konfiguracji
@code{gawk}.  Niemniej jednak prawdopodobnie nie musisz się tym przejmować.}
(Programy napisane dla administratorów systemu powinny używać zmiennej
@code{AWKPATH}, która nie zawiera katalogu bieżącego, @file{.}.)

Funkcja ścieżki wyszukiwania jest szczególnie przydatna przy tworzeniu
bibliotek użytecznych funkcji @code{awk}.  Pliki bibliotek można umieścić
w standardowym katalogu, będącym w ścieżce domyślnej, a następnie podać w
wierszu poleceń za pomocą krótkiej nazwy pliku.  W przeciwnym razie, dla
każdego pliku musiałaby być wpisana pełna nazwa pliku.

Własne programy @code{awk} z wiersza poleceń mogą korzystać ze
wspomagających plików bibliotecznych używając równocześnie opcji
@samp{--source} i @samp{-f}.
@xref{Funkcje biblioteczne, , Biblioteczka funkcji @code{awk}}.

Przeszukiwanie ścieżki nie jest wykonywane gdy @code{gawk} pracuje
w trybie zgodności.  Jest to prawdą zarówno dla @samp{--traditional}
jak i dla @samp{--posix}.  @xref{Opcje, ,Opcje wiersza poleceń}.

@strong{Zauważ:} jeśli chcemy, by zostały znalezione pliki w bieżącym
katalogu, musimy ująć go w ścieżce, albo przez umieszczenie w niej
jawnie katalogu @file{.}, albo przez zapisanie w niej pustej pozycji.
(Pusta pozycja jest wskazywana przez rozpoczęcie lub zakończenie ścieżki
dwukropkiem lub przez umieszczenie obok siebie dwóch dwukropków (@samp{::}).)
Jeżeli bieżącego katalogu nie ujęto w ścieżce, to plików nie można znaleźć
w bieżącym katalogu.  Ten mechanizm ścieżki wyszukiwania jest identyczny
jak występujący w powłoce.
@c someday, @cite{The Bourne Again Shell}....

Począwszy od wersji 3.0, jeśli w środowisku nie ma zdefiniowanej
@code{AWKPATH}, @code{gawk} umieści w @code{ENVIRON["AWKPATH"]} swoją
domyślną ścieżkę wyszukiwania.  Ułatwia to ustalenie ścieżki wyszukiwania,
jaką posłuży się @code{gawk}.

@node Przestarzałe, Nieudokumentowane, Zmienna AWKPATH, Wywołanie gawk
@section Przestarzałe opcje i/lub cechy

@cindex przestarzałe opcje
@cindex niezalecane opcje
@cindex nieaprobowane opcje
@cindex przestarzałe cechy
@cindex niezalecane cechy
@cindex nieaprobowane cechy
Ta sekcja opisuje cechy i/lub opcje wiersza poleceń z poprzednich wersji
@code{gawk}, które albo nie są dostępne w obecnej wersji albo są nadal
obsługiwane, lecz niezalecane (co znaczy, że @emph{nie} będzie ich
w kolejnym wydaniu).

@c update this section for each release!

W wersji @value{VERSION}.@value{PATCHLEVEL} @code{gawk}, nie ma opcji
wiersza poleceń ani innych niezalecanych cech z poprzednich wersji
@code{gawk}.

Ta sekcja
jest więc w gruncie rzeczy wypełniaczem, rezerwującym miejsce na wypadek
gdyby w którejś następnej wersji @code{gawk} jakieś opcje stały się
przestarzałe.

@ignore
@c This is pretty old news...
The public-domain version of @code{strftime} that is distributed with
@code{gawk} changed for the 2.14 release.  The @samp{%V} conversion specifier
that used to generate the date in VMS format was changed to @samp{%v}.
This is because the POSIX standard for the @code{date} utility now
specifies a @samp{%V} conversion specifier.
@xref{Funkcje czasu, ,Funkcje obsługi znaczników czasu}, for details.
@end ignore

@node Nieudokumentowane, Znane błędy, Przestarzałe, Wywołanie gawk
@section Nieudokumentowane opcje i cechy
@cindex nieudokumentowane cechy
@display
@i{Use the Source, Luke!}
Obi-Wan
@end display
@sp 1

Tę sekcję celowo pozostawiono pustą.

@c Read The Source, Luke!

@c tłum.: skoro już tu dotarłeś, nie będziesz mieć problemów z oryginałem ;)

@ignore
@c If these came out in the Info file or TeX document, then they wouldn't
@c be undocumented, would they?

@code{gawk} has one undocumented option:

@table @code
@item -W nostalgia
@itemx --nostalgia
Print the message @code{"awk: bailing out near line 1"} and dump core.
This option was inspired by the common behavior of very early versions of
Unix @code{awk}, and by a t--shirt.
@end table

Early versions of @code{awk} used to not require any separator (either
a newline or @samp{;}) between the rules in @code{awk} programs.  Thus,
it was common to see one-line programs like:

@example
awk '@{ sum += $1 @} END @{ print sum @}'
@end example

@code{gawk} actually supports this, but it is purposely undocumented
since it is considered bad style.  The correct way to write such a program
is either

@example
awk '@{ sum += $1 @} ; END @{ print sum @}'
@end example

@noindent
or

@example
awk '@{ sum += $1 @}
     END @{ print sum @}' data
@end example

@noindent
@xref{Instrukcje/wiersze, ,Instrukcje @code{awk} a wiersze}, for a fuller
explanation.

@end ignore

@node Znane błędy, , Nieudokumentowane, Wywołanie gawk
@section Znane błędy @code{gawk}
@cindex błędy, znane w @code{gawk}
@cindex znane błędy

@itemize @bullet
@item
Opcja @samp{-F} do zmiany wartości @code{FS}
(@pxref{Opcje, ,Opcje wiersza poleceń})
nie jest niezbędna, gdyż mamy funkcję przypisań zmiennych
w wierszu poleceń.  Pozostaje tylko ze względu na zgodność wsteczną.

@item
Jeżeli nasz system rzeczywiście obsługuje @file{/dev/fd} i skojarzone pliki
@file{/dev/stdin}, @file{/dev/stdout} i @file{/dev/stderr}, to
możemy uzyskać inne wyjście z @code{awk} niż otrzymalibyśmy na systemie bez
tych plików.  Gdy @code{gawk} interpretuje te pliki wewnętrznie, to
synchronizuje wyjście na standardowe wyjście z wyjściem do
@file{/dev/stdout}, podczas gdy na systemie z tymi plikami, wyjście
jest faktycznie do innych otwartych plików
(@pxref{Pliki specjalne, ,Specjalne nazwy plików w @code{gawk}}).

@item
Składniowo niepoprawne, jednoznakowe programy mają skłonność do
przepełniania stosu analizatora składni, wysyłając niezbyt pomocny
komunikat.  Programy takie są zaskakująco trudne do rozpoznania
w przypadku całkiem ogólnym i naprawdę nie byłoby to warte włożonego
wysiłku.
@end itemize

@node Funkcje biblioteczne, Przykładowe programy, Wywołanie gawk, Top
@chapter Biblioteczka funkcji @code{awk}

@c 2e: USE TEXINFO-2 FUNCTION DEFINITION STUFF!!!!!!!!!!!!!
W niniejszym rozdziale pokazano biblioteczkę przydatnych funkcji
@code{awk}.  Funkcje te wykorzystano w pokazanych dalej przykładowych
programach (@pxref{Przykładowe programy, ,Praktyczne programy @code{awk}}).
Funkcje przedstawiono kolejno od prostych do skomplikowanych.

@ref{Program extract, ,Wydzielanie programów z plików źródłowych Texinfo},
pokazuje program, który można wykorzystać do wydzielenia kodu
źródłowego omawianych funkcji bibliotecznych i programów ze źródła
Texinfo tej książki.  (Zrobiono to już jako część dystrybucji @code{gawk}.)

Jeżeli napisałeś jakąś przydatną funkcję @code{awk} ogólnego zastosowania
i chciałbyś wnieść ją do kolejnego wydania książki, skontaktuj się proszę z
autorem.  @xref{Błędy, ,Zgłaszanie problemów i błędów}, gdzie opisano, jak to
robić.  Nie wysyłaj samego kodu, gdyż będzie wymagana twoja zgoda albo na
umieszczenie go w zasobach ogólnie dostępnych (public domain),
albo opublikowanie go
na licencji GPL (@pxref{Kopiowanie, ,GNU GENERAL PUBLIC LICENSE}),
albo przypisanie jego praw autorskich Fundacji (Free Software Foundation).

@menu
* Uwagi o przenośności::        Co zrobić, jeśli nie mamy @code{gawk}.
* Funkcja nextfile::            Dwie implementacje funkcji @code{nextfile}.
* Funkcja assert::              Funkcja do obsługi asercji w programach @code{awk}.
* Funkcja round::               Funkcja do zaokrąglania jeśli @code{sprintf}
                                nie robi tego poprawnie.
* Funkcje porządku::            Funkcje do stosowania znaków jako liczb
                                i odwrotnie.
* Funkcja join::                Funkcja do łączenia tablicy w łańcuch.
* Funkcja mktime::              Funkcja do przekształcania daty
                                w znacznik czasu.
* Funkcja gettimeofday::        Funkcja do pobierania sformatowanych czasów.
* Funkcja filetrans::           Funkcja obsługi przejść między plikami.
* Funkcja getopt::              Funkcja do przetwarzania argumentów wiersza
                                poleceń.
* Funkcje passwd::              Funkcje do pobierania danych o użytkownikach.
* Funkcje group::               Funkcje do pobierania danych o grupach.
* Nazwy biblioteczne::          Jak najlepiej nazywać prywatne zmienne
                                globalne w funkcjach bibliotecznych.
@end menu

@node Uwagi o przenośności, Funkcja nextfile, Funkcje biblioteczne, Funkcje biblioteczne
@section Symulowanie cech specyficznych dla @code{gawk}
@cindex przenośność

Programy w tym rozdziale i w
@ref{Przykładowe programy, ,Praktyczne programy @code{awk}},
swobodnie korzystają z cech specyficznych dla @code{gawk}.
Ta sekcja krótko omawia, w jaki sposób można je przepisać dla innych
implementacji @code{awk}.

Komunikaty diagnostyczne wysyłane są na @file{/dev/stderr}.
Należy użyć @samp{| "cat 1>&2"} zamiast @samp{> "/dev/stderr"}, jeśli dany
system nie posiada @file{/dev/stderr}, lub jeżeli nie można użyć
@code{gawk}.

Wiele z programów korzysta z @code{nextfile}
(@pxref{Instrukcja nextfile, ,Instrukcja @code{nextfile}}),
do pominięcia ewentualnych pozostałych danych z pliku wejściowego.
@ref{Funkcja nextfile, ,Implementacja @code{nextfile} jako funkcji},
pokazuje jak napisać funkcję, która robi to samo.

Na koniec, niektóre z tych programów ignorują rozróżnianie dużych i małych
liter w wejściu.  Robią to przypisując jeden do @code{IGNORECASE}.  Można
osiągnąć ten sam skutek dodając następującą regułę na początku programu:

@example
# ignorujemy wielkość znaków
@{ $0 = tolower($0) @}
@end example

@noindent
Należy też sprawdzić czy wszystkie stałe wyrażenia regularne i stałe
łańcuchowe wykorzystywane w porównaniach posługują się tylko małymi
literami.

@node Funkcja nextfile, Funkcja assert, Uwagi o przenośności, Funkcje biblioteczne
@section Implementacja @code{nextfile} jako funkcji

@cindex pomijanie plików wejściowych
@cindex pliki wejściowe, pomijanie
Instrukcja @code{nextfile} przedstawiona w
@ref{Instrukcja nextfile, ,Instrukcja @code{nextfile}},
jest rozszerzeniem specyficznym dla @code{gawk}.  Nie jest dostępna
w innych implementacjach @code{awk}.  Ta sekcja pokazuje dwie wersje
funkcji @code{nextfile}, które można wykorzystać do symulowania instrukcji
@code{nextfile} z @code{gawk} jeśli nie można użyć samego @code{gawk}.

Oto pierwsza próba napisania funkcji @code{nextfile}.

@example
@group
# nextfile --- pomiń pozostałe rekordy bieżącego pliku

# to powinno być przeczytane przed "głównym" programem awk

function nextfile()    @{ _porzuc_ = FILENAME; next @}

_porzuc_ == FILENAME  @{ next @}
@end group
@end example

Plik ten powinien był dołączony przed głównym programem, gdyż podaje on
regułę, która musi być wykonana wcześniej.  Reguła porównuje nazwę
bieżącego pliku danych (która jest zawsze w zmiennej @code{FILENAME}) ze
zmienną prywatną o nazwie @code{_porzuc_}.  Jeśli nazwa pliku pasuje, to
akcja tej reguły wykonuje instrukcję @code{next}, by przejść dalej do
kolejnego rekordu.  (Użycie @samp{_} w nazwie zmiennej jest konwencją.
Opisano ją pełniej
w @ref{Nazwy biblioteczne,  , Nazywanie zmiennych globalnych funkcji bibliotecznych}.)

Użycie instrukcji @code{next} w praktyce tworzy pętlę czytającą wszystkie
rekordy bieżącego pliku danych.  Ostatecznie, osiągany jest koniec pliku
i otwierany jest nowy plik danych, co zmienia wartość @code{FILENAME}.
Gdy się to stanie, porównanie @code{_porzuc_} z @code{FILENAME} daje wynik
negatywny, a wykonywanie jest kontynuowane od pierwszej reguły
``faktycznego'' programu.

Sama funkcja @code{nextfile} po prostu nadaje wartość zmiennej
@code{_porzuc_} a następnie wykonuje instrukcję @code{next}, by uruchomić
pętlę.@footnote{Niektóre implementacje @code{awk} nie powalają na
wykonywanie @code{next} z wnętrza ciała funkcji.  Jeżeli korzysta się z
takiej wersji, konieczne jest inne obejście problemu.}
@c mawk is what we're talking about.

Przedstawiona początkowa wersja ma drobną usterkę.  Co się stanie jeśli jakiś
plik danych wymieniono w wierszu poleceń @emph{dwukrotnie}, raz za razem,
lub nawet z samym tylko przypisaniem zmiennej między oboma wystąpieniami tej
samej nazwy pliku?

@c @findex nextfile
@c do it this way, since all the indices are merged
@cindex @code{nextfile} funkcja
W takim przypadku, nasz kod przeskoczy przez plik, drugi raz, mimo że
powinien zatrzymać się po dojściu do końca pierwszego wystąpienia.
Oto druga wersja @code{nextfile}, która zaradzi temu kłopotowi.

@example
@c file eg/lib/nextfile.awk
# nextfile --- pomiń pozostałe rekordy bieżącego pliku
# poprawnie obsługuje kolejne wystąpienia tego samego pliku
# Arnold Robbins, arnold@@gnu.org, Public Domain
# May, 1993

# to powinno być przeczytane przed "głównym" programem awk

function nextfile()   @{ _porzuc_ = FILENAME; next @}

@group
_porzuc_ == FILENAME @{
      if (FNR == 1)
          _porzuc_ = ""
      else
          next
@}
@end group
@c endfile
@end example

Funkcja @code{nextfile} nie zmieniła się.  Przypisuje @code{_porzuc_} nazwę
bieżącego pliku a następnie wykonuje instrukcję @code{next}.  Instrukcja ta
odczytuje kolejny rekord i zwiększa @code{FNR}, tak że @code{FNR} na pewno
będzie mieć wartość co najmniej dwa.  Jeśli jednak @code{nextfile} wywołano
dla ostatniego rekordu pliku, to @code{awk} zamknie bieżący plik danych
i przejdzie do następnego.  Robiąc to, przypisze @code{FILENAME} nazwę
nowego pliku i nada @code{FNR} początkową wartość jeden.  Jeżeli
następny plik jest taki sam jak poprzedni, @code{_porzuc_} będzie nadal
równe @code{FILENAME}.  Jednak @code{FNR} będzie równe jeden, mówiąc nam, że
jest to nowe wystąpienie tego pliku, a nie to, które odczytywaliśmy podczas
wykonywania funkcji @code{nextfile}.  W tym przypadku zmiennej
@code{_porzuc_} przywracana jest początkowa wartość łańcucha pustego, tak że
następne wywołania tej reguły dadzą wynik negatywny (do następnego razu gdy
zostanie wywołana @code{nextfile}).

Jeśli @code{FNR} nie jest równe jeden, to jesteśmy nadal w pierwotnym
pliku danych, a program wykonuje instrukcję @code{next}, przeskakując
przezeń.

W tym momencie pojawia się istotne pytanie:  ``Skoro sposób działania
@code{nextfile} można zapewnić stosując plik biblioteczny, po co wbudowano
ją w @code{gawk}?''  Jest to ważna kwestia.  Dodawanie cech z błahych
powodów prowadzi do większych, wolniejszych programów, które są trudniejsze
w pielęgnacji.

Odpowiedź brzmi: wbudowanie @code{nextfile} w @code{gawk} daje znaczący
przyrost efektywności.  Jeżeli funkcja @code{nextfile} wykonywana jest na
początku dużego pliku danych, @code{awk} nadal musi badać cały plik,
rozbijając go na rekordy, tylko po to by po nim przeskakiwać.  Wbudowane
@code{nextfile} może po prostu natychmiast zamknąć plik i przejść do
następnego, oszczędzając mnóstwa czasu.  Jest to szczególnie ważne
w @code{awk}, gdyż programy @code{awk} są na ogół ograniczone
wejściem/wyjściem (tj.@: większość czasu zużywają na dokonywanie
operacji wejścia i wyjścia, a nie na wykonywanie obliczeń).

@node Funkcja assert, Funkcja round, Funkcja nextfile, Funkcje biblioteczne
@section Asercje

@cindex asercje
@cindex @code{assert}, wersja C
Przy pisaniu dużych programów często przydatna jest możliwość dowiedzenia
się, że dany warunek czy zestaw warunków jest prawdziwy.  Przed
przystąpieniem do konkretnego obliczenia, tworzymy zdanie, stwierdzające,
jaki jest oczekiwany stan.  Zdanie takie nazywamy ``asercją''.  W języku C
dostarczany jest plik nagłówkowy @code{<assert.h>} i odpowiadające mu
makro @code{assert}, które programista może wykorzystać do tworzenia
asercji.  Jeżeli asercja daje wynik negatywny, to makro @code{assert}
zapewnia wypisanie komunikatu diagnostycznego opisującego warunek, który
powinien być prawdziwy a nie był, a następnie ubija program.
W C wykorzystanie @code{assert} wygląda tak:

@c NEEDED
@page
@example
#include <assert.h>

int myfunc(int a, double b)
@{
     assert(a <= 5 && b >= 17);
     @dots{}
@}
@end example

Jeśli asercja nie byłaby spełniona, program wypisałby komunikat podobny
do tego:

@example
prog.c:5: assertion failed: a <= 5 && b >= 17
@end example

@findex assert
Język ANSI C umożliwia przekształcenie warunku na łańcuch znakowy w celu
zamieszczenia go w wypisywanym komunikacie diagnostycznym.  Nie jest to
możliwe w @code{awk}, więc ta funkcja @code{assert} wymaga testowanego
warunku także w postaci łańcucha.

@example
@c @group
@c file eg/lib/assert.awk
# assert --- zweryfikuj, czy warunek jest prawdziwy.
#            Jeśli nie, to zakończ.
# Arnold Robbins, arnold@@gnu.org, Public Domain # May, 1993

function assert(warunek, lancuch)
@{
    if (! warunek) @{
        printf("%s:%d: assertion failed: %s\n",
            FILENAME, FNR, lancuch) > "/dev/stderr"
        _assert_exit = 1
        exit 1
    @}
@}

END @{
    if (_assert_exit)
        exit 1
@}
@c endfile
@c @end group
@end example

Funkcja @code{assert} testuje parametr @code{warunek}.  Jeśli jest on
fałszywy, wypisuje na standardowym wyjściu komunikat, do opisania nie
spełnionego warunku posługując się parametrem @code{lancuch}.  Następnie
przypisuje zmiennej @code{_assert_exit} jeden i wykonuje instrukcję
@code{exit}.  Instrukcja @code{exit} skacze do reguły @code{END}.
Jeśli reguła @code{END} stwierdzi, że @code{_assert_exit} jest prawdziwe,
to natychmiast kończy pracę programu.

Celem reguły @code{END} i jej testu jest powstrzymanie innych reguł
@code{END} przed zadziałaniem.   Gdy asercja nie jest spełniona, program
powinien bezzwłocznie zakończyć pracę.
Jeżeli żadna asercja nie zawiodła, to podczas normalnego uruchomienia
reguły @code{END} @code{_assert_exit} będzie nadal fałszywe, i zostaną
wykonane pozostałe reguły @code{END} programu.
By wszystko to funkcjonowało poprawnie, @file{assert.awk} musi być
pierwszym plikiem źródłowym czytanym przez @code{awk}.

@c NEEDED
@page
Z funkcji @code{assert} w programach korzysta się tak:

@example
function myfunc(a, b)
@{
     assert(a <= 5 && b >= 17, "a <= 5 && b >= 17")
     @dots{}
@}
@end example

@noindent
Jeśli asercja nie będzie spełniona, zobaczymy komunikat typu:

@example
mydata:1357: assertion failed: a <= 5 && b >= 17
@end example

Z tą wersją @code{assert} jest pewien kłopot, który może być nie do obejścia
w standardowym @code{awk}.
Reguła @code{END} jest automatycznie dodawana do programu wywołującego
@code{assert}.  Normalnie, jeśli program składa się wyłącznie z reguły
@code{BEGIN}, pliki wejściowe i/lub standardowe wejście nie są czytane.
Teraz jednak, ponieważ program ma regułę @code{END}, @code{awk}
będzie próbował czytać pliki wejściowe czy standardowe wejście
(@pxref{Używanie BEGIN/END, , Akcje początkowe i końcowe}),
najprawdopodobniej powodując zawieszenie pracy programu, czekającego na dane
wejściowe.

@node Funkcja round, Funkcje porządku, Funkcja assert, Funkcje biblioteczne
@section Zaokrąglanie liczb

@cindex zaokrąglanie
Sposób, w jaki @code{printf} i @code{sprintf}
(@pxref{Printf, , Wymyślne wyjście dzięki instrukcji @code{printf}})
wykonują zaokrąglanie będzie często zależał od procedury C @code{sprintf}
danego systemu.
Na wielu maszynach,
zaokrąglanie @code{sprintf} jest ``nierówne'', co znaczy, że, wbrew
prostodusznym oczekiwaniom, nie zawsze zaokrągla końcowe @samp{.5} w górę.
W zaokrągleniu nierównym @samp{.5} zaokrąglane jest do najbliższej
parzystej, zamiast zawsze w górę.  Zatem 1.5 zaokrąglane jest do 2, ale
4.5 do 4.  W wyniku tego, jeśli stosujemy format wykonujący zaokrąglenia
(np., @code{"%.0f"}), to powinniśmy sprawdzić, co robi nasz system.
Poniższa funkcja wykonuje tradycyjne zaokrąglanie.  Może się przydać jeśli
@code{printf} naszego @code{awk} zaokrągla nierówno.

@findex round
@example
@c file eg/lib/round.awk
# round --- robi normalne zaokrąglanie
#
# Arnold Robbins, arnold@@gnu.org, August, 1996
# Public Domain

function round(x,   wartc, wartb, ulamek)
@{
   wartc = int(x)    # część całkowita, int() obcina

   # zobacz, czy jest część ułamkowa
   if (wartc == x)   # bez ułamka
      return x

   if (x < 0) @{
      wartb = -x     # wartość bezwzględna
      wartc = int(wartb)
      ulamek = wartb - wartc
@group
      if (ulamek >= .5)
         return int(x) - 1   # -2.5 --> -3
      else
         return int(x)       # -2.3 --> -2
@end group
   @} else @{
      ulamek = x - wartc
      if (ulamek >= .5)
         return wartc + 1
      else
         return wartc
   @}
@}

# uruchomienie z testem
@{ print $0, round($0) @}
@c endfile
@end example

@node Funkcje porządku, Funkcja join, Funkcja round, Funkcje biblioteczne
@section Konwersja między znakami a liczbami

@cindex liczbowe wartości znaków
@cindex numeryczne wartości znaków
@cindex wartości znaków jako liczby
Jedna z komercyjnych implementacji @code{awk} zawiera funkcję wbudowaną
@code{ord}, pobierającą znak i zwracającą liczbową wartość tego znaku
w zestawie znaków naszej maszyny.  Jeżeli łańcuch przekazany @code{ord}
zawiera więcej niż jeden znak, to używany jest tylko pierwszy.

Odwrotnością tej funkcji jest @code{chr} (od funkcji o tej samej nazwie
w Pascalu), która pobiera liczbę i zwraca odpowiadający jej znak.

Obie funkcje można ładnie napisać w @code{awk}; nie faktycznego powodu, by
wbudowywać je w interpreter @code{awk}.

@findex ord
@findex chr
@example
@group
@c file eg/lib/ord.awk
# ord.awk --- robi ord i chr
#
# Identyfikatory globalne:
#    _ord_:      wartości numeryczne indeksowane znakami
#    _ord_init:  funkcja inicjująca _ord_
#
# Arnold Robbins
# arnold@@gnu.org
# Public Domain
# 16 January, 1992
# 20 July, 1992, revised

BEGIN    @{ _ord_init() @}
@c endfile
@end group

@c @group
@c file eg/lib/ord.awk
function _ord_init(    low, high, i, t)
@{
    low = sprintf("%c", 7) # BEL to ascii 7
    if (low == "\a") @{    # zwykłe ascii
        low = 0
        high = 127
    @} else if (sprintf("%c", 128 + 7) == "\a") @{
        # ascii, ze znacznikiem parzystości
        low = 128
        high = 255
    @} else @{        # ebcdic(!)
        low = 0
        high = 255
    @}

    for (i = low; i <= high; i++) @{
        t = sprintf("%c", i)
        _ord_[t] = i
    @}
@}
@c endfile
@c @end group
@end example

@cindex zestawy znaków
@cindex kodowanie znaków
@cindex znaki, kodowanie
@cindex znaki, zestawy
@cindex ASCII
@cindex EBCDIC
@cindex znacznik parzystości
Warto poświęcić chwilę na pewne wyjaśnienie liczb używanych przez @code{chr}.
Najważniejszym obecnie stosowanym zestawem znaków jest ASCII. Mimo, że bajt
ośmiobitowy może przechować 256 różnych wartości (od zera do 255), ASCII
definiuje tylko znaki wykorzystujące wartości od zera
do 127.@footnote{W wielu krajach rozszerzono ASCII, tak by wykorzystywało
wartości od 128 do 255 dla znaków specyficznych dla danego kraju.  Jeżeli
nasz system korzysta z takich rozszerzeń, można uprościć @code{_ord_init},
by wykonywało zwykłą pętlę od zera do 255.}
Wiemy o co najmniej jednym producencie komputerów,
@c Pr1me, blech
który stosuje ASCII, ale ze znacznikiem parzystości, co znaczy, że skrajny
lewy bit bajtu jest zawsze jedynką.  Znaczy to, że na takich systemach
znaki mają numeryczne wartości od 128 do 255.
Na koniec, wielkie systemy mainframe stosują zestaw znaków EBCDIC,
wykorzystujący wszystkie 256 wartości.  Mimo, że w niektórych starszych
systemach w użytku są inne zestawy znaków, nie warto faktycznie się
nimi przejmować.

@example
@group
@c file eg/lib/ord.awk
function ord(str,    c)
@{
    # interesuje nas tylko pierwszy znak
    c = substr(str, 1, 1)
    return _ord_[c]
@}
@c endfile
@end group

@group
@c file eg/lib/ord.awk
function chr(c)
@{
    # wymuś numeryczne c przez dodanie 0
    return sprintf("%c", c + 0)
@}
@c endfile
@end group

@group
@c file eg/lib/ord.awk
#### kod testowy ####
# BEGIN    \
# @{
#    for (;;) @{
#        printf("podaj znak: ")
#        if (getline zmn <= 0)
#            break
#        printf("ord(%s) = %d\n", zmn, ord(zmn))
#    @}
# @}
@c endfile
@end group
@end example

Oczywistym udoskonaleniem tych funkcji byłoby przesunięcie kodu funkcji
@code{@w{_ord_init}} do ciała reguły @code{BEGIN}.  Napisano go początkowo
w ten sposób by ułatwić budowę.

Mamy tu ``program testowy'' w regule @code{BEGIN}, do testowania funkcji.
Do czynnego użytkowania został zakomentowany.

@node Funkcja join, Funkcja mktime, Funkcje porządku, Funkcje biblioteczne
@section Scalanie tablicy w łańcuch

@cindex łączenie łańcuchów
Przy przetwarzaniu łańcuchów często przydaje się możliwość połączenia
wszystkich łańcuchów z jakiejś tablicy w jeden długi łańcuch.  Cel ten
realizuje poniższa funkcja, @code{join}.  Jest wykorzystywana dalej w kilku
programach użytkowych
(@pxref{Przykładowe programy, ,Praktyczne programy @code{awk}}).

Istotny jest dobry projekt funkcji.  Nasza funkcja powinna być ogólna, ale
też jej zachowanie domyślne powinno być rozsądne.  Wywoływana jest z tablicą
oraz początkowym i końcowym indeksem elementów, jakie mają zostać połączone.
Zakłamy, że elementy tablicy są numeryczne -- rozsądne założenie, gdyż
tablica zapewne została utworzona za pomocą @code{split}
(@pxref{Funkcje łańcuchowe, ,Funkcje wbudowane działające na łańcuchach}).

@findex join
@example
@group
@c file eg/lib/join.awk
# join.awk --- łączy tablicę w łańcuch
# Arnold Robbins, arnold@@gnu.org, Public Domain
# May 1993

function join(tablica, pocz, kon, sep,    wynik, i)
@{
    if (sep == "")
       sep = " "
    else if (sep == SUBSEP) # magiczna wartość
       sep = ""
    wynik = tablica[pocz]
    for (i = pocz + 1; i <= kon; i++)
        wynik = wynik sep tablica[i]
    return wynik
@}
@c endfile
@end group
@end example

Dodatkowy, opcjonalny argument jest separatorem, jaki ma być zastosowany
przy ponownym łączeniu łańcuchów.  Jeśli wywołanie dostarczy niepustą
wartość, @code{join} skorzysta z niej.  Jeśli jej nie poda, to argument
będzie mieć wartość pustą.  W tym przypadku @code{join} jako domyślny
separator łańcuchów stosuje pojedynczy odstęp.  Jeżeli wartość jest równa
@code{SUBSEP}, to @code{join} złączy łańcuchy bez separatora między nimi.
@code{SUBSEP} służy jako ``magiczna'' wartość, wskazująca, że między
składowymi łańcuchami nie powinno być rozdzielania.

Byłoby miło, gdyby @code{awk} miał operator przypisania dla konkatenacji.
Brak jawnego operatora konkatenacji powoduje, że operacje na łańcuchach są
trudniejsze niż muszą być faktycznie.

@node Funkcja mktime, Funkcja gettimeofday, Funkcja join, Funkcje biblioteczne
@section Konwersja dat na znaczniki czasu

Funkcja @code{systime} wbudowana w @code{gawk} zwraca bieżący czas jako
znacznik czasowy w ``sekundach od początku Epoki''.  Stosując wbudowaną
funkcję @code{strftime} znacznik czasu można przekształcić na drukowalną
datę w niemal nieograniczenie dowolnym formacie.  (Więcej o @code{systime}
i @code{strftime},
@pxref{Funkcje czasu, ,Funkcje obsługi znaczników czasu}.)

@cindex konwersja dat na znaczniki czasu
@cindex daty, konwersja na znaczniki czasu
@cindex znaczniki czasu, konwersja na daty
@cindex timestamp, konwersja na datę
Interesującym, lecz trudnym problemem jest konwersja czytelnej reprezentacji
daty z powrotem na znacznik czasu.  Biblioteka C posiada funkcję
@code{mktime}, która wykonuje podstawowe zadanie, przekształcając
na znacznik czasu reprezentację kanoniczną daty.

Na pierwszy rzut oka, wygląda na to, że @code{gawk} musiałby mieć
funkcję wbudowaną @code{mktime}, która byłaby po prostu ``punktem
zaczepienia'' do wersji z języka C.  W rzeczywistości jednak @code{mktime}
można zrealizować w całości w @code{awk}.@footnote{@value{UPDATE-MONTH}:
W rzeczywistości myliłem się pisząc to.  Przedstawiona tu wersja
nie zawsze działa prawidłowo, a następna główna wersja @code{gawk} będzie
zapewniać @code{mktime} jako funkcję wbudowaną.}
@c sigh.

Oto wersja @code{mktime} napisana w @code{awk}.  Pobiera zwykłą
reprezentację daty i czasu i przekształca ją na znacznik czasu.

Przedstawiony kod jest przepleciony prozą.  W
@ref{Program extract, ,Wydzielanie programów z plików źródłowych Texinfo},
zobaczymy, w jaki sposób można przetworzyć plik źródłowy Texinfo tej
książki, by wydzielić kod do pojedynczego pliku źródłowego.

Program zaczyna się komentarzem opisowym i regułą @code{BEGIN}, która
inicjuje tablicę @code{_tm_mies}.  Jest to dwuwymiarowa tablica
zawierająca długości poszczególnych miesięcy.  Pierwszym indeksem jest zero
dla zwykłych lat, zaś jeden dla przestępnych.  W obu rodzajach lat wartości
dla wszystkich miesięcy, z wyjątkiem lutego, są takie same.  Z tego powodu
stosujemy przypisanie wielokrotne.

@example
@c @group
@c file eg/lib/mktime.awk

# mktime.awk --- przekształca kanoniczną reprezentację
#                daty na znacznik czasu

# Arnold Robbins, arnold@@gnu.org, Public Domain
# May 1993

BEGIN    \
@{
    # inicjacja tablicy długości miesięcy
    _tm_mies[0,1] = _tm_mies[1,1] = 31
    _tm_mies[0,2] = 28; _tm_mies[1,2] = 29
    _tm_mies[0,3] = _tm_mies[1,3] = 31
    _tm_mies[0,4] = _tm_mies[1,4] = 30
    _tm_mies[0,5] = _tm_mies[1,5] = 31
    _tm_mies[0,6] = _tm_mies[1,6] = 30
    _tm_mies[0,7] = _tm_mies[1,7] = 31
    _tm_mies[0,8] = _tm_mies[1,8] = 31
    _tm_mies[0,9] = _tm_mies[1,9] = 30
    _tm_mies[0,10] = _tm_mies[1,10] = 31
    _tm_mies[0,11] = _tm_mies[1,11] = 30
    _tm_mies[0,12] = _tm_mies[1,12] = 31
@}
@c endfile
@c @end group
@end example

Korzyści z łączenia wielu reguł @code{BEGIN}
(@pxref{BEGIN/END, ,Wzorce specjalne @code{BEGIN} i @code{END}})
są szczególnie oczywiste przy pisaniu plików bibliotecznych.  Funkcje
zawarte w bibliotece mogą bez trudności inicjować własne prywatne dane.
Mogą też zapewnić akcje porządkowe w prywatnych regułach @code{END}.

Następna funkcja jest prosta.  Oblicza, czy dany rok jest przestępny czy nie.
Jeżeli rok jest podzielny bez reszty przez cztery, ale nie dzieli się przez
100, albo jeśli jest podzielny przez 400, to jest to rok przestępny.
Zatem, 1904 był rokiem przestępnym, 1900 nie był, ale 2000 jest
przestępny.
@c Change this after the year 2000 to ``2000 was'' (:-)

@findex _tm_isleap
@example
@group
@c file eg/lib/mktime.awk
# decyduje czy rok jest przestępny
function _tm_isleap(rok,    ret)
@{
    ret = (rok % 4 == 0 && rok % 100 != 0) ||
            (rok % 400 == 0)

    return ret
@}
@c endfile
@end group
@end example

Funkcja ta w naszym pliku wykorzystywana jest tylko kilkukrotnie, a jej
obliczenia mogłyby zostać wstawione (zapisane @dfn{in-line}) w miejscu,
gdzie jest używana.  Zrobienie z nich osobnej funkcji ułatwiło początkowe
konstruowanie, zapobiega także możliwości popełnienia błędów typograficznych
przy powielaniu kodu w wielu miejscach.

Kolejna funkcja jest bardziej interesująca.  Wykonuje większość pracy przy
tworzeniu znacznika czasu, polegającej na konwersji daty i czasu na pewną
liczbę sekund od początku Epoki.  Wywołujący przekazuje tablicę (dość
wymyślnie nazwaną @code{a}) zawierającą sześć wartości: rok łącznie ze
stuleciem, miesiąc jako liczbę między 1 a 12, dzień miesiąca, godzinę jako
liczbę między 0 a 23, minuty i sekundy.

Do wstępnego obliczenia liczby sekund w godzinie, sekund w dniu i sekund
w roku funkcja wykorzystuje kilka zmiennych lokalnych.  Często kod w C
po prostu zapisuje dane wyrażenie in-line, spodziewając się, że kompilator
wykona @dfn{złożenie stałych} (constant folding).  Np., większość
kompilatorów C przekształciłaby @samp{60 * 60} na @samp{3600} w czasie
kompilacji, zamiast przeliczać to każdorazowo w czasie wykonania.
Wstępne obliczenie tych wartości powoduje, że funkcja jest bardziej efektywna.

@findex _tm_addup
@example
@c @group
@c file eg/lib/mktime.awk
# zamienia datę na sekundy
function _tm_addup(a,    razem, roksek, dziensek,
                         godzsek, i, j)
@{
    godzsek = 60 * 60
    dziensek = 24 * godzsek
    roksek = 365 * dziensek

    razem = (a[1] - 1970) * roksek

@group
    # dodatkowy dzień dla lat przestępnych
    for (i = 1970; i < a[1]; i++)
        if (_tm_isleap(i))
            razem += dziensek
@end group

@group
    j = _tm_isleap(a[1])
    for (i = 1; i < a[2]; i++)
        razem += _tm_mies[j, i] * dziensek
@end group

    razem += (a[3] - 1) * dziensek
    razem += a[4] * godzsek
    razem += a[5] * 60
    razem += a[6]

    return razem
@}
@c endfile
@c @end group
@end example

Funkcja zaczyna od pierwszego przybliżenia wszystkich sekund pomiędzy
północą 1 stycznia 1970,@footnote{Jest to początek Epoki w systemach
POSIX-owych.  Na innych systemach może być inny.} a początkiem bieżącego
roku.  Następnie przechodzi przez wszystkie te lata i dla każdego roku
przestępnego dodaje równowartość w sekundach jednego dnia.

Zmienna @code{j} przechowuje jeden lub zero, w zależności od tego czy
bieżący rok jest czy nie jest przestępny.  Dla każdego miesiąca
bieżącego roku poprzedzającego aktualny miesiąc dodaje liczbę sekund
tego miesiąca, wykorzystując odpowiednią pozycję tablicy @code{_tm_mies}.

Na koniec, dodaje sekundy odpowiadające liczbie dni poprzedzających bieżący
oraz liczbie godzin, minut i sekund bieżącego dnia.

Wynikiem jest ilość sekund od 1 stycznia 1970.  Wartość ta nie jest jednak
jeszcze tym, czego potrzebujemy.  Opiszemy pokrótce powód.

Główna funkcja @code{mktime} pobiera pojedynczy argument łańcuchowy.
Łańcuch przedstawia datę i czas w postaci ``kanonicznej'' (ustalonej).
Powinno to być
@code{"@var{rok} @var{mies} @var{dzien} @var{godz} @var{min} @var{sek}"}.

@findex mktime
@example
@c @group
@c file eg/lib/mktime.awk
# mktime --- zamień datę na sekundy,
#            koryguj z uwagi na strefę czasową

function mktime(str,    wyn1, wyn2, a, b, i, j, t, rozn)
@{
    i = split(str, a, " ")    # nie polegaj na FS

    if (i != 6)
        return -1

    # wymuś numeryczne
    for (j in a)
        a[j] += 0

@group
    # sprawdź poprawność
    if (a[1] < 1970 ||
        a[2] < 1 || a[2] > 12 ||
        a[3] < 1 || a[3] > 31 ||
        a[4] < 0 || a[4] > 23 ||
        a[5] < 0 || a[5] > 59 ||
        a[6] < 0 || a[6] > 60 )
            return -1
@end group

    wyn1 = _tm_addup(a)
    t = strftime("%Y %m %d %H %M %S", wyn1)

    if (_tm_debug)
        printf("(%s) -> (%s)\n", str, t) > "/dev/stderr"

    split(t, b, " ")
    wyn2 = _tm_addup(b)

    rozn = wyn1 - wyn2

    if (_tm_debug)
        printf("rozn = %d sekund\n", rozn) > "/dev/stderr"

    wyn1 += rozn

    return wyn1
@}
@c endfile
@c @end group
@end example

Funkcja najpierw dzieli łańcuch, stosując jako separatory spacje i tabulacje
i umieszczając wynik w tablicy.  Jeżeli w tablicy nie ma sześciu elementów,
to zwraca błąd, sygnalizowany jako wartość @minus{}1.
Następnie wymusza numeryczność każdego elementu tablicy, dodając doń zero.
Kolejna instrukcja, @samp{if}, upewnia się, że każdy element mieści się
w dopuszczalnym zakresie.  (Ta kontrola powinna zostać później poszerzona,
np., by upewnić się, że dzień miesiąca jest w poprawnym zakresie dla
konkretnego, podanego miesiąca.)  Wszystko to w gruncie rzeczy stanowi
wstępną konfigurację i kontrolę błędów.

Przypomnijmy, że @code{_tm_addup} tworzyła wartość w sekundach od północy
1 stycznia 1970.  Wartość ta nie nadaje się wprost do użytku jako wynik,
którego potrzebujemy, @emph{gdyż obliczenia nie biorą pod uwagę lokalnej
strefy czasowej}.  Inaczej mówiąc, wartość ta przedstawia ilość sekund od
początku Epoki, ale tylko dla UTC (czasu uniwersalnego, Greenwich).
Jeśli lokalna strefa czasowa leży na wschód lub zachód od UTC, to do
wynikowego znacznika czasu należy dodać, lub odjąć od niego, pewną liczbę
godzin.

Na przykład, 18:23 w Atlancie, stan Georgia (USA), jest normalnie pięć godzin
na zachód (za) UTC.  Przy czasie letnim jest to tylko cztery godziny
za UTC.
Jeśli wywołujemy @code{mktime} w Atlancie, z argumentem
@code{@w{"1993 5 23 18 23 12"}}, wynikiem z @code{_tm_addup} będzie
18:23 UTC, co stanowi dopiero 14:23 w Atlancie.  Niezbędne jest dodanie
do otrzymanego wyniku kolejnych sekund o równowartości czterech godzin.

Jak @code{mktime} może stwierdzić, jak daleko do UTC się znajduje?
To jest zaskakująco łatwe.  Zwrócony znacznik czasu przedstawia czas
przekazany do @code{mktime} @emph{jako UTC}.  Znacznikiem tym można
z powrotem nakarmić @code{strftime}, które sformatuje go jako
czas @emph{lokalny}, tj.@: tak, jakby miał już w sobie dodaną różnicę
w stosunku do UTC.  Zrobiono to przez przekazanie do @code{strftime}
łańcucha @code{@w{"%Y %m %d %H %M %S"}} jako argumentu formatu.
Zwróci ono obliczony znacznik w formacie pierwotnego łańcucha.  Wynik
reprezentuje czas uwzględniający różnicę do UTC.  Gdy nowy czas jest
konwertowany z powrotem na znacznik czasu, różnica pomiędzy tymi dwoma
znacznikami jest różnicą (w sekundach) między lokalną strefą czasową a UTC.
Różnica ta jest następnie dodawana do pierwotnego wyniku.  Przykład
pokazujący to przedstawiono poniżej.

Na koniec, mamy ``główny'' program do przetestowania funkcji.

@example
@c there used to be a blank line after the getline,
@c squished out for page formatting reasons
@c @group
@c file eg/lib/mktime.awk
BEGIN  @{
    if (_tm_test) @{
        printf "Wprowadź datę yyyy mm dd hh mm ss: "
        getline _tm_test_date
        t = mktime(_tm_test_date)
        r = strftime("%Y %m %d %H %M %S", t)
        printf "Otrzymujemy zwrotnie (%s)\n", r
    @}
@}
@c endfile
@c @end group
@end example

Cały program do sterowania diagnostyką wyjścia i włączenia testu w końcowej
regule @code{BEGIN} korzysta z dwu zmiennych, którym wartość można nadać
w wierszu poleceń.  Oto wynik przebiegu testu.  (Zauważ, że wyjściem
diagnostycznym jest standardowe wyjście błędów, zaś wyjściem testu
standardowe wyjście.)

@example
@c @group
$ gawk -f mktime.awk -v _tm_test=1 -v _tm_debug=1
@print{} Wprowadź datę yyyy mm dd hh mm ss: 1993 5 23 15 35 10
@error{} (1993 5 23 15 35 10) -> (1993 05 23 11 35 10)
@error{} rozn = 14400 sekund
@print{} Otrzymujemy zwrotnie (1993 05 23 15 35 10)
@c @end group
@end example

Wprowadzono czas 15:25, 23 maja 1993.  Pierwszy wiersz wyjścia
diagnostycznego pokazuje czas wynikowy jako UTC -- cztery godziny
wyprzedzający czas lokalny.  Drugi wiersz pokazuje, że różnica wynosi
14400 sekund, co stanowi cztery godziny.  (Różnica jest tylko
czterogodzinna, gdyż w maju obowiązuje tu czas letni.)  Ostatni
wiersz wyjścia testowego pokazuje, że algorytm wyrównywania strefy czasowej
działa: zwrócony czas jest taki sam jak czas wprowadzony.

Program ten nie rozwiązuje ogólnego problemu zamiany dowolnej daty
na znacznik czasu.  Problem taki jest bardzo zagmatwany.  Jednak funkcja
@code{mktime} daje fundament, na którym można budować rozwiązanie.
Inny program może przekształcać nazwy miesięcy na ich numery
kolejne i czasy AM/PM [tłum:przed/po południu, stosowane przy zegarze
12-godzinnym] na czas 24-godzinny, by utworzyć format ``kanoniczny'',
jakiego wymaga @code{mktime}.

@node Funkcja gettimeofday, Funkcja filetrans, Funkcja mktime, Funkcje biblioteczne
@section Obsługa daty i czasu

@cindex sformatowane znaczniki czasu
@cindex znaczniki czasu, sformatowane
Funkcje @code{systime} i @code{strftime} opisane w
@ref{Funkcje czasu, ,Funkcje obsługi znaczników czasu},
zapewniają minimalną funkcjonalność niezbędną przy działaniach na czasie
w postaci czytelnej dla człowieka.  Mimo, że @code{strftime} jest rozległa,
formaty sterujące niekonieczne są łatwe do zapamiętania i intuicyjnie
oczywiste przy czytaniu programu.

Poniższa funkcja, @code{gettimeofday}, zapełnia dostarczoną przez
użytkownika tablicę sformatowaną informacją o czasie.  Zwraca łańcuch
z bieżącym czasem sformatowanym tak samo, jak przez narzędzie @code{date}.

@findex gettimeofday
@example
@c @group
@c file eg/lib/gettime.awk
# gettimeofday --- pobierz datę i czas w dającym się użyć formacie
# Arnold Robbins, arnold@@gnu.org, Public Domain, May 1993
#
# Zwraca łańcuch w formacie wyjściowym date(1)
# Wypełnia tablicę argumentu czasu poszczególnymi wartościami:
#    czas["sekunda"]         -- sekundy (0 - 59)
#    czas["minuta"]          -- minuty (0 - 59)
#    czas["godzina"]         -- godziny (0 - 23)
#    czas["altgodzina"]      -- godziny (0 - 12)
#    czas["dzienmca"]        -- dzień miesiąca (1 - 31)
#    czas["miesiac"]         -- miesiąc roku (1 - 12)
#    czas["nazwamca"]        -- nazwa miesiąca
#    czas["mckrotko"]        -- krótka nazwa miesiąca
#    czas["rok"]             -- rok w stuleciu (0 - 99)
#    czas["pelnyrok"]        -- rok ze stuleciem (19xx lub 20xx)
#    czas["dzientyg"]        -- dzien tygodnia (niedziela = 0)
#    czas["altdzientyg"]     -- dzien tygodnia (poniedziałek = 0)
#    czas["numtyg"]          -- numer tygodnia, niedziela pierwsza
#    czas["altnumtyg"]       -- numer tygodnia, poniedziałek pierwszy
#    czas["nazwadnia"]       -- nazwa dnia tygodnia
#    czas["dzienkrotko"]     -- krótka nazwa dnia tygodnia
#    czas["dzienroku"]       -- dzień roku (0 - 365)
#    czas["strefa"]          -- skrót nazwy strefy czasowej
#    czas["ampm"]            -- określenie AM lub PM

function gettimeofday(czas,    ret, teraz, i)
@{
    # pobierz czas raz, unikając zbędnych wywołań systemowych
    teraz = systime()

    # zwróć wyjście w stylu date(1)
    ret = strftime("%a %b %d %H:%M:%S %Z %Y", teraz)

    # wyczyść tablicę docelową
    for (i in czas)
        delete czas[i]

    # wypełnij wartościami, wymuszając na numerycznych
    # wartościach ich numeryczność przez dodanie 0
    czas["sekunda"]     = strftime("%S", now) + 0
    czas["minuta"]      = strftime("%M", now) + 0
    czas["godzina"]     = strftime("%H", now) + 0
    czas["altgodzina"]  = strftime("%I", now) + 0
    czas["dzienmca"]    = strftime("%d", now) + 0
    czas["miesiac"]     = strftime("%m", now) + 0
    czas["nazwamca"]    = strftime("%B", now)
    czas["mckrotko"]    = strftime("%b", now)
    czas["rok"]         = strftime("%y", now) + 0
    czas["pelnyrok"]    = strftime("%Y", now) + 0
    czas["dzientyg"]    = strftime("%w", now) + 0
    czas["altdzientyg"] = strftime("%u", now) + 0
    czas["nazwadzien"]  = strftime("%A", now)
    czas["dzienkrotko"] = strftime("%a", now)
    czas["dzienroku"]   = strftime("%j", now) + 0
    czas["strefa"]      = strftime("%Z", now)
    czas["ampm"]        = strftime("%p", now)
    czas["numtyg"]      = strftime("%U", now) + 0
    czas["altnumtyg"]   = strftime("%W", now) + 0

    return ret
@}
@c endfile
@end example

Indeksy łańcuchowe są łatwiejsze w korzystaniu i czytaniu niż rozmaite
formaty wymagane przez @code{strftime}.  Funkcja ta jest wykorzystywana przez
program @code{alarm} przedstawiony
w @ref{Program alarm, ,Program-budzik}.

@c exercise!!!
Funkcję @code{gettimeofday} przedstawiono powyżej tak, jak została napisana.
Ogólniejsza konstrukcja funkcji pozwoliłaby użytkownikowi podanie
opcjonalnej wartości znacznika czasu, która byłaby użyta zamiast bieżącego
czasu.

@node Funkcja filetrans, Funkcja getopt, Funkcja gettimeofday, Funkcje biblioteczne
@section Obsługa przejść między plikami

@cindex inicjalizacja i porządki dla każdego pliku
Każda z reguł @code{BEGIN} i @code{END} wykonywana jest dokładnie raz,
odpowiednio na początku i na końcu programu @code{awk}
(@pxref{BEGIN/END, ,Wzorce specjalne @code{BEGIN} i @code{END}}).
Sami, jako autorzy @code{gawk}, mieliśmy kiedyś użytkownika, który błędnie
sądził, że reguła @code{BEGIN} jest wykonywana na początku każdego pliku
a @code{END} na końcu każdego pliku danych.  Gdy został poinformowany, że
tak nie jest, poprosił byśmy dodali specjalne wzorce do @code{gawk},
o nazwach @code{BEGIN_FILE} i @code{END_FILE}, które miałyby pożądane
zachowanie.  Nawet dostarczył nam kod, by to zrobić.

Jednak, po krótkim namyśle, doszedłem do następującego programu
bibliotecznego.  Organizuje on wywoływanie dwu zapewnianych przez
użytkownika funkcji, @code{beginfile} i @code{endfile}, na początku i końcu
każdego pliku danych.  Program, oprócz tego, że rozwiązuje problem
w jedynie dziewięciu(!) linijkach kodu, robi to w sposób @emph{przenośny}.
Konstrukcja ta będzie działać w dowolnej implementacji @code{awk}.

@example
@c @group
# transfile.awk
#
# Daje użytkownikowi obsługę przejścia między plikami
#
# Użytkownik musi zapewnić funkcje beginfile() i endfile(),
# z których każda pobiera odpowiednio nazwę pliku
# rozpoczynanego lub kończonego.
#
# Arnold Robbins, arnold@@gnu.org, January 1992
# Public Domain

FILENAME != _staryplik \
@{
    if (_staryplik != "")
        endfile(_staryplik)
    _staryplik = FILENAME
    beginfile(FILENAME)
@}

END   @{ endfile(FILENAME) @}
@c @end group
@end example

Plik ten musi być wczytany przed ``głównym'' programem użytkownika, tak by
reguła, jaką zawiera, była wykonywana jako pierwsza.

Reguła ta opiera się na zmiennej @code{awk} @code{FILENAME}, która zmienia
się automatycznie dla każdego nowego pliku danych.  Bieżąca nazwa pliku
przechowywana jest w zmiennej prywatnej, @code{_staryplik}.  Jeżeli
@code{FILENAME} nie jest równe @code{_staryplik}, to rozpoczęto
przetwarzanie nowego pliku danych, i konieczne jest wywołanie @code{endfile}
dla starego pliku.  Ponieważ @code{endfile} powinna być wywołana jeśli
przetworzono plik, program upewnia się najpierw, czy @code{_staryplik}
nie jest łańcuchem pustym.  Następnie przypisuje nazwę bieżącego pliku
zmiennej @code{_staryplik} i wywołuje @code{beginfile} dla tego pliku.
Ponieważ, jak wszystkie zmienne @code{awk}, @code{_staryplik} będzie
inicjowane łańcuchem pustym, reguła ta wykona się poprawnie nawet dla
pierwszego pliku danych.

Program zawiera także regułę @code{END}, do wykonania końcowego
przetwarzania ostatniego pliku.  Ponieważ @code{END} przychodzi przed
wszystkimi innymi ewentualnymi regułami @code{END} podanymi w programie
``głównym'', najpierw zostanie wywołana @code{endfile}.  Raz jeszcze zalety
wielokrotnych reguł @code{BEGIN} i @code{END} powinny być bezsporne.

@findex beginfile
@findex endfile
Nasza wersja ma ten sam kłopot, co pierwsza wersja @code{nextfile}
(@pxref{Funkcja nextfile, ,Implementacja @code{nextfile} jako funkcji}).
Jeżeli ten sam plik danych pojawia się w wierszu poleceń dwa razy z rzędu,
to @code{endfile} i @code{beginfile} nie zostaną wykonane na końcu
pierwszego przebiegu i na początku drugiego.  Ta wersja rozwiązuje problem.

@example
@c @group
@c file eg/lib/ftrans.awk
# ftrans.awk --- obsługa  przejścia między plikami
#
# użytkownik zapewnia funkcje beginfile() i endfile()
#
# Arnold Robbins, arnold@@gnu.org, November 1992
# Public Domain

FNR == 1 @{
    if (_plik_ != "")
        endfile(_plik_)
    _plik_ = FILENAME
    beginfile(FILENAME)
@}

END  @{ endfile(_plik_) @}
@c endfile
@c @end group
@end example

W @ref{Program wc, ,Zliczanie rzeczy},
zobaczymy, jak można wykorzystać tę funkcję biblioteczną,
i jak upraszcza ona pisanie głównego programu.

@node Funkcja getopt, Funkcje passwd, Funkcja filetrans, Funkcje biblioteczne
@section Przetwarzanie opcji wiersza poleceń

@cindex @code{getopt}, wersja C
@cindex przetwarzanie argumentów
@cindex argumenty, przetwarzanie
Większość narzędzi w systemach zgodnych z POSIX przyjmuje w wierszu poleceń
opcje lub ``przełączniki'', które służą do zmiany sposobu zachowania się
programu.
@code{awk} jest przykładem takiego programu
(@pxref{Opcje, ,Opcje wiersza poleceń}).
Często opcje pobierają @dfn{argumenty}, dane, których program potrzebuje
do poprawnego wykonania danej opcji wiersza poleceń.  Na przykład, opcja
@samp{-F} narzędzia @code{awk} wymaga łańcucha, jaki ma być użyty jako
separator pól.  Pierwsze wystąpienie w wierszu poleceń @samp{--} albo
łańcucha nie rozpoczynającego się od @samp{-} kończy opcje.

Większość systemów uniksowych do przetwarzania argumentów wiersza poleceń
udostępnia funkcję C o nazwie @code{getopt}.  Programista dostarcza łańcuch
opisujący jednoliterowe opcje.  Jeżeli opcja wymaga argumentu, w łańcuchu
występuje po nim dwukropek.  Do @code{getopt} są też przekazywane ilość
i wartości argumentów wiersza poleceń.  Wywoływana jest ona w pętli.
@code{getopt} przetwarza argumenty wiersza poleceń z uwagi na litery opcji.
Przy każdym obrocie pętli zwraca pojedynczy znak reprezentujący kolejną
literę opcji, jaką znalazła, albo @samp{?} jeśli napotkała niepoprawną
opcję.  Gdy zwraca @minus{}1, to w wierszu poleceń ma już nie opcji.

Przy korzystaniu z @code{getopt} opcje nie pobierające argumentów można
grupować, łącząc je ze sobą.  Ponadto, opcje pobierające argumenty wymagają
obecności argumentu.  Argument może występować bezpośrednio po literze opcji
albo być osobnym argumentem wiersza poleceń.

Zakładając, że mamy hipotetyczny program, który przyjmuje trzy opcje wiersza
poleceń @samp{-a}, @samp{-b} i @samp{-c}, a @samp{-b} wymaga argumentu,
poprawne są wszystkie poniższe sposoby wywołania programu:

@example
@c @group
prog -a -b foo -c dane1 dane2 dane3
prog -ac -bfoo -- dane1 dane2 dane3
prog -acbfoo dane1 dane2 dane3
@c @end group
@end example

Zwróć uwagę, że gdy argument jest połączony z opcją, reszta argumentów
wiersza poleceń uważana jest za argument tej opcji.  W powyższym
przykładzie, @samp{-acbfoo} wskazuje, że podano wszystkie z opcji @samp{-a},
@samp{-b} i @samp{-c}, a @samp{foo} jest argumentem opcji @samp{-b}.

@code{getopt} dostarcza cztery zewnętrzne zmienne do wykorzystania przez
programistę.

@table @code
@item optind
Indeks w tablicy wartości argumentów (@code{argv}), gdzie znaleziono
pierwszy nie będący opcją argument wiersza poleceń.

@item optarg
Wartość łańcuchowa argumentu aktualnej opcji.

@item opterr
Zwykle @code{getopt} wypisuje komunikat o błędzie gdy znajdzie niepoprawną
opcję.  Nadanie @code{opterr} wartości zero wyłącza tę cechę.
(Program użytkowy może zechcieć wypisać własny komunikat o błędzie.)

@item optopt
Litera reprezentująca aktualną opcję wiersza poleceń.
Mimo, że zwykle nie jest udokumentowana, większość wersji zapewnia tę
zmienną.
@end table

Poniższy fragment w C pokazuje, jak @code{getopt} mógłby przetwarzać
argumenty wiersza poleceń przekazane do @code{awk}.

@example
@group
int
main(int argc, char *argv[])
@{
    @dots{}
    /* wypisz nasz własny komunikat */
    opterr = 0;
@end group
@group
    while ((c = getopt(argc, argv, "v:f:F:W:")) != -1) @{
        switch (c) @{
        case 'f':    /* plik */
            @dots{}
            break;
        case 'F':    /* separator pól */
            @dots{}
            break;
        case 'v':    /* przypisanie zmiennej */
            @dots{}
            break;
        case 'W':    /* rozszerzenie */
            @dots{}
            break;
        case '?':
        default:
            usage();
            break;
        @}
    @}
    @dots{}
@}
@end group
@end example

Nawiasem mówiąc, @code{gawk} w rzeczywistości zarówno do przetwarzania
zwykłych, jak i długich opcji w stylu GNU, korzysta z funkcji GNU
@code{getopt_long} (@pxref{Opcje, ,Opcje wiersza poleceń}).

Abstrakcja zapewniana przez @code{getopt} jest bardzo przydatna
i w programach @code{awk} również byłaby bardzo poręczna.
Oto wersja @code{getopt} napisana w @code{awk}.  Ta funkcja ujawnia jedną
z największych słabości @code{awk}: jest kiepski w operowaniu na
pojedynczych znakach.  Dla uzyskania dostępu do indywidualnych znaków
niezbędne jest powtarzanie wywołań @code{substr}
(@pxref{Funkcje łańcuchowe, ,Funkcje wbudowane działające na łańcuchach}).

Kod jest omawiany po kawałku.

@example
@c @group
@c file eg/lib/getopt.awk
# getopt --- robi w awk funkcję getopt(3) z biblioteki C
#
# arnold@@gnu.org
# Public domain
#
# Initial version: March, 1991
# Revised: May, 1993

@group
# Zmienne zewnętrzne:
#    Optind -- indeks w ARGV pierwszego argumentu nie-opcyjnego
#    Optarg -- wartość łańcuchowa argumentu bieżącej opcji
#    Opterr -- jeśli niezerowe, wypisuje naszą diagnostykę
#    Optopt -- litera bieżącej opcji
@end group

# Zwraca
#    -1     na końcu opcji
#    ?      dla nierozpoznanej opcji
#    <c>    znak reprezentujący bieżącą opcję

# Dane prywatne
#    _opti  indeks w opcji wieloflagowej, np. -abc
@c endfile
@c @end group
@end example

Funkcja zaczyna się od dokumentacji: kto napisał kod, i kiedy został on
wypuszczony, po czym następuje lista wykorzystywanych zmiennych globalnych,
jakie są zwracane wartości i co znaczą, i wszelkie zmienne globalne, które
dla tej funkcji bibliotecznej są ``prywatne''.  Taka dokumentacja jest
kluczowa dla każdego programu, a szczególnie dla funkcji bibliotecznych.

@findex getopt
@example
@c @group
@c file eg/lib/getopt.awk
function getopt(argc, argv, options,    optl, thisopt, i)
@{
    optl = length(options)
    if (optl == 0)        # nie podano opcji
        return -1

    if (argv[Optind] == "--") @{  # wszystko zrobione
        Optind++
        _opti = 0
        return -1
    @} else if (argv[Optind] !~ /^-[^: \t\n\f\r\v\b]/) @{
        _opti = 0
        return -1
    @}
@c endfile
@c @end group
@end example

Funkcja sprawdza najpierw, czy rzeczywiście została wywołana z łańcuchem
opcji (parametr @code{options}).  Jeśli @code{options} ma długość zerową,
@code{getopt} od razu zwraca @minus{}1.

Następną rzeczą do sprawdzenia jest koniec opcji.  Ciąg @samp{--} kończy
opcje wiersza poleceń, podobnie każdy argument wiersza poleceń nie
rozpoczynający się od @samp{-}.  Do przechodzenia przez tablicę
argumentów wiersza poleceń używana jest @code{Optind}.  Zachowuje ona
swoją wartość pomiędzy wywołaniami @code{getopt}, gdyż jest zmienną
globalną.

Użyte wyrażenie regularne, @code{@w{/^-[^: \t\n\f\r\v\b]/}},
jest być może nieco za ostre.  Kontroluje, czy po @samp{-} występuje
coś, co nie jest białym znakiem ani dwukropkiem.
Jeśli bieżący argument wiersza poleceń nie pasuje do tego wzorca, to nie
jest opcją i kończy przetwarzanie opcji.

@example
@group
@c file eg/lib/getopt.awk
    if (_opti == 0)
        _opti = 2
    thisopt = substr(argv[Optind], _opti, 1)
    Optopt = thisopt
    i = index(options, thisopt)
    if (i == 0) @{
        if (Opterr)
            printf("%c -- invalid option\n",
                                  thisopt) > "/dev/stderr"
        if (_opti >= length(argv[Optind])) @{
            Optind++
            _opti = 0
        @} else
            _opti++
        return "?"
    @}
@c endfile
@end group
@end example

Zmienna @code{_opti} zapamiętuje pozycję w bieżącym argumencie wiersza poleceń
(@code{argv[Optind]}).  W przypadku, gdy połączono wiele opcji z jednym
@samp{-} (np. @samp{-abx}), należy zwracać je użytkownikowi po jednej.

Jeśli @code{_opti} jest równe zero, otrzymuje wartość dwa, indeks następnego
znaku, jaki należy zbadać w łańcuchu (pomijamy @samp{-}, stojące na pozycji
numer jeden).  Znak ten, uzyskany z @code{substr}, przechowuje zmienna
@code{thisopt}. Jest on równocześnie przechowywany w @code{Optopt},
do wykorzystania przez program główny.

Jeśli @code{thisopt} nie ma w łańcuchu @code{options}, to jest to
niepoprawna opcja.  Jeżeli @code{Opterr} jest niezerowe, @code{getopt}
wypisze na standardowym wyjściu błędów komunikat o błędzie podobny do
komunikatu @code{getopt} w wersji C.

Ponieważ opcja jest niepoprawna, należy ją pominąć i przejść do następnego
znaku opcyjnego.  Jeżeli @code{_opti} jest większe lub równe długości
bieżącego argumentu wiersza poleceń, to należy przejść do kolejnego
argumentu.  Wówczas zwiększane jest @code{Optind} i zerowane @code{_opti}.
W przeciwnym przypadku, @code{Optind} jest pozostawiane bez zmian,
a zwiększane jest tylko @code{_opti}.

W każdym z przypadków, ponieważ opcja jest niepoprawna, @code{getopt}
zwraca @samp{?}.  Program główny może zbadać @code{Optopt} jeśli potrzebuje
wiedzieć, jaka była faktycznie litera niepoprawnej opcji.

@example
@group
@c file eg/lib/getopt.awk
    if (substr(options, i + 1, 1) == ":") @{
        # pobierz argument opcji
        if (length(substr(argv[Optind], _opti + 1)) > 0)
            Optarg = substr(argv[Optind], _opti + 1)
        else
            Optarg = argv[++Optind]
        _opti = 0
    @} else
        Optarg = ""
@c endfile
@end group
@end example

Jeżeli dana opcja wymaga argumentu, to w łańcuchu @code{options} po jej
literze występuje dwukropek.  Jeżeli w bieżącym argumencie wiersza poleceń
(@code{argv[Optind]}) pozostały jakieś znaki, to reszta tego łańcucha
przypisywana jest do @code{Optarg}.  W przeciwnym razie używany jest
następny argument wiersza poleceń (@samp{-xFOO} versus @samp{@w{-x FOO}}).
W obu przypadkach zerowane jest @code{_opti}, gdyż w bieżącym argumencie
wiersza poleceń nie ma już znaków pozostałych do zbadania.

@example
@c @group
@c file eg/lib/getopt.awk
    if (_opti == 0 || _opti >= length(argv[Optind])) @{
        Optind++
        _opti = 0
    @} else
        _opti++
    return thisopt
@}
@c endfile
@c @end group
@end example

Na koniec, jeżeli @code{_opti} jest albo zerowe albo większe niż długość
bieżącego argumentu wiersza poleceń, to znaczy to, że ten element
w @code{argv} jest już w całości przetworzony.  Zwiększane jest więc
@code{Optind}, tak by wskazywało na kolejny element @code{argv}.  Jeżeli
żaden z tych warunków nie jest prawdziwy, to zwiększane jest tylko
@code{_opti}, tak by przy następnym wywołaniu @code{getopt} była
przetwarzana kolejna litera opcji.

@example
@c @group
@c file eg/lib/getopt.awk
BEGIN @{
    Opterr = 1    # domyślnie włączona diagnostyka
    Optind = 1    # pomiń ARGV[0]

    # program testowy
    if (_getopt_test) @{
        while ((_go_c = getopt(ARGC, ARGV, "ab:cd")) != -1)
            printf("c = <%c>, optarg = <%s>\n",
                                       _go_c, Optarg)
        printf("argumenty nieopcyjne:\n")
        for (; Optind < ARGC; Optind++)
            printf("\tARGV[%d] = <%s>\n",
                                    Optind, ARGV[Optind])
    @}
@}
@c endfile
@c @end group
@end example

Reguła @code{BEGIN} inicjuje zarówno @code{Opterr}, jak i @code{Optind},
jedynką.  @code{Opterr} otrzymuje wartość jeden, gdyż domyślnym
zachowaniem @code{getopt} jest wypisywanie komunikatu diagnostycznego
po zauważeniu niepoprawnej opcji. @code{Optind} otrzymuje wartość jeden,
gdyż nie ma powodu, by badać nazwę programu, znajdującą się w @code{ARGV[0]}.

Dalsza część reguły @code{BEGIN} jest prostym programem testowym.
Oto wynik dwu przykładowych przebiegów programu testowego.

@example
@group
$ awk -f getopt.awk -v _getopt_test=1 -- -a -cbARG bax -x
@print{} c = <a>, optarg = <>
@print{} c = <c>, optarg = <>
@print{} c = <b>, optarg = <ARG>
@print{} argumenty nieopcyjne:
@print{}         ARGV[3] = <bax>
@print{}         ARGV[4] = <-x>
@end group

@group
$ awk -f getopt.awk -v _getopt_test=1 -- -a -x -- xyz abc
@print{} c = <a>, optarg = <>
@error{} x -- invalid option
@print{} c = <?>, optarg = <>
@print{} argumenty nieopcyjne:
@print{}         ARGV[4] = <xyz>
@print{}         ARGV[5] = <abc>
@end group
@end example

Pierwsze @samp{--} kończy argumenty przekazywane do @code{awk}, więc
@code{awk} nie próbuje interpretować @samp{-a} itd. jako własnych opcji.

Do przetwarzania swoich opcji korzysta z @code{getopt}
kilka programów przykładowych przedstawionych w
@ref{Przykładowe programy, ,Praktyczne programy @code{awk}}.

@node Funkcje passwd, Funkcje group, Funkcja getopt, Funkcje biblioteczne
@section Czytanie bazy użytkowników

@cindex @file{/dev/user}
Plik specjalny  @file{/dev/user}
(@pxref{Pliki specjalne, ,Specjalne nazwy plików w @code{gawk}})
daje dostęp do związanych z bieżącym użytkownikiem numerycznych
rzeczywistych i efektywnych identyfikatorów użytkownika i grupy, oraz, jeśli
jest dostępny, zestawu dodatkowych grup użytkownika.  Jednak, ponieważ są to
liczby, przeciętnemu użytkownikowi nie dają zbyt użytecznej informacji.
Musi istnieć jakaś metoda znalezienia danych o użytkowniku związanych
z numerami użytkowników i grup.  Niniejsza sekcja przedstawia pakiet funkcji
do pobierania informacji z bazy danych użytkowników.
@xref{Funkcje group, ,Czytanie bazy grup},
gdzie jest podobny pakiet, pobierający informacje z bazy grup.

@cindex @code{getpwent}, wersja C
@cindex informacje o użytkowniku
@cindex informacje o koncie
@cindex plik haseł
Standard POSIX nie definiuje pliku, w którym trzymane są dane
o użytkownikach.  Zamiast tego, zapewnia plik nagłówkowy @code{<pwd.h>}
i kilka podprogramów w języku C służących do uzyskiwania informacji
o użytkowniku.  Najważniejszą z nich jest @code{getpwent}, od ``get password
entry'' (pobierz wpis z haseł). Użyte ``password'' pochodzi od pierwotnej
bazy danych o użytkownikach, @file{/etc/passwd}, która przechowuje dane
o użytkowniku, razem z zakodowanymi hasłami (stąd nazwa).

Mimo, że program @code{awk} mógłby po prostu bezpośrednio czytać
@file{/etc/passwd} (format jest dobrze znany), z powodu sposobu, w jaki
pliki haseł obsługiwane są w systemach sieciowych, plik ten może nie
zawierać pełnej informacji o zbiorze użytkowników systemu.

@cindex @code{pwcat}, program
@cindex program @code{pwcat}
Aby być pewnym możności stworzenia czytelnej, pełnej wersji bazy
użytkowników, trzeba napisać mały program w C, który wywołuje
@code{getpwent}.  Funkcję @code{getpwent} zdefiniowano tak, by zwracała
wskaźnik do @code{struct passwd}.  Przy każdym wywołaniu zwraca kolejną
pozycję bazy danych.  Jeżeli nie ma już więcej pozycji, zwraca
@code{NULL}, wskaźnik pusty.  Gdy się to stanie, program C powinien
wywołać @code{endpwent}, by zamknąć bazę.  Oto @code{pwcat}, program w C,
który wypisuje, jak @code{cat}, bazę haseł.

@findex pwcat.c
@example
@c @group
@c file eg/lib/pwcat.c
/*
 * pwcat.c
 *
 * Tworzy drukowalną wersją bazy haseł
 *
 * Arnold Robbins
 * arnold@@gnu.org
 * May 1993
 * Public Domain
 */

#include <stdio.h>
#include <pwd.h>

int
main(argc, argv)
int argc;
char **argv;
@{
    struct passwd *p;

    while ((p = getpwent()) != NULL)
        printf("%s:%s:%d:%d:%s:%s:%s\n",
            p->pw_name, p->pw_passwd, p->pw_uid,
            p->pw_gid, p->pw_gecos, p->pw_dir, p->pw_shell);

    endpwent();
    exit(0);
@}
@c endfile
@c @end group
@end example

Nie przejmuj się, jeżeli nie rozumiesz C.
Wyjściem z @code{pwcat} jest baza użytkowników, w tradycyjnym formacie
@file{/etc/passwd}, o polach rozdzielanych dwukropkami.  Polami są:

@table @asis
@item Login name
Nazwa zgłoszeniowa użytkownika.

@item Encrypted password
Zakodowane hasło użytkownika.  Na niektórych systemach może nie być dostępne.

@item User-ID
Numeryczny identyfikator danego użytkownika.

@item Group-ID
Numeryczny identyfikator grupy użytkownika.

@item Full name
Pełna nazwa (imię, nazwisko) użytkownika, i być może inne dane z nim
związane.

@item Home directory
Katalog zgłoszeniowy, ``domowy'' użytkownika (znany programującym w
powłoce jako @code{$HOME}).

@item Login shell
Program, który zostanie uruchomiony gdy użytkownik się zaloguje.
Jest zwykle to powłoka, taka jak Bash (Gnu Bourne-Again shell).
@end table

Oto kilka typowych dla wyjścia z @code{pwcat} wierszy.

@example
@c @group
$ pwcat
@print{} root:3Ov02d5VaUPB6:0:1:Operator:/:/bin/sh
@print{} nobody:*:65534:65534::/:
@print{} daemon:*:1:1::/:
@print{} sys:*:2:2::/:/bin/csh
@print{} bin:*:3:3::/bin:
@print{} arnold:xyzzy:2076:10:Arnold Robbins:/home/arnold:/bin/sh
@print{} miriam:yxaay:112:10:Miriam Robbins:/home/miriam:/bin/sh
@print{} andy:abcca2:113:10:Andy Jacobs:/home/andy:/bin/sh
@dots{}
@c @end group
@end example

Po tym wprowadzeniu pokażemy grupę funkcji do pozyskiwania danych o
użytkowniku.  Mamy tu kilka funkcji, odpowiadających funkcjom C o tych
samych nazwach.

@findex _pw_init
@example
@c file eg/lib/passwdawk.in
@group
# passwd.awk --- dostęp do danych pliku haseł
# Arnold Robbins, arnold@@gnu.org, Public Domain
# May 1993

BEGIN @{
    # dopasuj to do własnego systemu
    _pw_awklib = "/usr/local/libexec/awk/"
@}
@end group

@group
function _pw_init(    oldfs, oldrs, olddol0, pwcat)
@{
    if (_pw_inited)
        return
    oldfs = FS
    oldrs = RS
    olddol0 = $0
    FS = ":"
    RS = "\n"
    pwcat = _pw_awklib "pwcat"
    while ((pwcat | getline) > 0) @{
        _pw_byname[$1] = $0
        _pw_byuid[$3] = $0
        _pw_bycount[++_pw_total] = $0
    @}
    close(pwcat)
    _pw_count = 0
    _pw_inited = 1
    FS = oldfs
    RS = oldrs
    $0 = olddol0
@}
@c endfile
@end group
@end example

Reguła @code{BEGIN} przypisuje zmiennej prywatnej katalog, w którym
przechowywany jest @code{pwcat}.  Ponieważ @code{pwcat} wykorzystujemy
jako pomoc dla procedury bibliotecznej @code{awk}, zdecydowaliśmy się
umieścić go w @file{/usr/local/libexec/awk}.
W swoim systemie możesz trzymać go w jakimś innym katalogu.

Funkcja @code{_pw_init} przechowuje trzy kopie danych o użytkowniku
w trzech tablicach asocjacyjnych.
Tablice są indeksowane nazwą użytkownika (@code{_pw_byname}),
numerycznym identyfikatorem użytkownika (@code{_pw_byuid}) i kolejnością
występowania (@code{_pw_bycount}).

Zmienną @code{_pw_inited} posłużono się w celu poprawy efektywności:
@code{_pw_init} wystarczy wywołać tylko raz.

Ponieważ nasza funkcja do czytania danych z @code{pwcat} wykorzystuje
instrukcję @code{getline}, najpierw zapamiętuje wartości @code{FS},
@code{RS} i @code{$0}.  Jest to konieczne, gdyż omawiane funkcje mogą
zostać wywołane z dowolnego miejsca programu użytkownika, a może on mieć
swoje własne wartości @code{FS} i @code{RS}.
@ignore
Problem, what if FIELDWIDTHS is in use? Sigh.
@end ignore

Główna część funkcji wykorzystuje pętlę do czytania wierszy bazy, podziału
danego wiersza na pola, a następnie, jak tego potrzebujemy, zapamiętania go
w każdej z tablic.  Po wykonaniu pętli, @code{@w{_pw_init}} robi porządki,
zamykając potok, przypisując @code{@w{_pw_inited}} jedynkę i odtwarzając
@code{FS}, @code{RS} i  @code{$0}.  Posługiwanie się @code{@w{_pw_count}}
będzie objaśnione niżej.

@findex getpwnam
@example
@group
@c file eg/lib/passwdawk.in
function getpwnam(name)
@{
    _pw_init()
    if (name in _pw_byname)
        return _pw_byname[name]
    return ""
@}
@c endfile
@end group
@end example

Funkcja @code{getpwnam} pobiera nazwę użytkownika jako argument łańcuchowy.
Jeśli dany użytkownik jest w bazie, zwraca odpowiedni wiersz.  W przeciwnym
razie zwraca łańcuch pusty.

@findex getpwuid
@example
@group
@c file eg/lib/passwdawk.in
function getpwuid(uid)
@{
    _pw_init()
    if (uid in _pw_byuid)
        return _pw_byuid[uid]
    return ""
@}
@c endfile
@end group
@end example

Podobnie,
funkcja @code{getpwuid} pobiera jako argument numeryczny
identyfikator użytkownika.  Jeśli taki numer użytkownika jest w bazie,
zwraca odpowiedni wiersz.  W przeciwnym razie zwraca łańcuch pusty.

@findex getpwent
@example
@c @group
@c file eg/lib/passwdawk.in
function getpwent()
@{
    _pw_init()
    if (_pw_count < _pw_total)
        return _pw_bycount[++_pw_count]
    return ""
@}
@c endfile
@c @end group
@end example

Funkcja @code{getpwent} po prostu przechodzi przez bazę, po jednej pozycji
naraz.  Korzysta z @code{_pw_count} do zapamiętywania swojej bieżącej pozycji
w tablicy @code{_pw_bycount}.

@findex endpwent
@example
@c @group
@c file eg/lib/passwdawk.in
function endpwent()
@{
    _pw_count = 0
@}
@c endfile
@c @end group
@end example

Funkcja @code{@w{endpwent}} zeruje @code{@w{_pw_count}}, tak że kolejne
wywołania @code{getpwent} rozpoczną się znów od początku.

Świadomą decyzją projektową w pakiecie jest to, że każdy z podprogramów
wywołuje @code{@w{_pw_init}} w celu zainicjowania tablic bazy.  Dodatkowy
koszt uruchomienia osobnego procesu do stworzenia bazy użytkowników
i operacji wejścia/wyjścia do jej przeszukania poniesiony zostanie tylko
jeśli program główny użytkownika faktycznie wywoła jedną z tych funkcji.
Jeżeli razem z programem użytkownika wczytywany jest plik biblioteczny, ale
żaden z podprogramów nie zostanie nigdy wywołany, to nie będzie żadnego
dodatkowego narzutu na czas wykonania.  (Alternatywą byłoby przesunięcie
ciała @code{@w{_pw_init}} do reguły @code{BEGIN}, która zawsze uruchamiałaby
@code{pwcat}.  Upraszcza to kod, lecz uruchamia dodatkowy proces, który może
nigdy nie być potrzebny.)

Z kolei, wywołanie @code{_pw_init} nie jest zbyt kosztowne, gdyż zmienna
@code{_pw_inited} powstrzymuje program od czytania danych więcej niż raz.
Jeśli chcielibyśmy ze swojego programu wycisnąć ostatni cykl, to kontrola
@code{_pw_inited} powinna być przesunięta poza @code{_pw_init} i powielona
w każdej z pozostałych funkcji.  W praktyce nie jest to konieczne, gdyż
większość programów @code{awk} jest ograniczona wejściem/wyjściem,
a tylko zapchałoby to kod.

Funkcji tych używa program @code{id} w
@ref{Program id, ,Wypisywanie informacji o użytkowniku}.

@node Funkcje group, Nazwy biblioteczne, Funkcje passwd, Funkcje biblioteczne
@section Czytanie bazy grup

@cindex @code{getgrent}, wersja C
@cindex informacje o grupach
@cindex informacje o koncie
@cindex plik grup
Większość rozważań przedstawionych w
@ref{Funkcje passwd, ,Czytanie bazy użytkowników},
odnosi się również do bazy grup.  Mimo, że tradycyjnie istnieje dobrze znany
plik, @file{/etc/group}, w dobrze znanym formacie, standard POSIX zapewnia
wyłącznie zestaw podprogramów bibliotecznych C
(@code{<grp.h>} i @code{getgrent}) dających dostęp do tych danych.
Mimo tego nawet, że plik ten istnieje, możliwe jest, że nie zawiera pełnej
informacji.  Z tego powodu, tak jak w przypadku bazy użytkowników, niezbędne
jest posiadanie małego programu w C, który tworzy jako swoje wyjście bazę
grup.

@cindex @code{grcat}, program
Oto @code{grcat}, program w C, który wypisuje, jak @code{cat}, bazę grup.

@findex grcat.c
@example
@c @group
@c file eg/lib/grcat.c
/*
 * grcat.c
 *
 * tworzy drukowalną wersję bazy grup
 *
 * Arnold Robbins, arnold@@gnu.org
 * May 1993
 * Public Domain
 */

#include <stdio.h>
#include <grp.h>

@group
int
main(argc, argv)
int argc;
char **argv;
@{
    struct group *g;
    int i;
@end group

@group
    while ((g = getgrent()) != NULL) @{
        printf("%s:%s:%d:", g->gr_name, g->gr_passwd,
                                            g->gr_gid);
@end group
        for (i = 0; g->gr_mem[i] != NULL; i++) @{
            printf("%s", g->gr_mem[i]);
            if (g->gr_mem[i+1] != NULL)
                putchar(',');
        @}
        putchar('\n');
    @}
    endgrent();
    exit(0);
@}
@c endfile
@c @end group
@end example

Każdy wiersz bazy grup reprezentuje jedną grupę.  Pola rozdzielone są
dwukropkami, i reprezentują poniższe dane.

@table @asis
@item Group Name
Nazwa grupy

@item Group Password
Zakodowane hasło grupy.  W praktyce pole to nie jest nigdy wykorzystywane.
Zwykle jest puste lub ma wartość @samp{*}.

@item Group ID Number
Numeryczny identyfikator grupy.  Liczba ta powinna być niepowtarzalna
w obrębie pliku.

@item Group Member List
Lista rozdzielonych dwukropkami nazw użytkowników.  Są oni członkami
danej grupy.  Większość systemów uniksowych zezwala, by użytkownicy byli
członkami wielu grup równocześnie.  Jeśli nasz system również na to pozwala,
to odczyt @file{/dev/user} zwróci te numery identyfikatorów grup w polach
@code{$5} do @code{$NF}.  (Zauważ, że @file{/dev/user} jest rozszerzeniem
@code{gawk};
@pxref{Pliki specjalne, ,Specjalne nazwy plików w @code{gawk}}.)
@end table

Oto, co może dać uruchomienie @code{grcat}:

@example
@group
$ grcat
@print{} wheel:*:0:arnold
@print{} nogroup:*:65534:
@print{} daemon:*:1:
@print{} kmem:*:2:
@print{} staff:*:10:arnold,miriam,andy
@print{} other:*:20:
@dots{}
@end group
@end example

Poniżej przedstawiono funkcje do uzyskiwania informacji z bazy grup.
Mamy tu kilka funkcji, wzorowanych na funkcjach bibliotecznych C o tych
samych nazwach.

@findex _gr_init
@example
@group
@c file eg/lib/groupawk.in
# group.awk --- funkcje do obsługi pliku grup
# Arnold Robbins, arnold@@gnu.org, Public Domain
# May 1993

BEGIN    \
@{
    # dopasuj to do własnego systemu
    _gr_awklib = "/usr/local/libexec/awk/"
@}
@c endfile
@end group

@group
@c file eg/lib/groupawk.in
function _gr_init(    oldfs, oldrs, olddol0, grcat, n, a, i)
@{
    if (_gr_inited)
        return
@end group

@group
    oldfs = FS
    oldrs = RS
    olddol0 = $0
    FS = ":"
    RS = "\n"
@end group

@group
    grcat = _gr_awklib "grcat"
    while ((grcat | getline) > 0) @{
        if ($1 in _gr_byname)
            _gr_byname[$1] = _gr_byname[$1] "," $4
        else
            _gr_byname[$1] = $0
        if ($3 in _gr_bygid)
            _gr_bygid[$3] = _gr_bygid[$3] "," $4
        else
            _gr_bygid[$3] = $0

        n = split($4, a, "[ \t]*,[ \t]*")
@end group
@group
        for (i = 1; i <= n; i++)
            if (a[i] in _gr_groupsbyuser)
                _gr_groupsbyuser[a[i]] = \
                    _gr_groupsbyuser[a[i]] " " $1
            else
                _gr_groupsbyuser[a[i]] = $1
@end group

@group
        _gr_bycount[++_gr_count] = $0
    @}
@end group
@group
    close(grcat)
    _gr_count = 0
    _gr_inited++
    FS = oldfs
    RS = oldrs
    $0 = olddol0
@}
@c endfile
@end group
@end example
Reguła @code{BEGIN} przypisuje zmiennej prywatnej katalog, w którym
przechowywany jest @code{grcat}.  Ponieważ @code{grcat} wykorzystujemy
jako pomoc dla procedury bibliotecznej @code{awk}, zdecydowaliśmy się
umieścić go w @file{/usr/local/libexec/awk}.
W swoim systemie możesz trzymać go w jakimś innym katalogu.

Podprogramy te mają ten sam schemat, co podprogramy bazy użytkowników
(@pxref{Funkcje passwd, ,Czytanie bazy użytkowników}).
Zmienna @code{@w{_gr_inited}} wykorzystywana jest do zagwarantowania, że
baza danych nie będzie przeglądana więcej niż raz.
Funkcja @code{@w{_gr_init}} najpierw zachowuje @code{FS}, @code{RS}
i @code{$0}, a następnie przypisuje @code{FS} i @code{RS} poprawne przy
przeglądaniu informacji o grupach wartości.

Dane o grupach przechowywane są w kilku tablicach asocjacyjnych.
Tablice indeksowane są nazwą grupy (@code{@w{_gr_byname}}), identyfikatorem
grupy (@code{@w{_gr_bygid}}) i pozycją w bazie (@code{@w{_gr_bycount}}).
Istnieje dodatkowa tablica indeksowana nazwą użytkownika
(@code{@w{_gr_groupsbyuser}}), będąca listą rozdzielonych spacjami grup,
do których należy każdy poszczególny użytkownik.

W przeciwieństwie do bazy użytkowników, można mieć w bazie wiele rekordów
dla tej samej grupy.  Jest to częste gdy grupa ma dużą ilość członków.
Taka para wpisów może wyglądać tak:

@example
tvpeople:*:101:johny,jay,arsenio
tvpeople:*:101:david,conan,tom,joan
@end example

Z tego powodu, @code{_gr_init} patrzy, czy nazwa lub identyfikator
grupy nie były już widziane.  Jeśli tak, to nazwy użytkowników są po prostu
łączone z poprzednią listą użytkowników grupy.  (W przedstawionym powyżej
kodzie występuje pewnien trudno uchwytny problem.  Załóżmy, że za pierwszym
razem nie było żadnych nazw.  Kod ten dodaje nazwy wraz z początkowym
przecinkiem.  Nie sprawdza też, czy istnieje @code{$4}.)

Na koniec, @code{_gr_init} zamyka potok do @code{grcat}, odtwarza
@code{FS}, @code{RS} i @code{$0}, inicjuje @code{_gr_count} zerem (jest
używane później), i czyni niezerowym @code{_gr_inited}.

@findex getgrnam
@example
@c @group
@c file eg/lib/groupawk.in
function getgrnam(group)
@{
    _gr_init()
    if (group in _gr_byname)
        return _gr_byname[group]
    return ""
@}
@c endfile
@c @end group
@end example

Funkcja @code{getgrnam} pobiera nazwę grupy jako swój argument i, jeśli
grupa ta istnieje, zwraca ją.  W przeciwnym razie @code{getgrnam} zwraca
łańcuch pusty.

@findex getgrgid
@example
@c @group
@c file eg/lib/groupawk.in
function getgrgid(gid)
@{
    _gr_init()
    if (gid in _gr_bygid)
        return _gr_bygid[gid]
    return ""
@}
@c endfile
@c @end group
@end example

Funkcja @code{getgrgid} jest podobna, pobiera numeryczny identyfikator
grupy i szuka informacji związanej z tym identyfikatorem.

@findex getgruser
@example
@group
@c file eg/lib/groupawk.in
function getgruser(user)
@{
    _gr_init()
    if (user in _gr_groupsbyuser)
        return _gr_groupsbyuser[user]
    return ""
@}
@c endfile
@end group
@end example

Funkcja @code{getgruser} nie ma odpowiednika w C.  Pobiera nazwę
użytkownika i zwraca listę grup, których jest on członkiem.

@findex getgrent
@example
@c @group
@c file eg/lib/groupawk.in
function getgrent()
@{
    _gr_init()
    if (++_gr_count in _gr_bycount)
        return _gr_bycount[_gr_count]
    return ""
@}
@c endfile
@c @end group
@end example

Funkcja @code{getgrent} przechodzi przez bazę, kolejno po jednym wpisie.
Korzysta z @code{_gr_count} do zapamiętywania swego położenia na liście.

@findex endgrent
@example
@group
@c file eg/lib/groupawk.in
function endgrent()
@{
    _gr_count = 0
@}
@c endfile
@end group
@end example

@code{endgrent} zeruje @code{_gr_count}, tak że @code{getgrent} może
rozpocząć ponownie od początku.

Jak w przypadku funkcji obsługi bazy użytkowników, każda z funkcji wywołuje
@code{_gr_init}, by zainicjować tablice.  Wykonywanie tych wywołań
skutkuje dodatkowymi kosztami uruchamiania @code{grcat} tylko wtedy, gdy
funkcje te zostaną użyte (w przeciwieństwie do przesunięcia ciała
@code{_gr_init} do wnętrza reguły @code{BEGIN}).

Większość pracy stanowi przeszukiwanie bazy i tworzenie rozmaitych tablic
asocjacyjnych.  Funkcje, które wywołuje użytkownik, są same bardzo proste,
zdając się na wykonanie zadania przez tablice asocjacyjne @code{awk}.

Opisane funkcje wykorzystywane są przez program @code{id} w
@ref{Program id, ,Wypisywanie informacji o użytkowniku}.

@node Nazwy biblioteczne,  , Funkcje group, Funkcje biblioteczne
@section Nazywanie zmiennych globalnych funkcji bibliotecznych

@cindex kwestie przestrzeni nazw w @code{awk}
@cindex dokumentowanie programów @code{awk}
@cindex programy, dokumentowanie
Z powodu sposobu, w jaki ewoluował język @code{awk}, zmienne są albo
@dfn{globalne} (do użytku całego programu), albo @dfn{lokalne}
(do użytku tylko konkretnej funkcji).  Nie ma żadnego stanu pośredniego,
analogicznego do zmiennych @code{statycznych} w C.

Funkcje biblioteczne często potrzebują zmiennych globalnych, które mogłyby
wykorzystać do zachowania pomiędzy wywołaniami funkcji informacji o stanie.
Na przykład, zmienna @code{_opti} występująca w @code{getopt}
(@pxref{Funkcja getopt, ,Przetwarzanie opcji wiersza poleceń}),
czy tablica @code{_tm_mies} wykorzystywana przez @code{mktime}
(@pxref{Funkcja mktime, ,Konwersja dat na znaczniki czasu}).
Zmienne takie nazywamy @dfn{prywatnymi}, gdyż jedynymi funkcjami, jakie
potrzebują z nich korzystać są funkcje z biblioteki.

Przy pisaniu funkcji bibliotecznej, powinno się próbować wybrać nazwy
swoich zmiennych prywatnych tak, by nie kolidowały one ze zmiennymi
wykorzystywanymi albo przez inną funkcję biblioteczną, albo przez program
główny użytkownika.  Na przykład, nazwa taka jak @samp{i} czy @samp{j} nie
jest dobrym wyborem, gdyż programy użytkownika często używają podobnych nazw
zmiennych dla własnych celów.

Wszystkie programy przykładowe pokazane w niniejszym rozdziale zaczynały
nazwy swoich zmiennych prywatnych od znaku podkreślenia (@samp{_}).
Użytkownicy na ogół nie stosują początkowych znaków podkreślenia w nazwach
własnych zmiennych, więc konwencja ta od razu zmniejsza ryzyko
przypadkowego współdzielenia nazwy zmiennej z programem użytkownika.

Dodatkowo, kilka spośród funkcji bibliotecznych stosuje przedrostek,
wskazujący która funkcja czy zestaw funkcji wykorzystują dane zmienne.
Na przykład, @code{_tm_mies} w @code{mktime}
(@pxref{Funkcja mktime, ,Konwersja dat na znaczniki czasu})
i @code{_pw_byname} w podprogramach bazy użytkowników
(@pxref{Funkcje passwd, ,Czytanie bazy użytkowników}).
Zalecamy stosowanie się do tej konwencji, ponieważ zmniejsza ona
nawet w większym stopniu ryzyko nieumyślnego konfliktu nazw.  Zauważ, że
konwencja ta może być wykorzystywana równie dobrze do nazw zmiennych,
jak i do nazw funkcji prywatnych.

Mimo, iż mógłbym przepisać wszystkie procedury biblioteczne tak, by
stosowały się do tej konwencji, nie zrobiłem tego, by pokazać jak ewoluował
mój styl programowania w @code{awk} i zapewnić jakąś podstawę do rozważań.

Poczyńmy jeszcze ostatnią uwagę na temat nazywania zmiennych.
Jeśli funkcja udostępnia zmienne globalne programowi głównemu, dobra
konwencją jest rozpoczęcie nazwy zmiennej dużą literą. Na przykład,
zmienne @code{Opterr} i @code{Optind} z @code{getopt}
(@pxref{Funkcja getopt, ,Przetwarzanie opcji wiersza poleceń}).  Początkowa
duża litera wskazuje, że jest to zmienna globalna, podczas gdy fakt, że cała
nazwa zmiennej nie składa się z dużych liter wskazuje, że nie jest to jedna
ze zmiennych wbudowanych @code{awk}, jak np. @code{FS}.

Ważne jest również, by @emph{wszystkie} zmienne w funkcjach
bibliotecznych, które nie muszą zachowywać stanu, były zadeklarowane jako
lokalne.  Jeśli się tego nie zrobi, zmienna może zostać przypadkowo użyta
w programie użytkownika, co prowadzi do bardzo trudnych do wyśledzenia
błędów.

@example
function fun_bibl(x, y,    l1, l2)
@{
    @dots{}
    @var{użycie zmiennej} zmn  # zmn mogłaby być lokalna, ale
    @dots{}                 # przez niedopatrzenie nie jest
    @}
@end example

@cindex Tcl
Inną konwencją, powszechną w społeczności Tcl, jest stosowanie pojedynczej
tablicy asocjacyjnej do przechowywania wartości potrzebnych funkcji
(funkcjom) bibliotecznym, czy inaczej ``pakietowi''.  Znacząco zmniejsza
to liczbę faktycznie wykorzystywanych nazw.  Na przykład, funkcje opisane w
@ref{Funkcje passwd, , Czytanie bazy użytkowników},
mogłyby używać @code{@w{PW_data["inited"]}}, @code{@w{PW_data["total"]}},
@code{@w{PW_data["count"]}} i @code{@w{PW_data["awklib"]}} zamiast
@code{@w{_pw_inited}}, @code{@w{_pw_awklib}}, @code{@w{_pw_total}}
i @code{@w{_pw_count}}.

Konwencje przedstawione w tej sekcji są dokładnie tym -- konwencjami.
Nie musisz pisać programów w ten sposób, jedynie zalecamy, byś tak robił.

@node Przykładowe programy, Historia języka, Funkcje biblioteczne, Top
@chapter Praktyczne programy @code{awk}

W tym rozdziale przedstawiamy mieszankę programów @code{awk} dla
przyjemności czytania.
@iftex
Rozdział ten składa się z dwu sekcji. Pierwsza pokazuje zrobione w @code{awk}
wersje kilku popularnych narzędzi POSIX-owych.  Druga jest
workiem pełnym interesujących programów.
@end iftex

Wiele z tych programów wykorzystuje funkcje biblioteczne przedstawione
w @ref{Funkcje biblioteczne, ,Biblioteczka funkcji @code{awk}}.

@menu
* Klony::                       Klony typowych narzędzi.
* Rozmaite programy::           Parę interesujących programów @code{awk}.
@end menu

@node Klony, Rozmaite programy, Przykładowe programy, Przykładowe programy
@section Wymyślanie prochu dla rozrywki i zysku

Ta sekcja przedstawia kilka narzędzi POSIX, które zostały zaimplementowane
w @code{awk}.  Ponowne wymyślanie tych programów w @code{awk} jest często
dobrą zabawą, gdyż odpowiednie algorytmy można wyrazić przejrzyście, jasno,
a kod jest zwykle zwięzły i prosty.  Jest to możliwe dzięki temu, że
@code{awk} robi tak wiele za nas.

Należy zauważyć, że przeznaczeniem opisywanych programów nie jest
zastąpienie wersji zainstalowanych w twoim systemie.  Ich celem jest
natomiast zilustrowanie programowania w języku @code{awk} rzeczywistych,
``z życia wziętych'' zadań.

Programy przedstawiono w kolejności alfabetycznej.

@menu
* Program cut::             Narzędzie @code{cut}.
* Program egrep::           Narzędzie @code{egrep}.
* Program id::              Narzędzie @code{id}.
* Program split::           Narzędzie @code{split}.
* Program tee::             Narzędzie @code{tee}.
* Program uniq::            Narzędzie @code{uniq}.
* Program wc::              Narzędzie @code{wc}.
@end menu

@node Program cut, Program egrep, Klony, Klony
@subsection Wycinanie pól i kolumn

@cindex @code{cut}, narzędzie
@cindex narzędzie @code{cut}
Narzędzie @code{cut} wybiera, lub ``wycina'' (``cut''), znaki albo pola
ze swego standardowego wejścia i wysyła je na standardowe wyjście.
@code{cut} potrafi wyciąć albo listę znaków, albo listę pól.  Domyślnie,
pola oddzielane są tabulacjami, ale można podać opcję wiersza poleceń, by
zmienić @dfn{ogranicznik} pól, tj.@: znak separatora pól.  Definicja pól
w @code{cut} jest mniej ogólna niż w @code{awk}.

Typowym zastosowaniem @code{cut} może być wyciągnięcie z wyjścia programu
@code{who}, pokazującego zalogowanych użytkowników, tylko nazw kont.
Na przykład, poniższy potok tworzy posortowaną, nie zawierającą powtórzeń
listę zalogowanych użytkowników:

@example
who | cut -c1-8 | sort | uniq
@end example

@code{cut} ma następujące opcje:

@table @code
@item -c @var{lista}
Wykorzystuje @var{listę} jako listę znaków do wycięcia.  Pozycje listy można
rozdzielać, a zakresy znaków oddzielać myślnikami.  Lista @samp{1-8,15,22-35}
określa znaki od jeden do osiem, 15, i 22 do 35.

@item -f @var{lista}
Wykorzystuje @var{listę} jako listę pól do wycięcia.

@item -d @var{ogranicz}
Jako znaku separatora pól, zamiast znaku tabulacji, używa @var{ogranicz}.

@item -s
Pomija wypisywanie wierszy, które nie zawierają ogranicznika pól.
@end table

Implementacja @code{cut} wykonana w @code{awk} korzysta z funkcji
bibliotecznej @code{getopt}
(@pxref{Funkcja getopt, ,Przetwarzanie opcji wiersza poleceń}), oraz funkcji
bibliotecznej @code{join}
(@pxref{Funkcja join, ,Scalanie tablicy w łańcuch}).

Program rozpoczyna się od komentarza opisującego opcje i funkcji @code{usage}
(sposób użycia), która wypisuje komunikat o sposobie użycia i kończy pracę
programu.  @code{usage} wywoływana jest gdy podano nieprawidłowe argumenty.

@findex cut.awk
@example
@c @group
@c file eg/prog/cut.awk
# cut.awk --- implementacja cut w awk
# Arnold Robbins, arnold@@gnu.org, Public Domain
# May 1993

# Opcje:
#    -f list        wycina pola (fields)
#    -d c           znak separatora (delimiter) pól
#    -c list        wycina znaki (characters)
#
#    -s        pomija wiersze bez znaku separatora

function usage(    e1, e2)
@{
    e1 = "składnia: cut [-f lista] [-d c] [-s] [pliki...]"
    e2 = "składnia: cut [-c lista] [pliki...]"
    print e1 > "/dev/stderr"
    print e2 > "/dev/stderr"
    exit 1
@}
@c endfile
@c @end group
@end example

@noindent
Zmienne @code{e1} i @code{e2} zastosowano, by funkcja ładnie
mieściła się na
@iftex
stronie.
@end iftex
@ifinfo
ekranie.
@end ifinfo

Następnie mamy regułę @code{BEGIN}, która wykonuje analizę składniową opcji
wiersza poleceń.  Przypisuje @code{FS} pojedynczy znak tabulacji, gdyż taki
jest domyślny separator pól @code{cut}.  Ustalany jest też separator pól
wyjściowych, by był taki sam jak separator pól wejściowych.  Następnie
do przechodzenia przez kolejne opcje wiersza poleceń wykorzystywana jest
@code{getopt}.  Jedna ze zmiennych @code{wg_pol} i @code{wg_znakow} staje
się prawdziwa, wskazując, że przetwarzanie powinno być wykonane, odpowiednio,
według pól lub według znaków.  Przy wycinaniu według znaków, separator pól
wyjściowych staje się łańcuchem pustym.

@example
@c @group
@c file eg/prog/cut.awk
BEGIN    \
@{
    FS = "\t"    # domyślne
    OFS = FS
    while ((c = getopt(ARGC, ARGV, "sf:c:d:")) != -1) @{
        if (c == "f") @{
            by_fields = 1
            fieldlist = Optarg
        @} else if (c == "c") @{
            by_chars = 1
            fieldlist = Optarg
            OFS = ""
@group
        @} else if (c == "d") @{
            if (length(Optarg) > 1) @{
                printf("Korzystam z pierwszego znaku %s" \
                " jako separatora\n", Optarg) > "/dev/stderr"
                Optarg = substr(Optarg, 1, 1)
            @}
            FS = Optarg
            OFS = FS
            if (FS == " ")    # obrona semantyki awk
                FS = "[ ]"
        @} else if (c == "s")
            suppress++
        else
            usage()
    @}
@end group

    for (i = 1; i < Optind; i++)
        ARGV[i] = ""
@c endfile
@c @end group
@end example

Gdy separator pól jest spacją, podejmowane są specjalne środki ostrożności.
Stosowanie @code{@w{" "}} (pojedynczej spacji) jako wartości @code{FS} jest
niepoprawne -- @code{awk} rozdzielałby pola ciągami spacji, tabulacji i/lub
znaków nowej linii, a chcemy, by były oddzielane pojedynczymi spacjami.
Zwróć też uwagę, że po ukończeniu @code{getopt} musimy wyczyścić wszystkie
elementy @code{ARGV}, od jeden do @code{Optind}, by @code{awk} nie próbował
przetwarzać opcji wiersza poleceń jako nazw plików.

Po uporaniu się z opcjami wiersza poleceń, program upewnia się, czy mają one
sens.  Powinna być użyta tylko jedna z opcji @samp{-c} i @samp{-f}, i obie z
nich wymagają listy pól.  Następnie, do rozbioru na części listy pól czy
znaków, wywoływana jest albo @code{set_fieldlist} albo @code{set_charlist}.

@example
@c @group
@c file eg/prog/cut.awk
    if (by_fields && by_chars)
        usage()

    if (by_fields == 0 && by_chars == 0)
        by_fields = 1    # domyślne

    if (fieldlist == "") @{
        print "cut: potrzebna lista dla -c lub -f" > "/dev/stderr"
        exit 1
    @}

@group
    if (by_fields)
        set_fieldlist()
    else
        set_charlist()
@}
@c endfile
@end group
@end example

Oto funkcja @code{set_fieldlist}.  Najpierw łamie na przecinkach listę pól
na części, umieszczając wyniki w tablicy.  Następnie, dla każdego
elementu tablicy, patrzy czy jest on może w rzeczywistości zakresem, a jeśli
tak, to dzieli go na składowe.  Podany zakres jest sprawdzany, by upewnić
się, że pierwsza z liczb jest mniejsza od drugiej.  Każda liczba z listy
dodawana jest do tablicy @code{flist}, będącej po prostu wykazem pól do
wypisania.  Wykorzystywany jest zwykły podział na pola.  Program pozwala,
by @code{awk} sam zajął się rozdzielaniem na pola.

@example
@c @group
@c file eg/prog/cut.awk
function set_fieldlist(        n, m, i, j, k, f, g)
@{
    n = split(fieldlist, f, ",")
    j = 1    # indeks w flist
    for (i = 1; i <= n; i++) @{
        if (index(f[i], "-") != 0) @{ # zakres
            m = split(f[i], g, "-")
            if (m != 2 || g[1] >= g[2]) @{
                printf("błędna lista pól: %s\n",
                                  f[i]) > "/dev/stderr"
                exit 1
            @}
            for (k = g[1]; k <= g[2]; k++)
                flist[j++] = k
        @} else
            flist[j++] = f[i]
    @}
    nfields = j - 1
@}
@c endfile
@c @end group
@end example

Funkcja @code{set_charlist} jest bardziej skomplikowana niż
@code{set_fieldlist}.  Pomysł polega tu na zastosowaniu występującej
w @code{gawk} zmiennej @code{FIELDWIDTHS}
(@pxref{Stały rozmiar, ,Czytanie danych o stałej szerokości}), opisującej
wejście o stałej szerokości.  Gdy używamy listy znaków, jest to dokładnie
to, czego potrzebujemy.

Przygotowanie @code{FIELDWIDTHS} jest bardziej skomplikowane, niż zwykłe
wykazanie pól, jakie powinny być wypisane.  Musimy pamiętać pola,
które będą wypisane oraz wtrącone znaki, które mają być pominięte.
Na przykład, załóżmy, że potrzebujemy znaków od jeden do osiem, 15,
i 22 do 35.  Użylibyśmy wówczas @samp{-c 1-8,15,22-35}.  Potrzebną wartością
@code{FIELDWIDTHS} byłoby @code{@w{"8 6 1 6 14"}}.  Daje nam to pięć pól,
z których powinny zostać wypisane @code{$1}, @code{$3} i @code{$5}.
Wtrącone pola są ``wypełniaczem'' (``filler''), materiałem pomiędzy
pożądanymi danymi.

@code{flist} zawiera listę pól do wypisania, a @code{t} pamięta pełną listę
pól, łącznie z polami wypełniacza.

@example
@c @group
@c file eg/prog/cut.awk
function set_charlist(    field, i, j, f, g, t,
                          filler, last, len)
@{
    field = 1   # zlicza pola razem
    n = split(fieldlist, f, ",")
    j = 1       # indeks w flist
    for (i = 1; i <= n; i++) @{
        if (index(f[i], "-") != 0) @{ # zakres
            m = split(f[i], g, "-")
            if (m != 2 || g[1] >= g[2]) @{
                printf("błędna lista znaków: %s\n",
                               f[i]) > "/dev/stderr"
                exit 1
            @}
            len = g[2] - g[1] + 1
            if (g[1] > 1)  # oblicza długość filler
                filler = g[1] - last - 1
            else
                filler = 0
            if (filler)
                t[field++] = filler
            t[field++] = len  # długość pola
            last = g[2]
            flist[j++] = field - 1
        @} else @{
            if (f[i] > 1)
                filler = f[i] - last - 1
            else
                filler = 0
            if (filler)
                t[field++] = filler
            t[field++] = 1
            last = f[i]
            flist[j++] = field - 1
        @}
    @}
@group
    FIELDWIDTHS = join(t, 1, field - 1)
    nfields = j - 1
@}
@end group
@c endfile
@end example

Oto reguła, która faktycznie przetwarza dane.  Jeżeli podano opcję
@samp{-s}, to @code{suppress} będzie prawdziwe.  Pierwsza instrukcja
@code{if} zapewnia, że rekord wejściowy nie zawiera separatora pól.
Jeśli @code{cut} w danym przebiegu przetwarza pola, @code{suppress} jest
prawdziwe, a w rekordzie nie ma znaku separatora rekordów, to rekord ten
jest pomijany.

Jeżeli rekord jest poprawny, to w tym miejscu @code{gawk} rozdzielił już
dane na pola, albo za pomocą znaku w @code{FS}, albo używając pól o stałej
długości i @code{FIELDWIDTHS}.  Występująca tu pętla przechodzi przez
listę pól, jakie mają być wypisane.  Jeśli odpowiednie pole zawiera dane,
to jest wypisywane.  Jeżeli następne pole także zawiera dane, to pomiędzy
tymi polami wypisywany jest znak separatora.

@c 2e: Could use `index($0, FS) != 0' instead of `$0 !~ FS', below

@example
@c @group
@c file eg/prog/cut.awk
@{
    if (by_fields && suppress && $0 !~ FS)
        next

    for (i = 1; i <= nfields; i++) @{
        if ($flist[i] != "") @{
            printf "%s", $flist[i]
            if (i < nfields && $flist[i+1] != "")
                printf "%s", OFS
        @}
    @}
    print ""
@}
@c endfile
@c @end group
@end example

Ta wersja @code{cut} w wykonywaniu wycinania według znaków opiera się na
używanej w @code{gawk} zmiennej @code{FIELDWIDTHS}.  Mimo, iż
w innych implementacjach @code{awk} byłoby możliwe skorzystanie
z @code{substr}
(@pxref{Funkcje łańcuchowe, ,Funkcje wbudowane działające na łańcuchach}),
metoda taka byłaby równocześnie niezwykle bolesna.  Zmienna
@code{FIELDWIDTHS} zapewnia eleganckie rozwiązanie problemu podziału wiersza
wejściowego na poszczególne znaki.

@node Program egrep, Program id, Program cut, Klony
@subsection Wyszukiwanie wyrażeń regularnych w plikach

@cindex @code{egrep}, narzędzie
@cindex narzędzie @code{egrep}
Narzędzie @code{egrep} szuka wzorców w plikach.  Korzysta z wyrażeń
regularnych, które są prawie identyczne, jak dostępne w @code{awk}
(@pxref{Stałe regexp, ,Stałe regexp}).  Używane jest w ten sposób:

@example
egrep @r{[} @var{opcje} @r{]} '@var{wzorzec}' @var{pliki} @dots{}
@end example

@var{wzorzec} jest wyrażeniem regularnym.
W typowym zastosowaniu, wyrażenie regularne jest cytowane, by zapobiec
rozwijaniu przez powłokę znaków specjalnych jako masek nazw plików.
Normalnie, @code{egrep} wypisuje pasujące wiersze.  Jeśli w wierszu poleceń
podano kilka nazw plików, to każdy wiersz wyjściowy poprzedzony jest nazwą
pliku i dwukropkiem.

Opcjami są:

@table @code
@item -c
Zamiast pasujących do wzorca wierszy wypisuje tylko ich ilość.

@item -s
Tryb cichy.  Nie jest tworzone żadne wyjście, a kod zakończenia wskazuje
czy dopasowano wzorzec, czy też nie.

@item -v
Odwraca znaczenie testu.  @code{egrep} wypisuje wiersze, które @emph{nie}
pasują do wzorca, i kończy pomyślnie pracę jeśli nie dopasowano wzorca.

@item -i
Nie rozróżnia wielkości liter zarówno we wzorcu, jak i w danych wejściowych.

@item -l
Wypisuje tylko nazwy plików, w których znaleziono dopasowania, a nie
pasujące wiersze.

@item -e @var{wzorzec}
Używa @var{wzorca} jako wyrażenia regularnego do dopasowania.
Celem opcji @samp{-e} jest umożliwienie podania wzorca zaczynającego
się od @samp{-}.
@end table

Nasza wersja wykorzystuje funkcję biblioteczną @code{getopt}
(@pxref{Funkcja getopt, ,Przetwarzanie opcji wiersza poleceń}) i program
biblioteczny do obsługi przejścia między plikami
(@pxref{Funkcja filetrans, ,Obsługa przejść między plikami}).

Program zaczyna się od komentarza opisowego, a następnie reguły @code{BEGIN},
przetwarzającej za pomocą @code{getopt} argumenty wiersza poleceń.  Opcja
@samp{-i} (ignoruj wielkość liter) jest szczególnie łatwa w @code{gawk};
wykorzystujemy po prostu zmienną wbudowaną @code{IGNORECASE}
(@pxref{Zmienne wbudowane}).

@findex egrep.awk
@example
@c @group
@c file eg/prog/egrep.awk
# egrep.awk --- symulacja egrep w awk
# Arnold Robbins, arnold@@gnu.org, Public Domain
# May 1993

# Opcje:
#    -c    zlicza (count) wiersze
#    -s    cicho (silent): używa kodu zakończenia
#    -v    odwraca (invert) test:
#            powodzenie, gdy nie pasuje
#    -i    ignoruje wielkość liter
#    -l    wypisuje (list) tylko nazwy plików
#    -e    argument jest wzorcem

BEGIN @{
    while ((c = getopt(ARGC, ARGV, "ce:svil")) != -1) @{
        if (c == "c")
            count_only++
        else if (c == "s")
            no_print++
        else if (c == "v")
            invert++
        else if (c == "i")
            IGNORECASE = 1
        else if (c == "l")
            filenames_only++
        else if (c == "e")
            pattern = Optarg
        else
            usage()
    @}
@c endfile
@c @end group
@end example

Dalej mamy kod, który obsługuje charakterystyczne zachowanie @code{egrep}.
Jeżeli nie podano wzorca za pomocą @samp{-e}, to jako wzorzec wykorzystywany
jest pierwszy nie będący opcją argument wiersza poleceń.  Argumenty wiersza
poleceń @code{awk} aż do @code{ARGV[Optind]} są czyszczone, by @code{awk}
nie usiłował przetworzyć ich jako pliki.  Jeżeli nie podano żadnych plików,
to używane jest standardowe wejście, a jeśli podano kilka, to odnotowujemy
to, by później w wydruku poprzedzić dopasowane wiersze nazwami plików.

Ostatnie dwa wiersze są zakomentowane, gdyż nie są potrzebne w @code{gawk}.
Powinny zostać odkomentowane jeśli będziemy musieli korzystać z innej wersji
@code{awk}.

@example
@c @group
@c file eg/prog/egrep.awk
    if (pattern == "")
        pattern = ARGV[Optind++]

    for (i = 1; i < Optind; i++)
        ARGV[i] = ""
    if (Optind >= ARGC) @{
        ARGV[1] = "-"
        ARGC = 2
    @} else if (ARGC - Optind > 1)
        do_filenames++

#    if (IGNORECASE)
#        pattern = tolower(pattern)
@}
@c endfile
@c @end group
@end example

Kolejna grupa wierszy również powinna być odkomentowana jeśli nie
korzystasz z @code{gawk}.  Reguła ta, jeśli podano opcję @samp{-i}, zamienia
wszystkie litery wiersza wejściowego na małe.  Jest ona zakomentowana gdyż
nie jest konieczna w @code{gawk}.
@c bug: if a match happens, we output the translated line, not the original

@example
@c @group
@c file eg/prog/egrep.awk
#@{
#    if (IGNORECASE)
#        $0 = tolower($0)
#@}
@c endfile
@c @end group
@end example

Funkcja @code{beginfile} wywoływana jest przez regułę z @file{ftrans.awk}
za każdym razem, gdy rozpoczyna się przetwarzanie nowego pliku.  W tym
przypadku jest ona bardzo prosta: wykonuje tylko inicjowanie zmiennej
@code{fcount} zerem.  @code{fcount} pamięta, ile wierszy bieżącego pliku
pasowało do wzorca.

@example
@group
@c file eg/prog/egrep.awk
function beginfile(smiec)
@{
    fcount = 0
@}
@c endfile
@end group
@end example

Funkcja @code{endfile} wywoływana jest po przetworzeniu każdego pliku.
Stosowana jest tylko wtedy, gdy użytkownik chce przeliczyć pasujące wiersze.
@code{no_print} będzie prawdziwa tylko jeśli wymagany jest kod zakończenia.
@code{count_only} będzie prawdziwe jeśli wymagane są liczby wierszy.
Zgodnie z tym, @code{egrep} będzie wypisywał liczby wierszy tylko jeśli
włączone są wypisywanie i zliczanie.  Format wyjściowy musi być dostosowany
do liczby plików, jakie będą przetwarzane.  Na koniec, @code{fcount} jest
dodawane do @code{total}, byśmy wiedzieli, ile ogółem wierszy pasowało do
wzorca.

@example
@group
@c file eg/prog/egrep.awk
function endfile(file)
@{
    if (! no_print && count_only)
        if (do_filenames)
            print file ":" fcount
        else
            print fcount

    total += fcount
@}
@c endfile
@end group
@end example

Poniższa reguła wykonuje większość pracy związanej z dopasowywaniem wierszy.
Zmienna @code{matches} będzie prawdziwa jeśli wiersz pasuje do wzorca.
Jeżeli użytkownik chce wierszy, które nie pasują, znaczenie @code{matches}
jest odwracane za pomocą operatora @samp{!}.  @code{fcount} zwiększane jest
o wartość @code{matches}, która będzie albo jedynką albo zerem, zależnie od
tego czy dopasowanie było pomyślne czy nie.  Jeżeli wiersz nie pasuje, to
instrukcja @code{next} po prostu przechodzi do następnego.

W poniższych kilku wierszach kodu występuje parę optymalizacji.  Jeżeli
użytkownik chce tylko kodu zakończenia (@code{no_print} jest prawdziwe),
i nie musimy zliczać wierszy, to wystarczy wiedzieć, że pasuje jeden wiersz
danego pliku, i możemy przeskoczyć do następnego pliku za pomocą
@code{nextfile}.  Dalej, w podobnych wierszach, jeśli wypisujemy tylko nazwy
plików, a nie musimy zliczać wierszy, to możemy wypisać nazwę pliku,
a następnie dzięki @code{nextfile} przejść do następnego pliku.

Wreszcie, wypisywany jest każdy wiersz, z poprzedzającą go nazwą
pliku i dwukropkiem, jeśli to konieczne.

@ignore
2e: note, probably better to recode the last few lines as
    if (! count_only) @{
        if (no_print)
            nextfile

        if (filenames_only) @{
            print FILENAME
            nextfile
        @}

        if (do_filenames)
            print FILENAME ":" $0
        else
            print
    @}
@end ignore

@example
@c @group
@c file eg/prog/egrep.awk
@{
    matches = ($0 ~ pattern)
    if (invert)
        matches = ! matches

    fcount += matches    # 1 lub 0

    if (! matches)
        next

    if (no_print && ! count_only)
        nextfile

    if (filenames_only && ! count_only) @{
        print FILENAME
        nextfile
    @}

    if (do_filenames && ! count_only)
        print FILENAME ":" $0
@group
    else if (! count_only)
        print
@end group
@}
@c endfile
@c @end group
@end example

@c @strong{Exercise}: rearrange the code inside @samp{if (! count_only)}.

Reguła @code{END} czuwa nad utworzeniem poprawnego kodu zakończenia.
Jeżeli nie było żadnych dopasowań, kod zakończenia wynosi jeden,
w przeciwnym razie -- zero.

@example
@c @group
@c file eg/prog/egrep.awk
END    \
@{
    if (total == 0)
        exit 1
    exit 0
@}
@c endfile
@c @end group
@end example

W przypadku wystąpienia niepoprawnych opcji funkcja @code{usage} wypisuje
komunikat o sposobie wywoływania i kończy pracę programu.

@example
@c @group
@c file eg/prog/egrep.awk
function usage(    e)
@{
    e = "Składnia: egrep [-csvil] [-e wzorzec] [pliki ...]"
    print e > "/dev/stderr"
    exit 1
@}
@c endfile
@c @end group
@end example

Zmienną @code{e} zastosowano by funkcja ładnie mieściła się na drukowanej
stronie.

@cindex kontynuacja odwrotnym ukośnikiem
Mała uwaga o stylu programowania.  Spostrzegłeś być może, że reguła
@code{END} wykorzystuje kontynuację odwrotnym ukośnikiem, z samotnym
nawiasem otwierającym w wierszu.  Zrobiono to tak, by bardziej przypominało
sposób, w jaki zapisywane są funkcje.  Wiele naszych przykładów
@iftex
umieszczonych w tym rozdziale
@end iftex
stosuje ten styl.  Sam zdecyduj, czy podoba ci się taki sposób zapisywania
własnych reguł @code{BEGIN} i @code{END}, czy nie.

@node Program id, Program split, Program egrep, Klony
@subsection Wypisywanie informacji o użytkowniku

@cindex @code{id}, narzędzie
@cindex narzędzie @code{id}
Narzędzie @code{id} wypisuje dla danego użytkownika rzeczywisty
i efektywny identyfikator użytkownika, rzeczywisty i efektywny
identyfikator grupy, i zbiór grup użytkownika, jeśli są takie.
@code{id} wypisze efektywny identyfikator użytkownika i efektywny
identyfikator grupy tylko wtedy jeśli są one różne od rzeczywistych.
Jeśli to możliwe, poda także odpowiednie nazwy użytkowników i grup.
Wynik może wyglądać tak:

@example
$ id
@print{} uid=2076(arnold) gid=10(staff) groups=10(staff),4(tty)
@end example

Dane te są dokładnie takie same, jak te, które zapewnia występujący
w @code{gawk} plik specjalny @file{/dev/user}
(@pxref{Pliki specjalne, ,Specjalne nazwy plików w @code{gawk}}).
Narzędzie @code{id} daje jednak przyjemniejsze wyjście niż sam tylko łańcuch
liczb.

Oto prosta wersja @code{id} napisana w @code{awk}.
Korzysta z funkcji bibliotecznych obsługujących bazę użytkowników
(@pxref{Funkcje passwd, ,Czytanie bazy użytkowników}),
oraz z funkcji bibliotecznych do obsługi bazy grup
(@pxref{Funkcje group, ,Czytanie bazy grup}).

Program jest całkiem prosty.  Cała robota wykonywana jest
w regule @code{BEGIN}.  Numery identyfikatorów użytkownika i grupy
uzyskiwane są z @file{/dev/user}.  Jeżeli nie ma obsługi @file{/dev/user},
program poddaje się.

Kod powtarza się.  Pozycja w bazie użytkowników dotycząca rzeczywistego
identyfikatora użytkownika dzielona jest na dwukropkach @samp{:} na
części składowe.  Nazwa jest pierwszym polem.  Podobny kod wykorzystywany
jest dla efektywnego identyfikatora użytkownika i identyfikatorów grupy.

@findex id.awk
@example
@c @group
@c file eg/prog/id.awk
# id.awk --- implementacja id w awk
# Arnold Robbins, arnold@@gnu.org, Public Domain
# May 1993

# wyjściem jest:
# uid=12(foo) euid=34(bar) gid=3(baz) \
#             egid=5(blat) groups=9(nine),2(two),1(one)

BEGIN    \
@{
    if ((getline < "/dev/user") < 0) @{
        err = "id: brak obsługi /dev/user - nie mogę działać"
        print err > "/dev/stderr"
        exit 1
    @}
    close("/dev/user")

    uid = $1
    euid = $2
    gid = $3
    egid = $4

    printf("uid=%d", uid)
    pw = getpwuid(uid)
@group
    if (pw != "") @{
        split(pw, a, ":")
        printf("(%s)", a[1])
    @}
@end group

    if (euid != uid) @{
        printf(" euid=%d", euid)
        pw = getpwuid(euid)
        if (pw != "") @{
            split(pw, a, ":")
            printf("(%s)", a[1])
        @}
    @}

    printf(" gid=%d", gid)
    pw = getgrgid(gid)
    if (pw != "") @{
        split(pw, a, ":")
        printf("(%s)", a[1])
    @}

    if (egid != gid) @{
        printf(" egid=%d", egid)
        pw = getgrgid(egid)
        if (pw != "") @{
            split(pw, a, ":")
            printf("(%s)", a[1])
        @}
    @}

    if (NF > 4) @{
        printf(" groups=");
        for (i = 5; i <= NF; i++) @{
            printf("%d", $i)
            pw = getgrgid($i)
            if (pw != "") @{
                split(pw, a, ":")
                printf("(%s)", a[1])
            @}
@group
            if (i < NF)
                printf(",")
@end group
        @}
    @}
    print ""
@}
@c endfile
@c @end group
@end example

@c exercise!!!
@ignore
The POSIX version of @code{id} takes arguments that control which
information is printed.  Modify this version to accept the same
arguments and perform in the same way.
@end ignore

@node Program split, Program tee, Program id, Klony
@subsection Podział dużego pliku na części

@cindex @code{split}, narzędzie
@cindex narzędzie @code{split}
Program @code{split} dzieli duże pliki tekstowe na mniejsze kawałki.
Domyślnie pliki wyjściowe nazywane są @file{xaa}, @file{xab}, i tak dalej.
Każdy z nich zawiera 1000 wierszy, z wyjątkiem, na ogół, ostatniego pliku.
Ilość wierszy w każdym pliku zmieniamy podając w wierszu poleceń liczbę
poprzedzoną znakiem minus, np. @samp{-500} dla plików o 500 wierszach
zamiast 1000.  Chcąc zmienić nazwę plików wyjściowych na coś w rodzaju
@file{mojplikaa}, @file{mojplikab}, i tak dalej, podajemy dodatkowy argument
określający zadaną nazwę.

Oto wersja @code{split} wykonana w @code{awk}. Wykorzystuje ona funkcje
@code{ord} i @code{chr} przedstawione
w @ref{Funkcje porządku, ,Konwersja między znakami a liczbami}.

Program ustala najpierw wartości domyślne, a następnie sprawdza, czy nie ma
zbyt wielu argumentów.  Następnie po kolei przygląda się każdemu
argumentowi.  Pierwszy może być minusem, po którym występuje liczba.  Jeśli
tak jest, to wygląda on jak liczba ujemna, więc robimy z niej dodatnią i to
jest liczba wierszy.  Nazwa pliku danych jest pomijana, a ostatni argument
jest wykorzystywany jako przedrostek nazw plików wynikowych.

@findex split.awk
@example
@c @group
@c file eg/prog/split.awk
# split.awk --- robi split w awk
# Arnold Robbins, arnold@@gnu.org, Public Domain
# May 1993

# składnia: split [-num] [plik] [nazwawyj]

BEGIN @{
    outfile = "x"    # domyślne
    count = 1000
    if (ARGC > 4)
        usage()

    i = 1
    if (ARGV[i] ~ /^-[0-9]+$/) @{
        count = -ARGV[i]
        ARGV[i] = ""
        i++
    @}
    # sprawdźmy argv na wypadek czytania z stdin zamiast z pliku
    if (i in ARGV)
        i++    # pomiń nazwę pliku danych
    if (i in ARGV) @{
        outfile = ARGV[i]
        ARGV[i] = ""
    @}

    s1 = s2 = "a"
    out = (outfile s1 s2)
@}
@c endfile
@c @end group
@end example

Następna reguła wykonuje większość pracy. @code{tcount} (temporary count -
licznik tymczasowy) zapamiętuje, ile wierszy do tej pory wypisano do pliku
wynikowego.  Jeśli jest większa niż @code{count}, to pora zamknąć bieżący
plik i rozpocząć nowy.  @code{s1} i @code{s2} pamiętają aktualne przyrostki
nazwy pliku.  Jeżeli oba mają wartość @samp{z}, to plik danych jest
po prostu zbyt duży.  W przeciwnym razie, @code{s1} zmiania się na następną
na literę alfabetu a @code{s2} zaczyna znów od @samp{a}.

@example
@c @group
@c file eg/prog/split.awk
@{
    if (++tcount > count) @{
        close(out)
        if (s2 == "z") @{
            if (s1 == "z") @{
                printf("split: %s jest za duży do podziału\n", \
                       FILENAME) > "/dev/stderr"
                exit 1
            @}
            s1 = chr(ord(s1) + 1)
            s2 = "a"
        @} else
            s2 = chr(ord(s2) + 1)
        out = (outfile s1 s2)
        tcount = 1
    @}
    print > out
@}
@c endfile
@c @end group
@end example

Funkcja @code{usage} po prostu wypisuje komunikat o błędzie i kończy pracę
programu.

@example
@c @group
@c file eg/prog/split.awk
function usage(   e)
@{
    e = "składnia: split [-num] [plik] [nazwawyj]"
    print e > "/dev/stderr"
    exit 1
@}
@c endfile
@c @end group
@end example

@noindent
Zmienną @code{e} zastosowano by funkcja ładnie mieściła się na
@iftex
stronie.
@end iftex
@ifinfo
ekranie.
@end ifinfo

Program jest troszkę niechlujny; zdaje się na @code{awk}, by zamknął
za niego automatycznie ostatni plik, zamiast samemu zrobić to
w regule @code{END}.

@node Program tee, Program uniq, Program split, Klony
@subsection Duplikowanie wyjścia do wielu plików

@cindex @code{tee}, narzędzie
@cindex narzędzie @code{tee}
Program @code{tee} znany jest jako ``pipe fitting''.@footnote{od tłum.@:
armatura instalacji; ang.pipe, potok, znaczy dosłownie ``przewód
rurowy''. ``Tee'' (ti:) to po prostu ``litera Te'', trójnik, T-kształtka.}
@code{tee} kopiuje swoje standardowe wejście na standardowe
wyjście, a równocześnie powiela je do plików wymienionych w wierszu poleceń.
Ma taką składnię:

@example
tee @r{[}-a@r{]} plik @dots{}
@end example

Opcja @samp{-a} mówi @code{tee}, by wykonywał dopisywanie do wskazanych
plików, zamiast obcinać je i zaczynać od nowa.

Reguła @code{BEGIN} najpierw w tablicy o nazwie @code{copy} tworzy kopię
wszystkich argumentów wiersza poleceń.  @code{ARGV[0]} nie jest kopiowane,
gdyż nie jest potrzebne.  @code{tee} nie może korzystać bezpośrednio
z @code{ARGV}, ponieważ @code{awk} będzie usiłował każdy plik wymieniony
w @code{ARGV} przetworzyć jako dane wejściowe.

Jeżeli pierwszym argumentem jest @samp{-a}, to zmienna znacznikowa
@code{append} otrzymuje wartość prawdziwą, i usuwane są @code{ARGV[1]}
i @code{copy[1]}.  Jeżeli @code{ARGC} jest mniejsze niż dwa, to nie podano
nazw plików, i @code{tee} wypisuje  komunikat o sposobie użycia i kończy
pracę.  Na koniec, dzięki nadaniu @code{ARGV[1]} wartości @code{"-"},
a @code{ARGC} wartości dwa, na @code{awk} wymuszany jest odczyt standardowego
wyjścia.

@c 2e: the `ARGC--' in the `if (ARGV[1] == "-a")' isn't needed.

@findex tee.awk
@example
@group
@c file eg/prog/tee.awk
# tee.awk --- tee w awk
# Arnold Robbins, arnold@@gnu.org, Public Domain
# May 1993
# Revised December 1995
@end group

@group
BEGIN    \
@{
    for (i = 1; i < ARGC; i++)
        copy[i] = ARGV[i]
@end group

@group
    if (ARGV[1] == "-a") @{
        append = 1
        delete ARGV[1]
        delete copy[1]
        ARGC--
    @}
@end group
@group
    if (ARGC < 2) @{
        print "składnia: tee [-a] plik ..." > "/dev/stderr"
        exit 1
    @}
@end group
@group
    ARGV[1] = "-"
    ARGC = 2
@}
@c endfile
@end group
@end example

Pojedyncza reguła wykonuje całą pracę.  Ponieważ nie ma tu wzorca,
wykonywana jest dla każdego wiersza wejścia.  Ciało reguły po prostu
wypisuje dany wiersz do każdego pliku z wiersza poleceń, a następnie
na standardowe wyjście.

@example
@group
@c file eg/prog/tee.awk
@{
    # przesunięcie if poza pętlę przyspiesza ją
    if (append)
        for (i in copy)
            print >> copy[i]
    else
        for (i in copy)
            print > copy[i]
    print
@}
@c endfile
@end group
@end example

Można by było zakodować pętlę w ten sposób:

@example
for (i in copy)
    if (append)
        print >> copy[i]
    else
        print > copy[i]
@end example

@noindent
jest to bardziej zwięzłe, ale równocześnie mniej efektywne. Warunek @samp{if}
jest sprawdzany dla każdego rekordu i każdego pliku wyjściowego.  Dzięki
powieleniu ciała pętli, @samp{if} sprawdzany jest tylko raz dla każdego
rekordu wejściowego.  Jeżeli mamy @var{N} rekordów wejściowych i @var{M}
plików wejściowych, to pierwsza metoda wykonuje @var{N} instrukcji
@samp{if}, podczas gdy druga wykonałaby @var{N}@code{*}@var{M} instrukcji
@samp{if}.

Na koniec, reguła @code{END} robi porządki, zamykając wszystkie pliki
wyjściowe.

@example
@c @group
@c file eg/prog/tee.awk
END    \
@{
    for (i in copy)
        close(copy[i])
@}
@c endfile
@c @end group
@end example

@node Program uniq, Program wc, Program tee, Klony
@subsection Wypisywanie nie powtarzających się wierszy tekstu

@cindex @code{uniq}, narzędzie
@cindex narzędzie @code{uniq}
Narzędzie @code{uniq} czyta posortowane wiersze danych ze swego
standardowego wejścia, i (domyślnie) usuwa dublujące się wiersze.
Inaczej mówiąc, wypisywane są tylko niepowtarzalne, unikatowe wiersze,
stąd nazwa.  @code{uniq} ma kilka opcji.  Wywoływany jest tak:

@example
uniq @r{[}-udc @r{[}-@var{n}@r{]]} @r{[}+@var{n}@r{]} @r{[} @var{plik wejściowy} @r{[} @var{plik wyjściowy} @r{]]}

@end example

Opcje te oznaczają:

@table @code
@item -d
Wypisuje tylko wiersze powtarzające się.

@item -u
Wypisuje tylko wiersze nie powtarzające się.

@item -c
Zlicza wiersze.  Opcja ta przesłania @samp{-d} i @samp{-u}.  Zliczane są
zarówno wiersze powtarzające się, jak i nie powtarzające się.

@item -@var{n}
Przed porównaniem wierszy pomija @var{n} pól.  Definicja pól jest podobna do
domyślnej @code{awk}: nie-białe znaki oddzielone ciągami spacji i/lub
tabulacji.

@item +@var{n}
Przed porównaniem wierszy pomija @var{n} znaków.  Wcześniej pomijane są
ewentualne pola określone za pomocą @samp{-@var{n}}.

@item @var{plik wejściowy}
Dane czytane są z pliku wejściowego wymienionego w wierszu poleceń, a nie
ze standardowego wejścia.

@item @var{plik wyjściowy}
Tworzone wyjście wysyłane jest do wskazanego pliku wyjściowego, zamiast na
standardowe wyjście.
@end table

Normalnie @code{uniq} zachowuje się tak, jakby podano równocześnie opcje
@samp{-d} i @samp{-u}.

Oto realizacja @code{uniq} w @code{awk}.  Wykorzystuje funkcje biblioteczne
@code{getopt} (@pxref{Funkcja getopt, ,Przetwarzanie opcji wiersza poleceń}),
i @code{join} (@pxref{Funkcja join, ,Scalanie tablicy w łańcuch}).

Program zaczyna się od funkcji @code{usage} a następnie komentarza
zawierającego krótki zarys opcji i ich znaczenia.

Reguła @code{BEGIN} zajmuje się argumentami i opcjami wiersza poleceń.
Korzysta z pewnej sztuczki, by uzyskać od @code{getopt} obsługę opcji
postaci @samp{-25}.  Traktuje mianowicie taką opcję jako literę opcji
@samp{2} z argumentem @samp{5}.  Jeżeli faktycznie podano dwie lub więcej
cyfr (@code{Optarg} wygląda jak liczba), to @code{Optarg} jest sklejane
z cyfrą opcji, a następnie do wyniku jest dodawane zero, by zrobić z niego
liczbę.  Jeśli opcja składa się tylko z jednej cyfry, to @code{Optarg} nie
jest potrzebne, a @code{Optind} musi zostać zmniejszone, by @code{getopt}
przetworzyła je następnym razem. Ten kod jest niewątpliwie nieco zawiły.

Jeżeli nie podano opcji, to brane są domyślne, wypisywanie zarówno
powtarzających się jak i unikatowych wierszy.  Plik wyjściowy, jeśli go
podano, jest przypisywany do @code{outputfile}.  Wcześniej @code{outputfile}
było inicjowane jako standardowe wyjście, @file{/dev/stdout}.

@findex uniq.awk
@example
@c file eg/prog/uniq.awk
# uniq.awk --- robi uniq w awk
# Arnold Robbins, arnold@@gnu.org, Public Domain
# May 1993

@group
function usage(    e)
@{
    e = "składnia: uniq [-udc [-n]] [+n] [ wej [ wyj ]]"
    print e > "/dev/stderr"
    exit 1
@}
@end group

# -c    zlicza (count) wiersze. przesłania -d i -u
# -d    tylko zdublowane wiersze
# -u    tylko unikatowe wiersze
# -n    pomija n pól
# +n    pomija n znaków, najpierw pomija pola

BEGIN   \
@{
    count = 1
    outputfile = "/dev/stdout"
    opts = "udc0:1:2:3:4:5:6:7:8:9:"
    while ((c = getopt(ARGC, ARGV, opts)) != -1) @{
        if (c == "u")
            non_repeated_only++
        else if (c == "d")
            repeated_only++
        else if (c == "c")
            do_count++
        else if (index("0123456789", c) != 0) @{
            # getopt wymaga argumentów opcji, co
            # gmatwa sprawę dla rzeczy typu -5
            if (Optarg ~ /^[0-9]+$/)
                fcount = (c Optarg) + 0
@group
            else @{
                fcount = c + 0
                Optind--
            @}
@end group
        @} else
            usage()
    @}

    if (ARGV[Optind] ~ /^\+[0-9]+$/) @{
        charcount = substr(ARGV[Optind], 2) + 0
        Optind++
    @}

    for (i = 1; i < Optind; i++)
        ARGV[i] = ""

    if (repeated_only == 0 && non_repeated_only == 0)
        repeated_only = non_repeated_only = 1

    if (ARGC - Optind == 2) @{
        outputfile = ARGV[ARGC - 1]
        ARGV[ARGC - 1] = ""
    @}
@}
@c endfile
@end example

Poniższa funkcja, @code{are_equal}, porównuje bieżący wiersz, @code{$0},
z poprzednim, @code{last}.  Obsługuje pomijanie pól i znaków.

Jeżeli nie podano ani liczby pól ani znaków, @code{are_equal} zwraca po
prostu jeden lub zero, w zależności od wyniku zwykłego porównania łańcuchów
@code{last} i @code{$0}.  W przeciwnym przypadku, sprawy się komplikują.

Jeżeli mają zostać pominięte pola, to każdy wiersz rozbijany jest w tablicę
za pomocą @code{split}
(@pxref{Funkcje łańcuchowe, ,Funkcje wbudowane działające na łańcuchach}),
a następnie żądane pola za pomocą @code{join} są ponownie łączone w wiersz.
Złączone wiersze przechowywane są w @code{clast} i @code{cline}.
Jeżeli nie pomija się pól, to @code{clast} i @code{cline} otrzymują
wartości, odpowiednio, @code{last} i @code{$0}.

Wreszcie, jeżeli pomijane są znaki, to do usunięcia początkowych
@code{charcount} znaków z @code{clast} i @code{cline} wykorzystywana jest
funkcja @code{substr}.  Oba łańcuchy są następnie porównywane,
a @code{are_equal} zwraca wynik porównania.

@example
@c @group
@c file eg/prog/uniq.awk
function are_equal(    n, m, clast, cline, alast, aline)
@{
    if (fcount == 0 && charcount == 0)
        return (last == $0)

    if (fcount > 0) @{
        n = split(last, alast)
        m = split($0, aline)
        clast = join(alast, fcount+1, n)
        cline = join(aline, fcount+1, m)
    @} else @{
        clast = last
        cline = $0
    @}
    if (charcount) @{
        clast = substr(clast, charcount + 1)
        cline = substr(cline, charcount + 1)
    @}

    return (clast == cline)
@}
@c endfile
@c @end group
@end example

Poniższe dwie reguły stanowią ciało programu.  Pierwsza z nich jest
wykonywana wyłącznie dla pierwszego wiersza danych. Nadaje @code{last}
wartość @code{$0}, by kolejne wierszy tekstu mogły być z czymś porównane.

Druga reguła realizuje nasze zadanie.  Zmienna @code{equal} będzie jedynką
lub zerem w zależności od wyniku porównania wykonanego przez @code{are_equal}.
Jeżeli @code{uniq} zlicza powtarzające się wiersze, to jeśli wiersze są
równe zwiększana jest zmienna @code{count}.  W przeciwnym razie wypisuje się
wiersz, a zmienna jest sprowadzana do stanu początkowego, gdyż dane dwa
wiersze nie są równe.

Jeżeli @code{uniq} nie zlicza, to @code{count} zwiększane jest jeśli
wiersze są równe.  W przeciwnym razie, jeśli @code{uniq} zlicza powtarzające
się wiersze, a spostrzeżono więcej niż jeden wiersz taki jak bieżący, lub
też jeśli @code{uniq} zlicza unikatowe wiersze, a zauważono tylko jeden
wiersz, to wiersz ten jest wypisywany, a @code{count} jest zerowane.

Na koniec, podobne rozwiązanie użyte jest w regule @code{END} do wypisania
ostatniego wiersza danych wejściowych.

@example
@c @group
@c file eg/prog/uniq.awk
@group
NR == 1 @{
    last = $0
    next
@}
@end group

@{
    equal = are_equal()

    if (do_count) @{    # przesłania -d i -u
        if (equal)
            count++
        else @{
            printf("%4d %s\n", count, last) > outputfile
            last = $0
            count = 1    # stan wyjściowy
        @}
        next
    @}

    if (equal)
        count++
    else @{
        if ((repeated_only && count > 1) ||
            (non_repeated_only && count == 1))
                print last > outputfile
        last = $0
        count = 1
    @}
@}

@group
END @{
    if (do_count)
        printf("%4d %s\n", count, last) > outputfile
    else if ((repeated_only && count > 1) ||
            (non_repeated_only && count == 1))
        print last > outputfile
@}
@end group
@c endfile
@c @end group
@end example

@node Program wc,  , Program uniq, Klony
@subsection Zliczanie rzeczy

@cindex @code{wc}, narzędzie
@cindex narzędzie @code{wc}
Narzędzie @code{wc} (word count - zliczanie wyrazów) zlicza wiersze,
wyrazy i znaki z jednego lub więcej plików wejściowych.  Ma taką składnię:

@example
wc @r{[}-lwc@r{]} @r{[} @var{pliki} @dots{} @r{]}
@end example

Jeżeli w wierszu poleceń nie podano plików, @code{wc} czyta swoje
standardowe wejście.  Jeśli jest więcej plików, to wypisze także
całkowite ilości dla wszystkich plików.  Ma następujące opcje:

@table @code
@item -l
Zlicza tylko wiersze.

@item -w
Zlicza tylko wyrazy.
``Wyraz'' jest nieprzerwanym ciągiem nie-białych znaków, oddzielonym
spacjami i/lub tabulacjami.  Tak się dobrze składa, że w @code{awk} jest to
normalna metoda rozdzielania pól w danych wejściowych.

@item -c
Zlicza tylko znaki.
@end table

Realizacja @code{wc} w @code{awk} jest szczególnie elegancka, gdyż @code{awk}
wykonuje za nas mnóstwo pracy: dzieli wiersze na wyrazy (tj.@: pola) i zlicza
je, zlicza wiersze (tj.@: rekordy), i łatwo możemy się od niego dowiedzieć,
jak długi jest wiersz.

Ta wersja korzysta z funkcji bibliotecznej @code{getopt}
(@pxref{Funkcja getopt, ,Przetwarzanie opcji wiersza poleceń}) oraz
funkcji obsługi przejść między plikami
(@pxref{Funkcja filetrans, ,Obsługa przejść między plikami}).

Wykazuje ona zasadniczą różnicę w stosunku do tradycyjnych wersji @code{wc}.
Nasza wersja zawsze wypisuje uzyskane liczby w kolejności: wiersze, wyrazy
i znaki.  Wersje tradycyjne zwracają uwagę na kolejność występowania opcji
@samp{-l}, @samp{-w} i @samp{-c} w wierszu poleceń, i wypisują liczby w tej
kolejności.

Reguła @code{BEGIN} wykonuje przetwarzanie argumentów.
Zmienna @code{print_total} będzie prawdziwa jeśli w wierszu poleceń
wymieniono więcej niż jeden plik.

@findex wc.awk
@example
@c @group
@c file eg/prog/wc.awk
# wc.awk --- zlicza wiersze, wyrazy, znaki
# Arnold Robbins, arnold@@gnu.org, Public Domain
# May 1993

# Options:
#    -l    zlicza tylko wiersze
#    -w    zlicza tylko wyrazy
#    -c    zlicza tylko znaki
#
# domyślnie zliczane są wiersze, wyrazy, znaki

BEGIN @{
    # niech getopt wypisze komunikat o nieprawidłowych
    # opcjach. my je ignorujemy
    while ((c = getopt(ARGC, ARGV, "lwc")) != -1) @{
        if (c == "l")
            do_lines = 1
        else if (c == "w")
            do_words = 1
        else if (c == "c")
            do_chars = 1
    @}
    for (i = 1; i < Optind; i++)
        ARGV[i] = ""

    # jeśli bez opcji, rób wszystkie
    if (! do_lines && ! do_words && ! do_chars)
        do_lines = do_words = do_chars = 1

    print_total = (ARGC - i > 2)
@}
@c endfile
@c @end group
@end example

Funkcja @code{beginfile} jest prosta: zeruje tylko liczniki wierszy, wyrazów
i znaków i zapamiętuje nazwę bieżącego pliku w @code{fname}.

Funkcja @code{endfile} dodaje liczby dotyczące bieżącego pliku do
narastających sum wierszy, wyrazów i znaków.  Następnie wypisuje liczniki
dotyczące właśnie przeczytanego pliku.  Zakłada, że zerowanie liczb dla
kolejnego pliku danych wykona @code{beginfile}.

@example
@c left brace on line with `function' because of page breaking
@c file eg/prog/wc.awk
@group
function beginfile(file) @{
    chars = lines = words = 0
    fname = FILENAME
@}
@end group

function endfile(file)
@{
    tchars += chars
    tlines += lines
    twords += words
    if (do_lines)
        printf "\t%d", lines
    if (do_words)
        printf "\t%d", words
    if (do_chars)
        printf "\t%d", chars
    printf "\t%s\n", fname
@}
@c endfile
@end example

Mamy tu jedną regułę, wykonywaną dla każdego wiersza.  Dodaje ona długość
rekordu do @code{chars}.  Musi jeszcze dodać jeden, gdyż znak nowej linii
rozdzielający rekordy (wartość @code{RS}) sam nie jest częścią rekordu.
@code{lines} z każdym przeczytanym wierszem zwiększa się o jeden, a
@code{words} o @code{NF}, liczbę ``wyrazów''
w tym wierszu.@footnote{Przeanalizuj kod w
@ref{Funkcja filetrans, ,Obsługa przejść między plikami}.  Dlaczego
@code{wc} musi używać osobnej zmiennej @code{lines}, zamiast korzystania
z wartości @code{FNR} w @code{endfile}?}

Na koniec, reguła @code{END} po prostu wypisuje sumy całkowite dla
wszystkich plików.

@example
@c @group
@c file eg/prog/wc.awk
# robi po jednym wierszu
@{
    chars += length($0) + 1    # weź znak newline
    lines++
    words += NF
@}

END @{
    if (print_total) @{
        if (do_lines)
            printf "\t%d", tlines
        if (do_words)
            printf "\t%d", twords
        if (do_chars)
            printf "\t%d", tchars
        print "\ttotal"
    @}
@}
@c endfile
@c @end group
@end example

@node Rozmaite programy,  , Klony, Przykładowe programy
@section Pełen worek programów @code{awk}

Ta sekcja to wielki ``worek'' pełen rozmaitych programów.
Mam nadzieję, że uznasz je za interesujące i przyjemne.

@menu
* Program dupword::         Znajdowanie w dokumencie zdublowanych wyrazów.
* Program alarm::           Budzik.
* Program translate::       Program podobny do narzędzia @code{tr}.
* Program labels::          Drukowanie etykiet adresowych.
* Sortowanie wyrazów::      Program do tworzenia statystyki wyrazów.
* Sortowanie historii::     Usuwanie zdublowanych pozycji z pliku historii.
* Program extract::         Wyciąganie programów z plików
                            źródłowych Texinfo.
* Prosty sed::              Prosty edytor strumieniowy.
* Program igawk::           Interfejs dla @code{awk}, który dołącza pliki.
@end menu

@node Program dupword, Program alarm, Rozmaite programy, Rozmaite programy
@subsection Znajdowanie w dokumencie zdublowanych wyrazów

Powszechnym błędem przy pisaniu dużej ilości prozy jest przypadkowe
powtórzenie słów.  Często można to zauważyć w tekście jako coś w rodzaju ``Ten
ten program robi następujące @dots{}''.  Jeżeli tekst jest w postaci
elektronicznej, często zdublowane wyrazy występują na końcu jednego wiersza
i na początku następnego, co powoduje, że są bardzo trudne do zauważenia.
@c jak tu!

Opisywany program, @file{dupword.awk}, przegląda plik po jednym wierszu,
szukając sąsiadujących wystąpień tego samego słowa.  Zapamiętuje także
ostatni wyraz w wierszu (w zmiennej @code{prev}), by móc go porównać
z pierwszym wyrazem następnego wiersza.

Pierwsze dwie instrukcje zapewniają, że wiersz będzie w całości małymi
literami, więc, na przykład, ``Ten'' i ``ten'' przy porównywaniu będą takie
same.  Druga instrukcja usuwa z wiersza wszystkie znaki, które nie są ani
alfanumeryczne ani białymi znakami, by interpunkcja również nie wpływała na
porównywanie.  Prowadzi to czasem do meldunków o powtórzonych słowach, które
w rzeczywistości są różne, ale zdarza się to rzadko.

@c FIXME: add check for $i != ""
@findex dupword.awk
@example
@group
@c file eg/prog/dupword.awk
# dupword --- znajduje w tekście zdublowane słowa
# Arnold Robbins, arnold@@gnu.org, Public Domain
# December 1991

@{
    $0 = tolower($0)
    gsub(/[^A-Za-z0-9 \t]/, "");
    if ($1 == prev)
        printf("%s:%d: zdublowane %s\n",
            FILENAME, FNR, $1)
    for (i = 2; i <= NF; i++)
        if ($i == $(i-1))
            printf("%s:%d: zdublowane %s\n",
                FILENAME, FNR, $i)
    prev = $NF
@}
@c endfile
@end group
@end example

@node Program alarm, Program translate, Program dupword, Rozmaite programy
@subsection Program-budzik

Poniższy program jest prostym ``budzikiem''.
Podajemy mu godzinę i opcjonalny komunikat.  O zadanej porze wypisuje
komunikat na standardowym wyjściu.  Dodatkowo, można podać mu, ile razy
ma być powtórzony komunikat, a także jaka ma być zwłoka między
powtórzeniami.

Program wykorzystuje funkcję @code{gettimeofday} z
@ref{Funkcja gettimeofday, ,Obsługa daty i czasu}.

Cała praca wykonywana jest w regule @code{BEGIN}. Pierwszą częścią jest
sprawdzenie argumentów i nadanie ustawień domyślnych: opóźnienia, liczby
powtórzeń i komunikatu do wypisania.  Jeżeli użytkownik podał komunikat, ale
nie zawiera on znaku ASCII BEL (znanego jako znak ``dzwonka'', alarmu,
@samp{\a}), to jest on dodawany do komunikatu.  (W wielu systemach wypisanie
ASCII BEL daje jakiś rodzaj sygnału dźwiękowego.  Zatem, wysyłając sygnał
ostrzegawczy, system zwraca na siebie uwagę, na wypadek gdyby użytkownik nie
patrzył na komputer czy terminal.)

@c WK zmieniono 'print skladn' na 'print skladn1'
@findex alarm.awk
@example
@c @group
@c file eg/prog/alarm.awk
# alarm --- ustawia alarm
# Arnold Robbins, arnold@@gnu.org, Public Domain
# May 1993

# składnia: alarm czas [ "komunikat" [ ile_razy [ zwłoka ] ] ]

BEGIN    \
@{
    # wstępne sprawdzenie poprawności argumentów
    skladn1 = "składnia: alarm czas ['komunikat' [ile_razy [zwłoka]]]"
    skladn2 = sprintf("\t(%s) czas ::= hh:mm", ARGV[1])

    if (ARGC < 2) @{
        print skladn1 > "/dev/stderr"
        exit 1
    @} else if (ARGC == 5) @{
        zwloka = ARGV[4] + 0
        ile_razy = ARGV[3] + 0
        komunikat = ARGV[2]
    @} else if (ARGC == 4) @{
        ile_razy = ARGV[3] + 0
        komunikat = ARGV[2]
    @} else if (ARGC == 3) @{
        komunikat = ARGV[2]
    @} else if (ARGV[1] !~ /[0-9]?[0-9]:[0-9][0-9]/) @{
        print skladn1 > "/dev/stderr"
        print skladn2 > "/dev/stderr"
        exit 1
    @}

    # ustawienia domyślne akcji
    # po osiągnięciu zadanego czasu
    if (zwloka == 0)
        zwloka = 180    # 3 minuty
    if (ile_razy == 0)
        ile_razy = 5
@group
    if (komunikat == "")
        komunikat = sprintf("\aTeraz jest %s!\a", ARGV[1])
    else if (index(komunikat, "\a") == 0)
        komunikat = "\a" komunikat "\a"
@end group
@c endfile
@end example

Kolejny fragment kodu zamienia czas alarmu na godziny i minuty, i, jeśli
to konieczne, przekształca go na czas 24-godzinny.  Potem zamienia go
na liczbę sekund od północy.  Następnie na liczbę sekund od północy zamienia
czas bieżący.  Różnica pomiędzy tymi dwoma liczbami wskazuje, jak długo
należy odczekać przed wywołaniem alarmu.

@example
@c @group
@c file eg/prog/alarm.awk
    # podział czasu docelowego
    split(ARGV[1], aczas, ":")
    godz = aczas[1] + 0  # wymuś numeryczne
    min  = aczas[2] + 0  # wymuś numeryczne

    # pobranie bieżącego czasu podzielonego na składowe
    gettimeofday(teraz)

    # jeśli podano czas w formacie 12-godzinnym i jest
    # już po tej godzinie, np. `alarm 5:30' o 9 rano
    # znaczy 5:30 po południu, to dodajmy 12 do faktycznej
    # godziny
    if (godz < 12 && teraz["godzina"] > godz)
        godz += 12

    # ustal czas docelowy w sekundach od północy
    cel = (godz * 60 * 60) + (min * 60)

    # weź czas bieżący w sekundach od północy
    biezacy = (teraz["godzina"] * 60 * 60) + \
              (teraz["minuta"] * 60) + teraz["sekunda"]

    # jak długo odczekać
    czasdrzemki = cel - biezacy
    if (czasdrzemki <= 0) @{
        print "czas w przeszłości!" > "/dev/stderr"
        exit 1
    @}
@c endfile
@c @end group
@end example

Na koniec, program wykorzystuje funkcję @code{system}
(@pxref{Funkcje I/O, ,Wbudowane funkcje wejścia/wyjścia}) do wywołania
narzędzia @code{sleep}.  Narzędzie to odczekuje po prostu zadaną liczbę
sekund.  Jeśli kodem zakończenia nie jest zero, to program przyjmuje, że
przerwano @code{sleep}, i kończy pracę. Jeżeli @code{sleep} zakończyło
działanie ze statusem OK (zero), to program wypisuje komunikat w pętli,
ponownie stosując @code{sleep} do odczekania tylu sekund, ile to konieczne.

@example
@c file eg/prog/alarm.awk
@group
    # chrrrr.... idź precz jeśli ci przerwą
    if (system(sprintf("sleep %d", czasdrzemki)) != 0)
        exit 1
@end group

    # czas na powiadomienie!
    polecenie = sprintf("sleep %d", zwloka)
    for (i = 1; i <= ile_razy; i++) @{
        print komunikat
        # jeśli przerwano polecenie sleep, idź sobie
        if (system(polecenie) != 0)
            break
    @}

    exit 0
@}
@c endfile
@end example

@node Program translate, Program labels, Program alarm, Rozmaite programy
@subsection Zamiana znaków

Systemowe narzędzie @code{tr} transliteruje znaki [tłum: zamienia znaki
pewnego zestawu na znaki innego zestawu].  Na przykład, często używane jest
do przekształcenia dużych liter na małe, w celu dalszego przetwarzania.

@example
@var{tworzenie danych} | tr '[A-Z]' '[a-z]' | @var{przetwarzanie danych} @dots{}
@end example

@code{tr} podajemy dwie listy znaków objęte nawiasami kwadratowymi.
Zazwyczaj, listy są ujmowane w znaki cytowania, by powstrzymać powłokę przed
próbą wykonania rozwinięcia nazw plików.@footnote{Na starszych,
nie POSIX-owych systemach, @code{tr} często nie wymaga ujmowania list
w nawiasy kwadratowe i cudzysłowy.  Jest to cecha produktu.}
Przy przetwarzaniu wejścia, pierwszy znak pierwszej listy zastępowany jest
pierwszym znakiem drugiej listy, drugi znak pierwszej drugim znakiem
drugiej, i tak dalej.  Jeżeli lista ``z'' ma więcej znaków niż lista ``na'',
to  dla pozostałych znaków listy ``z'' jest używany ostatni znak listy
``na''.

Jakiś czas temu,
@c na początku czy w połowie 1989!
pewien użytkownik zaproponował nam, byśmy dodali funkcję transliteracji do
@code{gawk}.  Będąc przeciwnym ``efektowi choinki'' [tłum.: przeładowanie
programu funkcjami], napisałem poniższy program, by udowodnić, że
transliterację znaków można zrobić za pomocą funkcji użytkownika.
Program ten nie jest tak kompletny, jak systemowe narzędzie @code{tr},
ale generalnie spełnia zadanie.

Program @code{translate} ukazuje jedną z kilku słabości standardowego
@code{awk}: zajmowanie się pojedynczymi znakami jest bardzo uciążliwe,
wymagając powtarzanego stosowania funkcji wbudowanych @code{substr},
@code{index} i @code{gsub}
(@pxref{Funkcje łańcuchowe, ,Funkcje wbudowane działające na łańcuchach}).@footnote{Ten
program został napisany zanim @code{gawk} uzyskał możliwość podziału
łańcucha na pojedyncze znaki umieszczane w osobnych elementach tablicy.
Jak mógłbyś wykorzystać tę nową cechę do uproszczenia programu?}

Mamy tu dwie funkcje.  Pierwsza @code{stranslate}, pobiera trzy argumenty.

@table @code
@item z
Lista znaków, które konwertować.

@item na
Lista znaków, na które konwertować.

@item cel
Łańcuch, jaki ma podlegać konwersji.
@end table

Tablice asocjacyjne powodują, że część wykonująca konwersję znaków jest
całkiem łatwa. @code{t_ar} przechowuje znaki ``na'', indeksowane znakami
``z''.  Następnie przez @code{z} przechodzi zwykłą pętla, po jednym znaku
naraz.  Dla każdego znaku w @code{z}, jeśli znak ten pojawia się
w @code{cel}, wykorzystywana jest @code{gsub}, zmieniająca go na odpowiedni
znak @code{na}.

Funkcja @code{translate} po prostu wywołuje @code{stranslate} używając jako
celu @code{$0}.  Program główny inicjuje dwie zmienne globalne, @code{Z}
i @code{NA}, według wiersza poleceń, a następnie zmienia @code{ARGV}, tak
że @code{awk} będzie czytał ze standardowego wejścia.

Wreszcie, reguła przetwarzania po prostu dla każdego rekordu wywołuje
@code{translate}.

@findex translate.awk
@example
@c @group
@c file eg/prog/translate.awk
# translate --- robi rzeczy podobne do tr
# Arnold Robbins, arnold@@gnu.org, Public Domain
# August 1989

# błędy: nie obsługuje rzeczy typu: tr A-Z a-z, muszą
# być przeliterowane. Jeśli jednak `na' jest krótsze od `z',
# to dla reszty `z' jest stosowany ostatni znak z `na'.

function stranslate(z, na, cel,   dl_z, dl_na, t_tr, i, c)
@{
    dl_z = length(z)
    dl_na = length(na)
    for (i = 1; i <= dl_na; i++)
        t_tr[substr(z, i, 1)] = substr(na, i, 1)
    if (dl_na < dl_z)
        for (; i <= dl_z; i++)
            t_tr[substr(z, i, 1)] = substr(na, dl_na, 1)
    for (i = 1; i <= dl_z; i++) @{
        c = substr(z, i, 1)
        if (index(cel, c) > 0)
            gsub(c, t_tr[c], cel)
    @}
    return cel
@}

function translate(z, na)
@{
    return $0 = stranslate(z, na, $0)
@}

@group
# program główny
BEGIN @{
    if (ARGC < 3) @{
        print "składnia: translate z na" > "/dev/stderr"
        exit
    @}
@end group
    Z = ARGV[1]
    NA = ARGV[2]
    ARGC = 2
    ARGV[1] = "-"
@}

@{
    translate(Z, NA)
    print
@}
@c endfile
@c @end group
@end example

Mimo że możliwe jest wykonanie transliteracji znaków w funkcji
zdefiniowanej na poziomie użytkownika, niekoniecznie jest to efektywne,
i zaczęliśmy się zastanawiać nad dodaniem funkcji wbudowanej.  Jednak,
wkrótce po napisaniu tego programu, dowiedzieliśmy się, że w @code{awk}
z System V Release 4 dodano funkcje @code{toupper} i @code{tolower}.
Funkcje te obsługują przeważającą większość przypadków, w których
transliteracja jest niezbędna, zatem woleliśmy po prostu dołożyć te
funkcje również do @code{gawk}, a zostawić w spokoju całą resztę.

Oczywistym udoskonaleniem tego programu byłoby inicjowanie tablicy
@code{t_tr} tylko raz, w regule @code{BEGIN}.  Zakłada to jednak, że
listy ``z'' i ``na'' w trakcie działania programu nigdy się nie zmienią.


@node Program labels, Sortowanie wyrazów, Program translate, Rozmaite programy
@subsection Wypisywanie etykiet adresowych

Oto przykład ``rzeczywistego''@footnote{``Rzeczywisty'' definiujemy jako
``program faktycznie wykorzystywany do zrobienia czegoś''.} programu.  Ten
skrypt czyta listę nazw i adresów, i tworzy etykiety adresowe.  Na każdej
stronie jest 20 etykiet, dwie w poziomie i dziesięć w pionie.  Adresy na
pewno nie będą większe niż pięć wierszy danych.  Każdy z adresów oddzielony
jest od następnego pustym wierszem.

Podstawowym pomysłem jest odczytanie danych o 20 etykietach. Każdy
wiersz każdej etykiety przechowywany jest w tablicy @code{line}.
Jedyna reguła główna zajmuje się wypełnianiem tej tablicy i wypisywaniem
strony po przeczytaniu 20 etykiet.

Reguła @code{BEGIN} po prostu przypisuje @code{RS} łańcuch pusty, tak by
@code{awk} dzielił rekordy w miejscu pustych wierszy
(@pxref{Rekordy, ,Jak wejście dzielone jest na rekordy}).  Nadaje
@code{MAXLINES} wartość 100, gdyż @code{MAXLINE} jest maksymalną liczbą
wierszy na stronie (20 * 5 = 100).

Większość pracy wykonywane jest w funkcji @code{printpage}.  Wiersze
etykiet składowane są kolejno w tablicy @code{line}.  Muszą one jednak
zostać wydrukowane poziomo: @code{line[1]} obok @code{line[6]},
@code{line[2]} obok @code{line[7]}, i tak dalej.  Aby to osiągnąć
wykorzystano dwie pętle.  Zewnętrzna, sterowana przez @code{i}, przechodzi
przez co dziesiąty wiersz danych, to jest każdy rząd etykiet.
Wewnętrzna pętla, kontrolowana przez @code{j}, przechodzi przez wiersze tego
rzędu.  Ponieważ @code{j} zmienia się od zera do czterech, @samp{i+j} jest
@code{j}-tym wierszem w @code{i}-tym rzędzie etykiet, a @samp{i+j+5}
jest wpisem obok niej.  Wynik wygląda ostatecznie mniej więcej tak:

@example
wiersz 1          wiersz 6
wiersz 2          wiersz 7
wiersz 3          wiersz 8
wiersz 4          wiersz 9
wiersz 5          wiersz 10
@end example

Zauważmy na koniec, że przy wierszach numer 21 i 61, wypisywany jest
dodatkowy pusty wiersz, by utrzymać wyrównane etykiety na wyjściu.
Zależy to od konkretnego rodzaju etykiet wykorzystywanych w czasie, gdy
był pisany program.  Zwróć też uwagę, że są tu dwa puste wiersze
na górze strony i dwa puste na dole.

Reguła @code{END} organizuje opróżnienie bufora ostatniej strony etykiet:
w danych mogła nie wystąpić pełna wielokrotność 20 etykiet.

@findex labels.awk
@example
@c @group
@c file eg/prog/labels.awk
# labels.awk
# Arnold Robbins, arnold@@gnu.org, Public Domain
# June 1992

# Program do wydruku etykiet.  Każda etykieta to 5 wierszy
# danych. Mogą one zawierać puste wiersze.  Arkusze
# etykiet mają po 2 puste wiersze na górze i 2 na dole.

BEGIN    @{ RS = "" ; MAXLINES = 100 @}

function printpage(    i, j)
@{
    if (Nlines <= 0)
        return

    printf "\n\n"        # nagłówek

    for (i = 1; i <= Nlines; i += 10) @{
        if (i == 21 || i == 61)
            print ""
        for (j = 0; j < 5; j++) @{
            if (i + j > MAXLINES)
                break
            printf "   %-41s %s\n", line[i+j], line[i+j+5]
        @}
        print ""
    @}

    printf "\n\n"        # stopka

    for (i in line)
        line[i] = ""
@}

# reguła główna
@{
    if (Count >= 20) @{
        printpage()
        Count = 0
        Nlines = 0
    @}
    n = split($0, a, "\n")
    for (i = 1; i <= n; i++)
        line[++Nlines] = a[i]
    for (; i <= 5; i++)
        line[++Nlines] = ""
    Count++
@}

END    \
@{
    printpage()
@}
@c endfile
@c @end group
@end example

@node Sortowanie wyrazów, Sortowanie historii, Program labels, Rozmaite programy
@subsection Tworzenie statystyk użycia wyrazów

Poniższy program @code{awk} wypisuje liczbę wystąpień każdego słowa ze
swojego wejścia.  Przez wykorzystanie łańcuchów jako indeksów
ilustruje skojarzeniową naturę tablic @code{awk}.  Demonstruje także
konstrukcję @samp{for @var{x} in @var{tablica}}.  Wreszcie,
pokazuje, w jaki sposób można wykorzystać @code{awk} w połączeniu z innymi
programami narzędziowymi do wykonania stosunkowo złożonych, użytecznych
zadań przy minimum wysiłku.
Po listingu programu zamieszczono nieco wyjaśnień.

@example
awk '
# wypisuje częstości słów
@{
    for (i = 1; i <= NF; i++)
        czest[$i]++
@}

@group
END @{
    for (slowo in czest)
        printf "%s\t%d\n", slowo, czest[slowo]
@}'
@end group
@end example

Pierwsza rzecz, na jaką warto zwrócić uwagę w tym programie to to, że ma on
dwie reguły.  Pierwsza, ponieważ ma pusty wzorzec, wykonywana jest na każdym
wierszu wejścia.  Wykorzystuje dostępny w @code{awk} mechanizm dostępu do
pól (@pxref{Pola, ,Badanie pól}) do wyłapania z wiersza poszczególnych
słów, a zmienną wbudowaną @code{NF} (@pxref{Zmienne wbudowane}) do
rozpoznania, ile jest dostępnych pól.

Dla każdego pola wejściowego zwiększany jest element tablicy @code{czest},
by odzwierciedlał, że wyraz ten widziano kolejny raz.

Druga reguła, ponieważ ma wzorzec @code{END}, nie jest wykonywana aż
do momentu wyczerpania wejścia.  Wypisuje ona zawartość tablicy
@code{czest}, która została skonstruowana wewnątrz pierwszej akcji.

Program ma kilka niedociągnięć, które nie pozwalają, by mógł być przydatny
z rzeczywistymi plikami tekstowymi:

@itemize @bullet
@item
Słowa wykrywane są za pomocą konwencji @code{awk} mówiącej, że pola są
oddzielone białym znakiem, i że inne znaki w wejściu (z wyjątkiem znaków
nowej linii) nie mają żadnego specjalnego znaczenia dla @code{awk}.  Znaczy
to, że znaki interpunkcyjne uważane są za części wyrazów.

@item
Język @code{awk} uważa duże i małe litery za różne.  Stąd też,
@samp{bartender} i @samp{Bartender} nie są traktowane jak to samo słowo.
Jest to niepożądane, gdyż w zwykłym tekście słowa rozpoczynające zdanie
pisane są z dużej litery i analizator częstości nie powinien być wrażliwy
na wielkość liter.

@item
Wyniki nie pojawiają się w żadnej użytecznym porządku.  Prawdopodobnie
jesteśmy raczej zainteresowani tym, które słowa pojawiają się najczęściej,
lub ułożoną alfabetycznie tabelą częstości poszczególnych słów.
@end itemize

Metodą rozwiązania tego problemu jest wykorzystanie pewnych bardziej
zaawansowanych cech języka @code{awk}.  Najpierw, skorzystamy
z @code{tolower} by usunąć różnice w wielkości liter.  Następnie,
wykorzystamy @code{gsub} do usunięcia znaków interpunkcyjnych.  Na koniec,
użyjemy systemowego narzędzia @code{sort} by przetworzyć wyjście
naszego skryptu @code{awk}.  Oto nowa wersja programu:

@findex wordfreq.sh
@example
@c file eg/prog/wordfreq.awk
# Wypisuje częstości słów
@{
    $0 = tolower($0)    # usuwa różnice między
                        # dużymi a małymi literami
    gsub(/[^a-z0-9_ \t]/, "", $0)  # usuwa interpunkcję
    for (i = 1; i <= NF; i++)
        czest[$i]++
@}
@c endfile

@group
END @{
    for (slowo in czest)
        printf "%s\t%d\n", slowo, czest[slowo]
@}
@end group
@end example

Zakładając, że zapisaliśmy ten program w pliku o nazwie @file{wordfreq.awk},
a dane są w @file{plik1}, poniższy potok

@example
awk -f wordfreq.awk plik1 | sort +1 -nr
@end example

@noindent
tworzy tabelę słów pojawiających się w @file{plik1} uporządkowanych
w kolejności malejącej częstości.

Program @code{awk} odpowiednio gromadzi dane i tworzy tabelę częstości
wyrazów, która nie jest uporządkowana.

Wyjście skryptu @code{awk} jest następnie sortowane przez narzędzie
@code{sort} i wypisywane na terminalu.  Opcje podane @code{sort} w tym
przykładzie mówią, że sortowanie powinno być według drugiego pola każdego
wiersza wejściowego (pominięcie jednego pola), klucze sortowania powinny być
traktowane jak wielkości numeryczne (inaczej @samp{15} byłoby przed
@samp{5}), i że sortowanie ma być wykonane w porządku malejącym
(reverse, odwrotnym).

Moglibyśmy nawet zrobić @code{sort} z wnętrza programu, zmieniając akcję
@code{END} na:

@example
@c file eg/prog/wordfreq.awk
END @{
    sort = "sort +1 -nr"
    for (slowo in czest)
        printf "%s\t%d\n", slowo, czest[slowo] | sort
    close(sort)
@}
@c endfile
@end example

Musielibyśmy użyć tej metody na systemach, które nie mają prawdziwych
potoków.

Więcej o sposobie korzystania z programu @code{sort} można znaleźć w ogólnej
dokumentacji systemu operacyjnego.

@node Sortowanie historii, Program extract, Sortowanie wyrazów, Rozmaite programy
@subsection Usuwanie duplikatów z niesortowanego tekstu

Program @code{uniq}
(@pxref{Program uniq, ,Wypisywanie nie powtarzających się wierszy tekstu}),
usuwa zdublowane wiersze z @emph{posortowanych} danych.

Załóżmy jednak, że potrzebujemy usunąć powtarzające się wiersze z pliku
danych, ale zachowując kolejność wierszy?  Dobrym przykładem może tu być
plik historii poleceń powłoki.  Plik historii przechowuje kopię każdego
wprowadzonego polecenia, a nie jest niczym nietypowym kilkakrotne
powtarzanie tego samego polecenia.  Chcemy od czasu do czasu
kondensować plik historii przez usunięcie powielonych pozycji.
Nadal jednak pożądane jest zachowanie pierwotnej kolejności poleceń.

Zadanie takie wykonuje poniższy prosty program.  Wykorzystuje dwie tablice.
Tablica @code{dane} indeksowana jest tekstem każdego wiersza.  Dla każdego
wiersza inkrementowane jest @code{dane[$0]}.

Jeśli jakiegoś konkretnego wiersza nie napotkano wcześniej, to
@code{dane[$0]} będzie zerem.  W tym przypadku, jego tekst zapamiętywany
jest w @code{wiersze[ile]}.  Każdy element w tablicy @code{wiersze} jest
niepowtarzalnym poleceniem, a indeksy tej tablicy wskazują na kolejność w
jakiej napotkano te wiersze.  Reguła wypisuje po prostu wiersze, po kolei.

@cindex Rakitzis, Byron
@findex histsort.awk
@example
@group
@c file eg/prog/histsort.awk
# histsort.awk --- upakowanie pliku historii powłoki
# Arnold Robbins, arnold@@gnu.org, Public Domain
# May 1993

# Dzięki Byronowi Rakitzis za ogólny pomysł
@{
    if (dane[$0]++ == 0)
        wiersze[++ile] = $0
@}

END @{
    for (i = 1; i <= ile; i++)
        print wiersze[i]
@}
@c endfile
@end group
@end example

Program stanowi też podstawę do generowania innych przydatnych danych.
Na przykład, zastosowanie poniższej instrukcji @code{print} w regule
@code{END} wskazałoby, jak często używane były poszczególne polecenia.

@example
print dane[lines[i]], wiersze[i]
@end example

Fragment ten działa prawidłowo, ponieważ @code{dane[$0]} inkrementowano
przy każdym wystąpieniu wiersza.

@node Program extract, Prosty sed, Sortowanie historii, Rozmaite programy
@subsection Wydzielanie programów z plików źródłowych Texinfo

@iftex
Ten i poprzedni rozdział
(@ref{Funkcje biblioteczne, ,Biblioteczka funkcji @code{awk}}),
przedstawiają wiele programów @code{awk}.
@end iftex
@ifinfo
@ref{Funkcje biblioteczne, ,Biblioteczka funkcji @code{awk}},
i @ref{Przykładowe programy, ,Praktyczne programy @code{awk}},
są sekcjami najwyższego poziomu dla dużej ilości programów @code{awk}.
@end ifinfo
Jeżeli chcielibyśmy poeksperymentować z tymi programami, konieczność
wpisywania ich ręcznie byłaby nudna.  Pokażemy tu program, który potrafi
wydzielić części pliku wejściowego Texinfo do oddzielnych plików.

Niniejszą książkę napisano w Texinfo, języku formatowania dokumentów
projektu GNU.  Pojedynczy plik źródłowy można wykorzystać do utworzenia
zarówno dokumentacji drukowanej, jak i elektronicznej.

@iftex
Texinfo opisano w pełni w @cite{Texinfo---The GNU Documentation Format},
dostępnym z Free Software Foundation.
@end iftex
@ifinfo
Texinfo jest opisany w całości, poczynając od
@ref{Top, , Introduction, texi, Texinfo---The GNU Documentation Format}.

@end ifinfo

Do naszych celów wystarczy wiedzieć trzy rzeczy o plikach wejściowych
Texinfo.

@itemize @bullet
@item
Symbol ``at'', @samp{@@}, w Texinfo ma znaczenie specjalne, całkiem podobnie
jak @samp{\} w C czy @code{awk}.  Dosłowne symbole @samp{@@} reprezentowane
są w plikach źródłowych Texinfo jako @samp{@@@@}.

@item
Komentarze zaczynają się albo od @samp{@@c} albo od @samp{@@comment}.
Program wydobywający pliki będzie pracował wykorzystując specjalne
komentarze rozpoczynające się na samym początku wiersza.

@item
Tekst przykładu, który nie powinien być dzielony między strony zgrupowany
jest między wierszami zawierającymi polecenia @samp{@@group}
i @samp{@@end group}.
@end itemize

Poniższy program, @file{extract.awk}, czyta plik źródłowy Texinfo i,
w oparciu o wspomniane specjalne komentarze, robi dwie rzeczy.
W momencie zauważenia @samp{@w{@@c system @dots{}}} wykonuje polecenie,
wyodrębniając tekst polecenia z wiersza sterującego i przesyłając go
do funkcji
@code{system} (@pxref{Funkcje I/O, ,Wbudowane funkcje wejścia/wyjścia}).
Po zauważeniu @samp{@@c file @var{nazwapliku}}, każdy następny wiersz
wysyłany jest do pliku @var{nazwapliku}, do momentu
napotkania @samp{@@c endfile}.
Reguły w @file{extract.awk} dopasowują @samp{@@c} lub @samp{@@comment},
dzięki użyciu części @samp{omment} jako opcjonalnej.  Wiersze zawierające
@samp{@@group} i @samp{@@end group} są po prostu usuwane.
@file{extract.awk} korzysta z funkcji bibliotecznej @code{join}
(@pxref{Funkcja join, ,Scalanie tablicy w łańcuch}).

Wszystkie programy przykładowe w źródle Texinfo książki @cite{@value{TITLE}}
(@file{gawk.texi}) zostały ujęte między wiersze @samp{file}
i @samp{endfile}.  Dystrybucja @code{gawk} wykorzystuje kopię
@file{extract.awk} do wydzielenia programów przykładowych i instalacji
wielu z nich w standardowym katalogu, gdzie może je znaleźć @code{gawk},
Plik Texinfo wygląda podobnie jak to:

@example
@dots{}
Ten program ma blok @@code@{BEGIN@},
wypisujący miły komunikat:

@@example
@@c file examples/messages.awk
BEGIN @@@{ print "Nie panikuj!" @@@}
@@c end file
@@end example

Wypisuje też pewną końcową radę:

@@example
@@c file examples/messages.awk
END @@@{ print "Zawsze unikaj znudzonych archeologów!" @@@}
@@c end file
@@end example
@dots{}
@end example

@file{extract.awk} zaczyna od nadania @code{IGNORECASE} wartości jeden, co
powoduje, że mieszanie dużych i małych liter w dyrektywach nie będzie mieć
znaczenia.

Pierwsza reguła obsługuje wywołanie instrukcji @code{system}, sprawdzając
czy podano polecenie (@code{NF} równe co najmniej trzy).  Sprawdza też
czy polecenie to zakończyło pracę z kodem zerowym, znaczącym OK.

@findex extract.awk
@example
@c @group
@c file eg/prog/extract.awk
# extract.awk --- wydziela pliki i uruchamia programy
#                 z plików texinfo
# Arnold Robbins, arnold@@gnu.org, Public Domain, May 1993

BEGIN    @{ IGNORECASE = 1 @}

@group
/^@@c(omment)?[ \t]+system/    \
@{
    if (NF < 3) @{
        e = (FILENAME ":" FNR)
        e = (e  ": źle zbudowany wiersz `system'")
        print e > "/dev/stderr"
        next
    @}
    $1 = ""
    $2 = ""
    stat = system($0)
    if (stat != 0) @{
        e = (FILENAME ":" FNR)
        e = (e ": ostrzeżenie: system zwrócił " stat)
        print e > "/dev/stderr"
    @}
@}
@end group
@c endfile
@end example

@noindent
Zmienną @code{e} zastosowano by funkcja ładnie mieściła się na
@iftex
stronie.
@end iftex
@ifinfo
ekranie.
@end ifinfo

Druga reguła obsługuje przenoszenie danych do plików.  Upewnia się, czy
w dyrektywie podano nazwę pliku.  Jeżeli wymieniony plik nie jest aktualnie
tworzonym plikiem, to bieżący plik jest zamykany.  Oznacza to, że nie podano
dla niego @samp{@@c endfile}.  (Powinniśmy zapewne wypisać w tym przypadku
komunikat diagnostyczny, choć teraz tego nie robimy.)

Zasadniczą część zadania realizuje pętla @samp{for}.  Czyta wiersze
za pomocą
@code{getline} (@pxref{Getline, ,Odczyt bezpośredni przez @code{getline}}).
W przypadku napotkania niespodziewanego końca pliku wywołuje funkcję
@code{@w{unexpected_eof}}.  Jeżeli wiersz jest wierszem ``endfile'', to
przerywa pętlę.  Jeżeli wiersz jest typu @samp{@@group} lub
@samp{@@end group}, to jest ignorowany, a program przechodzi do następnego.
(Te wiersze sterujące w Texinfo trzymają bloki kodu razem na jednej
stronie.  Niestety, @TeX{} nie zawsze jest dość sprytny, by zrobić swoje
całkiem dobrze, i musimy mu trochę podpowiadać.)

Większość pracy wykonuje poniższych kilka linijek kodu.  Jeżeli w wierszu
nie ma symboli @samp{@@}, to można go wypisać wprost.  W przeciwnym razie
muszą zostać usunięte wszystkie początkowe @samp{@@}.

W celu usunięcia symboli @samp{@@}, wiersz dzielony jest, za pomocą
funkcji @code{split}
(@pxref{Funkcje łańcuchowe, ,Funkcje wbudowane działające na łańcuchach}),
na odrębne elementy tablicy @code{a}.  Każdy pusty element @code{a}
wskazuje na dwa kolejne symbole @samp{@@} w pierwotnym wierszu.
Dla każdych dwu pustych elementów (@samp{@@@@} w pliku pierwotnym) musimy
dodać z powrotem pojedynczy symbol @samp{@@}.

Po zakończeniu przetwarzania tablicy, do ponownego złączenia kawałków
w pojedynczy wiersz wywoływana jest @code{join} z wartością @code{SUBSEP}.
Wiersz ten jest następnie wypisywany do pliku wyjściowego.

@example
@c @group
@c file eg/prog/extract.awk
@group
/^@@c(omment)?[ \t]+file/    \
@{
    if (NF != 3) @{
        e = (FILENAME ":" FNR ": źle zbudowany wiersz `file'")
        print e > "/dev/stderr"
        next
    @}
@end group
    if ($3 != curfile) @{
        if (curfile != "")
            close(curfile)
        curfile = $3
    @}

    for (;;) @{
        if ((getline line) <= 0)
            unexpected_eof()
        if (line ~ /^@@c(omment)?[ \t]+endfile/)
            break
        else if (line ~ /^@@(end[ \t]+)?group/)
            continue
        if (index(line, "@@") == 0) @{
            print line > curfile
            continue
        @}
        n = split(line, a, "@@")
@group
        # jeśli a[1] == "", tzn. początkowe @@,
        # nie oddawaj jednego.
@end group
        for (i = 2; i <= n; i++) @{
            if (a[i] == "") @{ # było @@@@
                a[i] = "@@"
                if (a[i+1] == "")
                    i++
            @}
        @}
        print join(a, 1, n, SUBSEP) > curfile
    @}
@}
@c endfile
@c @end group
@end example

Ważne jest zwrócenie uwagi na użycie przekierowania @samp{>}.
Wyjście wykonane za pomocą @samp{>} otwiera dany plik tylko raz. Pozostaje
on otwarty a kolejne elementy wyjścia są do niego dopisywane.
(@pxref{Przekierowanie, , Przekierowanie wyjścia @code{print} i @code{printf}}).
Daje nam to możliwość łatwego przeplatania tekstu programu i objaśnień
dotyczących tego samego pliku źródłowego (tak jak to zrobiono tutaj!) bez
żadnych kłopotów.
@c    hassle
Plik zamykany jest tylko wtedy, gdy napotkana zostanie nowa nazwa pliku albo
koniec pliku wejściowego.

Na koniec, funkcja @code{@w{unexpected_eof}} wypisuje odpowiedni komunikat
o błędzie i kończy pracę programu.

Reguła @code{END} obsługuje końcowe porządkowanie, zamykając otwarty plik.

@example
@c file eg/prog/extract.awk
@group
function unexpected_eof()
@{
    printf("%s:%d: niespodziewany EOF lub błąd\n", \
        FILENAME, FNR) > "/dev/stderr"
    exit 1
@}
@end group

END @{
    if (curfile)
        close(curfile)
@}
@c endfile
@end example

@node Prosty sed, Program igawk, Program extract, Rozmaite programy
@subsection Prosty edytor strumieniowy

@cindex @code{sed}, narzędzie
@cindex narzędzie @code{sed}
Narzędzie @code{sed} to ``edytor strumieniowy'' (stream editor), program,
który czyta strumień danych, dokonuje na nim zmian, i przekazuje zmienione
dane dalej.  Jest często wykorzystywany do robienia zmian w dużych plikach
lub w strumieniach danych tworzonych przez potoki poleceń.

Chociaż trzeba przyznać, że @code{sed} jest skomplikowanym programem,
najczęstszym jego wykorzystaniem jest wykonywanie globalnych podstawień
w środku potoku:

@example
polecenie1 < dane.pocz | sed 's/stare/nowe/g' | polecenie2 > wynik
@end example

Tu, @samp{s/stare/nowe/g} nakazuje @code{sed} wyszukanie wyrażenia
regularnego @samp{stare} w każdym wierszu wejściowym i zastąpienie go
tekstem @samp{nowe}, globalnie (tj.@: wszystkie wystąpienia w wierszu).
Przypomina to funkcję @code{gsub}
(@pxref{Funkcje łańcuchowe, , Funkcje wbudowane działające na łańcuchach})
z @code{awk}.

Poniższy program, @file{awksed.awk}, przyjmuje co najmniej dwa argumenty
wiersza poleceń: wzorzec, jakiego szukać, i tekst, jaki ma go zastąpić.
Dodatkowe argumenty traktowane są jak nazwy plików danych do przetworzenia.
Jeżeli nie podano żadnych, to używane jest standardowe wejście.

@cindex Brennan, Michael
@cindex @code{awksed}
@cindex prosty edytor strumieniowy
@cindex edytor strumieniowy, prosty
@example
@c @group
@c file eg/prog/awksed.awk
# awksed.awk --- robi s/foo/bar/g za pomocą samego print
#    Dzięki Michaelowi Brennanowi za pomysł

# Arnold Robbins, arnold@@gnu.org, Public Domain
# August 1995

function usage()
@{
    print "składnia: awksed wzr zast [pliki...]" > "/dev/stderr"
    exit 1
@}

@group
BEGIN @{
    # kontrola poprawności argumentów
    if (ARGC < 3)
        usage()
@end group

    RS = ARGV[1]
    ORS = ARGV[2]

    # nie używaj argumentów jako plików
    ARGV[1] = ARGV[2] = ""
@}

# patrzaj, bez trzymanki!
@{
    if (RT == "")
        printf "%s", $0
    else
        print
@}
@c endfile
@c @end group
@end example

Program opiera się na zdolności @code{gawk} do obsługi @code{RS} jako
wyrażenia regularnego, oraz na przypisywaniu zmiennej @code{RT} tekstu,
jaki faktycznie
zakończył rekord (@pxref{Rekordy, ,Jak wejście dzielone jest na rekordy}).

Pomysł polega na tym, by w @code{RS} był wzorzec do wyszukania. @code{gawk}
automatycznie przypisze do @code{$0} tekst pomiędzy dopasowaniami wzorca.
To tekst, który chcemy pozostawić bez zmian.  Następnie, dzięki przypisaniu
tekst zastępującego do @code{ORS}, pojedyncza instrukcja @code{print}
wypisze tekst, jaki chcemy zostawić, a po nim tekst zastąpienia.

W tym schemacie jest pewna zagwozdka: co zrobić, jeśli ostatni rekord nie
kończy się tekstem pasującym do @code{RS}?  Skorzystanie z instrukcji
@code{print} powoduje bezwarunkowe wypisanie tekstu zastąpienia, co nie jest
poprawne.

Jeśli jednak plik nie kończy się tekstem pasującym do @code{RS}, to @code{RT}
zostanie przypisany łańcuch pusty.  W tym przypadku możemy wypisać @code{$0}
za pomocą @code{printf}
(@pxref{Printf, ,Wymyślne wyjście dzięki instrukcji @code{printf}}).

Reguła @code{BEGIN} obsługuje konfigurację, kontrolę poprawnej liczby
argumentów i w przypadku problemów wywołanie @code{usage}.  Następnie
inicjuje @code{RS} i @code{ORS} argumentami wiersza poleceń i przypisuje
@code{ARGV[1]} i @code{ARGV[2]} łańcuch pusty, by nie zostały potraktowane
jak nazwy plików (@pxref{ARGC i ARGV, , Używanie @code{ARGC} i @code{ARGV}}).

Funkcja @code{usage} wypisuje komunikat o błędzie i kończy pracę programu.

Wreszcie, jedyna reguła główna obsługuje nakreślony powyżej schemat
tworzenia wyjścia za pomocą odpowiednio @code{print} lub @code{printf},
w zależności od wartości @code{RT}.

@ignore
Exercise, compare the performance of this version with the more
straightforward:

BEGIN {
    pat = ARGV[1]
    repl = ARGV[2]
    ARGV[1] = ARGV[2] = ""
}

{ gsub(pat, repl); print }

Exercise: what are the advantages and disadvantages of this version vs. sed?
  Advantage: egrep regexps
             speed (?)
  Disadvantage: no & in replacement text

Others?
@end ignore

@node Program igawk, , Prosty sed, Rozmaite programy
@subsection Łatwa metoda korzystania z funkcji bibliotecznych

Korzystanie z funkcji bibliotecznych w @code{awk} może być bardzo korzystne.
Zachęca do wielokrotnego używania kodu i pisania ogólnych funkcji.  Programy
są mniejsze, zatem czytelniejsze.  Jednak stosowanie funkcji bibliotecznych
jest łatwe tylko przy pisaniu programów @code{awk}.  Jest bolesne przy ich
uruchamianiu, gdyż wymaga wielu opcji @samp{-f}.  Jeśli nie jest dostępny
@code{gawk}, to niedostępna jest też zmienna środowiska @code{AWKPATH}
i możliwość umieszczenia funkcji @code{awk} w katalogu
bibliotek (@pxref{Opcje, ,Opcje wiersza poleceń}).

Byłoby miło, gdybyśmy mogli napisać program tak:

@example
# funkcje biblioteczne
@@include getopt.awk
@@include join.awk
@dots{}

# program główny
BEGIN @{
    while ((c = getopt(ARGC, ARGV, "a:b:cde")) != -1)
        @dots{}
    @dots{}
@}
@end example

Poniższy program, @file{igawk.sh}, udostępnia taką obsługę.  Symuluje
wyszukiwanie przez @code{gawk} zmiennej @code{AWKPATH}, pozwala też na
@dfn{zagnieżdżone} dołączenia, tj.@: plik, który został dołączony za pomocą
@samp{@@include} może zawierać dalsze instrukcje @samp{@@include}.
@code{igawk} będzie usiłował dołączać pliki tylko raz, by zagnieżdżone
dołączenia nie spowodowały przypadkowo dwukrotnego dołączenia funkcji
bibliotecznej.

@code{igawk} zewnętrznie powinien zachowywać się tak jak @code{gawk}.
To znaczy, że powinien przyjmować wszystkie argumenty wiersza poleceń
@code{gawk}, łącznie z możliwością podania wielu nazw plików źródłowych
poprzez @samp{-f}, i możliwością przeplatania plików źródłowych z wiersza
poleceń i bibliotecznych.

Program napisano za pomocą języka poleceń Powłoki POSIX (POSIX Shell,
@code{sh}).  Działa w następujący sposób:

@enumerate
@item
Pętla po argumentach, zachowująca wszystko, co nie reprezentuje kodu
źródłowego @code{awk}, na później, gdy zostanie uruchomiony rozwinięty
program.

@item
Zachowanie ewentualnych argumentów nie reprezentujących tekstu @code{awk}
w pliku tymczasowym, który zostanie rozwinięty.  Mamy dwa przypadki.

@enumerate a
@item
Tekst dosłowny, dostarczony przez @samp{--source} lub @samp{--source=}.
Ten tekst jest po prostu bezpośrednio powtarzany przez program @code{echo},
który samoczynnie zapewni końcowy znak nowej linii.

@item
Nazwy plików dostarczone przez @samp{-f}.  Stosujemy ładną sztuczkę,
i powtarzamy echem @samp{@@include @var{nazwapliku}} do pliku tymczasowego.
Ponieważ program dołączania będzie działał w ten sam sposób, co @code{gawk},
spowoduje to włączenie tekstu pliku do programu w odpowiednim miejscu.
@end enumerate

@item
Uruchomienie programu napisanego w @code{awk} (naturalnie) z utworzonym
plikiem tymczasowym jako plikiem danych, by rozwinąć instrukcje
@samp{@@include}.  Rozwinięty program umieszczany jest w drugim pliku
tymczasowym.

@item
Uruchomienie rozwiniętego programu za pomocą @code{gawk}, z pozostałymi
początkowymi argumentami wiersza poleceń podanymi przez użytkownika (jak
nazwy plików danych).
@end enumerate

Początkowa część programu włącza śledzenie w powłoce jeśli pierwszym
argumentem było @samp{debug}.  W przeciwnym razie, instrukcja @code{trap}
powłoki organizuje sprzątanie plików tymczasowych przy zakończeniu lub
przerwaniu pracy programu.

@c 2e: For the temp file handling, go with Darrel's ig=${TMP:-/tmp}/igs.$$
@c 2e: or something as similar as possible.

Następna część jest pętlą po wszystkich argumentach wiersza poleceń.
Mamy kilka interesujących nas kilka przypadków.

@table @code
@item --
Ta opcja kończy argumenty @code{igawk}.  Cała reszta powinna bez dalszej
analizy zostać przekazana do programu @code{awk} użytkownika.

@item -W
Wskazuje, że następna opcja jest specyficzna dla @code{gawk}.  W celu
ułatwienia przetwarzania argumentów, przed pozostałymi argumentami
dopisywane jest @samp{-W} a pętla kontynuuje działanie.
(To trik programowania w @code{sh}.  Nie przejmuj się nim, jeśli nie znasz
@code{sh}.)

@item -v
@itemx -F
Są zapamiętywane i przekazywane do @code{gawk}.

@item -f
@itemx --file
@itemx --file=
@itemx -Wfile=
Nazwa pliku zapamiętywana jest w pliku tymczasowym @file{/tmp/ig.s.$$}
za pomocą instrukcji @samp{@@include}.
Do usunięcia początkowej, opcyjnej części argumentu (np., @samp{--file=})
wykorzystywane jest narzędzie @code{sed}.

@item --source
@itemx --source=
@itemx -Wsource=
Tekst źródłowy jest zapisywany do @file{/tmp/ig.s.$$}.

@item --version
@itemx -Wversion
@code{igawk} wypisuje swój numer wersji, uruchamia @samp{gawk --version},
by uzyskać informację o wersji @code{gawk}, a następnie kończy pracę.
@end table

Jeśli nie podano żadnej z opcji @samp{-f}, @samp{--file}, @samp{-Wfile},
@samp{--source}, ani @samp{-Wsource}, to pierwszy nie będący opcją
argument powinien być programem @code{awk}.  Jeżeli nie pozostały już
żadne argumenty wiersza poleceń, @code{igawk} wypisze komunikat o
błędzie i zakończy pracę.  W przeciwnym razie, pierwszy argument powtarzany
jest echem do @file{/tmp/ig.s.$$}.

W każdym z przypadków, po przetworzeniu argumentów plik @file{/tmp/ig.s.$$}
zawiera pełny tekst pierwotnego programu @code{awk}.

Zapis @samp{$$} w @code{sh} reprezentuje numeryczny identyfikator bieżącego
procesu.  W programach powłoki jest często wykorzystywany do tworzenia
niepowtarzalnych nazw plików tymczasowych.  Pozwala to na równoczesne
uruchamianie @code{igawk} przez wielu użytkowników bez obawy o konflikt nazw
plików tymczasowych.

@cindex @code{sed}, narzędzie
@cindex narzędzie @code{sed}
Oto i nasz program:

@findex igawk.sh
@example
@c @group
@c file eg/prog/igawk.sh
#! /bin/sh

# igawk --- jak gawk, ale przetwarza @@include
# Arnold Robbins, arnold@@gnu.org, Public Domain
# July 1993

if [ "$1" = debug ]
then
    set -x
    shift
else
    # sprzątanie przy zakończeniu i otrzymaniu
    # hangup, interrupt, quit, termination

    trap 'rm -f /tmp/ig.[se].$$' 0 1 2 3 15
fi

while [ $# -ne 0 ] # pętla po argumentach
do
    case $1 in
    --)     shift; break;;

    -W)     shift
            set -- -W"$@@"
            continue;;

    -[vF])  opts="$opts $1 '$2'"
            shift;;

    -[vF]*) opts="$opts '$1'" ;;

    -f)     echo @@include "$2" >> /tmp/ig.s.$$
            shift;;

@group
    -f*)    f=`echo "$1" | sed 's/-f//'`
            echo @@include "$f" >> /tmp/ig.s.$$ ;;
@end group

    -?file=*)    # -Wfile lub --file
            f=`echo "$1" | sed 's/-.file=//'`
            echo @@include "$f" >> /tmp/ig.s.$$ ;;

    -?file)    # get arg, $2
            echo @@include "$2" >> /tmp/ig.s.$$
            shift;;

    -?source=*)    # -Wsource lub --source
            t=`echo "$1" | sed 's/-.source=//'`
            echo "$t" >> /tmp/ig.s.$$ ;;

    -?source)  # pobierz argument, $2
            echo "$2" >> /tmp/ig.s.$$
            shift;;

    -?version)
            echo igawk: version 1.0 1>&2
            gawk --version
            exit 0 ;;

    -[W-]*)    opts="$opts '$1'" ;;

    *)      break;;
    esac
    shift
done

if [ ! -s /tmp/ig.s.$$ ]
then
    if [ -z "$1" ]
    then
         echo igawk: brak programu! 1>&2
         exit 1
    else
        echo "$1" > /tmp/ig.s.$$
        shift
    fi
fi

# w tym momencie w /tmp/ig.s.$$ jest końcowy program
@c endfile
@c @end group
@end example

Program @code{awk} do przetwarzania dyrektyw @samp{@@include} czyta
po jednym wierszu utworzony program, używając @code{getline}
(@pxref{Getline, ,Odczyt bezpośredni przez @code{getline}}).  Nazwy plików
wejściowych i instrukcje @samp{@@include} zarządzane są z wykorzystaniem
stosu.  Za każdym razem, gdy napotkane zostanie @samp{@@include}, nazwa
bieżącego pliku umieszczana jest na stosie, a plik wymieniony w dyrektywie
@samp{@@include} staje się bieżącym plikiem wejściowym.  Po zakończeniu
każdego pliku, ze stosu zdejmowana jest nazwa poprzedniego pliku
wejściowego, który staje się ponownie bieżącym plikiem.  Proces rozpoczyna
się od umieszczenia pierwotnego pliku jako pierwszego na stosie.

Funkcja @code{pathto} zajmuje się znajdowaniem pełnej ścieżki do pliku.
Symuluje zachowanie się @code{gawk} przy przeszukiwaniu zmiennej
@code{AWKPATH}
(@pxref{Zmienna AWKPATH, ,Zmienna środowiska @code{AWKPATH}}).
Jeśli nazwa pliku zawiera @samp{/}, to nie jest wykonywane przeszukiwanie
ścieżki.  W przeciwnym razie, nazwa pliku sklejana jest z nazwą każdego
z katalogów ścieżki i wykonywana jest próba otwarcia pliku o tak utworzonej
nazwie.  Jedyną metodą sprawdzenia w @code{awk} czy można odczytać plik jest
spróbowanie i podjęcie odczytania go za pomocą @code{getline}: to właśnie
robi @code{pathto} @footnote{W niektórych bardzo starych wersjach @code{awk},
test @samp{getline smiec < t} może się zapętlić jeśli plik istnieje, ale
jest pusty.  Caveat Emptor [tłum.: przysł.łac. "Niech się strzeże
kupujący"].} Jeżeli można przeczytać plik, to jest on zamykany i zwracana
jest jego nazwa.
@ignore
An alternative way to test for the file's existence would be to call
@samp{system("test -r " t)}, which uses the @code{test} utility to see if
the file exists and is readable.  The disadvantage to this method is that it
requires creating an extra process, and can thus be slightly slower.
@end ignore

@example
@c file eg/prog/igawk.sh
gawk -- '
# przetwarza dyrektywy @@include
@c endfile

@group
@c file eg/prog/igawk.sh
function pathto(file,    i, t, smiec)
@{
    if (index(file, "/") != 0)
        return file

    for (i = 1; i <= ndirs; i++) @{
        t = (pathlist[i] "/" file)
        if ((getline smiec < t) > 0) @{
            # mamy go
            close(t)
            return t
        @}
    @}
    return ""
@}
@c endfile
@end group
@end example

Program główny zawiera się w jednej regule @code{BEGIN}.  Pierwszą
rzeczą, jaką robi, jest zainicjowanie tablicy @code{pathlist}, której
używa @code{pathto}.  Po podziale ścieżki w miejscach @samp{:}, elementy
puste zastępowane są przez @code{"."}, co oznacza katalog bieżący.

@example
@group
@c file eg/prog/igawk.sh
BEGIN @{
    path = ENVIRON["AWKPATH"]
    ndirs = split(path, pathlist, ":")
    for (i = 1; i <= ndirs; i++) @{
        if (pathlist[i] == "")
            pathlist[i] = "."
    @}
@c endfile
@end group
@end example

Stos inicjowany jest wartością @code{ARGV[1]}, którą będzie
@file{/tmp/ig.s.$$}.  Następnie mamy główną pętlę.  Kolejno czytane są
wiersze wejściowe.  Wiersze, które nie rozpoczynają się od @samp{@@include}
wypisywane są dosłownie.

Jeżeli dany wiersz zaczyna się od @samp{@@include}, to nazwa pliku jest
w @code{$2}.  Do utworzenia pełnej ścieżki wywoływana jest @code{pathto}.
Jeśli się to nie powiodło, wypisujemy komunikat o błędzie i kontynuujemy.

Następną rzeczą do sprawdzenia jest to, czy plik został już przez nas
dołączony.  Tablica @code{processed} zaindeksowana jest pełnymi nazwami
każdego dołączonego pliku i zapamiętuje dla nas tę informację.  Jeżeli plik
już obsługiwano, to wypisywany jest komunikat ostrzegawczy.  W przeciwnym
razie, nazwa nowego pliku jest umieszczana na stosie a przetwarzanie
kontynuowane.

Na koniec, gdy @code{getline} napotka koniec pliku wejściowego, plik ten
jest zamykany a ze stosu jest zdejmowana nazwa poprzedniego.
Gdy @code{stackptr} jest mniejsze od zera, to program jest zakończony.

@example
@c @group
@c file eg/prog/igawk.sh
    stackptr = 0
    input[stackptr] = ARGV[1] # ARGV[1] jest pierwszym plikiem

    for (; stackptr >= 0; stackptr--) @{
        while ((getline < input[stackptr]) > 0) @{
            if (tolower($1) != "@@include") @{
                print
                continue
            @}
            fpath = pathto($2)
            if (fpath == "") @{
                printf("igawk:%s:%d: nie można znaleźć %s\n", \
                    input[stackptr], FNR, $2) > "/dev/stderr"
                continue
            @}
@group
            if (! (fpath in processed)) @{
                processed[fpath] = input[stackptr]
                input[++stackptr] = fpath
            @} else
                print $2, "dołączony w", input[stackptr], \
                    "już dołączony w", \
                    processed[fpath] > "/dev/stderr"
        @}
@end group
@group
        close(input[stackptr])
    @}
@}' /tmp/ig.s.$$ > /tmp/ig.e.$$
@end group
@c endfile
@c @end group
@end example

Ostatnim krokiem jest wywołanie @code{gawk} z rozwiniętym programem i
pierwotnymi, podanymi przez użytkownika, opcjami i argumentami wiersza
poleceń.  Kod zakończenia zwrócony przez @code{gawk} odsyłany jest do
programu wywołującego @code{igawk}.

@c this causes more problems than it solves, so leave it out.
@ignore
The special file @file{/dev/null} is passed as a data file to @code{gawk}
to handle an interesting case. Suppose that the user's program only has
a @code{BEGIN} rule, and there are no data files to read. The program should exit without reading any data
files.  However, suppose that an included library file defines an @code{END}
rule of its own. In this case, @code{gawk} will hang, reading standard
input. In order to avoid this, @file{/dev/null} is explicitly to the
command line. Reading from @file{/dev/null} always returns an immediate
end of file indication.

@c Hmm. Add /dev/null if $# is 0?  Still messes up ARGV. Sigh.
@end ignore

@example
@c @group
@c file eg/prog/igawk.sh
eval gawk -f /tmp/ig.e.$$ $opts -- "$@@"

exit $?
@c endfile
@c @end group
@end example

Pokazana wersja @code{igawk} jest moim trzecim podejściem do tego programu.
Oto trzy kluczowe uproszczenia, które spowodowały, że program działa lepiej.

@enumerate
@item
Zastosowanie @samp{@@include} nawet do plików wskazanych przez @samp{-f}
znacznie upraszcza zbudowanie wstępnie poskładanego programu @code{awk}.
Całość przetwarzania @samp{@@include} można wykonać jednokrotnie.

@item
Funkcja @code{pathto} nie usiłuje zapamiętać wiersza odczytanego za pomocą
@code{getline} przy sprawdzaniu dostępności pliku.  Próba zapamiętania tego
wiersza do wykorzystania w programie głównym znacznie komplikuje sprawę.
@c what problem does this engender though - exercise
@c answer, reading from "-" or /dev/stdin

@item
Pętla @code{getline} w regule @code{BEGIN} robi wszystko w jednym
miejscu.  Nie jest konieczne tworzenie osobnej pętli
do przetwarzania zagnieżdżonych instrukcji @samp{@@include}.
@end enumerate

Program ten pokazuje także, że często warto połączyć programowanie
w @code{sh} i @code{awk}.  Zwykle można sporo osiągnąć, bez potrzeby
uciekania się do niskopoziomowego programowania w C czy C++, a często
łatwiej wykonać pewne rodzaje operacji na łańcuchach czy argumentach
korzystając z powłoki niż z @code{awk}.

Wreszcie, @code{igawk} pokazuje, że nie zawsze konieczne jest dodawanie
do programu nowych funkcji: można je często umieścić w wyższej warstwie.
Z @code{igawk} nie ma faktycznego powodu wbudowywania przetwarzania
@samp{@@include} w sam @code{gawk}.

Jako dodatkowy przykład tego, rozważmy pomysł umieszczenia dwu plików
w katalogu ze ścieżki wyszukiwania.

@table @file
@item default.awk
Plik ten zawierałby zbiór domyślnych funkcji bibliotecznych, jak
@code{getopt} i @code{assert}.

@item site.awk
Ten plik zawierałby funkcje biblioteczne swoiste dla danego miejsca
czy  instalacji, tj.@: funkcji opracowanych lokalnie.  Posiadanie osobnego
pliku pozwala na zmianę @file{default.awk} przy nowych edycjach @code{gawk},
bez potrzeby każdorazowej aktualizacji go przez administratora systemu przez
dodawanie funkcji lokalnych.
@end table

Pewien użytkownik
@c Karl Berry, karl@ileaf.com, 10/95
zasugerował zmodyfikowanie @code{gawk} tak, by przy uruchomieniu
automatycznie czytał te pliki.  Zamiast tego, bardzo łatwo byłoby zmienić
@code{igawk}, by to robił.  Ponieważ @code{igawk} potrafi przetwarzać
zagnieżdżone dyrektywy @samp{@@include}, plik @file{default.awk} mógłby po
prostu zawierać instrukcje @samp{@@include} dla żądanych funkcji
bibliotecznych.

@c Exercise: make this change

@node Historia języka, Podsumowanie gawk, Przykładowe programy, Top
@chapter Ewolucja języka @code{awk}

W tej książce opisano implementację GNU narzędzia @code{awk}, przestrzegającą
specyfikacji POSIX.  Wielu użytkowników @code{awk} zna tylko pierwotną
implementację @code{awk} z Unix Version 7.  (Implementacja ta była bazą dla
@code{awk} w Berkeley Unix, aż do 4.3--Reno.  Wydanie 4.4 Berkeley Unix
korzysta z @code{gawk} 2.15.2 jako własnej wersji @code{awk}.)
W tym rozdziale pokrótce opisano ewolucję języka @code{awk}, z odsyłaczami
do innej części książki, gdzie można znaleźć więcej informacji.

@menu
* V7/SVR3.1::                Główne zmiany między V7 a System V Release 3.1.
* SVR4::                     Pomniejsze zmiany między System V Release 3.1
                             a Release 4.
* POSIX::                    Nowe cechy ze standardu POSIX.
* BTL::                      Nowe cechy z wersji @code{awk} z Bell
                             Laboratories.
* POSIX/GNU::                Rozszerzenia w @code{gawk} nie występujące
                             w POSIX @code{awk}.
@end menu

@node V7/SVR3.1, SVR4, Historia języka, Historia języka
@section Główne różnice między V7 a SVR3.1

Język @code{awk} znacząco ewoluował pomiędzy wydaniem Version 7 Unix (1978)
a nową wersją, po raz pierwszy ogólnie dostępną w System V Release 3.1
(1987).  W niniejszej sekcji podsumowano zmiany, z odsyłaczami do
dodatkowych szczegółów.

@itemize @bullet
@item
Wymaganie @samp{;} do rozdzielania reguł w wierszu
(@pxref{Instrukcje/wiersze, ,Instrukcje @code{awk} a wiersze}).

@item
Funkcje definiowane przez użytkownika, instrukcja @code{return}
(@pxref{Użytkownika, ,Funkcje użytkownika}).

@item
Instrukcja @code{delete} (@pxref{Delete, ,Instrukcja @code{delete}}).

@item
Instrukcja @code{do}-@code{while}
(@pxref{Instrukcja do, ,Instrukcja @code{do}-@code{while}}).

@item
Funkcje wbudowane @code{atan2}, @code{cos}, @code{sin}, @code{rand} i
@code{srand} (@pxref{Funkcje numeryczne, ,Wbudowane funkcje numeryczne}).

@item
Funkcje wbudowane @code{gsub}, @code{sub} i @code{match}
(@pxref{Funkcje łańcuchowe, ,Funkcje wbudowane działające na łańcuchach}).

@item
Funkcje wbudowane @code{close} i @code{system}
(@pxref{Funkcje I/O, ,Wbudowane funkcje wejścia/wyjścia}).

@item
Zmienne wbudowane @code{ARGC}, @code{ARGV}, @code{FNR}, @code{RLENGTH},
@code{RSTART} i @code{SUBSEP} (@pxref{Zmienne wbudowane}).

@item
Wyrażenie warunkowe stosujące operator trójargumentowy @samp{?:}
(@pxref{Wyrażenia warunkowe, ,Wyrażenia warunkowe}).

@item
Operator potęgowania @samp{^}
(@pxref{Operatory arytmetyczne, ,Operatory arytmetyczne}) i odpowiadająca mu
postać operatora przypisania @samp{^=}
(@pxref{Operatory przypisania, ,Wyrażenia przypisania}).

@item
Priorytet operatorów zgodny z C, co psuje niektóre stare programy @code{awk}
(@pxref{Priorytet, , Priorytet operatorów)}).

@item
Wyrażenia regularne jako wartość @code{FS}
(@pxref{Separatory pól, ,Jak rozdzielać pola}), i jako trzeci argument
funkcji @code{split}
(@pxref{Funkcje łańcuchowe, ,Funkcje wbudowane działające na łańcuchach}).

@item
Dynamiczne wyrażenia regularne jako operandy operatorów @samp{~} i @samp{!~}
(@pxref{Używanie regexp, , Jak stosować wyrażenia regularne}).

@item
Sekwencje specjalne @samp{\b}, @samp{\f} i @samp{\r}
(@pxref{Sekwencje specjalne}).
(Niektórzy producenci zaktualizowali swoje stare wersje @code{awk} tak, by
rozpoznawały @samp{\r}, @samp{\b}, and @samp{\f}, ale nie jest to coś, na
czym można polegać.)

@item
Przekierowanie wejścia funkcji @code{getline}
(@pxref{Getline, ,Odczyt bezpośredni przez @code{getline}}).

@item
Wiele reguł @code{BEGIN} i @code{END}
(@pxref{BEGIN/END, ,Wzorce specjalne @code{BEGIN} i @code{END}}).

@item
Tablice wielowymiarowe
(@pxref{Wielowymiarowe, ,Tablice wielowymiarowe}).
@end itemize

@node SVR4, POSIX, V7/SVR3.1, Historia języka
@section Różnice między SVR3.1 a SVR4

@cindex język @code{awk}, wersja V.4
W uniksowej wersji @code{awk} z System V Release 4 wersja dodano takie
funkcje (część z nich została zapoczątkowana w @code{gawk}):

@itemize @bullet
@item
Zmienna @code{ENVIRON} (@pxref{Zmienne wbudowane}).

@item
Wiele opcji @samp{-f} w wierszu poleceń
(@pxref{Opcje, ,Opcje wiersza poleceń}).

@item
Opcja @samp{-v} do przypisywania zmiennych przed rozpoczęciem wykonywania
programu (@pxref{Opcje, ,Opcje wiersza poleceń}).

@item
Opcja @samp{--} do kończenia opcji wiersza poleceń.

@item
Sekwencje specjalne @samp{\a}, @samp{\v} i @samp{\x}
(@pxref{Sekwencje specjalne}).

@item
Zdefiniowana wartość zwracana przez funkcję wbudowaną @code{srand}
(@pxref{Funkcje numeryczne, ,Wbudowane funkcje numeryczne}).

@item
Wbudowane funkcje łańcuchowe @code{toupper} i @code{tolower}
do konwersji wielkości liter
(@pxref{Funkcje łańcuchowe, ,Funkcje wbudowane działające na łańcuchach}).

@item
Jaśniejsza specyfikacja @samp{%c}, litery sterującej formatem funkcji
@code{printf} (@pxref{Litery sterujące, ,Litery sterujące formatem}).

@item
Możliwość dynamicznego przekazywania szerokości pola i dokładności
(@code{"%*.*d"}) w liście argumentów funkcji @code{printf}
(@pxref{Litery sterujące, ,Litery sterujące formatem}).

@item
Stosowanie stałych wyrażeń regularnych, jak @code{/foo/}, jako wyrażeń,
równoważnych użyciu operatora dopasowania, jak w @samp{$0 ~ /foo/}
(@pxref{Używanie stałych regexp, ,Używanie stałych regexp}).
@end itemize

@node POSIX, BTL, SVR4, Historia języka
@section Różnice między SVR4 a POSIX @code{awk}

W POSIX-owym standardzie języka poleceń i narzędzi (Command Language and
Utilities) wprowadzono następujące zmiany do języka @code{awk}:

@itemize @bullet
@item
Użycie @samp{-W} dla opcji zależnych od implementacji.

@item
Zastosowanie @code{CONVFMT} do sterowania konwersją liczb na łańcuchy
(@pxref{Konwersja, ,Konwersja łańcuchów i liczb}).

@item
Pojęcie łańcucha liczbowego, i ściślejsze reguły porównań z tym związane
(@pxref{Typy i porównania, ,Typy zmiennych i wyrażenia porównania}).

@item
Pełniejsze udokumentowanie wielu uprzednio nieudokumentowanych cech języka.
@end itemize

Poniższe popularne rozszerzenia nie są dozwolone przez standard POSIX:

@c IMPORTANT! Keep this list in sync with the one in node Options

@itemize @bullet
@item
Nie są rozpoznawane sekwencje specjalne @code{\x}
(@pxref{Sekwencje specjalne}).

@item
Znaki nowej linii nie działają jak białe znaki do oddzielania pól
gdy @code{FS} jest równe pojedynczej spacji.

@item
Nie jest rozpoznawany synonim @code{func} słowa kluczowego @code{function}
(@pxref{Składnia definicji, ,Składnia definicji funkcji}).

@item
Nie można używać operatorów @samp{**} i @samp{**=} zamiast @samp{^} i
@samp{^=} (@pxref{Operatory arytmetyczne, ,Operatory arytmetyczne}, a także
@pxref{Operatory przypisania, ,Wyrażenia przypisania}).

@item
Podanie @samp{-Ft} w wierszu poleceń nie nadaje @code{FS} wartości
pojedynczej tabulacji (@pxref{Separatory pól, ,Jak rozdzielać pola}).

@item
Nie jest obsługiwana funkcja wbudowana @code{fflush}
(@pxref{Funkcje I/O, , Wbudowane funkcje wejścia/wyjścia}).
@end itemize

@node BTL, POSIX/GNU, POSIX, Historia języka
@section Rozszerzenia w @code{awk} z Bell Laboratories

@cindex Kernighan, Brian
Brian Kernighan, jeden z pierwotnych projektantów uniksowego @code{awk},
udostępnił swoją wersję przez anonimowe @code{ftp}
(@pxref{Inne wersje, ,Inne swobodnie dostępne implementacje @code{awk}}).
Opisujemy tu te rozszerzenia w jego wersji @code{awk}, które nie występują
w POSIX-owym @code{awk}.

@itemize @bullet
@item
Opcje wiersza poleceń @samp{-mf @var{NNN}} i @samp{-mr @var{NNN}} do
ustawiania, odpowiednio, maksymalnej liczby pól i maksymalnego rozmiaru
rekordu (@pxref{Opcje, ,Opcje wiersza poleceń}).

@item
Funkcja wbudowana @code{fflush} do opróżniania buforowanego wyjścia
(@pxref{Funkcje I/O, ,Wbudowane funkcje wejścia/wyjścia}).

@ignore
@item
Tablica @code{SYMTAB}, która pozwla na dostęp do wewnętrznej tablicy symboli
@code{awk}. Cecha ta nie jest udokumentowana, głównie dlatego, że jest
zaimplementowana nieco niepewnie.  Na przykład, nie można poprzez nią
     somewhat shakily implemented.
sięgnąć do tablic czy elementów tablic.
@end ignore
@end itemize

@node POSIX/GNU, , BTL, Historia języka
@section Rozszerzenia @code{gawk} poza POSIX @code{awk}

@cindex tryb zgodności
@cindex zgodności, tryb
Implementacja GNU, @code{gawk}, dodaje wiele możliwości.
W tej sekcji opisano je w kolejności, w jakiej były dodawane do @code{gawk}.
Można je wyłączyć za pomocą opcji albo @samp{--traditional}
albo @samp{--posix} (@pxref{Opcje, ,Opcje wiersza poleceń}).

W wersji 2.10 @code{gawk} wprowadzono takie cechy:

@itemize @bullet
@item
Zmienna środowiska @code{AWKPATH} do określania ścieżki wyszukiwania dla
opcji @samp{-f} wiersza poleceń (@pxref{Opcje, ,Opcje wiersza poleceń}).

@item
Zmienna @code{IGNORECASE} i jej skutki
(@pxref{Wielkość liter, ,Wielkość liter w dopasowaniach}).

@item
Interpretacja nazw plików @file{/dev/stdin}, @file{/dev/stdout},
@file{/dev/stderr} i @file{/dev/fd/@var{n}}
(@pxref{Pliki specjalne, ,Specjalne nazwy plików w @code{gawk}}).
@end itemize

W wersji 2.13 @code{gawk} wprowadzono takie cechy:

@itemize @bullet
@item
Zmienna @code{FIELDWIDTHS} i jej skutki
(@pxref{Stały rozmiar, ,Czytanie danych o stałej szerokości}).

@item
Funkcje wbudowane @code{systime} i @code{strftime} do uzyskiwania i
wypisywania znaczników czasu
(@pxref{Funkcje czasu, ,Funkcje obsługi znaczników czasu}).

@item
Opcja @samp{-W lint} do podawania kodu źródłowego i kontroli przenośności
i błędów wykonania (@pxref{Opcje, ,Opcje wiersza poleceń}).

@item
Opcja @samp{-W compat} do wyłączania tych rozszerzeń
(@pxref{Opcje, ,Opcje wiersza poleceń}).

@item
Opcja @samp{-W posix} do uzyskiwania pełnej zgodności z POSIX
(@pxref{Opcje, ,Opcje wiersza poleceń}).
@end itemize

W wersji 2.14 @code{gawk} wprowadzono takie cechy:

@itemize @bullet
@item
Instrukcja @code{next file} do przechodzenia do następnego pliku
danych (@pxref{Instrukcja nextfile, ,Instrukcja @code{nextfile}}).
@end itemize

W wersji 2.15 @code{gawk} wprowadzono takie cechy:

@itemize @bullet
@item
Zmienna @code{ARGIND}, zapamiętująca przemieszczanie się @code{FILENAME}
przez @code{ARGV} (@pxref{Zmienne wbudowane}).

@item
Zmienna @code{ERRNO}, która zawiera komunikat o błędzie systemowym gdy
@code{getline} zwróci @minus{}1 lub zawiedzie @code{close}
(@pxref{Zmienne wbudowane}).

@item
Możliwość stosowania długich nazw opcji w stylu GNU, rozpoczynających się
od @samp{--} (@pxref{Opcje, ,Opcje wiersza poleceń}).

@item
Opcja @samp{--source} do przeplatania kodu źródłowego z wiersza poleceń i
plików bibliotecznych (@pxref{Opcje, ,Opcje wiersza poleceń}).

@item
Interpretacja nazw plików @file{/dev/pid}, @file{/dev/ppid},
@file{/dev/pgrpid} i @file{/dev/user}
(@pxref{Pliki specjalne, ,Specjalne nazwy plików w @code{gawk}}).
@end itemize

W wersji 3.0 @code{gawk} wprowadzono takie cechy:

@itemize @bullet
@item
Instrukcja @code{next file} stała się @code{nextfile}
(@pxref{Instrukcja nextfile, ,Instrukcja @code{nextfile}}).

@item
Opcja @samp{--lint-old}, ostrzegająca o konstrukcjach, które nie są dostępne
w pierwotnej wersji @code{awk} z Version 7 Unix
(@pxref{V7/SVR3.1, , Główne różnice między V7 a SVR3.1}).

@item
Dodano opcję @samp{--traditional} jako lepszą nazwę dla
@samp{--compat} (@pxref{Opcje, ,Opcje wiersza poleceń}).

@item
Możliwość, by @code{FS} było łańcuchem pustym, również trzeci argument
@code{split} może być łańcuchem pustym
(@pxref{Pola jednoznakowe, , Jak z każdego znaku zrobić osobne pole}).

@item
Możliwość, by @code{RS} było wyrażeniem regularnym
(@pxref{Rekordy, , Jak wejście dzielone jest na rekordy}).

@item
Zmienna @code{RT}
(@pxref{Rekordy, , Jak wejście dzielone jest na rekordy}).

@item
Funkcja @code{gensub} do efektywniejszego operowania na tekście
(@pxref{Funkcje łańcuchowe, , Funkcje wbudowane działające na łańcuchach}).

@item
Funkcja @code{strftime} uzyskała domyślny format czasu, pozwalający na
wywoływanie jej bez argumentów
(@pxref{Funkcje czasu,  , Funkcje obsługi znaczników czasu}).

@item
Pełna obsługa zarówno wyrażeń regularnych POSIX, jak i GNU
(@pxref{Regexp, , Regular Expressions}).

@item
Opcja @samp{--re-interval} do udostępniania wyrażeń przedziałowych
w wyrażeniach regularnych
(@pxref{Operatory regexp, , Operatory wyrażeń regularnych}).

@item
Zmienione @code{IGNORECASE}, obecnie stosowane zarówno tak do porównań
łańcuchów jak i operacji na wyrażeniach regularnych.
(@pxref{Wielkość liter, ,Wielkość liter w dopasowaniach}).

@item
Opcja @samp{-m} i funkcja @code{fflush} z wersji @code{awk}
z Bell Labs research
(@pxref{Opcje, ,Opcje wiersza poleceń}; także
@pxref{Funkcje I/O, ,Wbudowane funkcje wejścia/wyjścia}).

@item
Użycie GNU Autoconf do sterowania procesem konfiguracji
(@pxref{Szybka instalacja, , Kompilowanie @code{gawk} dla Uniksa}).

@item
Obsługa Amigi
(@pxref{Instalacja na Amidze, ,Instalowanie @code{gawk} na Amidze}).

@c XXX ADD MORE STUFF HERE

@end itemize

@node Podsumowanie gawk, Instalacja, Historia języka, Top
@appendix Podsumowanie @code{gawk}

Ten dodatek zawiera krótkie podsumowanie wiersza poleceń @code{gawk}
i języka @code{awk}.  Ma zadanie służyć jako ``skrócona instrukcja''.
Z tego powodu jest zwięzły, ale kompletny.

@menu
* Podsumowanie wiersza poleceń::  Streszczenie wiersza poleceń.
* Podsumowanie języka::           Zwięzły przegląd języka.
* Zmienne/Pola::                  Zmienne, pola i tablice.
* Podsumowanie reguł::            Wzorce i akcje, i ich części składowe.
* Podsumowanie akcji::            Krótki przegląd akcji.
* Podsumowanie funkcji::          Definiowanie i wywoływanie funkcji.
* Cechy historyczne::             Nieudokumentowane, ale obsługiwane
                                  ``możliwości''.
@end menu

@node Podsumowanie wiersza poleceń, Podsumowanie języka, Podsumowanie gawk, Podsumowanie gawk
@appendixsec Podsumowanie opcji wiersza poleceń

Wiersz poleceń składa się z opcji przeznaczonych dla samego @code{gawk},
tekstu programu @code{awk} (jeśli nie podano go przez opcję @samp{-f})
i wartości, jakie mają być udostępnione w predefiniowanych zmiennych
@code{ARGC} i @code{ARGV}:

@example
gawk @r{[@var{opcje w stylu POSIX lub GNU}]} -f @var{plik-źródł} @r{[@code{--}]} @var{plik} @dots{}
gawk @r{[@var{opcje w stylu POSIX lub GNU}]} @r{[@code{--}]} '@var{program}' @var{plik} @dots{}
@end example

Opcje, które akceptuje @code{gawk}:

@table @code
@item -F @var{sp}
@itemx --field-separator @var{sp}
Wykorzystuje @var{sp} jako separator pól (wartość predefiniowanej
zmiennej @code{FS}).

@item -f @var{plik-programu}
@itemx --file @var{plik-programu}
Czyta program źródłowy @code{awk} z pliku @var{plik-programu}, zamiast
z pierwszego argumentu wiersza poleceń.

@item -mf @var{NNN}
@itemx -mr @var{NNN}
Flaga @samp{f} ustala maksymalną liczbę pól, a @samp{r} maksymalny rozmiar
rekordu.  Opcje te są ignorowane przez @code{gawk}, gdyż @code{gawk}
nie ma predefiniowanych ograniczeń. Występują one tylko dla
zachowania zgodności z wersją @code{awk} z Bell Labs research.

@item -v @var{zmn}=@var{wart}
@itemx --assign @var{zmn}=@var{wart}
Przed rozpoczęciem wykonywania programu przypisuje zmiennej @var{zmn}
wartość @var{wart}.

@item -W traditional
@itemx -W compat
@itemx --traditional
@itemx --compat
Stosuje tryb zgodności, w którym rozszerzenia @code{gawk} są wyłączone.

@item -W copyleft
@itemx -W copyright
@itemx --copyleft
@itemx --copyright
Wypisuje na standardowym wyjściu krótką wersję Powszechnej Licencji
Publicznej (GPL) i kończy pracę.  Opcja ta może zniknąć w kolejnych
wersjach @code{gawk}.

@item -W help
@itemx -W usage
@itemx --help
@itemx --usage
Wypisuje na standardowym wyjściu stosunkowo krótkie podsumowanie dostępnych
opcji i kończy pracę.

@item -W lint
@itemx --lint
Daje ostrzeżenia o podejrzanych lub nieprzenośnych konstrukcjach @code{awk}.

@item -W lint-old
@itemx --lint-old
Ostrzega o konstrukcjach niedostępnych w pierwotnej wersji @code{awk}
z Version 7 Unix.

@item -W posix
@itemx --posix
Stosuje tryb zgodności z POSIX, w którym wyłączone są rozszerzenia
@code{gawk} i wprowadzone są dodatkowe ograniczenia.

@item -W re-interval
@itemx --re-interval
Zezwala na wyrażenia przedziałowe
(@pxref{Operatory regexp, , Operatory wyrażeń regularnych}),
w wyrażeniach regularnych.

@item -W source=@var{tekst-programu}
@itemx --source @var{tekst-programu}
Wykorzystuje @var{tekst-programu} jako kod źródłowy programu @code{awk}.
Pozwala na przeplatanie kodu źródłowego z wiersza poleceń z kodem źródłowym
z plików i jest szczególnie przydatna do używania programów z wiersza
poleceń z funkcjami bibliotecznymi.

@item -W version
@itemx --version
Wypisuje na standardowym wyjściu błędów informacje o tym konkretnym
egzemplarzu @code{gawk}.

@item --
Sygnalizuje koniec opcji.  Przydatna, gdy chce się zezwolić, by kolejne
argumenty samego programu @code{awk} zaczynały się od @samp{-}.
Występuje głównie dla spójności z występującymi w POSIX konwencjami
analizy składniowej argumentów.
@end table

Wszelkie inne opcje są zaznaczane jako nieprawidłowe, lecz poza tym są
ignorowane.
@xref{Opcje, ,Opcje wiersza poleceń}, gdzie podano szczegóły.

@node Podsumowanie języka, Zmienne/Pola, Podsumowanie wiersza poleceń, Podsumowanie gawk
@appendixsec Podsumowanie języka

Program @code{awk} składa się z ciągu zera lub więcej instrukcji
wzorzec-akcja i opcjonalnych definicji funkcji.  Albo wzorzec albo akcję
można pominąć.

@example
@var{wzorzec}    @{ @var{instrukcje akcji} @}
@var{wzorzec}
          @{ @var{instrukcje akcji} @}

function @var{nazwa}(@var{lista parametrów})   @{ @var{instrukcje akcji} @}
@end example

@code{gawk} najpierw czyta źródło programu z @var{pliku-programu} (plików),
jeśli takowe podano, lub z pierwszego nie będącego opcją argumentu w wierszu
poleceń.  Opcji @samp{-f} w wierszu poleceń można użyć wielokrotnie.
@code{gawk} czyta tekst programu ze wszystkich plików @var{plik-programu},
w praktyce sklejając je w kolejności, w jakiej je podano.  Przydaje się to
przy konstruowaniu bibliotek funkcji @code{awk}, bez konieczności wpisywania
ich w każdy nowy program @code{awk}, jaki z nich korzysta. Chcąc w programie
wpisanym w wierszu poleceń wykorzystać funkcję biblioteczną z pliku, należy
podać @samp{--source '@var{program}'}, a program wpisać między pojedynczymi
cudzysłowami.  @xref{Opcje, ,Opcje wiersza poleceń}.

Ścieżkę wyszukiwania używaną przy szukaniu plików źródłowych wskazanych
opcją @samp{-f} określa zmienna środowiska @code{AWKPATH}.  Gdy nie
ustawiono @code{AWKPATH}, wykorzystywana jest domyślna ścieżka,
@samp{.:/usr/local/share/awk}@footnote{Ścieżka może korzystać z innego
katalogu niż @file{/usr/local/share/awk}, zależnie od sposobu utworzenia i
instalacji @code{gawk}.}.  Jeśli nazwa pliku podana opcji @samp{-f} zawiera
znak @samp{/}, to nie jest przeprowadzane wyszukiwanie.
@xref{Zmienna AWKPATH, ,Zmienna środowiska @code{AWKPATH}}.

@code{gawk} kompiluje program do postaci wewnętrznej, a następnie przechodzi
do odczytu plików wymienionych w tablicy @code{ARGV}.
Początkowe wartości @code{ARGV} pochodzą od argumentów wiersza poleceń.
Jeżeli w wierszu poleceń nie podano plików, @code{gawk} czyta
standardowe wejście.

Jeśli ``plik'' wskazany w wierszu poleceń ma postać
@samp{@var{zmn}=@var{wart}}, to jest traktowany jak przypisanie do zmiennej:
zmiennej @var{zmn} przypisywana jest wartość @var{wart}.  Jeśli któryś
z plików ma wartość będącą łańcuchem pustym, to ten element listy jest
pomijany.

@code{gawk} sprawdza dla każdego rekordu wejścia, czy pasuje on do jakiegoś
@var{wzorca} w programie @code{awk}.  Dla każdego wzorca, do którego pasuje
rekord, wykonywana jest skojarzona z nim @var{akcja}.

@node Zmienne/Pola, Podsumowanie reguł, Podsumowanie języka, Podsumowanie gawk
@appendixsec Zmienne i pola

Zmienne @code{awk} nie są deklarowane: pojawiają się przy pierwszym użyciu.
Ich wartości są albo liczbami zmiennoprzecinkowymi albo łańcuchami.
@code{awk} posiada także jednowymiarowe tablice; możliwe jest symulowanie
tablic wielowymiarowych.  Istnieje kilkanaście predefiniowanych zmiennych,
inicjowanych przez @code{awk} przy uruchamianiu programu.  Zestawiono
je poniżej.

@menu
* Podsumowanie pól::            Podział na pola wejściowe.
* Podsumowanie wbudowanych::    Zmienne wbudowane @code{awk}.
* Podsumowanie tablic::         Stosowanie tablic.
* Podsumowanie typów danych::   Wartości w @code{awk} są liczbami
                                lub łańcuchami.
@end menu

@node Podsumowanie pól, Podsumowanie wbudowanych, Zmienne/Pola, Zmienne/Pola
@appendixsubsec Pola

W czasie odczytu każdego wiersza wejściowego @code{gawk} dzieli go
na @var{pola}, jako separator pól wykorzystując wartość zmiennej @code{FS}.
Jeżeli @code{FS} jest pojedynczym znakiem, pola oddzielane są przez ten
znak.  W przeciwnym wypadku, oczekuje się, że @code{FS} będzie pełnym
wyrażeniem regularnym.  W przypadku szczególnym, gdy @code{FS} jest
pojedynczą spacją, pola oddzielane są ciągami spacji, tabulacji i/lub znaków
nowej linii.@footnote{W POSIX-owym @code{awk} znaki nowej linii nie
rozdzielają pól.}
Jeżeli @code{FS} jest łańcuchem pustym (@code{""}), to każdy pojedynczy
znak rekordu staje się osobnym polem.
Należy zwrócić uwagę na to, że wartość @code{IGNORECASE}
(@pxref{Wielkość liter, ,Wielkość liter w dopasowaniach})
wpływa również na sposób podziału pól gdy @code{FS} jest wyrażeniem
regularnym.

Do pola wiersza wejściowego odwołujemy się przez jego pozycję, @code{$1},
@code{$2}, i tak dalej.  @code{$0} to cały wiersz.  Polu można też przypisać
nową wartość.  Numery pól nie muszą być stałymi:

@example
n = 5
print $n
@end example

@noindent
wypisuje piąte pole wiersza wejściowego.  Zmiennej @code{NF} przypisywana
jest całkowita liczba pól w wierszu wejściowym.

Odwołania do nie istniejących pól (tj.@: pól po @code{$NF}) zwracają łańcuch
pusty.  Jednak przypisanie do nie istniejącego pola
(np., @code{$(NF+2) = 5}) zwiększa wartość @code{NF}, tworzy ewentualne
pola pośrednie z łańcuchem pustym jako wartością i powoduje przeliczenie
wartości @code{$0}, za pomocą pól rozdzielanych wartością @code{OFS}.
Zmniejszenie @code{NF} powoduje utratę wartości pól za nową wartością
i przeliczenie @code{$0}, za pomocą pól oddzielanych przez @code{OFS}.
@xref{Czytanie plików, ,Czytanie plików wejściowych}.

@node Podsumowanie wbudowanych, Podsumowanie tablic, Podsumowanie pól, Zmienne/Pola
@appendixsubsec Zmienne wbudowane

Zmienne wbudowane @code{gawk}:

@table @code
@item ARGC
Liczba elementów @code{ARGV}. Poniżej podano, co faktycznie wchodzi
do @code{ARGV}.

@item ARGIND
Indeks w @code{ARGV} aktualnie przetwarzanego pliku.  Gdy @code{gawk}
przetwarza wejściowe pliki danych, zawsze prawdziwe jest
@samp{FILENAME == ARGV[ARGIND]}.

@item ARGV
Tablica argumentów wiersza poleceń.  Tablica indeksowana jest od zera
do @code{ARGC} @minus{} 1.  Dzięki dynamicznym zmianom @code{ARGC} i
zawartości @code{ARGV} można sterować plikami wykorzystywanymi jako źródło
danych.  Pusty element w @code{ARGV} jest ignorowany.  @code{ARGV} nie
zawiera opcji @code{awk} ani tekstu samego programu @code{awk}.

@item CONVFMT
Format konwersji używany przy przekształcaniu liczb na łańcuchy.

@item FIELDWIDTHS
Lista rozdzielonych spacjami liczb opisujących dane wejściowe o stałej
szerokości.

@item ENVIRON
Tablica wartości zmiennych środowiska. Indeksowana nazwami zmiennych,
każdy element jest wartością odpowiedniej zmiennej.  Zatem,
dla zmiennej środowiska @code{HOME} mamy @code{ENVIRON["HOME"]}.
Może mieć wartość np. @file{/home/arnold}.

Zmiana tej tablicy nie wpływa na środowisko widziane przez programy
uruchamiane przez @code{gawk} za pośrednictwem przekierowań lub funkcji
@code{system}.  (Może się to zmienić w przyszłych wersjach @code{gawk}.)

Niektóre systemy operacyjne nie posiadają zmiennych środowiska.
Przy pracy w tych systemach tablica @code{ENVIRON} jest pusta.

@item ERRNO
Systemowy komunikat o błędzie gdy przy korzystaniu z @code{getline} lub
@code{close} pojawi się błąd.

@item FILENAME
Nazwa bieżącego pliku wejściowego. Jeżeli w wierszu poleceń nie podano
żadnego pliku, wartością @code{FILENAME} jest łańcuch pusty.

@item FNR
Numer rekordu wejściowego w bieżącym pliku wejściowym.

@item FS
Separator pól wejściowych, domyślnie spacja.

@item IGNORECASE
Flaga rozróżniania wielkości liter w porównywaniach łańcuchów i działaniach
na wyrażeniach regularnych.  Jeżeli @code{IGNORECASE} ma wartość niezerową,
to dopasowywanie wzorców w regułach, podział na rekordy za pomocą @code{RS},
podział na pola za pomocą @code{FS}, dopasowywanie wyrażeń regularnych
za pomocą @samp{~} i @samp{!~} oraz funkcje wbudowane @code{gensub},
@code{gsub}, @code{index}, @code{match}, @code{split} i @code{sub} ignorują
różnice w wielkości liter podczas wykonywania działań na wyrażeniach
regularnych. Ignorowana jest też wielkość liter przy porównywaniu łańcuchów.
Wartość @code{IGNORECASE} @emph{nie} wpływa na indeksowanie tablic.

@item NF
Liczba pól w bieżącym rekordzie wejściowym.

@item NR
Całkowita liczba przeglądniętych do tej pory rekordów wejściowych.

@item OFMT
Format wyjściowy w instrukcji @code{print}, domyślnie @code{"%.6g"}.

@item OFS
Separator pól wyjściowych, domyślnie spacja.

@item ORS
Separator rekordów wyjściowych, domyślnie znak nowej linii.

@item RS
Separator rekordów wejściowych, domyślnie znak nowej linii.
Jeżeli @code{RS} przypisano łańcuch pusty, to rekordy oddzielane są pustymi
wierszami.  Gdy @code{RS} jest łańcuchem pustym, to znak nowej linii zawsze
działa jako separator pól, oprócz podziału wyznaczanego wartością @code{FS}.
Jeżeli @code{RS} jest łańcuchem wieloznakowym, to oznacza wyrażenie
regularne; rekordy rozdzielane są przez tekst pasujący do danego wyrażenia
regularnego.

@item RT
Tekst wejściowy, który pasował do tekstu określonego przez @code{RS},
separator rekordów.

@item RSTART
Indeks pierwszego znaku ostatniego dopasowania wykonanego przez
@code{match}; zero jeśli brak dopasowań.

@item RLENGTH
Długość ostatnio dopasowanego przez @code{match} łańcucha; @minus{}1 jeśli
brak dopasowań.

@item SUBSEP
Łańcuch używany do oddzielania wielu indeksów w elemencie tablicy,
domyślnie @code{"\034"}.
@end table

@xref{Zmienne wbudowane}, gdzie podano szczegóły.

@node Podsumowanie tablic, Podsumowanie typów danych, Podsumowanie wbudowanych, Zmienne/Pola
@appendixsubsec Tablice

Tablice indeksowane są za pomocą wyrażenia w nawiasach kwadratowych
(@samp{[} i @samp{]}).  Indeksy tablicy są @emph{zawsze} łańcuchami: w razie
potrzeby liczby są przekształcane na łańcuchy, zgodnie ze standardowymi
regułami konwersji (@pxref{Konwersja, ,Konwersja łańcuchów i liczb}).

Przy stosowaniu wewnątrz nawiasów kwadratowych kilku wyrażeń oddzielonych
przecinkami indeks tablicy jest łańcuchem powstałym przez złączenie
wartości poszczególnych, zamienionych na łańcuchy, indeksów, oddzielonych
separatorem indeksów (wartością @code{SUBSEP}).

W kontekście warunkowym do sprawdzenia, czy w tablicy jest indeks o zadanej
wartości, można użyć specjalnego operatora @code{in}.

@example
if (wart in tabl)
        print tabl[wart]
@end example

Jeżeli tablica jest wieloindeksowa, do testowania istnienia elementu
wykorzystujemy @samp{(i, j, @dots{})}.

Konstrukcję @code{in} można też stosować w pętli @code{for}, do
przechodzenia kolejno przez wszystkie elementy tablicy.
@xref{Przeglądanie tablic, ,Przeglądanie wszystkich elementów tablicy}.

Element tablicy usuwa się za pomocą instrukcji @code{delete}.

Całą tablicę czyścimy za pomocą @samp{delete @var{tablica}}.

@xref{Tablice, ,Tablice w @code{awk}}.

@node Podsumowanie typów danych,  , Podsumowanie tablic, Zmienne/Pola
@appendixsubsec Typy danych

Wartością wyrażenia @code{awk} jest zawsze albo liczba albo łańcuch.

Niektóre konteksty (jak np. przy operatorach arytmetycznych) wymagają
wartości numerycznych.  Przekształcają one łańcuchy na liczby przez
interpretację tekstu łańcucha jako liczby.  Jeżeli łańcuch nie wygląda jak
liczba, to jest przekształcany na zero.

W innych kontekstach (jak przy konkatenacji) wymagane są wartości łańcuchowe.
Liczby są wówczas zamieniane na łańcuchy, praktycznie poprzez wypisanie ich
przez @code{sprintf}.  @xref{Konwersja, ,Konwersja łańcuchów i liczb},
gdzie podano szczegóły.

W celu wymuszenia konwersji wartości łańcuchowej na liczbę wystarczy po
prostu dodać do niej zero.  Jeżeli wartość, od jakiej zaczynamy jest już
liczbą, nie zmieni jej to.

W celu wymuszenia konwersji wartości numerycznej na łańcuch należy
skleić ją z łańcuchem pustym.

Porównywania dokonywane są numerycznie jeśli oba operandy są numeryczne lub
jeśli jeden jest liczbą a drugi łańcuchem liczbowym.  W przeciwnym razie
jeden lub oba operandy przekształcane są na łańcuchy i wykonywane jest
porównywanie znakowe.  Pola, wejście @code{getline}, @code{FILENAME},
elementy @code{ARGV}, elementy @code{ENVIRON} i elementy tablicy utworzonej
przez @code{split} są jedynymi elementami, które mogą być łańcuchami
liczbowymi.  Stałe łańcuchowe, jak @code{"3.1415927"} nie są łańcuchami
liczbowymi, są stałymi łańcuchowymi.  Pełne zasady porównań opisano
w @ref{Typy i porównania, ,Typy zmiennych i wyrażenia porównania}.

Niezainicjowane zmienne mają wartość łańcuchową @code{""} (łańcuch pusty,
zerowy).  W kontekstach, w których wymagana jest liczba, jest to
równoważne zeru.

@xref{Zmienne}, gdzie szerzej opisano nazywanie i inicjowanie zmiennych;
@pxref{Konwersja, ,Konwersja łańcuchów i liczb}, gdzie szerzej opisano,
jak interpretowane są wartości zmiennych.

@node Podsumowanie reguł, Podsumowanie akcji, Zmienne/Pola, Podsumowanie gawk
@appendixsec Wzorce

@menu
* Podsumowanie wzorców::        Krótki przegląd wzorców.
* Podsumowanie regexp::         Krótki przegląd wyrażeń regularnych.
@end menu

Program @code{awk} w większości złożony jest z reguł, z których każda
składa się ze wzorca i następującej po nim akcji.  Akcja objęta jest znakami
@samp{@{} i @samp{@}}.  Można pominąć wzorzec albo akcję, ale nie oba
równocześnie.  Jeśli pominięto wzorzec, akcja wykonywana jest dla każdego
rekordu wejściowego.  Pominięta akcja jest równoważna
@samp{@w{@{ print @}}}, co wypisuje cały wiersz.

@c These paragraphs repeated for both patterns and actions. I don't
@c like this, but I also don't see any way around it. Update both copies
@c if they need fixing.
Komentarze zaczynają się znakiem @samp{#} i rozciągają się do końca wiersza.
Do oddzielania instrukcji można stosować puste wiersze.  Instrukcje normalnie
kończą się znakiem nowej linii.  Nie obowiązuje to jednak dla wierszy, na
końcu których występują @samp{,}, @samp{@{}, @samp{?}, @samp{:}, @samp{&&}
lub @samp{||}.  Instrukcje wierszy kończących się na @code{do} lub
@code{else} również są automatycznie kontynuowane w następnym wierszu.
W pozostałych przypadkach wiersz można kontynuować kończąc go znakiem
@samp{\}; wówczas znak nowej linii jest ignorowany.

W jednym wierszu można umieścić kilka instrukcji oddzielając je od siebie
średnikiem @samp{;}.  Odnosi się to zarówno do instrukcji wewnątrz
części reguły definiującej akcję (zwykły przypadek), jak i do instrukcji
reguł.

@xref{Komentarze, ,Komentarze w programach @code{awk}}, gdzie opisano
konwencję komentarzy w @code{awk};

@pxref{Instrukcje/wiersze, ,Instrukcje @code{awk} a wiersze}, gdzie podano
opis mechanizmu kontynuacji linii w @code{awk}.

@node Podsumowanie wzorców, Podsumowanie regexp, Podsumowanie reguł, Podsumowanie reguł
@appendixsubsec Podsumowanie wzorców

Wzorzec @code{awk} może być jednym z poniższych:

@example
/@var{wyrażenie regularne}/
@var{wyrażenie relacyjne}
@var{wzorzec} && @var{wzorzec}
@var{wzorzec} || @var{wzorzec}
@var{wzorzec} ? @var{wzorzec} : @var{wzorzec}
(@var{wzorzec})
! @var{wzorzec}
@var{wzorzec1}, @var{wzorzec2}
BEGIN
END
@end example

@code{BEGIN} i @code{END} to dwa specjalne rodzaje wzorców, z którymi nie
jest porównywane wejście.  Akcje wszystkich reguł @code{BEGIN} są łączone
tak, jakby wszystkie ich instrukcje zapisano w pojedynczej regule
@code{BEGIN}.  Są one wykonywane przed rozpoczęciem odczytu wejścia.
Podobnie sklejane są wszystkie reguły @code{END}.  Wykonywane są po
wyczerpaniu całości wejścia (lub gdy wykonywana jest instrukcja @code{exit}).
Wzorce @code{BEGIN} i @code{END} nie mogą być łączone z innymi
wzorcami w pokazanych wyżej wyrażeniach wzorca.
Dla @code{BEGIN} i @code{END} nie można pominąć akcji.

Przy wzorcu @code{/}@var{wyrażenie-regularne}@code{/} skojarzona z nim
instrukcja wykonywana jest dla każdego rekordu wejściowego pasującego do
danego wyrażenia regularnego.  Wyrażenia regularne podsumowano poniżej.

@var{wyrażenie relacyjne} może wykorzystywać dowolny z operatorów
zdefiniowanych poniżej w sekcji o akcjach.  Ogólnie mówiąc, sprawdza,
czy pewne pola pasują do pewnych wyrażeń regularnych.

Operatory @samp{&&}, @samp{||} i @samp{!} są odpowiednio logicznym ``and'',
``or'' i ``not'', jak w C.  Wykonują skrócone wyznaczanie wartości, również
jak w C, i są stosowane do łączenia prostszych wyrażeń wzorców.
Jak w większości języków, do zmiany kolejności obliczeń można użyć nawiasów.

Operator @samp{?:} jest taki sam jak w C.  Jeżeli pasuje pierwszy wzorzec,
to rekord wejściowy dopasowywany jest do drugiego wzorca; w przeciwnym
razie, do trzeciego.  Dopasowanie jest wykonywane albo do drugiego albo do
trzeciego wzorca.

Postać @samp{@var{wzorzec1}, @var{wzorzec2}} wzorca zwana jest wzorcem
zakresu.  Dopasowuje wszystkie wiersze wejściowe począwszy od wiersza
pasującego do @var{wzorzec1} aż do wiersza pasującego do @var{wzorzec2}
włącznie.  Wzorzec zakresu nie może być używany jako operand jakiegokolwiek
operatora wzorców.

@xref{Przegląd wzorców, ,Elementy wzorców}.

@node Podsumowanie regexp, , Podsumowanie wzorców, Podsumowanie reguł
@appendixsubsec Wyrażenia regularne

Wyrażenia regularne oparto na POSIX-owych EREs (extended regular expressions
-- rozszerzonych wyrażeniach regularnych).  Sekwencje specjalne dozwolone
w stałych łańcuchowych są również poprawne w wyrażeniach regularnych
(@pxref{Sekwencje specjalne}).  Wyrażenia regularne złożone są ze znaków
w następujący sposób:

@table @code
@item @var{c}
dopasowuje znak @var{c} (zakładając, że @var{c} nie jest żadnym ze znaków
wymienionych niżej).

@item \@var{c}
dopasowuje dosłowny znak @var{c}.

@item .
dopasowuje dowolny znak, @emph{łącznie} ze znakiem nowej linii.
W trybie ścisłej zgodności z POSIX @samp{.} nie dopasowuje znaku @sc{nul},
czyli znaku o wszystkich bitach równych zero.

@item ^
dopasowuje początek łańcucha.

@item $
dopasowuje koniec łańcucha.

@item [@var{abc}@dots{}]
dopasowuje dowolny ze znaków @var{abc}@dots{} (lista znaków).

@item [[:@var{klasa}:]]
dopasowuje dowolny znak z klasy znaków @var{klasa}.  Dostępnymi klasami są
@code{alnum}, @code{alpha}, @code{blank}, @code{cntrl}, @code{digit},
@code{graph}, @code{lower}, @code{print}, @code{punct}, @code{space},
@code{upper} i @code{xdigit}.

@item [[.@var{symbol}.]]
dopasowuje wieloznakowy symbol porządkowania leksykograficznego @var{symbol}.
@code{gawk} nie obsługuje obecnie symboli porządkowania (collating symbols).

@item [[=@var{nazwaklasy}=]]
dopasowuje dowolny z równoważnych znaków z bieżącego ustawienia locale,
wskazanego klasą równoważności @var{nazwaklasy}.
@code{gawk} nie obsługuje obecnie klas równoważności.

@item [^@var{abc}@dots{}]
dopasowuje dowolny znak oprócz @var{abc}@dots{} (dopełniająca lista znaków).

@item @var{r1}|@var{r2}
dopasowuje @var{r1} lub @var{r2} (alternatywa).

@item @var{r1r2}
dopasowuje @var{r1}, a następnie @var{r2} (złączenie).

@item @var{r}+
dopasowuje jeden lub więcej @var{r}.

@item @var{r}*
dopasowuje zero lub więcej @var{r}.

@item @var{r}?
dopasowuje zero lub jeden @var{r}.

@item (@var{r})
dopasowuje @var{r} (grupowanie).

@item @var{r}@{@var{n}@}
@itemx @var{r}@{@var{n},@}
@itemx @var{r}@{@var{n},@var{m}@}
dopasowuje co najmniej @var{n}, @var{n} lub więcej, albo @var{n} do @var{m}
wystąpień @var{r} (wyrażenia przedziałowe).

@item \y
dopasowuje łańcuch pusty albo na początku albo na końcu słowa.

@item \B
dopasowuje łańcuch pusty wewnątrz słowa.

@item \<
dopasowuje pusty łańcuch na początku słowa.

@item \>
dopasowuje pusty łańcuch na końcu słowa.

@item \w
dopasowuje dowolny ze znaków tworzących wyrazy (znaki alfanumeryczne i znak
podkreślenia).

@item \W
dopasowuje dowolny znak nie będący znakiem współtworzącym słowa.

@item \`
dopasowuje łańcuch pusty na początku bufora (w @code{gawk} to samo, co
łańcuch).

@item \'
dopasowuje łańcuch pusty na końcu bufora.
@end table

O tym, jak @code{gawk} interpretuje znaki w wyrażeniach regularnych,
decydują rozmaite opcje wiersza poleceń.

@c NOTE!!! Keep this in sync with the same table in the regexp chapter!
@table @asis
@item bez opcji
W przypadku domyślnym @code{gawk} udostępnia wszystkie udogodnienia
POSIX-owych wyrażeń regularnych i operatorów GNU opisane powyżej.
Jednak wyrażenia przedziałowe nie są obsługiwane.

@item @code{--posix}
Obsługiwane są tylko wyrażenia regularne POSIX, operatory GNU nie mają
specjalnego znaczenia (np., @samp{\w} dopasowuje dosłowne @samp{w}).
Wyrażenia przedziałowe są dozwolone.

@item @code{--traditional}
Dopasowywane są wyrażenia regularne tradycyjnego uniksowego @code{awk}.
Operatory GNU nie mają znaczenia specjalnego, nie są dostępne wyrażenia
przedziałowe ani POSIX-owe klasy znaków (@code{[[:alnum:]]} i tak dalej).
Znaki opisane ósemkowymi i szesnastkowymi sekwencjami specjalnymi traktowane
są dosłownie, nawet jeśli reprezentują metaznaki wyrażeń regularnych.

@item @code{--re-interval}
Dopuszcza wyrażenia przedziałowe w wyrażeniach regularnych, nawet jeśli
podano @samp{--traditional}.
@end table

@xref{Regexp, ,Regular Expressions}.

@node Podsumowanie akcji, Podsumowanie funkcji, Podsumowanie reguł, Podsumowanie gawk
@appendixsec Akcje

Instrukcje akcji objęte są nawiasami klamrowymi @samp{@{} i @samp{@}}.
Pominięta akcja jest równoważna @samp{@w{@{ print @}}}.

Instrukcje akcji składają się z typowych instrukcji: przypisania,
instrukcji warunkowych i pętli, jakie można znaleźć w większości języków.
Dostępne operatory, instrukcje sterujące i instrukcje wejścia/wyjścia są
podobne do występujących w C.

@c These paragraphs repeated for both patterns and actions. I don't
@c like this, but I also don't see any way around it. Update both copies
@c if they need fixing.
Komentarze zaczynają się znakiem @samp{#} i rozciągają się do końca wiersza.
Do oddzielania instrukcji można stosować puste wiersze.  Instrukcje normalnie
kończą się znakiem nowej linii.  Nie obowiązuje to jednak dla wierszy, na
końcu których występują @samp{,}, @samp{@{}, @samp{?}, @samp{:}, @samp{&&}
lub @samp{||}.  Instrukcje wierszy kończących się na @code{do} lub
@code{else} również są automatycznie kontynuowane w następnym wierszu.
W pozostałych przypadkach wiersz można kontynuować kończąc go znakiem
@samp{\}; wówczas znak nowej linii jest ignorowany.

W jednym wierszu można umieścić kilka instrukcji oddzielając je od siebie
średnikiem @samp{;}.  Odnosi się to zarówno do instrukcji wewnątrz
części reguły definiującej akcję (zwykły przypadek), jak i do instrukcji
reguł.

@xref{Komentarze, ,Komentarze w programach @code{awk}}, gdzie opisano
konwencję komentarzy w @code{awk};

@pxref{Instrukcje/wiersze, ,Instrukcje @code{awk} a wiersze}, gdzie podano
opis mechanizmu kontynuacji linii w @code{awk}.

@menu
* Podsumowanie operatorów::           Operatory @code{awk}.
* Podsumowanie sterowania::           Instrukcje sterujące.
* Podsumowanie I/O::                  Instrukcje wejścia/wyjścia.
* Podsumowanie printf::               Podsumowanie @code{printf}.
* Podsumowanie plików specjalnych::   Interpretowane wewnętrznie specjalne
                                      nazwy plików.
* Podsumowanie funkcji wbudowanych::  Wbudowane funkcje numeryczne
                                      i łańcuchowe.
* Podsumowanie funkcji czasu::        Wbudowane funkcje czasu.
* Podsumowanie stałych łańcuchowych:: Sekwencje specjalne w łańcuchach.
@end menu

@node Podsumowanie operatorów, Podsumowanie sterowania, Podsumowanie akcji, Podsumowanie akcji
@appendixsubsec Operatory

Operatory w @code{awk}, w kolejności malejącego priorytetu:

@table @code
@item (@dots{})
Grupowanie.

@item $
Odwołanie do pola.

@item ++ --
Inkrementacja i dekrementacja, zarówno przedrostkowa jak i przyrostkowa.

@item ^
Potęgowanie (można też używać @samp{**}, a @samp{**=} do operatora
przypisania, ale nie są one wymienione w standardzie POSIX).

@item + - !
Jednoargumentowy plus, jednoargumentowy minus i negacja logiczna.

@item * / %
Mnożenie, dzielenie, reszta z dzielenia (modulo).

@item + -
Dodawanie i odejmowanie.

@item @var{space}
Konkatenacja łańcuchów.

@item < <= > >= != ==
Zwyczajowe operatory relacyjne.

@item ~ !~
Dopasowanie wyrażenia regularnego, zaprzeczone dopasowanie.

@item in
Przynależność do tablicy.

@item &&
Koniunkcja logiczna (``and'').

@item ||
Alternatywa logiczna (``or'').

@item ?:
Wyrażenie warunkowe.  Ma postać @samp{@var{wyr1} ? @var{wyr2} : @var{wyr3}}.
Jeżeli @var{wyr1} jest prawdziwe, to wartością wyrażenia jest @var{wyr2},
w przeciwnym razie @var{wyr3}.  Obliczane jest tylko jedno spośród
@var{wyr2} i @var{wyr3}.

@item = += -= *= /= %= ^=
Przypisanie.  Obsługiwane jest zarówno przypisanie bezpośrednie
(@code{@var{zmn}=@var{wartość}}) jak i przypisanie operatorowe (pozostałe
formy).
@end table

@xref{Wyrażenia}.

@node Podsumowanie sterowania, Podsumowanie I/O, Podsumowanie operatorów, Podsumowanie akcji
@appendixsubsec Instrukcje sterujące

Mamy następujące instrukcje sterujące:

@example
if (@var{warunek}) @var{instrukcja} @r{[} else @var{instrukcja} @r{]}
while (@var{warunek}) @var{instrukcja}
do @var{instrukcja} while (@var{warunek})
for (@var{wyr1}; @var{wyr2}; @var{wyr3}) @var{instrukcja}
for (@var{zmn} in @var{tabl}) @var{instrukcja}
break
continue
delete @var{tabl}[@var{indeks}]
delete @var{tabl}
exit @r{[} @var{wyrażenie} @r{]}
@{ @var{instrukcje} @}
@end example

@xref{Instrukcje, ,Instrukcje sterujące w akcjach}.

@node Podsumowanie I/O, Podsumowanie printf, Podsumowanie sterowania, Podsumowanie akcji
@appendixsubsec Instrukcje wejścia/wyjścia

Mamy następujące instrukcje wejścia/wyjścia:

@table @code
@item getline
Pobiera @code{$0} z kolejnego rekordu wejściowego; nadaje
wartości @code{NF}, @code{FNR} i @code{NR}.
@xref{Getline, ,Odczyt bezpośredni przez @code{getline}}.

@item getline <@var{plik}
Pobiera @code{$0} z kolejnego rekordu @var{pliku}; nadaje
wartość @code{NF}.

@item getline @var{zmn}
Pobiera @code{zmn} z kolejnego rekordu wejściowego; nadaje wartości
@code{NR}, @code{FNR}.

@item getline @var{zmn} <@var{plik}
Pobiera @code{zmn} z kolejnego rekordu @var{pliku}.

@item @var{polecenie} | getline
Uruchamia @var{polecenie}, przesyłając potokiem jego wyjście do
@code{getline}; nadaje wartości @code{$0}, @code{NF}, @code{NR}.

@item @var{polecenie} | getline @code{zmn}
Uruchamia @var{polecenie}, przesyłając potokiem jego wyjście do
@code{getline}; nadaje wartość @var{zmn}.

@item next
Przerywa przetwarzanie aktualnego rekordu wejściowego.  Czytany jest
następny rekord a przetwarzanie zaczyna się ponownie od pierwszego
wzorca programu @code{awk}.  Jeżeli osiągnięto koniec danych wejściowych,
wykonywane są reguły (reguła) @code{END}, jeśli istnieją.
@xref{Instrukcja next, ,Instrukcja @code{next}}.

@item nextfile
Przerywa przetwarzanie bieżącego pliku wejściowego.  Następny czytany rekord
wejściowy pochodzi z kolejnego pliku wejściowego.  Aktualizowane jest
@code{FILENAME}, @code{FNR} otrzymuje wartość jeden, zwiększa się
@code{ARGIND}, a przetwarzanie zaczyna się ponownie od pierwszego wzorca
programu @code{awk}.  Jeżeli osiągnięto koniec danych wejściowych,
wykonywane są reguły (reguła) @code{END}, jeśli istnieją.  Wcześniejsze
wersje @code{gawk} stosowały @samp{next file}; składnia ta jest nadal
obsługiwana, ale uważana za niezalecaną.
@xref{Instrukcja next, ,Instrukcja @code{next}}.

@item print
Wypisuje bieżący rekord wejściowy.
@xref{Wypisywanie, ,Wypisywanie wyników}.

@item print @var{lista-wyr}
Wypisuje wyrażenia.

@item print @var{lista-wyr} > @var{plik}
Wypisuje wyrażenia do @var{pliku}. Jeśli @var{plik} nie istnieje, jest
tworzony.  Jeśli istnieje, za pierwszym razem, gdy wykonywane jest
@code{print}, jego zawartość jest usuwana.

@item print @var{lista-wyr} >> @var{plik}
Wypisuje wyrażenia do @var{pliku}.  Poprzednia zawartość @var{pliku}
pozostaje zachowana, a wyjście @code{print} jest dopisywane do pliku.

@item print @var{lista-wyr} | @var{polecenie}
Wypisuje wyrażenia, wysyłając wyjście potokiem do @var{polecenia}.
Potok do polecenia pozostaje otwarty do momentu wywołania funkcji
@code{close}.

@item printf @var{fmt}, @var{lista-wyr}
Formatuje i wypisuje.

@item printf @var{fmt}, @var{lista-wyr} > @var{plik}
Formatuje i wypisuje do @var{pliku}. Jeśli @var{plik} nie
istnieje, jest tworzony.  Jeśli istnieje, za pierwszym razem, gdy wykonywane
jest @code{printf}, jego zawartość jest usuwana.

@item printf @var{fmt}, @var{lista-wyr} >> @var{plik}
Formatuje i wypisuje do @var{pliku}.  Poprzednia zawartość
@var{pliku} pozostaje zachowana, a wyjście @code{printf} jest dopisywane do
pliku.

@item printf @var{fmt}, @var{lista-wyr} | @var{polecenie}
Formatuje i wypisuje, wysyłając wyjście potokiem do @var{polecenia}.
Potok do polecenia pozostaje otwarty do momentu wywołania funkcji
@code{close}.
@end table

@code{getline} zwraca zero na końcu pliku, a @minus{}1 przy błędzie.
W przypadku błędu, @code{getline} nadaje zmiennej @code{ERRNO} wartość
zależnego od systemu łańcucha, który opisuje błąd.

@node Podsumowanie printf, Podsumowanie plików specjalnych, Podsumowanie I/O, Podsumowanie akcji
@appendixsubsec Podsumowanie @code{printf}

Specyfikacja konwersji ma postać
@code{%}[@var{flaga}][@var{szer}][@code{.}@var{dokł}]@var{format}.
@c whew!
Elementy w nawiasach kwadratowych są opcjonalne.

W @code{awk} instrukcja @code{printf} i funkcja @code{sprintf}
przyjmują poniższe formaty określające konwersję:

@table @code
@item %c
Znak ASCII.  Jeżeli użyty dla @samp{%c} argument jest numeryczny,
traktowany jest jak znak i wypisywany.  W przeciwnym wypadku, zakłada się,
że jest łańcuchem, i wypisywany jest tylko pierwszy znak tego łańcucha.

@item %d
@itemx %i
Liczba dziesiętna (część całkowita).

@item %e
@itemx %E
Liczba zmiennoprzecinkowa postaci
@samp{@r{[}-@r{]}d.dddddde@r{[}+-@r{]}dd}.
Format @samp{%E} stosuje @samp{E} zamiast @samp{e}.

@item %f
Liczba zmiennoprzecinkowa postaci
@r{[}@code{-}@r{]}@code{ddd.dddddd}.

@item %g
@itemx %G
Używa albo formatu @samp{%e} albo @samp{%f}, zależnie od tego, który z nich
daje krótszy łańcuch, z eliminacją nieznaczących zer.
@samp{%G} stosuje @samp{%E} zamiast @samp{%e}.

@item %o
Liczba ósemkowa bez znaku (także całkowita).

@item %u
Liczba dziesiętna bez znaku (znów, całkowita).

@item %s
Łańcuch znaków.

@item %x
@itemx %X
Liczba szesnastkowa bez znaku (całkowita).
Format @samp{%X} stosuje litery @samp{A} do @samp{F} zamiast @samp{a}
do @samp{f} dla dziesiętnych 10 do 15.

@item %%
Pojedynczy znak @samp{%}; nie jest przekształcany żaden argument.
@end table

Opcjonalne, dodatkowe parametry, które mogą wystąpić pomiędzy @samp{%}
a literą sterującą:

@table @code
@item -
Wyrażenie powinno być w swoim polu wyrównane do lewej.

@item @var{spacja}
W konwersjach numerycznych poprzedza wartości dodatnie spacją, a ujemne
znakiem minus.

@item +
Znak plus użyty przed modyfikatorem szerokości (zob. niżej), nakazuje
w konwersjach numerycznych zawsze podawać znak, nawet jeśli dane do
sformatowania są dodatnie. Modyfikator @samp{+} przesłania modyfikator
spacji.

@item #
Stosuje ``alternatywną postać'' dla niektórych liter sterujących.
Przy @samp{%o}, zapewnia początkowe zero.
Przy @samp{%x} i @samp{%X} zapewnia początkowe @samp{0x} lub @samp{0X} dla
wyniku niezerowego.
Przy @samp{%e}, @samp{%E} i @samp{%f} wynik będzie zawsze zawierał kropkę
dziesiętną.
Przy @samp{%g} i @samp{%G} końcowe zera nie są usuwane z wyniku.

@item 0
Początkowe @samp{0} (zero) działa jak flaga, wskazująca, że wyjście
powinno być dopełnione zerami zamiast spacjami.  Odnosi się to także do
nienumerycznych formatów wyjściowych.  Flaga ta ma znaczenie tylko gdy pole
jest szersze niż wartość do wypisania.

@item @var{szer}
Pole powinno zostać wypełnione do tej szerokości.  Normalnie dopełniane
jest spacjami.  Jeżeli użyto flagi @samp{0}, to jest dopełniane zerami.

@item .@var{dokł}
Liczba określająca dokładność, jaka ma być użyta zastosowana przy
wypisywaniu.  Przy formatach @samp{e}, @samp{E} i @samp{f} podaje liczbę
cyfr, jakie mają być wypisane na prawo od kropki dziesiętnej. Przy formatach
@samp{g} i @samp{G} określa maksymalną ilość cyfr znaczących.  Przy
formatach @samp{d}, @samp{o}, @samp{i}, @samp{u}, @samp{x} i @samp{X}
określa minimalną liczbę cyfr do wypisania.  Dla formatu @samp{s} podaje
maksymalną liczbę znaków łańcucha, jakie winny zostać wypisane.
@end table

Każda z wartości @var{szer} i @var{dokł}, albo obie z nich, może być podana
jako @samp{*}.  Wówczas, konkretna ich wartość pobierana jest z listy
argumentów.

@xref{Printf, ,Wymyślne wyjście dzięki instrukcji @code{printf}}.

@node Podsumowanie plików specjalnych, Podsumowanie funkcji wbudowanych, Podsumowanie printf, Podsumowanie akcji
@appendixsubsec Specjalne nazwy plików

Podczas wykonywania przekierowań wejścia/wyjścia z @code{print} czy
@code{printf} do pliku, albo za poprzez @code{getline} z pliku, @code{gawk}
rozpoznaje wewnętrznie pewne specjalne nazwy plików.  Nazwy te umożliwiają
dostęp do otwartych deskryptorów plików odziedziczonych przez @code{gawk}
po procesie macierzystym (zwykle powłoce).  Nazwami tymi są:

@table @file
@item /dev/stdin
Standardowe wejście.

@item /dev/stdout
Standardowe wyjście.

@item /dev/stderr
Standardowe wyjście błędów.

@item /dev/fd/@var{n}
Plik oznaczony otwartym deskryptorem @var{n}.
@end table

Dodatkowo, odczyt poniższych plików zapewnia informację związaną z procesem
wykonywanego programu @code{gawk}.  Wszystkie zwracane rekordy zakończone są
znakiem nowej linii.

@table @file
@item /dev/pid
Zwraca ID procesu dla bieżącego procesu.

@item  /dev/ppid
Zwraca ID procesu macierzystego dla bieżącego procesu.

@item  /dev/pgrpid
Zwraca ID grupy procesu dla bieżącego procesu.

@item /dev/user
Co najmniej cztery, oddzielone spacjami, pola, zawierające wartości zwracane
przez funkcje systemowe @code{getuid}, @code{geteuid}, @code{getgid}
i @code{getegid}.  Jeśli występują dodatkowe pola, to są one
identyfikatorami grup zwróconymi przez funkcję systemową @code{getgroups}.
(Przynależność do wielu grup może nie być obsługiwana na wszystkich
systemach.)
@end table

@noindent
Z tych nazw plików można też korzystać w wierszu poleceń do wskazania plików
danych.   Jeśli w rzeczywistości plików o tych nazwach nie ma w systemie,
to są one rozpoznawane tylko wewnętrznie.

@xref{Pliki specjalne, ,Specjalne nazwy plików w @code{gawk}}, gdzie
umieszczono dłuższy opis z uzasadnieniem tej cechy.

@node Podsumowanie funkcji wbudowanych, Podsumowanie funkcji czasu, Podsumowanie plików specjalnych, Podsumowanie akcji
@appendixsubsec Funkcje wbudowane

@code{awk} udostępnia wiele funkcji wbudowanych do wykonywania działań
na liczbach, łańcuchach czy operacji wejścia/wyjścia.

@c NEEDED
@page
Wbudowane funkcje arytmetyczne:

@table @code
@item atan2(@var{y}, @var{x})
Arcus tangens z @var{y/x} w radianach.

@item cos(@var{wyr})
Cosinus @var{wyr}, podanego w radianach.

@item exp(@var{wyr})
Potęga naturalna o wykładniku @var{wyr} (@code{e^@var{wyr}}).

@item int(@var{wyr})
Obcięcie do całkowitej.

@item log(@var{wyr})
Logarytm naturalny z @code{wyr}.

@item rand()
Liczba losowa między zero a jeden.

@item sin(@var{wyr})
Sinus @var{wyr}, podanego w radianach.

@item sqrt(@var{wyr})
Pierwiastek kwadratowy.

@item srand(@r{[}@var{wyr}@r{]})
Wykorzystuje @var{wyr} jako nowe ziarno generatora liczb losowych.  Jeżeli
nie podano @var{wyr}, to używany jest bieżący czas.  Wartością zwracaną jest
poprzednie ziarno generatora liczb losowych.
@end table

@code{awk} ma następujące wbudowane funkcje łańcuchowe:

@table @code
@item gensub(@var{regex}, @var{zastąp}, @var{jak} @r{[}, @var{cel}@r{]})
Jeżeli @var{jak} jest łańcuchem zaczynającym się od @samp{g} lub @samp{G},
to wszystkie dopasowania @var{regex} w @var{cel} zastępowane są przez
@var{zastąp}.  W przeciwnym razie, zastępowane jest @var{jak}ie kolejne
wystąpienie.  Jeżeli nie podano @var{celu}, to używane jest @code{$0}.
Wartością zwracaną jest zmieniony łańcuch -- oryginalny @var{cel} nie jest
modyfikowany.  Wewnątrz @var{zastąp}, do wskazania tekstu pasującego do
@var{n}-tego podwyrażenia w nawiasach stosuje się @samp{\@var{n}}, gdzie
@var{n} jest cyfrą od zera do dziewięciu.
Funkcja @code{gensub} jest specyficzna dla @code{gawk}.

@item gsub(@var{regex}, @var{zastąp} @r{[}, @var{cel}@r{]})
Zastępuje każdy podłańcuch łańcucha @var{cel} pasujący do wyrażenia
regularnego @var{regex} łańcuchem @var{zastąp}.  Zwraca liczbę zastąpień.
Jeżeli nie podano @var{celu}, używane jest @code{$0}.

@item index(@var{łańc}, @var{szuk})
Zwraca pozycję łańcucha @var{szuk} w łańcuchu @var{łańc}, lub zero jeśli
nie występuje @var{szuk}.

@item length(@r{[}@var{łańc}@r{]})
Zwraca długość łańcucha @var{łańc}.  Jeżeli nie podano argumentu, zwracana
jest długość @code{$0}.

@item match(@var{łańc}, @var{regex})
Zwraca pozycję w @var{łańc}, na której pojawia się wyrażenie regularne
@var{regex}, albo zero jeśli @var{regex} nie występuje, i nadaje wartości
zmiennym @code{RSTART} i @code{RLENGTH}.

@item split(@var{łańc}, @var{tabl} @r{[}, @var{regex}@r{]})
Dzieli @var{łańcuch} na kawałki rozdzielane przez wyrażenie regularne
@var{regex} i umieszczane w tablicy @var{tabl}.  Zwraca liczbę elementów.
Jeżeli pominięto @var{regex}, to zamiast niego używane jest @code{FS}.
@var{regex} może być łańcuchem pustym, co spowoduje umieszczenie każdego
znaku w osobnym elemencie tablicy.  Na początku wymazywana jest tablica
@var{tabl}.

@item sprintf(@var{fmt}, @var{lista-wyr})
Wypisuje @var{listę-wyr} zgodnie z @var{fmt} i zwraca wynikowy łańcuch.

@item sub(@var{regex}, @var{zastąp} @r{[}, @var{cel}@r{]})
Tak jak @code{gsub}, ale zastępowany jest tylko pierwszy pasujący podłańcuch.

@item substr(@var{łańc}, @var{indeks} @r{[}, @var{dł}@r{]})
Zwraca @var{dł}-znakowy podłańcuch łańcucha @var{łańc} zaczynający się
od pozycji @var{indeks}.  Jeżeli pominięto @var{dł}, używana jest reszta
@var{łańc}.

@item tolower(@var{łańc})
Zwraca kopię łańcucha @var{łańc} ze wszystkimi dużymi znakami zamienionymi
na odpowiadające im małe.  Znaki niealfabetyczne pozostawione są bez zmian.

@item toupper(@var{łańc})
Zwraca kopię łańcucha @var{łańc} ze wszystkimi małymi znakami zamienionymi
na odpowiadające im duże.  Znaki niealfabetyczne pozostawione są bez zmian.
@end table

Funkcje związane z wejściem/wyjściem:

@table @code
@item close(@var{wyr})
Zamyka otwarty plik lub potok wskazywany przez @var{wyr}.

@item fflush(@r{[}@var{wyr}@r{]})
Opróżnia wszelkie buforowane wyjście do pliku wyjściowego lub potoku
wskazanego przez @var{wyr}.  Jeżeli pominięto @var{wyr}, opróżniane jest
standardowe wyjście.  Jeśli @var{wyr} jest łańcuchem pustym (@code{""}),
opróżniane są wszystkie bufory wyjściowe.

@item system(@var{wiersz-polec})
Uruchamia polecenie @var{wiersz-polec} i zwraca jego kod zakończenia.
Jeżeli dany system operacyjny nie obsługuje funkcji @code{system}, wywołanie
jej spowoduje błąd krytyczny.

@samp{system("")} można wykorzystać do wymuszonego opróżnienia przez
@code{awk} oczekującego wyjścia.  Jest to bardziej przenośne, ale mniej
oczywiste, niż wywołanie @code{fflush}.
@end table

@node Podsumowanie funkcji czasu, Podsumowanie stałych łańcuchowych, Podsumowanie funkcji wbudowanych, Podsumowanie akcji
@appendixsubsec Funkcje czasu

Do pobierania bieżącego czasu i formatowania znaczników czasu dostępne są
dwie kolejne funkcje.  Są one specyficzne dla @code{gawk}.

@table @code
@item systime()
Zwraca czas bieżący jako liczbę sekund od konkretnej Epoki
(północ 1 stycznia 1970 UTC, na systemach POSIX-owych).

@item strftime(@r{[}@var{format}@r{[}, @var{timestamp}@r{]]})
Formatuje znacznik czasu @var{timestamp} zgodnie ze specyfikacją
@var{formatu}.  Jeżeli nie podano @var{timestamp} to stosowany jest czas
bieżący.  Jeżeli nie podano @var{formatu}, stosowany jest domyślny format
równoważny jest wyjściu tworzonemu przez narzędzie @code{date}.
@xref{Funkcje czasu, ,Funkcje obsługi znaczników czasu}, gdzie zamieszczono
szczegółowy opis specyfikatorów konwersji przyjmowanych przez
@code{strftime}.
@end table

@iftex
@xref{Wbudowane, ,Funkcje wbudowane}, gdzie zamieszczono opis wszystkich
funkcji wbudowanych @code{awk}.
@end iftex

@node Podsumowanie stałych łańcuchowych,  , Podsumowanie funkcji czasu, Podsumowanie akcji
@appendixsubsec Stałe łańcuchowe

Stałe łańcuchowe w @code{awk} są ciągami znaków ujętymi w cudzysłowy zwykłe
(@code{"}).  Wewnątrz łańcuchów rozpoznawane są pewne
@dfn{sekwencje specjalne}, jak w C.  Są to:

@table @code
@item \\
Dosłowny odwrotny ukośnik (backslash).

@item \a
Znak dzwonka (alarm, ``alert''), zwykle znak ASCII BEL.

@item \b
Backspace.

@item \f
Wysuw strony, formfeed.

@item \n
Nowa linia, newline.

@item \r
Powrót karetki, carriage return.

@item \t
Tabulacja pozioma.

@item \v
tabulacja pionowa.

@item \x@var{cyfry szesnastkowe}
Znak reprezentowany przez łańcuch cyfr szesnastkowych występujących po
@samp{\x}.  Jak w ANSI C, wszystkie kolejne cyfry szesnastkowe uważane są
za część tej sekwencji specjalnej.  Np., @code{"\x1B"} jest łańcuchem
złożonym ze znaku ASCII ESC (escape).  (Sekwencja specjalna @samp{\x}
nie występuje w POSIX-owym @code{awk}.)

@item \@var{ddd}
Znak reprezentowany przez jedno-, dwu- lub trzycyfrową sekwencję cyfr
ósemkowych.  Zatem, @code{"\033"} jest również łańcuchem złożonym ze znaku
ASCII ESC (escape).

@item \@var{c}
Dosłowny znak @var{c}, jeśli @var{c} nie jest jednym z powyższych.
@end table

Z sekwencji specjalnych można też korzystać wewnątrz stałych wyrażeń
regularnych (np., wyrażenie regularne @code{@w{/[@ \t\f\n\r\v]/}}
dopasowuje białe znaki).

@xref{Sekwencje specjalne}.

@node Podsumowanie funkcji, Cechy historyczne, Podsumowanie akcji, Podsumowanie gawk
@appendixsec Funkcje definiowane przez użytkownika

Funkcje w @code{awk} są definiowane następująco:

@example
function @var{nazwa}(@var{lista-parametrów}) @{ @var{instrukcje} @}
@end example

Do konkretyzowania parametrów formalnych, deklarowanych w funkcji, używane są
parametry aktualne dostarczone w wywołaniu funkcji.  Tablice przekazywane są
przez wskazanie, inne zmienne przez wartość.

Jeżeli przekazano mniej parametrów niż występuje nazw
w @var{liście-parametrów}, to dodatkowe nazwy otrzymują jako wartość łańcuch
pusty.  Dodatkowe nazwy działają jak zmienne lokalne.

Nawias otwierający w wywołaniu funkcji definiowanej przez użytkownika musi
występować bezpośrednio po nazwie funkcji, bez wtrąconego odstępu.
Ma to na celu uniknięcie niejednoznaczności składni i mylenia
z operatorem konkatenacji.

Zamiast @code{function} może być używane słowo @code{func} (ale nie
w POSIX @code{awk}).

Zwracanie wartości przez funkcję uzyskuje się instrukcją @code{return}.

@xref{Użytkownika, ,Funkcje użytkownika}.

@node Cechy historyczne,  , Podsumowanie funkcji, Podsumowanie gawk
@appendixsec Cechy historyczne

@cindex cechy historyczne
@code{gawk} obsługuje dwie cechy historycznych implementacji @code{awk}.

Po pierwsze, możliwe jest wywoływanie funkcji wbudowanej @code{length} nie
tylko bez argumentów, lecz nawet bez nawiasów!

@example
a = length
@end example

@noindent
to to samo, co którekolwiek z

@example
a = length()
a = length($0)
@end example

@noindent
Na przykład:

@example
$ echo abcdef | awk '@{ print length @}'
@print{} 6
@end example

@noindent
Cechę tę w standardzie POSIX oznaczono jako ``niezalecaną'', a
@code{gawk} wyśle ostrzeżenie o jej użyciu jeżeli w wierszu poleceń podano
@samp{--lint}.  (Możliwość takiego sposobu użycia @code{length} była
w oryginalnej implementacji uniksowego @code{awk} w rzeczywistości
przypadkowa.  Jeżeli jakakolwiek funkcja korzystała z @code{$0} jako
argumentu domyślnego, to możliwe było wywoływanie jej bez nawiasów.
W szczególności, powszechną praktyką było korzystanie w ten sposób z funkcji
@code{length}, i ten sposób użycia udokumentowano w podręczniku man
@code{awk}.)

Inną cechą historyczną jest stosowanie instrukcji @code{break} albo
@code{continue} poza ciałem pętli @code{while}, @code{for} lub @code{do}.
Tradycyjne implementacje @code{awk} traktowały taki sposób użycia jako
równoważny instrukcji @code{next}.  Nowsze wersje uniksowego @code{awk}
na to nie zezwalają.
@code{gawk} obsługuje taki sposób użycia jeśli podano @samp{--traditional}.

@xref{Opcje, ,Opcje wiersza poleceń}, gdzie bliżej opisano opcje
@samp{--posix} i @samp{--lint}.

@node Instalacja, Uwagi, Podsumowanie gawk, Top
@appendix Instalowanie @code{gawk}

Ten załącznik zawiera instrukcje dotyczące instalacji @code{gawk} na różnych
platformach wspieranych przez programistów.  Główni twórcy tworzą wersję
pracującą w Uniksie (i pewnego dnia, GNU), choć @code{gawk} przeniesiono
też na inne platformy.  Plik @file{ACKNOWLEDGMENT} w pakiecie dystrybucyjnym
@code{gawk} wymienia adresy poczty elektronicznej ludzi, którzy zrobili
odpowiednie przeniesienia (porty) programu, podano je też
w @ref{Błędy, ,Zgłaszanie problemów i błędów}.

@menu
* Dystrybucja gawk::            Co jest w dystrybucji @code{gawk}.
* Instalacja na Uniksie::       Instalowanie @code{gawk} na różnych wersjach
                                Uniksa.
* Instalacja na VMS::           Instalowanie @code{gawk} na VMS.
* Instalacja na PC::            Instalowanie i kopiowanie @code{gawk}
                                na MS-DOS i OS/2
* Instalacja na Atari::         Instalowanie @code{gawk} na Atari ST.
* Instalacja na Amidze::        Instalowanie @code{gawk} na Amidze.
* Błędy::                       Zgłaszanie problemów i błędów.
* Inne wersje::                 Inne wolnodostępne implementacje @code{awk}.
@end menu

@node Dystrybucja gawk, Instalacja na Uniksie, Instalacja, Instalacja
@appendixsec Dystrybucja @code{gawk}

W tej sekcji opisano najpierw jak zdobyć pakiet dystrybucyjny @code{gawk},
jak go zdekompresować, i co jest w rozmaitych plikach i podkatalogach.

@menu
* Pozyskiwanie::                      Jak pozyskać dystrybucyjnę.
* Rozpakowywanie::                    Jak rozpakować pakiet dystrybucyjny.
* Zawartość pakietu dystrybucyjnego:: Co jest w dystrybucji.
@end menu

@node Pozyskiwanie, Rozpakowywanie, Dystrybucja gawk, Dystrybucja gawk
@appendixsubsec Pozyskiwanie pakietu dystrybucyjnego @code{gawk}
@cindex zdobywanie @code{gawk}
@cindex pozyskiwanie @code{gawk}
@cindex anonimowe @code{ftp}
@cindex @code{ftp}, anonimowe
@cindex Free Software Foundation
Oprogramowanie GNU można pozyskać na trzy sposoby.

@enumerate
@item
Skopiować je od kogoś, kto już je ma.

@cindex Free Software Foundation
@item
Zamówić @code{gawk} bezpośrednio z Free Software Foundation.
Dostępne są pakiety dystrybucyjne do użytku w Uniksie, MS-DOS i VMS,
na taśmie i CD-ROM.  Adres Fundacji:

@quotation
Free Software Foundation @*
59 Temple Place---Suite 330 @*
Boston, MA  02111-1307 USA @*
Phone: +1-617-542-5942 @*
Fax (including Japan): +1-617-542-2652 @*
Email: @code{gnu@@gnu.org} @*
URL: @code{http://www.gnu.org/} @*
@end quotation

@noindent
Zamawianie bezpośrednio z FSF wspiera fundację i jest wkładem w dalsze
tworzenie wolnego oprogramowania.

@item
Pobrać @code{gawk} za pomocą anonimowego @code{ftp} z serwera internetowego
@code{gnudist.gnu.org}, z katalogu @file{/gnu/gawk}.

Podajemy listę alternatywnych ośrodków @code{ftp}, skąd można uzyskać
oprogramowanie GNU.  Gdy ośrodek wykazano jako
``@var{miejsce}@code{:}@var{katalog}'', to @var{katalog} wskazuje na
katalog, gdzie przechowywane jest oprogramowanie GNU.  Powinno się korzystać
z miejsca bliskiego geograficznie.

@table @asis
@item Azja:
@table @code
@item cair-archive.kaist.ac.kr:/pub/gnu
@itemx ftp.cs.titech.ac.jp
@itemx ftp.nectec.or.th:/pub/mirrors/gnu
@itemx utsun.s.u-tokyo.ac.jp:/ftpsync/prep
@end table

@c NEEDED
@page
@item Australia:
@table @code
@item archie.au:/gnu
(@code{archie.oz} lub @code{archie.oz.au} dla ACSnet)
@end table

@item Afryka:
@table @code
@item ftp.sun.ac.za:/pub/gnu
@end table

@item Środkowy Wschód:
@table @code
@item ftp.technion.ac.il:/pub/unsupported/gnu
@end table

@item Europa:
@table @code
@item archive.eu.net
@itemx ftp.denet.dk
@itemx ftp.eunet.ch
@itemx ftp.funet.fi:/pub/gnu
@itemx ftp.ieunet.ie:pub/gnu
@itemx ftp.informatik.rwth-aachen.de:/pub/gnu
@itemx ftp.informatik.tu-muenchen.de
@itemx ftp.luth.se:/pub/unix/gnu
@itemx ftp.mcc.ac.uk
@itemx ftp.stacken.kth.se
@itemx ftp.sunet.se:/pub/gnu
@itemx ftp.univ-lyon1.fr:pub/gnu
@itemx ftp.win.tue.nl:/pub/gnu
@itemx irisa.irisa.fr:/pub/gnu
@itemx isy.liu.se
@itemx nic.switch.ch:/mirror/gnu
@itemx src.doc.ic.ac.uk:/gnu
@itemx unix.hensa.ac.uk:/pub/uunet/systems/gnu
@end table

@item Polska:
@table @code
@item ftp.task.gda.pl:/pub/gnu
@itemx ftp.icm.edu.pl:/pub/gnu
@itemx ftp.man.torun.pl:/pub/gnu
@end table

@item Ameryka Południowa:
@table @code
@item ftp.inf.utfsm.cl:/pub/gnu
@itemx ftp.unicamp.br:/pub/gnu
@end table

@item Kanada Zachodnia:
@table @code
@item ftp.cs.ubc.ca:/mirror2/gnu
@end table

@item USA:
@table @code
@item col.hp.com:/mirrors/gnu
@itemx f.ms.uky.edu:/pub3/gnu
@itemx ftp.cc.gatech.edu:/pub/gnu
@itemx ftp.cs.columbia.edu:/archives/gnu/prep
@itemx ftp.digex.net:/pub/gnu
@itemx ftp.hawaii.edu:/mirrors/gnu
@itemx ftp.kpc.com:/pub/mirror/gnu
@itemx ftp.uu.net:/systems/gnu
@itemx gatekeeper.dec.com:/pub/GNU
@itemx jaguar.utah.edu:/gnustuff
@itemx labrea.stanford.edu
@itemx mrcnext.cso.uiuc.edu:/pub/gnu
@itemx vixen.cso.uiuc.edu:/gnu
@itemx wuarchive.wustl.edu:/systems/gnu
@end table
@end table
@end enumerate

@node Rozpakowywanie, Zawartość pakietu dystrybucyjnego, Pozyskiwanie, Dystrybucja gawk
@appendixsubsec Rozpakowywanie pakietu dystrybucyjnego
@code{gawk} rozpowszechniany jest jako plik @code{tar} skompresowany
programem GNU Zip, @code{gzip}.

Po uzyskaniu pakietu dystrybucyjnego (na przykład,
@file{gawk-@value{VERSION}.@value{PATCHLEVEL}.tar.gz}), najpierw
korzystamy z @code{gzip} do zdekompresowania pliku, a następnie z @code{tar}
do rozpakowania archiwum.  Do utworzenia dystrybucji @code{gawk} można
użyć poniższego potoku:

@example
# w System V, dodaj 'o' do flag programu tar
gzip -d -c gawk-@value{VERSION}.@value{PATCHLEVEL}.tar.gz | tar -xvpf -
@end example

@noindent
Utworzy to w bieżącym katalogu katalog o nazwie
@file{gawk-@value{VERSION}.@value{PATCHLEVEL}}.

Nazwa pliku pakietu dystrybucyjnego ma postać
@file{gawk-@var{V}.@var{R}.@var{n}.tar.gz}.
@var{V} wskazuje główną wersję @code{gawk}, @var{R} jest bieżącym
wydaniem wersji @var{V}, a @var{n} @dfn{poziomem poprawek} (patch level),
oznaczającym, że w tym wydaniu poprawiono pomniejsze błędy.
Aktualny poziom poprawek wynosi @value{PATCHLEVEL}, ale przy pobieraniu
pakietów dystrybucyjnych powinno się brać wersję o najwyższych numerach
wersji, wydania i poziomu poprawek.  (Warto zapamiętać, że poziomy wydania
większe lub równe 90 oznaczają oprogramowanie ``beta'', nie przeznaczone do
pracy.  Zwykle nie chcemy pobierać takiej wersję, chyba że nie przeszkadza
nam eksperymentowanie.)

W systemach innych niż uniksowe potrzebne będą odmienne rozwiązania
pozyskiwania i rozpakowywania pakietu dystrybucyjnego @code{gawk}.
Należy skontaktować się z miejscowym ekspertem.

@node Zawartość pakietu dystrybucyjnego,  , Rozpakowywanie, Dystrybucja gawk
@appendixsubsec Zawartość pakietu dystrybucyjnego @code{gawk}

Dystrybucja @code{gawk} zawiera wiele plików źródłowych w C, pliki
dokumentacji, podkatalogi i pliki związane z procesem konfiguracji
(@pxref{Instalacja na Uniksie, ,Kompilowanie i instalowanie @code{gawk} na Uniksie}),
oraz kilka podkatalogów związanych z różnymi, nieuniksowymi, systemami
operacyjnymi.

@table @asis
@item rozmaite pliki @samp{.c}, @samp{.y} i @samp{.h}
Te pliki są faktycznym kodem źródłowym @code{gawk}.
@end table

@table @file
@item README
@itemx README_d/README.*
Pliki opisowe: @file{README} do @code{gawk} w Uniksie,
a reszta do rozmaitych kombinacji sprzętowo-programowych.

@item INSTALL
Plik zawierający omówienie procesu konfiguracji i instalacji.

@item PORTS
Lista systemów, na które przeniesiono @code{gawk}, i które pomyślnie
przeszły przez zestaw testów.

@item ACKNOWLEDGMENT
Lista osób, które miały główny wkład w kod lub dokumentację.

@item ChangeLog
Szczegółowa lista zmian w kodzie źródłowym, jak poprawione błędy czy
ulepszenia.

@item NEWS
Lista zmian w @code{gawk} od ostatniego wydania czy poprawki.

@item COPYING
Powszechna Licencja Publiczna GNU.

@item FUTURES
Krótka lista możliwości i/lub zmian rozważanych w przyszłych wydaniach,
z jakimś wskazaniem czasu pojawienia się zmiany, zależnie od stopnia
trudności.

@item LIMITATIONS
Lista czynników ograniczających sprawność @code{gawk}.
Większość z nich zależy od sprzętu lub oprogramowania systemowego,
a nie jest ograniczeniami w samym @code{gawk}.

@item POSIX.STD
Opis pewnego obszaru, w którym standard POSIX dotyczący @code{awk} jest
niepoprawny, i sposobu, w jaki @code{gawk} radzi sobie z tym problemem.

@item PROBLEMS
Plik opisujący rozpoznane kłopoty występujące w bieżącym wydaniu.

@cindex sztuczna inteligencja, za pomocą @code{gawk}
@cindex programowanie AI, za pomocą @code{gawk}
@item doc/awkforai.txt
Krótki artykuł opisujący dlaczego @code{gawk} jest dobrym językiem do
programowania AI (Artificial Intelligence, sztucznej inteligencji) .

@item doc/README.card
@itemx doc/ad.block
@itemx doc/awkcard.in
@itemx doc/cardfonts
@itemx doc/colors
@itemx doc/macros
@itemx doc/no.colors
@itemx doc/setter.outline
Źródła @code{troff} pięciokolorowej karty informacyjnej @code{awk}.
Do utworzenia wersji kolorowej potrzebna jest nowoczesna wersja
@code{troff}, jak np. GNU Troff (@code{groff}).  W pliku @file{README.card}
zamieszczono instrukcje dla posiadaczy starszych wersji @code{troff}.

@item doc/gawk.1
Źródło @code{troff} podręcznika systemowego man opisującego @code{gawk}.
Rozpowszechniane dla wygody użytkowników Uniksa.

@item doc/gawk.texi
Plik źródłowy Texinfo niniejszej książki.  W celu uzyskania dokumentu
drukowanego powinien zostać przetworzony za pomocą @TeX{}-a, zaś w celu
utworzenia pliku Info -- za pomocą @code{makeinfo}.

@item doc/gawk.info
Gotowy, wygenerowany plik Info tej książki.

@item doc/igawk.1
Źródło @code{troff} podręcznika systemowego man opisującego program
@code{igawk} przedstawiony w
@ref{Program igawk, ,Łatwa metoda korzystania z funkcji bibliotecznych}.

@item doc/Makefile.in
Plik wejściowy wykorzystywany podczas procesu konfiguracji do generowania
faktycznego pliku @file{Makefile} do tworzenia dokumentacji.

@item Makefile.in
@itemx acconfig.h
@itemx aclocal.m4
@itemx configh.in
@itemx configure.in
@itemx configure
@itemx custom.h
@itemx missing/*
Te pliki i katalogi wykorzystywane są podczas konfigurowania @code{gawk}
w rozmaitych systemach uniksowych.  Objaśniono je szczegółowo w
@ref{Instalacja na Uniksie, ,Kompilowanie i instalowanie @code{gawk} na Uniksie}.

@item awklib/extract.awk
@itemx awklib/Makefile.in
Katalog @file{awklib} zawiera kopię @file{extract.awk}
(@pxref{Program extract, ,Wydzielanie programów z plików źródłowych Texinfo}),
którą można wykorzystać do wydzielenia programów przykładowych z pliku
źródłowego Texinfo tej książki, i plik @file{Makefile.in}, którego
używa @code{configure} do wygenerowania @file{Makefile}.
Częścią procesu tworzenia @code{gawk} jest wydzielenie funkcji
bibliotecznych z
@ref{Funkcje biblioteczne, , Biblioteczka funkcji @code{awk}}, i programu
@code{igawk}
z @ref{Program igawk, ,Łatwa metoda korzystania z funkcji bibliotecznych}
do postaci gotowych do użytku plików.
Są one instalowane jako część procesu instalacji.

@item atari/*
Pliki potrzebne do stworzenia @code{gawk} na Atari ST.
@xref{Instalacja na Atari, ,Instalowanie @code{gawk} na Atari ST},
gdzie opisano szczegóły.

@item pc/*
Pliki potrzebne do stworzenia @code{gawk} na MS-DOS i OS/2.
@xref{Instalacja na PC, ,Instalacja i kompilacja na MS-DOS i OS/2},
gdzie opisano szczegóły.

@item vms/*
Pliki potrzebne do stworzenia @code{gawk} VMS.
@xref{Instalacja na VMS, ,Jak skompilować i zainstalować @code{gawk} na VMS},
gdzie opisano szczegóły.

@item test/*
Zestaw testów do @code{gawk}.  Do uruchomienia danej wersji @code{gawk}
z tym zestawem należy zastosować @samp{make check} w katalogu @code{gawk}
najwyższego poziomu.  Jeżeli @code{gawk} pomyślnie przejdzie
@samp{make check}, to można być pewnym pomyślnego przeniesienia go na daną
platformę.
@end table

@node Instalacja na Uniksie, Instalacja na VMS, Dystrybucja gawk, Instalacja
@appendixsec Kompilowanie i instalowanie @code{gawk} na Uniksie

Zazwyczaj kompiluje się i instaluje @code{gawk} wpisując tylko dwa
polecenia.  Jednak, w przypadku nietypowych systemów, może zachodzić
potrzeba samodzielnej konfiguracji @code{gawk}.

@menu
* Szybka instalacja::           Kompilowanie @code{gawk} na Uniksie.
* Filozofia konfigurowania::    Jak to wszystko powinno działać.
@end menu

@node Szybka instalacja, Filozofia konfigurowania, Instalacja na Uniksie, Instalacja na Uniksie
@appendixsubsec Kompilowanie @code{gawk} dla Uniksa

@cindex instalacja, Unix
Po rozpakowaniu pakietu dystrybucyjnego @code{gawk} należy przez
@code{cd} zmienić katalog na @file{gawk-@value{VERSION}.@value{PATCHLEVEL}}.
Jak większość programów GNU, @code{gawk} automatycznie konfiguruje się
do pracy w systemie uniksowym przez uruchomienie programu @code{configure}.
Program ten jest skryptem powłoki Bourne'a utworzonym automatycznie za pomocą
GNU @code{autoconf}.
@iftex
(Oprogramowanie @code{autoconf} opisano szczegółowo w
@cite{Autoconf---Generating Automatic Configuration Scripts},
dostępnym z Free Software Foundation.)

@end iftex
@ifinfo
(Oprogramowanie @code{autoconf} jest szczegółowo opisane poczynając od
@ref{Top, , Introduction, autoconf, Autoconf---Generating Automatic Configuration Scripts}.)
@end ifinfo

W celu skonfigurowania @code{gawk} należy po prostu uruchomić
@code{configure}:

@example
sh ./configure
@end example

Tworzy to pliki @file{Makefile} i @file{config.h} dostosowane do naszego
systemu.  @file{config.h} zawiera opis rozmaitych faktów dotyczących systemu.
W pliku @file{Makefile} można zmodyfikować zmienną @code{CFLAGS}, która
steruje opcjami wiersza poleceń przekazywanych do kompilatora C (takimi jak
poziomy optymalizacji, czy kompilacja do celów debugowania).

Alternatywnie, można dołożyć własne wartości większości zmiennych
@code{make}, jak @code{CC} i @code{CFLAGS}, w wierszu poleceń przy
uruchamianiu @code{configure}:

@example
CC=cc CFLAGS=-g sh ./configure
@end example

@noindent
W pliku @file{INSTALL} dystrybucji @code{gawk} podano szczegóły.

Po uruchomieniu @code{configure} i ewentualnym zmodyfikowaniu
@file{Makefile}, wpisujemy:

@example
make
@end example

@noindent
i wkrótce potem powinniśmy mieć wykonywalną wersję @code{gawk}.
To wszystko, co trzeba zrobić!
(Jeżeli te kroki zawiodą, proszę przesłać zgłoszenie błędu;
@pxref{Błędy, ,Zgłaszanie problemów i błędów}.)

@node Filozofia konfigurowania, , Szybka instalacja, Instalacja na Uniksie
@appendixsubsec Proces konfigurowania

@cindex konfigurowanie @code{gawk}
(Ta sekcja adresowana jest tylko do osób, które wiedzą
coś o posługiwaniu się językiem C i systemem operacyjnym Unix.)

Kod źródłowy @code{gawk} zasadniczo usiłuje przystawać do standardów
formalnych gdzie tylko jest to możliwe.  Znaczy to, że @code{gawk}
wykorzystuje podprogramy biblioteczne wyszczególnione w standardzie ANSI C
i POSIX-owym standardzie interfejsu systemu operacyjnego.
Przy używaniu kompilatora ANSI C do usprawnienia kontroli podczas kompilacji
wykorzystywane są prototypy funkcji.

Wiele systemów uniksowych nie obsługuje wszystkich standardów ANSI czy POSIX.
Podkatalog @file{missing} w dystrybucji @code{gawk} zawiera zastępniki tych
podprogramów, których najprawdopodobniej brakuje.

Plik @file{config.h}, tworzony przez program @code{configure}, zawiera
definicje opisujące cechy konkretnego systemu operacyjnego, na którym
usiłujemy skompilować @code{gawk}.  Plik ten opisuje trzy rzeczy: jakie
pliki nagłówkowe są dostępne, by można je poprawnie dołączyć, jakich
funkcji standardowych można się spodziewać, że są faktycznie dostępne
w naszych bibliotekach C, i różne inne fakty dotyczące naszego wariantu
Uniksa.  Na przykład, w strukturze @code{stat} może nie być elementu
@code{st_blksize}.  W tym przypadku @samp{HAVE_ST_BLKSIZE} będzie
niezdefiniowane.

@cindex @code{custom.h}, plik konfiguracyjny
@cindex plik konfiguracyjny @code{custom.h}
Możliwe, że nasz kompilator C okłamie @code{configure}.  Może to zrobić
nie kończąc pracy z błędem gdy nie jest dostępna funkcja biblioteczna.
Można to obejść modyfikując plik @file{custom.h}.  Należy użyć odpowiedniego
do swojego systemu @samp{#ifdef} i zastosować albo @code{#define} albo
@code{#undef} w stosunku do stałych, które źle zdefiniował program
@code{configure}.  @file{custom.h} jest automatycznie dołączany przez
@file{config.h}.

Może się też zdarzyć, że @code{configure} utworzony przez @code{autoconf}
w jakiś inny sposób nie będzie działać w danym systemie.
Jeżeli pojawią się kłopoty, plik @file{configure.in} jest wejściem dla
@code{autoconf}.  Można zmienić ten plik i utworzyć nową wersję
@code{configure}, która zadziała.
@xref{Błędy, ,Zgłaszanie problemów i błędów}, gdzie opisano jak zgłaszać
problemy z konfigurowaniem @code{gawk}.  Tego samego rozwiązania można
użyć do wysłania aktualizacji @file{configure.in} i/lub @file{custom.h}.

@node Instalacja na VMS, Instalacja na PC, Instalacja na Uniksie, Instalacja
@appendixsec Jak skompilować i zainstalować @code{gawk} na VMS

@c based on material from Pat Rankin <rankin@eql.caltech.edu>

@cindex instalacja, vms
Ta sekcja opisuje jak skompilować i zainstalować @code{gawk} na VMS.

@menu
* Kompilacja na VMS::             Jak skompilować @code{gawk} na VMS.
* Szczegóły instalowania na VMS:: Jak zainstalować @code{gawk} na VMS.
* Uruchamianie na VMS::           Jak uruchamiać @code{gawk} na VMS.
* VMS POSIX::                     Alternatywne instrukcje dla VMS POSIX.
@end menu

@node Kompilacja na VMS, Szczegóły instalowania na VMS, Instalacja na VMS, Instalacja na VMS
@appendixsubsec Kompilowanie @code{gawk} na VMS

Do kompilacji @code{gawk} na VMS mamy procedurę poleceń @code{DCL}, która
wydaje wszystkie niezbędne polecenia @code{CC} i @code{LINK}, jest też
@file{Makefile} do wykorzystania przez narzędzie @code{MMS}.
W katalogu źródłowym należy użyć

@example
$ @@[.VMS]VMSBUILD.COM
@end example

@noindent
lub

@example
$ MMS/DESCRIPTION=[.VMS]DESCRIP.MMS GAWK
@end example

W zależności od wykorzystywanego kompilatora C, należy działać według jednej
z podanych w tabeli instrukcji postępowania:

@table @asis
@item VAX C V3.x
Należy użyć niezmienionych @file{vmsbuild.com} lub @file{descrip.mms}.
Stosują one @code{CC/OPTIMIZE=NOLINE}, co jest kluczowe przy Version 3.0.

@item VAX C V2.x
Musimy mieć Version 2.3 lub 2.4; starsze nie będą działać.  Należy zmienić
@file{vmsbuild.com} lub @file{descrip.mms} zgodnie z zawartymi w nich
komentarzami.  W przypadku @file{vmsbuild.com} wymaga to tylko usunięcia
dwu ograniczników @samp{!}.  Trzeba też poprawić @file{config.h} (który
jest kopią pliku @file{[.config]vms-conf.h}) i zakomentować lub usunąć
dwa wiersze @samp{#define __STDC__ 0} i @samp{#define VAXC_BUILTINS}
w pobliżu końca.

@item GNU C
Należy zmodyfikować @file{vmsbuild.com} lub @file{descrip.mms}; zmiany są
inne niż przy VAX C V2.x, ale równie proste.  Nie powinny być potrzebne
żadne zmiany w @file{config.h}.

@item DEC C
Należy zmodyfikować @file{vmsbuild.com} lub @file{descrip.mms} zgodnie
z zawartymi w nich komentarzami.  Nie powinny być potrzebne żadne
zmiany w @file{config.h}.
@end table

@code{gawk} był testowany z VAX/VMS 5.5-1 przy zastosowaniu VAX C V3.2,
GNU C 1.40 i 2.3.  Powinien działać bez zmian na VMS V4.6 i wyższych.

@node Szczegóły instalowania na VMS, Uruchamianie na VMS, Kompilacja na VMS, Instalacja na VMS
@appendixsubsec Instalowanie @code{gawk} na VMS

Do instalacji @code{gawk} wystarczy jedynie polecenie ``foreign'', będące
symbolem @code{DCL}, którego wartość zaczyna się od znaku dolara.
Na przykład:

@example
$ GAWK :== $disk1:[gnubin]GAWK
@end example

@noindent
(Za @samp{$disk1:[gnubin]} należy podstawić faktyczne położenie
@code{gawk.exe}.)  Symbol ten powinien zostać umieszczony w @file{login.com}
każdego użytkownika, który będzie chciał uruchamiać @code{gawk},
tak by był zdefiniowany za każdym razem, gdy użytkownik się loguje.
Alternatywnie, można umieścić go w ogólnosystemowej procedurze
@file{sylogin.com}, co pozwoli na uruchamianie @code{gawk} wszystkim
użytkownikom.

Opcjonalnie do biblioteki pomocy VMS można załadować wpis pomocy:

@example
$ LIBRARY/HELP SYS$HELP:HELPLIB [.VMS]GAWK.HLP
@end example

@noindent
(Można zastąpić standardową bibliotekę VMS @samp{HELPLIB} lokalną,
specyficzną dla maszyny biblioteką pomocy.)  Po załadowaniu, tekst pomocy,

@example
$ HELP GAWK
@end example

@noindent
poda informacje o implementacji @code{gawk} i o języku programowania
@code{awk}.

Domyślne położenie plików programów @code{awk} może być oznaczone nazwą
logiczną @samp{AWK_LIBRARY}.  Przy opcji @samp{-f}, jeśli podana nazwa pliku
nie zawiera informacji o urządzeniu ani ścieżce, @code{gawk} będzie szukał
najpierw w bieżącym katalogu, a następnie, jeśli nie znaleziono pliku,
w katalogu wyszczególnionym przez translację @samp{AWK_LIBRARY}.
Jeżeli po przeglądnięciu obu katalogów pliku nadal nie znaleziono, to
@code{gawk} do nazwy pliku dodaje przyrostek @samp{.awk} i ponawia próbę
szukania.  Jeżeli nie zdefiniowano @samp{AWK_LIBRARY}, to ta część
@c     will fail benignly.
poszukiwania pliku łagodnie zawiedzie.

@node Uruchamianie na VMS, VMS POSIX, Szczegóły instalowania na VMS, Instalacja na VMS
@appendixsubsec Uruchamianie @code{gawk} na VMS

Na VMS analiza składniowa wiersza poleceń i konwencje cytowania są znacząco
odmienne, więc przykłady z tej książki czy innych źródeł często wymagają
zmian.  Zmiany są jednak @emph{drobne}, a wszystkie programy @code{awk}
powinny działać poprawnie.

Parę prostych testów:

@example
$ gawk -- "BEGIN @{print ""Hello, World!""@}"
$ gawk -"W" version
! mogłoby też być -"W version" czy "-W version"
@end example

@noindent
Należy zwrócić uwagę, że tekst pisany dużymi literami (lub mieszanymi) musi
być cytowany.

Oprócz oryginalnego interfejsu w stylu powłoki, @code{gawk} przeniesiony na
VMS zawiera interfejs w stylu @code{DCL} (szczegóły znajdują się
w odpowiedniej pozycji pomocy).  Jednym ze skutków ubocznych podwójnej
analizy składni wiersza poleceń jest to, że jeśli wystąpi tylko jeden
parametr (jak w programie podanym jako cytowany łańcuch powyżej), to
polecenie staje się niejednoznaczne.  W celu obejścia tego problemu,
normalnie opcjonalna flaga @samp{--} jest wymagana do wymuszenia stylu
uniksowego zamiast składni @code{DCL}.  Jeżeli występują jakieś inne opcje
rozpoczynające się kreską (albo podano więcej parametrów, np. takich jak
pliki do przetworzenia), to nie ma niejednoznaczności i można pominąć
@samp{--}.

Domyślną ścieżką wyszukiwania przy szukaniu plików programów @code{awk}
podanych opcją @samp{-f} jest @code{"SYS$DISK:[],AWK_LIBRARY:"}.
Wartość tę przesłania się wykorzystując zmienną logiczną @samp{AWKPATH}.
Formatem @samp{AWKPATH} jest separowana przecinkami lista specyfikacji
katalogów.  Przy jej definiowaniu wartość należy zacytować, tak by
przechowała pojedynczą translację, a nie wielotranslacyjną listę
wyszukiwania @code{RMS}.

@node VMS POSIX,  , Uruchamianie na VMS, Instalacja na VMS
@appendixsubsec Tworzenie i użytkowanie @code{gawk} na VMS POSIX

Należy zignorować podane wyżej instrukcje, choć nadal w bibliotece pomocy
powinien zostać udostępniony @file{vms/gawk.hlp}.  Drzewo źródłowe należy
rozpakować raczej do podsystemu kontenera plików zamiast do zwykłego
systemu plików VMS.  Powinniśmy się upewnić, że skrypty @file{configure}
i @file{vms/posix-cc.sh} są wykonywalne.  Jeśli trzeba, stosujemy
w stosunku do nich @samp{chmod +x}.  Następnie uruchamiamy poniższe dwa
polecenia:

@example
@group
psx> CC=vms/posix-cc.sh configure
psx> make CC=c89 gawk
@end group
@end example

@noindent
Pierwsze polecenie, posługując się skryptem, aby kompilator C spełnił
oczekiwania @code{configure}, zbuduje z szablonów pliki @file{config.h}
i @file{Makefile}.  Drugie polecenie skompiluje i skonsoliduje @code{gawk}
bezpośrednio za pomocą kompilatora C.  Ostrzeżenia ze strony @code{make}
o niemożności ponownego zdefiniowania @code{CC} należy zignorować.
@code{configure} będzie się wykonywać bardzo długo, ale przynajmniej podaje
w czasie pracy informacje kontrolne o postępach.

Przetestowano z VAX/VMS V6.2, VMS POSIX V2.0 i DEC C V5.2.

Po zbudowaniu, @code{gawk} działa jak każde inne narzędzie powłoki.
W środowisku POSIX VMS, w przeciwieństwie do @code{gawk} przeniesionego
na zwykły VMS, nie jest potrzebne żadne specjalne operowanie wierszem
poleceń.

@c Rewritten by Scott Deifik <scottd@amgen.com>
@c and Darrel Hankerson <hankedr@mail.auburn.edu>
@node Instalacja na PC, Instalacja na Atari, Instalacja na VMS, Instalacja
@appendixsec Instalacja i kompilacja na MS-DOS i OS/2

@cindex instalacja, MS-DOS i OS/2
Jeśli uzyskaliśmy dystrybucje binarną przygotowaną przez prowadzących wersję
dla DOS, to @code{gawk} i niezbędne pliki
pomocnicze pojawią się wewnątrz katalogu @file{gnu}: pliki wykonywalne w
@file{gnu/bin}, biblioteki w @file{gnu/lib/awk}, a strony podręcznika
systemowego w @file{gnu/man}.  Dystrybucję zaprojektowano do łatwej
instalacji w katalogu @file{/gnu} danego napędu, ale pliki można
zainstalować gdziekolwiek, o ile poprawnie zostanie ustalona wartość
@code{AWKPATH}.  Bez względu na katalog instalacji może wymagać poprawienia
pierwszy wiersz @file{igawk.cmd} i @file{igawk.bat} (w @file{gnu/bin}).

Dystrybucja binarna będzie zawierała osobny plik opisujący jej zawartość.
W szczególności, może zawierać więcej niż jedną wersję wykonywalnego
@code{gawk}.  Pakiety dystrybucyjne do OS/2 mogą mieć inny układ, lecz
instalacja jest podobna.

Wersje @code{gawk} przeznaczone do pracy w OS/2 i MS-DOS szukają plików
programów tak, jak to opisano w @ref{Zmienna AWKPATH, ,Zmienna środowiska
@code{AWKPATH}}.  Jednak elementy w zmiennej @code{AWKPATH} oddzielane są
średnikami (zamiast dwukropkami).  Jeżeli nie zdefiniowano zmiennej
@code{AWKPATH} lub jest ona pusta, to domyślną ścieżką wyszukiwania jest
@code{@w{".;c:/lib/awk;c:/gnu/lib/awk"}}.

Przy programowaniu w @code{awk} przydatna może być powłoka podobna do
@code{sh} (w przeciwieństwie do @code{command.com} w MS-DOS
lub @code{cmd.exe} w OS/2).  Ian Stewartson napisał doskonałą powłokę
pracującą w MS-DOS i OS/2, a do OS/2 dostępne są klon @code{ksh} i GNU Bash.
Informacje o tych powłokach zawiera plik @file{README_d/README.pc}
w pakiecie dystrybucyjnym @code{gawk}.  Użytkownicy powłoki Stewartsona
w DOS-ie powinni sprawdzić w dokumentacji obsługę wierszy poleceń.
W szczególności, może być potrzebna zmiana ustawień dla @code{gawk}
w konfiguracji powłoki.  Istotna może też być opcja @code{ignoretype}.

@code{gawk} można skompilować do pracy w MS-DOS i OS/2 za pomocą narzędzi
konstrukcyjnych GNU od DJ Deloriego (DJGPP, tylko MS-DOS) lub
Eberharda Mattesa (EMX, MS-DOS i OS/2).  Do utworzenia 16-bitowych wersji
do MS-DOS i OS/2 można użyć Microsoft C.  Dodatkowe uwagi zawiera plik
@file{README_d/README.pc} w dystrybucji @code{gawk}.
@file{pc/Makefile} zaś zawiera istotne uwagi dotyczące opcji kompilacji.

W celu utworzenia @code{gawk} należy skopiować pliki z katalogu @file{pc}
(@emph{oprócz} pliku @file{ChangeLog}) do katalogu, w którym umieszczono
resztę źródeł @code{gawk}.  @file{Makefile} zawiera sekcje konfiguracyjne
z komentarzami; by zadziałał z użytym narzędziem @code{make} może być
konieczna jego modyfikacja.

@file{Makefile} zawiera kilka celów (targets) do budowy rozmaitych wersji
pracujących w MS-DOS i OS/2.  Lista celów zostanie wypisana po wydaniu
polecenia @code{make} bez podania celu.  Na przykład, by utworzyć
@code{gawk} za pomocą narzędzi DJGPP należy wprowadzić @samp{make djgpp}.

Stosowanie @code{make} do uruchamiania standardowych testów i instalacji
@code{gawk} wymaga dodatkowych uniksopodobnych narzędzi, łącznie
z @code{sh}, @code{sed} i @code{cp}.  Do uruchomienia testów może być
konieczna konwersja plików @file{test/*.ok}, tak by miały zwyczajowe
znaczniki końca linii w stylu DOS.  Większość testów będzie działać
poprawnie z powłoką Stewartsona z dodatkowymi narzędziami czy odpowiednimi
narzędziami GNU.  Wymagane jest jednak nieco zmian w @file{test/Makefile}.
Zaleca się skopiowanie pliku @file{pc/Makefile.tst} na @file{test/Makefile},
jako zastępnik.  Szczegóły można znaleźć w @file{README_d/README.pc}.

@node Instalacja na Atari, Instalacja na Amidze, Instalacja na PC, Instalacja
@appendixsec Instalowanie @code{gawk} na Atari ST

@c based on material from Michal Jaegermann <michal@gortel.phys.ualberta.ca>

@cindex atari
@cindex instalacja, atari
Nie ma istotnych różnic przy instalacji @code{gawk} na rozmaitych modelach
Atari.  Skompilowane pliki wykonywalne @code{gawk} przy większości programów
@code{awk} nie wymagają dużych ilości pamięci i powinny działać na
wszystkich modelach opartych o procesory Motoroli (nazywanych dalej ST,
nawet jeśli nie jest to całkiem poprawne).

Chcąc korzystać z @code{gawk} musimy posiadać powłokę, tekstową lub
graficzną, która nie przekształca wszystkich znaków wiersza poleceń na duże.
Obsługa rozróżniania dużych i małych liter we flagach opcji jest bardzo
ważna (@pxref{Opcje, ,Opcje wiersza poleceń}).
Obecnie jest to zachowanie domyślne, a problemy mogą wystąpić tylko przy
niektórych bardzo starych komputerach.  Jeżeli system nie zachowuje
wielkości liter flag, trzeba będzie zaktualizować narzędzia.  Do łatwego
importowania programów @code{awk} z innych środowisk konieczna jest
obsługa przekierowań wejścia/wyjścia.  Miło jest mieć potoki, ale nie jest
to kluczowe.

@menu
* Kompilowanie na Atari::       Kompilowanie @code{gawk} na Atari.
* Użytkowanie na Atari::        Uruchamianie @code{gawk} na Atari.
@end menu

@node Kompilowanie na Atari, Użytkowanie na Atari, Instalacja na Atari, Instalacja na Atari
@appendixsubsec Kompilowanie @code{gawk} na Atari ST

Gdy @code{sizeof(int)} różni się od @code{sizeof(void *)} do poprawnej
kompilacji @code{gawk} wymagany jest kompilator ANSI C.  Początkowe
przeniesienie programu wykonano za pomocą @code{gcc}.  Niektórzy wolą
pliki wykonywalne, w których wartości @code{int} mają cztery bajty, ale
alternatywny wariant też działa.

Podczas próby rekompilacji źródeł @code{gawk} może być potrzebne sporo
pamięci, gdyż niektóre pliki źródłowe (szczególnie @file{regex.c}) są dość
duże.  Jeżeli przy kompilacji takiego pliku zabraknie pamięci, należy
spróbować zmniejszyć poziom optymalizacji tego konkretnego pliku.
Może pomóc.

@cindex Linux
Z rozsądną powłoką (może być Bash), a w szczególności jeżeli pracujemy
na Linuksie, MiNT czy podobnym systemie operacyjnym, mamy całkiem niezłe
szanse na to, że narzędzie @code{configure} zadziała bezbłędnie.
Na wypadek, gdyby było inaczej, w podkatalogu @file{atari} umieszczono
przykładowe wersje @file{config.h} i @file{Makefile.st}.  Można je
zmodyfikować i skopiować na odpowiednie pliki w głównym katalogu
ze źródłami.  Nawet jeśli @code{configure} coś utworzył, warto porównać
jego wyniki z wersjami przykładowymi i ewentualnie dokonać korekt.

Niektóre fragmenty kodu źródłowego @code{gawk} zależą od zdefiniowania
przez preprocesor @samp{atarist}.  Najprościej mówiąc, zakładają
środowisko TOS z @code{gcc}.  Jeżeli nie odpowiada to danemu środowisku,
należy zmienić odnośne sekcje stosownie do potrzeb.  Zobacz także uwagi na
temat @code{AWKPATH} i @code{envsep} w @ref{Użytkowanie na Atari,
,Uruchamianie @code{gawk} na Atari ST}.

Dostarczony, przykładowy @file{config.h} twierdzi, że w bibliotekach brakuje
funkcji @code{system}, co nie jest prawdą, a alternatywna jej implementacja
zapewniona jest w @file{atari/system.c}.  W zależności od własnej konkretnej
kombinacji powłoki i systemu operacyjnego, można zmienić ten plik, tak by
wskazywał, że funkcja @code{system} jest dostępna.

@node Użytkowanie na Atari, , Kompilowanie na Atari, Instalacja na Atari
@appendixsubsec Uruchamianie @code{gawk} na Atari ST

Wykonywalna wersja @code{gawk} powinna być umieszczona, jak zwykle,
gdziekolwiek w ścieżce wyszukiwania @code{PATH}, gdzie może ją znaleźć
nasza powłoka.

Podczas wykonywania @code{gawk} tworzy wiele plików tymczasowych.
@code{gawk} przy korzystaniu z bibliotek @code{gcc} do TOS szuka zmiennej
środowiska albo @code{TEMP} albo @code{TMPDIR}, w tej kolejności.
Jeżeli znaleziono którąś z nich, to zakłada się, że jej wartość jest
katalogiem na pliki tymczasowe.  Katalog ten musi istnieć, a jeżeli możliwe
jest poświęcenie pamięci, dobrze jest umieścić go na napędzie RAM.  Jeżeli
nie znaleziono ani @code{TEMP} ani @code{TMPDIR}, to do przechowywania
plików tymczasowych @code{gawk} wykorzystuje katalog bieżący.

Wersja @code{gawk} przeznaczona dla ST szuka swoich plików programów jak
opisano w
@ref{Zmienna AWKPATH, ,Zmienna środowiska @code{AWKPATH}}.  Domyślna wartość
zmiennej @code{AWKPATH} pobierana jest z @code{DEFPATH} zdefiniowanej
w @file{Makefile}. Przykładowy, przeznaczony do pracy z @code{gcc}/TOS, plik
@file{Makefile} dla ST w zestawie dystrybucyjnym nadaje @code{DEFPATH}
wartość @code{@w{".,c:\lib\awk,c:\gnu\lib\awk"}}.  Ścieżkę wyszukiwania
zmienia się jawnie nadając @code{AWKPATH} żądaną wartość.  Zauważ, że na
ST do oddzielania elementów w zmiennej @code{AWKPATH} nie można użyć
dwukropków, gdyż mają one inne, zastrzeżone znaczenia.  Do rozdzielenia
elementów ścieżki należy zamiast tego użyć przecinka.  Przy rekompilacji
znak rozdzielający można zmienić inicjując inną wartością zmienną
@code{envsep} w @file{atari/gawkmisc.atr}.

Chociaż @code{awk} zezwala na dużą elastyczność przy dokonywaniu
przekierowań wejścia/wyjścia z programu, cecha ta na ST pracującej pod
kontrolą TOS powinna być wykorzystywana z rozwagą.  W pewnych okolicznościach
procedury systemu operacyjnego do przetwarzania kolejki uchwytów plików
tracą ślady niektórych zdarzeń, co powoduje pad komputera i wymaga
ponownego uruchomienia systemu.  Często wystarcza gorący restart.
Na szczęście, zdarza się to rzadko, i raczej w bardzo tajemniczych
sytuacjach.  W szczególności, powinno się unikać rozwiązań, w których
jakaś część programu @code{awk} stosuje instrukcje @code{print} jawnie
przekierowane do @code{"/dev/stdout"}, podczas gdy inne instrukcje
@code{print} używają domyślnego standardowego wyjścia, a wywołująca powłoka
przekierowała standardowe wyjście do pliku.

Gdy @code{gawk} skompilowany jest za pomocą @code{gcc} w wersji ST i jego
zwykłych bibliotek, przyjmuje jako separatory ścieżki zarówno @samp{/},
jak i @samp{\}.  Mimo że jest to wygodne, należy pamiętać, że odbiera jeden,
poprawny z technicznego punktu widzenia, znak (@samp{/}) z nazw plików.
Może to powodować kłopoty z programami zewnętrznymi, wywoływanymi za
pośrednictwem funkcji @code{system}, które mogą nie przestrzegać tej
konwencji.  Każdorazowo, gdy istnieje możliwość, że plik stworzony przez
@code{gawk} będzie wykorzystywany przez inne programy, należy w jego nazwie
używać tylko odwrotnych ukośników.  Powinno się też pamiętać, że w @code{awk}
odwrotne ukośniki w łańcuchach muszą być podwojone, jeśli chcemy uzyskać
dosłowne odwrotne ukośniki (@pxref{Sekwencje specjalne}).

@node Instalacja na Amidze, Błędy, Instalacja na Atari, Instalacja
@appendixsec Instalowanie @code{gawk} na Amidze

@cindex amiga
@cindex instalacja, amiga
Na systemie Amiga można zainstalować @code{gawk} korzystając z emulacji
środowiska Uniksa dostępnej poprzez anonimowe @code{ftp}
z @code{ftp.ninemoons.com} w katalogu @file{pub/ade/current}.
Zawiera ono powłokę opartą na @code{pdksh}.  Główną składową tego środowiska
jest biblioteka emulacji Uniksa, @file{ixemul.lib}.
@c could really use more background here, who wrote this, etc.

Bardziej kompletna dystrybucja przeznaczona na Amigę dostępna jest
na Geek Gadgets CD-ROM z:

@quotation
CRONUS @*
1840 E. Warner Road #105-265 @*
Tempe, AZ 85284  USA @*
US Toll Free: (800) 804-0833 @*
Phone: +1-602-491-0442 @*
FAX: +1-602-491-0048 @*
Email:  @code{info@@ninemoons.com} @*
WWW: @code{http://www.ninemoons.com} @*
Anonymous @code{ftp} site: @code{ftp.ninemoons.com} @*
@end quotation

Po uzyskaniu dystrybucji, konfigurujemy @code{gawk} po prostu uruchamiając
@code{configure}:

@example
configure -v m68k-amigaos
@end example

Następnie uruchamiamy @code{make} i powinniśmy mieć wszystko ustawione!
(Jeśli te kroki nie zadziałają, proszę wysłać zgłoszenie błędu
@pxref{Błędy, ,Zgłaszanie problemów i błędów}.)

@node Błędy, Inne wersje, Instalacja na Amidze, Instalacja
@appendixsec Zgłaszanie problemów i błędów
@display
@i{Nie ma nic bardziej niebezpiecznego niż znudzony archeolog.}
Autostopem przez Galaktykę
@c słuchowisko radiowe, nie książka. :-)
@end display
@sp 1

Jeśli masz kłopoty z @code{gawk} albo sądzisz, że znalazłeś błąd,
zgłoś, proszę, twórcom.  Nie możemy obiecać, że cokolwiek zrobimy, ale może
będziemy chcieli go poprawić.

Przed zgłoszeniem błędu, upewnij się, że faktycznie znalazłeś prawdziwy
błąd.  Uważnie przeczytaj ponownie dokumentację i sprawdź, czy rzeczywiście
mówi, że możesz zrobić to, co usiłujesz.  Jeżeli nie jest jasne, czy
powinieneś móc coś zrobić, czy nie, zgłoś to także -- jest to błąd
w dokumentacji!

Przed zgłoszeniem błędu lub próbą samodzielnego poprawienia go, spróbuj go
wyodrębnić do najmniejszego możliwego programu @code{awk} i pliku danych
wejściowych, które powielają problem.  Następnie wyślij nam pliki programu
i danych, jakieś pojęcie o rodzaju systemu uniksowego, którego używasz,
i dokładne rezultaty, jakie dał @code{gawk}.  Powiedz też, czego się
spodziewałeś: pomaga to rozstrzygnąć, czy problem nie leżał rzeczywiście
w dokumentacji.

Gdy problem jest już sprecyzowany, prześlij e-mail w języku angielskim
do @email{bug-gawk@@gnu.org}.

Dołącz, proszę, numer używanej wersji @code{gawk}.  Informację tę można
uzyskać poleceniem @samp{gawk --version}.  Skorzystanie z wyżej podanego
adresu automatycznie wyśle kopię twojej wiadomości do Arnolda Robbinsa.
Jeśli jest to konieczne, jest on też osiągalny wprost
pod adresem @email{arnold@@gnu.org}.

@cindex @code{comp.lang.awk}
@strong{Ważne!} Proszę @emph{nie} wysyłać listów ze zgłoszeniami błędów
w @code{gawk} na grupę dyskusyjną @code{comp.lang.awk}.
Mimo że twórcy @code{gawk} czasami czytają tę grupę, nie ma żadnej pewności,
że zobaczą twój list.  Kroki opisane wyżej są oficjalną, uznaną metodą
zgłaszania błędów.

Zawsze mile widziane są też sugestie nie związane z błędami.  Jeśli masz
pytania dotyczące niejasności w dokumentacji czy niezrozumiałych cech,
zapytaj Arnolda Robbinsa. Spróbuje ci pomóc, choć może nie mieć czasu, by
rozwiązać problem.  Możesz wysłać mu list elektroniczny na adres internetowy
podany powyżej.

Jeżeli napotkasz błąd w jednym z nie-uniksowych @code{gawk}, wyślij proszę
wiadomość pocztą elektroniczną do osoby zajmującej się przeniesieniem
@code{gawk} na tę platformę.  Wymieniono je niżej, a także w pliku
@file{README} pakietu dystrybucyjnego @code{gawk}.
Jeżeli informacja w pliku @file{README} jest sprzeczna z podaną tutaj,
to powinna być uważana za autorytatywną.

@c NEEDED for looks
@page
Osoby zajmujące się przeniesieniem @code{gawk} na systemy nie-uniksowe:

@cindex Deifik, Scott
@cindex Fish, Fred
@cindex Hankerson, Darrel
@cindex Jaegermann, Michal
@cindex Rankin, Pat
@cindex Rommel, Kai Uwe
@table @asis
@item MS-DOS
Scott Deifik, @samp{scottd@@amgen.com} i
Darrel Hankerson, @samp{hankedr@@mail.auburn.edu}.

@item OS/2
Kai Uwe Rommel, @samp{rommel@@ars.de}.

@item VMS
Pat Rankin, @samp{rankin@@eql.caltech.edu}.

@item Atari ST
Michal Jaegermann, @samp{michal@@gortel.phys.ualberta.ca}.

@item Amiga
Fred Fish, @samp{fnf@@ninemoons.com}.
@end table

Jeżeli twój błąd daje się powielić także na Uniksie, prześlij proszę kopie
swego zgłoszenia na ogólną listę błędów GNU, a także do Arnolda Robbinsa,
na wskazane wyżej adresy.

@node Inne wersje, , Błędy, Instalacja
@appendixsec Inne wolnodostępne implementacje @code{awk}
@cindex Brennan, Michael
@ignore
From: emory!amc.com!brennan (Michael Brennan)
Subject: C++ comments in awk programs
To: arnold@gnu.ai.mit.edu (Arnold Robbins)
Date: Wed, 4 Sep 1996 08:11:48 -0700 (PDT)

@end ignore
@display
@i{Wstawianie takich komentarzy w programie awk jest rodzajem zabawy.}
      @code{// Czy komentarze z C++ działają? odpowiedź: tak! oczywiście}
Michael Brennan
@end display
@sp 1

Istnieją dwie inne swobodnie dostępne implementacje @code{awk}
Niniejsza sekcja pokrótce opisuje, skąd je wziąć.

@table @asis
@cindex Kernighan, Brian
@cindex anonymous @code{ftp}
@cindex @code{ftp}, anonimowe
@item Unix @code{awk}
Brian Kernighan był w stanie uczynić swoją implementację @code{awk}
wolnodostępną.  Można ją uzyskać przez anonimowe @code{ftp} z serwera
@code{@w{netlib.bell-labs.com}}.  Należy zmienić katalog na
to @file{/netlib/research}, zastosować tryb ``binary'' lub ``image''
i pobrać @file{awk.bundle.gz}.

Jest to archiwum powłoki, które zostało skompresowane narzędziem GNU
@code{gzip}. Dekompresuje się je narzędziem @code{gunzip}.

Można ją też pobrać za pośrednictwem WWW
z jego @uref{http://cm.bell-labs.com/who/bwk, strony domowej}.

Wersja ta wymaga kompilatora ANSI C; GCC (kompilator C z projektu GNU)
działa całkiem nieźle.

@cindex Brennan, Michael
@cindex @code{mawk}
@item @code{mawk}
Michael Brennan napisał niezależną implementację @code{awk}, nazwaną
@code{mawk}.  Jest dostępna na zasadach GPL
(@pxref{Kopiowanie, ,GNU GENERAL PUBLIC LICENSE}), tak samo jak @code{gawk}.

Można ją uzyskać przez anonimowe @code{ftp} z serwera
@code{@w{ftp.whidbey.net}}.  Należy zmienić katalog na
@file{/pub/brennan}, zastosować tryb ``binary'' lub ``image'' i pobrać
@file{mawk1.3.3.tar.gz} (lub najnowszą wersję, jaka tam jest).

Dekompresję tego pliku można wykonać za pomocą @code{gunzip}.
Instalacja jest zbliżona jak w przypadku @code{gawk}
(@pxref{Instalacja na Uniksie, , Kompilowanie i instalowanie @code{gawk} na Uniksie}).
@end table

@node Uwagi, Słownik, Instalacja, Top
@appendix Uwagi implementacyjne

W tym dodatku zawarto informacje istotne głównie dla osób tworzących
i rozwijających @code{gawk}.  Całość jest swoista dla @code{gawk} i nie
odnosi się do innych implementacji.

@menu
* Tryb zgodności::              Jak wyłączyć pewne rozszerzenia @code{gawk}.
* Uzupełnienia::                Tworzenie uzupełnień @code{gawk}.
* Przyszłe rozszerzenia::       Nowe możliwości, które kiedyś mogą zostać
                                wprowadzone.
* Usprawnienia::                Sugestie usprawnień, jakie mogą wykonać
                                ochotnicy.
@end menu

@node Tryb zgodności, Uzupełnienia, Uwagi, Uwagi
@appendixsec Zgodność w dół i debuggowanie

@xref{POSIX/GNU, ,Extensions in @code{gawk} Not in POSIX @code{awk}},
gdzie podsumowano rozszerzenia GNU w stosunku do programu i języka @code{awk}.
Wszystkie te możliwości można wyłączyć wywołując @code{gawk} z opcją
@samp{--traditional} lub z opcją @samp{--posix}.

Jeżeli @code{gawk} skompilowano do diagnostyki z @samp{-DDEBUG}, to
w wierszu poleceń jest dostępna jeszcze jedna opcja:

@table @code
@item -W parsedebug
@itemx --parsedebug
Wypisuje informacje stosu analizatora podczas analizy składniowej programu.
@end table

Opcję tę przewidziano tylko dla poważnych twórców @code{gawk}, a nie dla
przypadkowego użytkownika.  Prawdopodobnie nie została nawet wkompilowana
w twoją wersję @code{gawk}, gdyż spowalnia wykonywanie.

@node Uzupełnienia, Przyszłe rozszerzenia, Tryb zgodności, Uwagi
@appendixsec Tworzenie uzupełnień @code{gawk}

Jeżeli masz zamiar w znaczący sposób poszerzyć @code{gawk}, masz pełną
swobodę w tej kwestii.  To właśnie jest zasadniczą cechą wolnego
oprogramowania: kod źródłowy jest dostępny i możesz bez swobodnie zmieniać go
jak zechcesz (@pxref{Kopiowanie, ,GNU GENERAL PUBLIC LICENSE}).

W tej sekcji omówiono dziedziny, w jakich można zmienić @code{gawk},
i warunki, o których powinno się pamiętać.

@menu
* Dodawanie kodu::              Dodawanie kodu do głównego ciała @code{gawk}.
* Nowe przeniesienia::          Przenoszenie @code{gawk} na nowy system
                                operacyjny.
@end menu

@node Dodawanie kodu, Nowe przeniesienia, Uzupełnienia, Uzupełnienia
@appendixsubsec Dodawanie nowych możliwości

@cindex dodawanie nowych możliwości
@cindex możliwości, dodawanie
@cindex cechy, dodawanie
Jeżeli chcesz, możesz swobodnie dodawać nowe możliwości do @code{gawk}.
Jeśli jednak chciałbyś, by te zmiany zostały zawarte w dystrybucji
@code{gawk}, to jest kilka kroków, jakie powinieneś podjąć, bym mógł
wcielić twoje zmiany.

@enumerate 1
@item
Pobierz najnowszą wersję.
Znacznie łatwiej mi scalać zmiany jeśli odnoszą się do najświeższej
rozpowszechnianej wersji @code{gawk}.  Jeśli twoja wersja @code{gawk} będzie
bardzo stara, mogę nie być w stanie zintegrować jej w ogóle.
@xref{Pozyskiwanie, ,Pozyskiwanie pakietu dystrybucyjnego @code{gawk}}, gdzie opisano
pozyskiwanie najnowszej wersji @code{gawk}.

@item
@iftex
Przestrzegaj @cite{Standardów Kodowania GNU}.
@end iftex
@ifinfo
Zobacz @inforef{Top, , Version, standards, GNU Coding Standards}.
@end ifinfo
Dokument ten opisuje w jaki sposób powinno być pisane oprogramowanie GNU.
Jeśli go nie czytałeś, proszę przeczytaj, najlepiej @emph{przed}
rozpoczęciem modyfikowania @code{gawk}.  (@cite{Standardy Kodowania GNU}
są częścią pakietu dystrybucyjnego Autoconf, z FSF.)

@cindex kodowanie, styl stosowany w @code{gawk}
@cindex @code{gawk}, styl kodowania
@cindex styl kodowania stosowany w @code{gawk}
@item
Korzystaj ze stylu kodowania @code{gawk}.
Kod C użyty do budowy @code{gawk} kieruje się instrukcjami zawartymi w
@cite{Standardach Kodowania GNU}, z pomniejszymi wyjątkami.
Kod sformatowano korzystając z tradycyjnego stylu ``K&R'', szczególnie
tyczy się to umieszczania nawiasów klamrowych i zastosowania tabulacji.
W skrócie, reguły kodowania użyte w @code{gawk} są następujące:

@itemize @bullet
@item
Przy definiowaniu funkcji stosujemy nagłówki w starym stylu
(bez prototypowania funkcji).

@item
Nazwę funkcji umieszczamy na początku wiersza.

@item
Typ zwracany przez funkcję, nawet jeśli jest to @code{int}, umieszczamy
w wierszu powyżej wiersza z nazwą i argumentami funkcji.

@item
Deklaracje argumentów funkcji nie powinny być wcięte.

@item
Wokół nawiasów używanych w strukturach sterujących
(@code{if}, @code{while}, @code{for}, @code{do}, @code{switch}
i @code{return}) umieszczamy spacje.

@item
Nie umieszczamy spacji przed nawiasami stosowanymi w wywołaniach funkcji.

@item
Umieszczamy spacje wokół wszystkich operatorów C i po przecinkach
w wywołaniach funkcji.

@item
Nie używamy operatora przecinkowego do tworzenia wielu efektów ubocznych,
z wyjątkiem części inicjujących i inkrementujących pętli @code{for},
oraz w ciałach makr.

@item
Do wcięć używamy prawdziwych tabulacji, nie spacji.

@item
Używamy rozmieszczenia nawiasów klamrowych w stylu``K&R''.

@item
Używamy porównań z @code{NULL} i @code{'\0'} w warunkach instrukcji
@code{if}, @code{while} i @code{for} oraz w przypadkach @code{case}
instrukcji @code{switch}, zamiast zwykłego, jawnego wskaźnika czy wartości
znakowej.

@item
Zamiast @code{1} i @code{0} stosujemy, gdzie jest to właściwe, stałe
symboliczne @code{TRUE}, @code{FALSE} i @code{NULL} i stałą znakową
@code{'\0'}.

@item
Każdą funkcję zaopatrujemy w jednowierszowy opisowy komentarz.

@item
Nie używamy @samp{#elif}.  Wiele starszych kompilatorów Unix C nie
potrafi go obsłużyć.

@item
Do alokacji pamięci ze stosu nie stosujemy funkcji @code{alloca}.
Korzystanie z niej powoduje więcej kłopotów z przenośnością niż daje
niewielkich korzyści brak konieczności zwalniania przydziału pamięci.
Zamiast tego, używamy @code{malloc} i @code{free}.
@end itemize

Jeśli będę musiał ponownie formatować twój kod, by dostosować go do stylu
kodowania stosowanego w @code{gawk}, być może nie będzie mi się chciało.

@item
Bądź przygotowany na podpisanie odpowiednich papierów.
Aby FSF mogła rozprowadzać twoje zmiany, musisz albo zamieścić je jako
public-domain i dostarczyć podpisane oświadczenie to stanowiące, albo
przyznać prawa autorskie FSF.  Obie te rzeczy łatwo wykonać i @emph{wiele}
osób już to zrobiło.  Jeśli masz pytania, proszę skontaktuj się ze mną
(@pxref{Błędy, , Zgłaszanie problemów i błędów}) lub @code{gnu@@gnu.org}.

@item
Zaktualizuj dokumentację.
Proszę, dostarcz razem ze swym nowym kodem nowe sekcje czy rozdziały do tej
książki.  Jeśli to możliwe, proszę użyj prawdziwego Texinfo zamiast dawać
po prostu niesformatowany tekst ASCII (mimo to, nawet to jest lepsze niż
brak dokumentacji w ogóle).  Konwencje, jakie powinny być stosowane
w @cite{@value{TITLE}} podano po @samp{@@bye} na końcu pliku źródłowego
Texinfo.  Jeśli to możliwe, proszę też zaktualizować stronę dokumentacji
systemowej man.

Będziesz także musiał podpisać odpowiednie papiery dotyczące zmian
w dokumentacji.

@item
Zmiany wysyłaj jako pliki różnic kontekstowych diff lub zunifikowane diff.
Do porównania oryginalnego drzewa źródłowego @code{gawk} ze swoją wersją
zastosuj @samp{diff -c -r -N} lub @samp{diff -u -r -N}.
(Pliki różnic kontekstowych są dla mnie czytelniejsze, ale pliki w formacie
zunifikowanym mają mniejsze rozmiary.)  Polecam wykorzystywanie @code{diff}
w wersji GNU.  Dostarczając zmiany prześlij mi, proszę, wyjście
utworzone przez któryś z podanych przebiegów @code{diff}.
@xref{Błędy, , Zgłaszanie problemów i błędów}, gdzie podano informacje o
poczcie elektronicznej.

Stosowanie tego formatu ułatwia mi nanoszenie twoich zmian na główną wersję
kodu źródłowego @code{gawk} (za pomocą @code{patch}).  Jeśli będę musiał
nanosić zmiany ręcznie, korzystając z edytora tekstów, mogę tego nie
zrobić, szczególnie jeśli to wiele zmian.

@item
Do dostarczonej pracy dołącz wpis przeznaczony do umieszczenia
w @file{ChangeLog}.
Pomoże to później w minimalizacji ilości pracy, jaką muszę wykonać,
ułatwiając mi zaakceptowanie poprawek.
@end enumerate

Chociaż wygląda to na mnóstwo pracy, proszę pamiętaj, że choć ty sam piszesz
nowy kod, ja muszę się nim opiekować i obsługiwać, a jeżeli nie będę
mógł tego robić przy minimum dodatkowej pracy, to prawdopodobnie nie będę
robił.

@node Nowe przeniesienia, , Dodawanie kodu, Uzupełnienia
@appendixsubsec Przenoszenie @code{gawk} na nowy system operacyjny

@cindex porting @code{gawk}
Jeżeli chciałbyś przenieść @code{gawk} na nowy system operacyjny, to
należy przestrzegać kilku zasad.

@enumerate 1
@item
Przestrzegaj wskazówek z @ref{Dodawanie kodu, ,Dodawanie nowych możliwości},
dotyczących stylu kodowania, dostarczania plików diff, i tak dalej.

@item
Wykonując przeniesienie, pamiętaj, że twój kod musi zgodnie współżyć
z resztą @code{gawk} i wersjami na inne platformy.  Unikaj nieuzasadnionych
zmian w częściach kodu niezależnych od systemu.  Jeżeli jest to możliwe,
unikaj rozsiewania @samp{#ifdef}-ów tylko dla swojej wersji po całym kodzie.

Jeżeli niezbędne dla danego systemu zmiany będą zbytnio wpływać na kod,
prawdopodobnie ich nie zaakceptuję.  W takim przypadku, będziesz mógł,
oczywiście, rozpowszechniać zmiany na własną rękę, dopóki będziesz działać
zgodnie z GPL (@pxref{Kopiowanie, ,GNU GENERAL PUBLIC LICENSE}).

@item
Wieloma plikami dostarczanych z @code{gawk} opiekują się inni ludzie
z Free Software Foundation.  Nie powinieneś zatem ich zmieniać, chyba że
masz bardzo mocne uzasadnienie.  Tzn.@: zmiany nie są wykluczone, ale zmiany
w tych plikach będą analizowane szczególnie uważnie.  Plikami tymi są:
@file{alloca.c}, @file{getopt.h}, @file{getopt.c}, @file{getopt1.c},
@file{regex.h}, @file{regex.c}, @file{dfa.h}, @file{dfa.c},
@file{install-sh} i @file{mkinstalldirs}.

@item
Bądź gotów kontynuować opiekę nad swoim przeniesieniem.
Nieuniksowe systemy operacyjne wspierane są przez ochotników, którzy
pielęgnują kod potrzebny do kompilacji i uruchomienia @code{gawk} na ich
systemach.  Jeżeli żaden z ochotników nie opiekuje się wersją na daną
platformę, przeniesienie takie staje się nieobsługiwane, i może być
konieczne usunięcie go z dystrybucji.

@item
Zapewnij odpowiedni plik @file{gawkmisc.???}.
Każda z przeniesionych wersji posiada własny @file{gawkmisc.???}, który
implementuje pewne funkcje specyficzne dla danego systemu operacyjnego.
Jest to przejrzystsze niż multum instrukcji @samp{#ifdef} rozrzuconych
po całym kodzie.  @file{gawkmisc.c} w głównym katalogu źródłowym dołącza
odpowiedni plik @file{gawkmisc.???} z każdego z podkatalogów.  Upewnij się,
że to także zaktualizowałeś.

Plik @file{gawkmisc.???} każdej z przeniesionych wersji posiada przyrostek
wskazujący odpowiednią nazwę maszyny czy systemu operacyjnego.  Na przykład,
@file{pc/gawkmisc.pc} i @file{vms/gawkmisc.vms}.  Zastosowanie osobnych
przyrostków, zamiast zwykłego @file{gawkmisc.c}, umożliwia przesuwanie
plików z podkatalogu danego systemu do głównego podkatalogu, bez ryzyka
przypadkowego zniszczenia faktycznego pliku @file{gawkmisc.c}.
(Obecnie dotyczy to tylko przenoszenia @code{gawk} na MS-DOS i OS/2.)

@item
Dostarcz @file{Makefile} i ewentualne inne pliki źródłowe i nagłówkowe C,
które są niezbędne dla twojego systemu operacyjnego.  Całość twego kodu
powinna być w osobnym podkatalogu, o nazwie takiej jak, lub przypominającej,
nazwę systemu operacyjnego albo komputera.  Jeżeli to możliwe, spróbuj
zorganizować to tak, by nie było konieczne przesuwanie plików z podkatalogu
do głównego katalogu źródłowego.  Jeśli nie jest to możliwe, upewnij się, że
nie używasz dla swoich plików nazw dublujących nazwy plików z głównego
katalogu źródłowego.

@item
Zaktualizuj dokumentację.
Napisz, proszę, sekcję (czy sekcje) do tej książki opisującą etapy
instalacji i konfiguracji potrzebne do zainstalowania i/lub skompilowania
@code{gawk} w twoim systemie.

@item
Bądź przygotowany na podpisanie odpowiednich papierów.
Aby FSF mogła rozprowadzać twoje zmiany, musisz albo zamieścić je jako
public-domain i dostarczyć podpisane oświadczenie to stanowiące, albo
przyznać prawa autorskie FSF.
@ifinfo
Obie te rzeczy łatwo wykonać i @emph{wiele} osób już to zrobiło.  Jeśli
masz pytania, proszę skontaktuj się ze mną
(@pxref{Błędy, ,Zgłaszanie problemów i błędów}) lub @code{gnu@@gnu.org}.
@end ifinfo
@end enumerate

Przestrzeganie tych wskazań znacznie ułatwi zintegrowanie twoich zmian
z @code{gawk} i umożliwi szczęśliwe współistnienie z kodem przeznaczonym
do innych systemów operacyjnych, który już tu jest.

W kodzie, jaki dostarczasz i którym się opiekujesz, możesz swobodnie
stosować taki styl kodowania i układ nawiasów klamrowych, jaki ci odpowiada.

@node Przyszłe rozszerzenia, Usprawnienia, Uzupełnienia, Uwagi
@appendixsec Prawdopodobne przyszłe rozszerzenia
@ignore
From emory!scalpel.netlabs.com!lwall Tue Oct 31 12:43:17 1995
Return-Path: <emory!scalpel.netlabs.com!lwall>
Message-Id: <9510311732.AA28472@scalpel.netlabs.com>
To: arnold@skeeve.atl.ga.us (Arnold D. Robbins)
Subject: Re: May I quote you?
In-Reply-To: Your message of "Tue, 31 Oct 95 09:11:00 EST."
             <m0tAHPQ-00014MC@skeeve.atl.ga.us>
Date: Tue, 31 Oct 95 09:32:46 -0800
From: Larry Wall <emory!scalpel.netlabs.com!lwall>

: Greetings. I am working on the release of gawk 3.0. Part of it will be a
: thoroughly updated manual. One of the sections deals with planned future
: extensions and enhancements.  I have the following at the beginning
: of it:
:
: @cindex PERL
: @cindex Wall, Larry
: @display
: @i{AWK is a language similar to PERL, only considerably more elegant.} @*
: Arnold Robbins
: @sp 1
: @i{Hey!} @*
: Larry Wall
: @end display
:
: Before I actually release this for publication, I wanted to get your
: permission to quote you.  (Hopefully, in the spirit of much of GNU, the
: implied humor is visible... :-)

I think that would be fine.

Larry
@end ignore
@cindex PERL
@cindex Wall, Larry
@display
@i{AWK jest językiem podobnym do PERLA, tylko znacznie bardziej eleganckim.}
Arnold Robbins

@i{Hey!}
Larry Wall
@end display
@sp 1

W tej sekcji wymieniono pokrótce rozszerzenia i możliwe usprawnienia,
wskazujące kierunki rozwoju @code{gawk}, jakie obecnie rozważamy.
Plik @file{FUTURES} w pakietach dystrybucyjnych @code{gawk} również
podaje te rozszerzenia.

Oto zestawienie prawdopodobnych przyszłych zmian do użytku programujących
w języku @code{awk}.

@c uszeregowane wg prawdopodobieństwa
@table @asis
@item Lokalizacja
Projekt GNU zaczyna obsługiwanie wielu języków.  Możliwe będzie co najmniej
wypisywanie przez @code{gawk} ostrzeżeń i komunikatów o błędach w językach
innych niż angielski.  Możliwe, że, prócz samego @code{gawk}, programy
@code{awk} będą mogły korzystać ze programów wspomagających z obsługą wielu
języków.

@item Bazy danych
Być może możliwe będzie odwzorowywanie pliku GDBM/NDBM/SDBM na tablicę
@code{awk}.

@item Tablica @code{PROCINFO}
Pliki specjalne, zapewniające dostęp do informacji dotyczących procesu
(@pxref{Pliki specjalne, ,Specjalne nazwy plików w @code{gawk}})
zostaną zastąpione tablicą @code{PROCINFO}, która dostarczy tych samych
danych, w sposób łatwiejszy w dostępie.

@item Więcej ostrzeżeń @code{lint}
Istnieje więcej rzeczy, które mogłyby być sprawdzane z uwagi na przenośność.

@item Kontrola nad środowiskiem podprocesu
Zmiany poczynione w @code{gawk} w tablicy @code{ENVIRON} mogą przenosić się
na procesy uruchamiane przez @code{gawk}.

@ignore
@item @code{RECLEN} variable for fixed length records
Along with @code{FIELDWIDTHS}, this would speed up the processing of
fixed-length records.

@item A @code{restart} keyword
After modifying @code{$0}, @code{restart} would restart the pattern
matching loop, without reading a new record from the input.

@item A @samp{|&} redirection
The @samp{|&} redirection, in place of @samp{|}, would open a two-way
pipeline for communication with a sub-process (via @code{getline} and
@code{print} and @code{printf}).

@item Function valued variables
It would be possible to assign the name of a user-defined or built-in
function to a regular @code{awk} variable, and then call the function
indirectly, by using the regular variable.  This would make it possible
to write general purpose sorting and comparing routines, for example,
by simply passing the name of one function into another.

@item A built-in @code{stat} function
The @code{stat} function would provide an easy-to-use hook to the
@code{stat} system call so that @code{awk} programs could determine information
about files.

@item A built-in @code{ftw} function
Combined with function valued variables and the @code{stat} function,
@code{ftw} (file tree walk) would make it easy for an @code{awk} program
to walk an entire file tree.
@end ignore
@end table

Oto lista prawdopodobnych ulepszeń, które spowodują, że @code{gawk} będzie
miał lepszą wydajność.

@table @asis
@item Udoskonalona wersja @code{dfa}
Dopasowywacz wzorców @code{dfa} z programu GNU @code{grep} na pewne
problemy.  Nowa lub poprawiona wersja będzie sobie radzić z niektórymi
ważnymi kwestiami dotyczącymi dopasowywania wyrażeń regularnych.

@item Wykorzystanie GNU @code{malloc}
@code{malloc} w wersji GNU może potencjalnie przyspieszyć @code{gawk},
gdyż w dużym stopniu opiera się na stosowaniu dynamicznej alokacji pamięci.

@end table

@node Usprawnienia,  , Przyszłe rozszerzenia, Uwagi
@appendixsec Sugestie usprawnień

Oto kilka projektów, jakie być może zechcą podjąć przyszli hakerzy
@code{gawk}.  Wielkość projektów waha się od kilku dni do kilku tygodni
programowania, w zależności od tego, który wybierzesz i jak szybkim jesteś
programistą.  Wszystkie napisane ulepszenia proszę przesyłać do opiekunów
w projekcie GNU.
@xref{Dodawanie kodu, , Dodawanie nowych możliwości},
gdzie zamieszczono wytyczne, jakich należy przestrzegać dodając nowe
możliwości do @code{gawk}.  @xref{Błędy, ,Zgłaszanie problemów i błędów},
gdzie podano informacje o kontaktowaniu się z opiekunami @code{gawk}.

@enumerate
@item
Kompilacja programów @code{awk}: @code{gawk} do konwersji podanego skryptu
na drzewo składni wykorzystuje analizator składni Bison (podobny do YACC).
Następnie drzewo składniowe wykonywane jest przez prosty rekurencyjny
ewaluator.  Odbywa to się sporym kosztem, gdyż ewaluator wykonuje wiele
wywołań procedur do zrobienia nawet najprostszych rzeczy.

Powinno być możliwe, by @code{gawk} przekształcał drzewo składniowe skryptu
w program C, który użytkownik mógłby następnie skompilować, korzystając
ze zwykłego kompilatora C i specjalnej biblioteki @code{gawk},
dostarczającej wszystkich niezbędnych funkcji (wyrażenia regularne, pola,
tablice asocjacyjne, koercja typów, i tak dalej).

Łatwiejszą możliwością może być faza pośrednia @code{awk}, konwersji
drzewa składniowego na postać liniowego kodu bajtowego jak to jest
w GNU Emacs Lisp.  Ewaluator rekurencyjny można by wówczas zastąpić
zwykłym interpreterem kodu bajtowego, co byłoby wypośrodkowane
szybkością między uruchamianiem skompilowanego programu a robieniem tego,
co  @code{gawk} robi obecnie.

@item
Programy z zestawu testowego mogłyby korzystać ze sposobu dokumentacji
z tej książki.

@item
Więcej pomysłów można znaleźć w pliku @file{FUTURES}.  Skontaktuj się
z nami jeśli chciałbyś poważnie zmierzyć się z którymś z wymienionych
tu zadań.
@end enumerate

@node Słownik, Kopiowanie, Uwagi, Top
@appendix Słownik

@table @asis
@item Akcja (action)
Ciąg instrukcji @code{awk} związanych z regułą.  Jeżeli rekord wejściowy
pasuje do wzorca reguły, @code{awk} wykonuje akcję tej reguły.
Akcje są zawsze objęte nawiasami klamrowymi.
@xref{Przegląd akcji, ,Przegląd akcji}.

@item Amazingly Workable Formatter (@code{awf}, O dziwo zdatny formater)
Henry Spencer z Uniwersytetu w Toronto napisał formater akceptujący duży
podzbiór poleceń formatujących @samp{nroff -ms} i @samp{nroff -man},
używając @code{awk} i @code{sh}.

@item ANSI
American National Standards Institute.  Organizacja tworząca wiele
standardów, między innymi standardy języków programowania C i C++.

@item Bash
Wersja GNU standardowej powłoki (Bourne-Again shell).
Zobacz ``Bourne Shell''.

@item BBS
Zobacz ``Bulletin Board System''.

@item Biały znak (whitespace)
Sekwencja znaków spacji, tabulacji lub nowej linii występująca wewnątrz
rekordu wejściowego lub łańcucha.

@item Bourne Shell
Standardowa powłoka (@file{/bin/sh}) w Uniksie i systemach uniksopodobnych,
pierwotnie napisana przez Stevena R.@: Bourne'a.
Wiele powłok (Bash, @code{ksh}, @code{pdksh}, @code{zsh}) jest zasadniczo
zgodnych w górę z powłoką Bourne'a.

@item Bulletin Board System
System komputerowy umożliwiający użytkownikom logowanie się i czytanie
i/lub zostawianie wiadomości dla innych użytkowników tego systemu,
przypominający pozostawianie papierowych notek na tablicy ogłoszeniowej.

@item C
Język programowania systemowego, w którym napisana jest większość
oprogramowania GNU.  Język programowania @code{awk} ma składnię podobną do
C, a w niniejszej książce wskazano, w odpowiednich miejscach, na występujące
podobieństwa między @code{awk} i C.

@item Całkowita (integer)
Liczba całkowita, tj.@: liczba nie posiadająca części ułamkowej.

@item CHEM
Preprocesor współpracujący z @code{pic}, który czyta opisy cząsteczek
i tworzy wejście @code{pic} do ich narysowania.  Został napisany w @code{awk}
przez Briana Kernighana i Jona Bentleya, i jest dostępny
z @email{@w{netlib@@research.bell-labs.com}}.

@item Ciemny kąt (dark corner)
Obszar języka, w którym specyfikacje często były (lub nadal są) niejasne,
prowadząc do nieoczekiwanych czy niepożądanych zachowań.  Obszary takie
oznaczono w tej książce przez ``(c.k.)'' w tekście, a pod nagłówkiem
``ciemny kąt'' w indeksie.

@item Dynamiczne wyrażenie regularne (dynamic regular expression)
Dynamiczne wyrażenie regularne jest wyrażeniem regularnym zapisanym jak
zwykłe wyrażenie.  Może być stałą łańcuchową, jak @code{"foo"}, ale może
być też wyrażeniem, którego wartość może się zmieniać.
@xref{Regexp obliczane, , Stosowanie dynamicznych wyrażeń regularnych}.

@item Edytor strumieniowy (stream editor)
Program, który odczytuje rekordy ze standardowego strumienia wejściowego
i przetwarza je raz lub więcej razy w jednym przebiegu.  Różni się to od
przypadku programów wsadowych, które zakładają odczytywanie plików
wejściowych w całości przed rozpoczęciem jakiejkolwiek pracy nad nimi.
Jest też inne niż w przypadku programów interaktywnych, które wymagają
podania danych wejściowych przez użytkownika.

@item Format
Łańcuchy formatu używane są do sterowania wyglądem wyjścia instrukcji
@code{printf}.  Również konwersja danych z liczb na łańcuchy kontrolowana
jest przez łańcuch formatu zawarty w zmiennej wbudowanej @code{CONVFMT}.
@xref{Litery sterujące, ,Litery sterujące formatem}.

@item FSF
Zobacz ``Free Software Foundation''.

@item Free Software Foundation
Organizacja non-profit, której celem jest tworzenie i rozpowszechnianie
swobodnie rozpowszechnialnego oprogramowania.  Założona przez
Richarda M.@: Stallmana, autora oryginalnego edytora Emacs.  GNU Emacs jest
obecnie najszerzej używaną wersją Emacsa.

@item Funkcja
Wyspecjalizowana grupa instrukcji stosowana do zamknięcia w całość ogólnych
lub specyficznych dla programu zadań.  @code{awk} ma wiele funkcji
wbudowanych, pozwala też na definiowanie własnych.
@xref{Wbudowane, ,Funkcje wbudowane},
i @ref{Użytkownika, ,Funkcje użytkownika}.

@item Funkcja wbudowana (built-in function)
Język @code{awk} zapewnia funkcje wbudowane, które wykonują różnorodne
obliczenia numeryczne, związane z czasem czy łańcuchami znakowymi.
Przykładem jest @code{sqrt} (pierwiastek kwadratowy z liczby) czy
@code{substr} (podłańcuch łańcucha).  @xref{Wbudowane, ,Funkcje wbudowane}.

@item @code{gawk}
Implementacja @code{awk} wykonana w ramach projektu GNU.

@item General Public License
Dokument ten opisuje warunki, na jakich może być rozpowszechniany
@code{gawk} i jego źródła. (@pxref{Kopiowanie, ,GNU GENERAL PUBLIC LICENSE})

@item GNU
Akronim: ``GNU's not Unix'' (GNU nie jest Uniksem).  Nieustający projekt
Fundacji Wolnego Oprogramowania (FSF) mający na celu stworzenie kompletnego,
swobodnie rozpowszechnialnego, zgodnego z POSIX środowiska
obliczeniowego.

@item GPL
Zobacz ``General Public License''.

@item Instrukcja złożona (compound statement)
Szereg instrukcji @code{awk} ujętych w nawiasy klamrowe.  Instrukcje
złożone mogą być zagnieżdżane.
@xref{Instrukcje, ,Instrukcje sterujące w akcjach}.

@item I/O
Skrót od ``Input/Output'' (wejście/wyjście), czynność przemieszczenia danych
do i/lub z pracującego programu.

@item Język @code{awk}
Język, w którym pisane są programy @code{awk}.

@item Konkatenacja
Konkatenacja dwu łańcuchów oznacza sklejenie ich razem, jeden za drugim,
co daje nowy łańcuch.  Na przykład, łańcuch @samp{foo} skonkatenowany
z łańcuchem @samp{bar} daje łańcuch @samp{foobar}.
@xref{Konkatenacja, ,Konkatenacja łańcuchów}.

@item Liczba zmiennoprzecinkowa (floating point number)
Często wzmiankowana według terminologii matematycznej jako liczba
``wymierna'', jest po prostu liczbą, która może mieć część ułamkową.
Zobacz ``Podwójna precyzja'' i ``Pojedyncza precyzja''.

@item Liczba (number)
Obiekt danych o wartości numerycznej.  Implementacja @code{gawk} do
reprezentacji liczb wykorzystuje wartości zmiennoprzecinkowe o podwójnej
precyzji.
Bardzo stare implementacje @code{awk} stosują liczby zmiennoprzecinkowe
pojedynczej precyzji.

@item Lwartość (lvalue)
Wyrażenie, które może pojawić się po lewej stronie operatora przypisania.
W większości języków lwartościami mogą być zmienne lub elementy tablic.
W @code{awk} jako lwartość może być też użyte oznaczenie pola.

@item Łańcuch (string)
Dana składająca się z ciągu znaków, jak @samp{Jestem łańcuchem}.
W języku @code{awk} łańcuchy stałe zapisywane są w cudzysłowach i mogą
zawierać sekwencje specjalne.
@xref{Sekwencje specjalne}.

@item Łańcuch pusty (empty string)
Łańcuch nie mający żadnych znaków.  W programach @code{awk} reprezentowany
jest jawnie przez umieszczenie obok siebie dwu znaków cudzysłowu (@code{""}).
Może pojawić się w danych wejściowych, w miejscu dwu kolejnych wystąpień
separatora pól obok siebie.

@item Łańcuch zerowy (null string)
Zobacz ``Łańcuch pusty''.

@item Nawiasy klamrowe (curly braces)
Znaki @samp{@{} i @samp{@}}.  Nawiasy klamrowe stosowane są w @code{awk}
do rozgraniczania akcji, instrukcji złożonych i ciał funkcji.

@item Obiekty danych (data objects)
Są to liczby i łańcuchy znaków.  W razie potrzeby, liczby przekształcane
są na łańcuchy i vice versa.
@xref{Konwersja, ,Konwersja łańcuchów i liczb}.

@item Ósemkowa (octal)
Notacja o podstawie ósemkowej, gdzie cyframi są @code{0}-@code{7}.
Liczby ósemkowe zapisywane są w C za pomocą początkowego @samp{0}, co
wskazuje ich podstawę.  Zatem, @code{013} to 11 (jeden razy 8 plus 3).

@item Plik specjalny (special file)
Nazwa pliku interpretowana przez @code{gawk} wewnętrznie, a nie
przekazana wprost do obsłużenia przez stosowany system operacyjny.
Na przykład, @file{/dev/stderr}.
@xref{Pliki specjalne, ,Specjalne nazwy plików w @code{gawk}}.

@item Podwójna precyzja (double precision)
Wewnętrzna reprezentacja liczb, które mogą mieć część ułamkową.
Liczby podwójnej precyzji pamiętają więcej cyfr niż liczby pojedynczej
precyzji, ale działania na nich są bardziej kosztowne.  Jest to sposób,
w jaki @code{awk} przechowuje wartości numeryczne.  Jest to występujący
w C typ @code{double}.

@item Pojedyncza precyzja (single precision)
Wewnętrzna reprezentacja liczb, które mogą mieć część ułamkową.
Liczby pojedynczej precyzji pamiętają mniej cyfr niż liczby podwójnej
precyzji, ale działania na nich są mniej kosztowne, jeśli chodzi o czas CPU.
Tego typu do przechowywania wartości numerycznych używają niektóre bardzo
stare wersje @code{awk}.  Jest to występujący w C typ @code{float}.

@item Pole (field)
Gdy @code{awk} czyta rekord wejściowy, dzieli go na części oddzielone
białymi znakami (lub separującym wyrażeniem regularnym, które zmienia się
nadając nową wartość zmiennej wbudowanej @code{FS}).  Części takie nazywamy
polami.  Jeżeli są one stałej długości, to do opisu tych długości można
zastosować zmienną @code{FIELDWIDTHS}.
@xref{Separatory pól, ,Jak rozdzielać pola}, zobacz też
@xref{Stały rozmiar, , Czytanie danych o stałej szerokości}.

@item POSIX
Nazwa szeregu standardów opracowanych przez IEEE, które określają
interfejs przenośnego systemu operacyjnego (Portable Operating System
Interface).  Końcówka ``IX'' oznacza dziedzictwo standardów po systemie
Unix.  Głównym standardem, jaki może zainteresować użytkowników
@code{awk} jest @cite{IEEE Standard for Information Technology,
Standard 1003.2-1992, Portable Operating System Interface (POSIX) Part 2:
Shell and Utilities}.  Nieformalnie standard ten często zwany
jest po prostu ``P1003.2''.

@item Powszechna Licencja Publiczna
Zobacz ``General Public License''.

@item Program @code{awk}
Dowolny program @code{awk} składa się z szeregu @dfn{wzorców} i @dfn{akcji},
wspólnie znanych jako @dfn{reguły}.  Dla każdego rekordu wejściowego
podanego programowi przetwarzane są po kolei wszystkie reguły.
Programy @code{awk} mogą też zawierać definicje funkcji.

@item Prywatne (private)
Zmienne i/lub funkcje przeznaczone do wyłącznego użytku przez funkcje
biblioteczne, a nie w głównym @code{awk} programie.  Przy nazywaniu takich
zmiennych i funkcji należy zachować szczególną ostrożność.
@xref{Nazwy biblioteczne, ,  Nazywanie zmiennych globalnych funkcji bibliotecznych}.

@item Przekierowanie (redirection)
Przekierowanie oznacza wykonywanie pobierania danych (wejścia) z innego
miejsca niż standardowy strumień wejścia, lub wyjścia gdzie indziej niż do
standardowego strumienia wyjścia.

Wyjście instrukcji @code{print} i @code{printf} przekierowuje się do pliku
lub polecenia systemowego za pomocą operatorów @samp{>}, @samp{>>}
i @samp{|}.  Wejście instrukcji @code{getline} przekierowuje się za pomocą
operatorów @samp{<} i @samp{|}.
@xref{Przekierowanie, ,Przekierowanie wyjścia @code{print} i @code{printf}},
i @ref{Getline, ,Odczyt bezpośredni przez @code{getline}}.

@item Przypisanie (assignment)
Wyrażenie @code{awk}, które zmienia wartość jakiejś zmiennej lub obiektu
danych @code{awk}.  Obiekt, do którego można wykonać przypisanie, nazywany
jest @dfn{lwartością}.  Przypisywane wartości zwane są @dfn{rwartościami}.
@xref{Operatory przypisania, ,Wyrażenia przypisania}.

@item Regexp
Skrót od @dfn{regular expression} (wyrażenie regularne).  Wyrażenie
regularne jest wzorcem opisującym zbiór łańcuchów, który może być
nieskończony.  Na przykład, do wyrażenia regularnego @samp{R.*xp} pasuje
każdy łańcuch zaczynający się od litery @samp{R} a kończący literami
@samp{xp}.  W @code{awk} wyrażenia regularne używane są we wzorcach
i wyrażeniach warunkowych.  Wyrażenia warunkowe mogą zawierać sekwencje
specjalne.  @xref{Regexp, ,Regular Expressions}.

@item Reguła (rule)
Segment programu @code{awk}, który określa w jaki sposób przetworzyć
pojedyncze rekordy wejściowe.  Reguła składa się ze @dfn{wzorca}
i z @dfn{akcji}.  @code{awk} czyta rekord wejściowy.  Następnie, dla każdej
reguły, jeżeli rekord wejściowy spełnia wzorzec reguły, to @code{awk}
wykonuje jej akcję.  W przeciwnym razie, dla tego rekordu wejściowego reguła
nic nie robi.

@item Rekord wejściowy (input record)
Pojedyncza porcja danych czytana przez @code{awk}.  Zwykle, rekord wejściowy
@code{awk} składa się z jednego wiersza tekstu.
@xref{Rekordy, ,Jak wejście dzielone jest na rekordy}.

@item Rekurencja (recursion)
Gdy funkcja wywołuje sama siebie, albo wprost albo pośrednio.
Jeśli nie jest to jasne, przejdź do hasła ``rekurencja''.

@item Rwartość (rvalue)
Wartość, która może pojawić się po prawej (right) stronie operatora
przypisania.  W @code{awk} wartość posiada zasadniczo każde wyrażenie.
Wartości te są rwartościami.

@item @code{sed}
Zobacz ``Edytor strumieniowy''.

@item Sekwencje specjalne (escape sequences)
Specjalny ciąg znaków stosowany do opisania znaków niedrukowalnych, jak
@samp{\n} dla znaku nowej linii, czy @samp{\033} dla znaku ASCII ESC
(escape).  @xref{Sekwencje specjalne}.

@item Skracanie (short-circuit)
Przyrodzona cecha operatorów logicznych @samp{&&} i @samp{||} z @code{awk}.
Jeżeli wartości całego wyrażenia można dociec na podstawie obliczenia tylko
lewostronnej części tych operatorów, to prawa strona nie będzie obliczana.
(@pxref{Operatory logiczne, ,Wyrażenia logiczne}).

@item Skrypt @code{awk}
Inne określenie programu @code{awk}.

@item Skutek uboczny (side effect)
Skutek uboczny występuje, gdy wyrażenie poza samym utworzeniem wartości ma
jakiś inny skutek.  Skutki uboczne mają wyrażenia przypisania, inkrementacji
i dekrementacji oraz wywołania funkcji.
@xref{Operatory przypisania, ,Wyrażenia przypisania}.

@item Słowo kluczowe (keyword)
W języku @code{awk} słowo kluczowe to słowo, które ma specjalne znaczenie.
Słowa kluczowe są zastrzeżone i nie mogą być wykorzystywane jako nazwy
zmiennych.

W @code{gawk} słowami kluczowymi są:
@code{BEGIN},
@code{END},
@code{if},
@code{else},
@code{while},
@code{do@dots{}while},
@code{for},
@code{for@dots{}in},
@code{break},
@code{continue},
@code{delete},
@code{next},
@code{nextfile},
@code{function},
@code{func},
i @code{exit}.

@item Spacja (space)
Znak tworzony przez naciśnięcie na klawiaturze klawisza odstępu.

@item Szesnastkowa (hexadecimal)
Notacja o podstawie 16, gdzie cyframi są @code{0}-@code{9} i
@code{A}-@code{F}, z @samp{A} reprezentującym 10, @samp{B} reprezentującym
11, i tak aż do @samp{F} dla 15.  Liczby szesnastkowe zapisywane są w C za
pomocą początkowego @samp{0x}, co wskazuje ich podstawę.
Zatem, @code{0x12} to 18 (jeden razy 16 plus 2).

@item Środowisko (environment)
Zbiór łańcuchów, postaci @var{nazwa@code{=}wart}, dostępny dla każdego
programu.  Użytkownicy na ogół umieszczają wartości w środowisku w celu
dostarczenia informacji rozmaitym programom.  Typowymi przykładami są
zmienne środowiska @code{HOME} i @code{PATH}.

@item Tabulacja (tab)
Znak tworzony przez naciśnięcie na klawiaturze klawisza @kbd{TAB}.
Przy wypisywaniu zazwyczaj rozwijany aż do ośmiu spacji.

@item Unix
Komputerowy system operacyjny pierwotnie opracowany we wczesnych latach
70-tych w AT&T Bell Laboratories.  Początkowo stał się popularny na
uniwersytetach na całym świecie, później przeniósł się do środowisk
komercyjnych jako system do tworzenia oprogramowania i system serwerów
sieciowych.  Istnieje wiele wersji handlowych Uniksa, jak też kilka podobnie
działających systemów, których kod źródłowy jest swobodnie dostępny, jak
Linux, NetBSD czy FreeBSD).

@item Wyrażenie boole'owskie (boolean expression)
Nazywane od angielskiego matematyka Boole'a. Zobacz ``Wyrażenie logiczne''.

@item Wyrażenie logiczne (logical expression)
Wyrażenie wykorzystujące operatory logiki, AND, OR i NOT, zapisywane
w @code{awk} jako @samp{&&}, @samp{||} i @samp{!}.  Często zwane
wyrażeniami boole'owskimi, od nazwiska matematyka, który był pionierem tego
rodzaju logiki matematycznej.

@item Wyrażenie porównania (comparison expression)
Relacja, która jest albo prawdziwa albo fałszywa, jak @samp{(a < b)}.
Wyrażenia porównania używane są w instrukcjach @code{if}, @code{while},
@code{do} i @code{for} oraz we wzorcach wybierających rekordy, jakie mają
być przetwarzane.
@xref{Typy i porównania, ,Typy zmiennych i wyrażenia porównania}.

@item Wyrażenie regularne (regular expression)
Zobacz ``regexp''.

@item Wyrażenie regularne stałe (regular expression constant)
Wyrażenie regularne stałe (stała regexp) jest wyrażeniem regularnym
zapisanym wewnątrz ukośników, jak @code{/foo/}.  Wyrażenie takie jest
dobierane podczas pisania programu @code{awk} i nie może być
zmienione podczas jego wykonywania.
@xref{Używanie regexp, , Jak stosować wyrażenia regularne}.

@item Wyrażenie warunkowe (conditional expression)
Wyrażenie wykorzystujące trójargumentowy operator @samp{?:}, jak
@samp{@var{wyr1} ? @var{wyr2} : @var{wyr3}}.  Obliczane jest wyrażenie
@var{wyr1}; jeżeli wynik jest prawdą, to wartością całego wyrażenia jest
wartość @var{wyr2}, w przeciwnym razie wartością jest @var{wyr3}.  W każdym
z przypadków obliczane jest tylko jedno z @var{wyr2} i @var{wyr3}.
@xref{Wyrażenia warunkowe, ,Wyrażenia warunkowe}.

@item Wzorzec (pattern)
Wzorce mówią @code{awk}, jakie rekordy wejściowe są obiektem zainteresowania
których reguł.

Wzorzec jest dowolnym wyrażeniem warunkowym, w stosunku do którego
sprawdzane jest wejście.  Jeżeli warunek jest spełniony, mówimy, że rekord
wejściowy @dfn{pasuje} do wzorca.  Typowy wzorzec może porównywać rekord
wejściowy z wyrażeniem regularnym.
@xref{Przegląd wzorców, ,Elementy wzorców}.

@item Zakres (range) (wierszy wejściowych)
Sekwencja kolejnych wierszy pliku wejściowego.  Zakresy wierszy wejściowych
przeznaczonych do przetworzenia przez @code{awk} mogą być określane
za pomocą wzorca.  Wzorzec taki może też określać pojedyncze wiersze.
@xref{Przegląd wzorców, ,Elementy wzorców}.

@item Zdumiewający asembler w @code{awk}
Henry Spencer z Uniwersytetu w Toronto napisał zmiennocelowy asembler
w całości jako skrypty @code{awk}.  Składa się z tysięcy linijek,
zawierając opisy architektur dla kilkunastu mikrokomputerów ośmiobitowych.
Jest to dobry przykład programu, który lepiej było napisać w innym języku.

@cindex ISO 8859-1
@cindex ISO Latin-1
@item Zestaw znaków (character set)
Zestaw kodów liczbowych wykorzystywanych przez system komputerowy do
reprezentacji znaków (liter, cyfr, znaków przestankowych itp.) konkretnego
kraju czy miejsca.  Najpowszechniej obecnie używanym zestawem znaków jest
ASCII (American Standard Code for Information Interchange).  Wiele
krajów europejskich używa rozszerzenia ASCII znanego
jako ISO-8859-1 (ISO Latin-1).

@item Zmienna wbudowana (built-in variable)
@code{ARGC}, @code{ARGIND}, @code{ARGV}, @code{CONVFMT}, @code{ENVIRON},
@code{ERRNO}, @code{FIELDWIDTHS}, @code{FILENAME}, @code{FNR}, @code{FS},
@code{IGNORECASE}, @code{NF}, @code{NR}, @code{OFMT}, @code{OFS}, @code{ORS},
@code{RLENGTH}, @code{RSTART}, @code{RS}, @code{RT} i @code{SUBSEP},
są zmiennymi mającymi specjalne znaczenie dla @code{awk}.  Zmiana którejś
z nich wpływa na środowisko pracy @code{awk}.  Kilka z tych zmiennych jest
specyficzne tylko dla @code{gawk}.  @xref{Zmienne wbudowane}.
@end table

@node Kopiowanie
@chapter Powszechna Licencja Publiczna GNU
@menu
* GNU General Public License::
@end menu
@include gpl-2.texi



@node Indeks, , Kopiowanie, Top
@unnumbered Indeks
@printindex cp

@summarycontents
@contents
@bye

Unresolved Issues:
------------------
1. From ADR.

   Robert J. Chassell points out that awk programs should have some indication
   of how to use them.  It would be useful to perhaps have a "programming
   style" section of the manual that would include this and other tips.

2. The default AWKPATH search path should be configurable via `configure'
   The default and how this changes needs to be documented.

Consistency issues:
	/.../ regexps are in @code, not @samp
	".." strings are in @code, not @samp
	no @print before @dots
	values of expressions in the text (@code{x} has the value 15),
		should be in roman, not @code
	Use   tab   and not   TAB
	Use   ESC   and not   ESCAPE
	Use   space and not   blank	to describe the space bar's character
	The term "blank" is thus basically reserved for "blank lines" etc.
	The `(d.c.)' should appear inside the closing `.' of a sentence
		It should come before (pxref{...})
	" " should have an @w{} around it
	Use "non-" everywhere
	Use @code{ftp} when talking about anonymous ftp
	Use upper-case and lower-case, not "upper case" and "lower case"
	Use alphanumeric, not alpha-numeric
	Use --foo, not -Wfoo when describing long options
	Use findex for all programs and functions in the example chapters
	Use "Bell Laboratories", but not "Bell Labs".
	Use "behavior" instead of "behaviour".
	Use "zeros" instead of "zeroes".
	Use "Input/Output", not "input/output". Also "I/O", not "i/o".
	Use @code{do}, and not @code{do}-@code{while}, except where
		actually discussing the do-while.
	The words "a", "and", "as", "between", "for", "from", "in", "of",
		"on", "that", "the", "to", "with", and "without",
		should not be capitalized in @chapter, @section etc.
		"Into" and "How" should.
	Search for @dfn; make sure important items are also indexed.
	"e.g." should always be followed by a comma.
	"i.e." should never be followed by a comma, and should be followed
		by `@:'.
	The numbers zero through ten should be spelled out, except when
		talking about file descriptor numbers. > 10 and < 0, it's
		ok to use numbers.
	In tables, put command line options in @code, while in the text,
		put them in @samp.
	When using @strong, use "Note:" or "Caution:" with colons and
		not exclamation points.  Do not surround the paragraphs
		with @quotation ... @end quotation.

Date: Wed, 13 Apr 94 15:20:52 -0400
From: rsm@gnu.ai.mit.edu (Richard Stallman)
To: gnu-prog@gnu.ai.mit.edu
Subject: A reminder: no pathnames in GNU

It's a GNU convention to use the term "file name" for the name of a
file, never "pathname".  We use the term "path" for search paths,
which are lists of file names.  Using it for a single file name as
well is potentially confusing to users.

So please check any documentation you maintain, if you think you might
have used "pathname".

Note that "file name" should be two words when it appears as ordinary
text.  It's ok as one word when it's a metasyntactic variable, though.

Suggestions:
------------
Enhance FIELDWIDTHS with some way to indicate "the rest of the record".
E.g., a length of 0 or -1 or something.  May be "n"?

Make FIELDWIDTHS be an array?

What if FIELDWIDTHS has invalid values in it?

%& -translate-file=il2-pl
\def\fontprefix{pl}
\input texinfo  @c -*-texinfo-*-
@c %**start of header
@setfilename bc.info
@settitle Podręcznik polecenia bc
@documentencoding ISO-8859-2
@documentlanguage pl
@c %**end of header

@c This file has the new style title page commands.
@c Run `makeinfo' rather than `texinfo-format-buffer'.

@smallbook

@c tex
@c \overfullrule=0pt
@c end tex

@titlepage
@title bc, język kalkulatora dowolnej precyzji
@subtitle wersja 1.06

@author Philip A. Nelson
@page
@ifinfo
@direntry
* bc: (bc).                   Język kalkulatora dowolnej precyzji.
@end direntry
@end ifinfo
Niniejszy podręcznik opisuje @code{bc}, język kalkulatora dowolnej
precyzji.

Jest on częścią GNU @code{bc}.@*
@sp4
Copyright (C) 1991, 1992, 1993, 1994, 1997 Free Software Foundation, Inc.
59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

@iftex
Permission is granted to process this file through TeX and print the
results, provided the printed document carries copying permission
notice identical to this one except for the removal of this paragraph
(this paragraph not being relevant to the printed manual).
@end iftex

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation approved
by the Foundation.

Z autorem można skontaktować się pod adresem:
e-mail: @email{phil@@cs.wwu.edu}@*
us-mail: Philip A. Nelson@*
Computer Science Department, 9062@*
Western Washington University@*
Bellingham, WA 98226-9062

@end titlepage

@node Top, Od tłumacza, (dir), (dir)

@menu
* Od tłumacza::
* Wprowadzenie::
* Podstawowe elementy::
* Wyrażenia::
* Instrukcje::
* Funkcje::
* Przykłady::
* Opcje Readline i Libedit::
* GNU bc a inne implementacje::
* Ograniczenia::
* Zmienne środowiska::
* Zgłaszanie błędów::
@end menu

@node Od tłumacza, Wprowadzenie, Top, Top
@comment  node-name,  next,  previous,  up
@unnumbered Od tłumacza
Niniejszy przekład powstał w ramach Projektu Tłumaczenia Manuali
(@uref{http://ptm.linux.pl/, http://ptm.linux.pl/}).  Zgłoszenia błędów,
komentarze i sugestie proszę przesyłać na listę dyskusyjną Projektu:
@email{ptm@@amg.net.pl} lub ewentualnie do autora tłumaczenia.

W.Kotwica (@email{wkotwica@@post.pl})

@unnumberedsec Rozpowszechnianie
To jest nieoficjalne tłumaczenie warunków rozpowszechniania na język polski.
Nie zostało ono opublikowane przez Free Software Foundation
i pod względem prawnym nie stanowi warunków rozpowszechniania -- ustanawia
je wyłącznie oryginalny tekst angielski.  Jednak tłumacz ma nadzieję, że
pomoże ono lepiej zrozumieć warunki rozpowszechniania osobom mówiącym
po polsku.

This is an unofficial translation of the distribution terms into
Polish language. It was not published by the Free Software Foundation, and
does not legally state the distribution terms--only the original English text
does that. However, the translator hopes that it will help Polish language
speakers understand distribution terms better.

Zezwala się na tworzenie i rozpowszechnianie wiernych kopii
tego podręcznika, pod warunkiem, że na wszystkich kopiach zostanie zachowana
informacja o prawach autorskich i niniejsze zezwolenie.

Zezwala się na kopiowanie i rozpowszechnianie zmienionych wersji
tego podręcznika na warunkach jak dla wiernych kopii, pod warunkiem, że
cała praca pochodna będzie rozpowszechniana na warunkach zezwolenia
identycznego jak niniejsze.

Zezwala się na kopiowanie i rozpowszechnianie tłumaczeń tego
podręcznika na inny język, pod wyżej podanymi warunkami dla zmienionych
wersji, z wyjątkiem tego, że niniejsze zezwolenie może być ustanowione
w tłumaczeniu zaakceptowanym przez Fundację.

@node Wprowadzenie, Podstawowe elementy, Od tłumacza, Top
@chapter Wprowadzenie
@menu
* Opis::
* Opcje wiersza poleceń::
@end menu

@node Opis, Opcje wiersza poleceń, Wprowadzenie, Wprowadzenie
@section Opis

@code{bc} [ -hlwsqv ] [długie_opcje] [ @var{ plik ...} ]

@code{bc} jest językiem obsługującym obliczenia na liczbach dowolnej
dokładności z interaktywnym wykonywaniem instrukcji. Istnieją pewne
podobieństwa składni do języka programowania C. Przy pomocy opcji wiersza
poleceń dostępna jest standardowa biblioteka matematyczna. Na żądanie,
biblioteka matematyczna jest definiowana przed rozpoczęciem przetwarzania
plików. @code{bc} rozpoczyna pracę przetwarzając kod z wszystkich plików
wymienionych w wierszu poleceń, zachowując ich kolejność. Po przetworzeniu
wszystkich plików, @code{bc} czyta ze standardowego wejścia. Całość kodu
wykonywana jest w miarę czytania. (Jeśli plik zawiera polecenie zatrzymania
procesora, to @code{bc} nie będzie prowadził odczytu ze standardowego
wejścia.)

Omawiana wersja @code{bc} zawiera kilka rozszerzeń w stosunku do
tradycyjnych realizacji @code{bc} i standardu POSIX.
Opcje wiersza poleceń mogą powodować, że rozszerzenia te będą wyświetlać
ostrzeżenia lub będą odrzucane. Niniejszy dokument opisuje język akceptowany
przez ten procesor bc. Rozszerzenia są w nim wyraźnie wyróżnione.

Autor chciałby podziękować Steve'owi Sommars
(@email{Steve.Sommars@@att.com}) za jego szeroką pomoc w testowaniu tej
implementacji. Podsunął on wiele cennych sugestii. Dzięki jego zaangażowaniu
jest to o wiele lepszy produkt.

@node Opcje wiersza poleceń, Liczby, Opis, Wprowadzenie
@section Opcje wiersza poleceń

@code{bc} pobiera z wiersza poleceń następujące opcje:
@table @code

@item -h, --help
Wypisuje informację o sposobie wywołania i kończy działanie.

@item -i, --interactive
Wymusza tryb interaktywny.

@item -l, --mathlib
Definiuje standardową bibliotekę matematyczną.

@item -w, --warn
Ostrzega o rozszerzeniach w stosunku do POSIX @code{bc}.

@item -s, --standard
Przetwarza wyłącznie standardowy, POSIX-owy język @code{bc}.

@item -q, --quiet
Nie wyświetla zwykłego przywitania GNU @code{bc}.

@item -v, --version
Wypisuje numer wersji, informację o prawach autorskich i kończy działanie.

@end table


@node Podstawowe elementy, Wyrażenia, Wprowadzenie, Top
@chapter Podstawowe elementy
@menu
* Liczby::
* Zmienne::
* Komentarze::
@end menu

@node Liczby, Zmienne, Opcje wiersza poleceń, Podstawowe elementy
@section Liczby

Najbardziej podstawowym elementem w @code{bc} jest liczba. Liczby są
liczbami dowolnej dokładności. Dokładność ta odnosi się zarówno do części
całkowitej jak i do ułamkowej. Wszystkie liczby są reprezentowane
wewnętrznie w postaci dziesiętnej i wszystkie obliczenia prowadzone są w
układzie dziesiętnym.  (Opisywana wersja obcina wyniki operacji dzielenia i
mnożenia.) Liczby posiadają dwa atrybuty: długość i dokładność.  [od tłum.:
(org.scale) - w tłumaczeniu używane będzie słowo ``dokładność'' w znaczeniu
zbliżonym do znanego np. z obsługi kalkulatorów] Długość jest całkowitą
liczbą cyfr znaczących liczby, zaś dokładność jest całkowitą liczbą cyfr
dziesiętnych po kropce dziesiętnej.  Na przykład, .000001 ma długość 6 i
dokładność 6, zaś 1935.000 ma długość 7 i dokładność 3.

@node Zmienne, Komentarze, Liczby, Podstawowe elementy
@section Zmienne

Liczby przechowywane są w dwu rodzajach zmiennych, zmiennych prostych
i tablicach. Zarówno zmienne proste jak i tablice posiadają nazwy. Nazwy
zaczynają się od litery, po której następuje dowolna liczba liter, cyfr
i znaków podkreślenia. Wszystkie litery muszą być małe. (Nazwy w pełni
alfanumeryczne są rozszerzeniem. W POSIX-owym @code{bc} wszystkie nazwy są
pojedynczymi małymi literami.) Rodzaj zmiennej wynika z kontekstu, gdyż
po nazwie każdej zmiennej tablicowej wystąpią nawiasy kwadratowe ([]).

Istnieją cztery zmienne specjalne: @var{scale}, @var{ibase}, @var{obase}
oraz @var{last}. @var{scale} określa, jak niektóre operacje używają cyfr po
kropce dziesiętnej. Domyślną wartością @var{scale} jest 0. @var{ibase}
oraz @var{obase} określają podstawę pozycyjnego systemu liczbowego przy
konwersji wejścia i wyjścia. Domyślną podstawą zarówno dla wejścia jak i dla
wyjścia jest 10. @var{last} (rozszerzenie standardu) jest zmienną, która
przechowuje wartość ostatnio wydrukowanej liczby. Zmienne te będą omówione
szczegółowo później, w odpowiedniej części. Wszystkie z nich mogą mieć
przypisywane wartości, jak również mogą być używane w wyrażeniach.

@node Komentarze, , Zmienne, Podstawowe elementy
@section Komentarze

Komentarze w @code{bc} rozpoczynają się od znaków @code{/*} zaś kończą
znakami @code{*/}. Komentarze mogą zaczynać się w dowolnym miejscu i na
wejściu pojawiają się jako pojedyncze spacje. (Powoduje to, że komentarze są
ogranicznikami innych elementów wejścia. Na przykład, komentarz nie może
znajdować się w środku nazwy zmiennej.) Komentarze obejmują znaki nowej
linii (końca linii) pomiędzy początkiem a końcem komentarza.

Do zapewnienia obsługi skryptów dla @code{bc}, jako rozszerzenie dodano
komentarz w pojedynczym wierszu. Komentarz jednowierszowy rozpoczyna się
znakiem @code{#} i rozciąga się do końca wiersza. Znak końca linii nie jest
tu częścią komentarza i jest przetwarzany jak zwykle.

@node Wyrażenia, Instrukcje, Podstawowe elementy, Top
@chapter Wyrażenia

@menu
* O wyrażeniach i zmiennych specjalnych::
* Podstawowe wyrażenia::
* Wyrażenia relacyjne::
* Wyrażenia logiczne::
* Priorytet::
* Wyrażenia specjalne::
@end menu

@node O wyrażeniach i zmiennych specjalnych, Podstawowe wyrażenia, Wyrażenia, Wyrażenia
@section O wyrażeniach i zmiennych specjalnych

Liczbami posługują się wyrażenia i instrukcje. Ponieważ język został
zaprojektowany jako interaktywny, instrukcje i wyrażenia wykonywane są
niezwłocznie. Nie ma żadnego programu "głównego". Zamiast tego, kod
jest wykonywany zaraz po jego napotkaniu. (Funkcje, omówione szczegółowo
dalej, są zdefiniowane po ich napotkaniu.)

Proste wyrażenie jest po prostu stałą. @code{bc} zamienia stałe na wewnętrzne
liczby dziesiętne przy użyciu bieżącej podstawy systemu dla wprowadzania,
podanej w zmiennej @var{ibase}. (Istnieje wyjątek dla funkcji.)
Dopuszczalnymi wartościami @var{ibase} są 2 do 16. Przypisanie @var{ibase}
wartości spoza tego zakresu nada jej wartość 2 lub 16. Liczby wejściowe mogą
zawierać znaki 0-9 oraz A-F. (Uwaga: muszą to być wielkie litery. Małe
litery są nazwami zmiennych.) Liczby jednocyfrowe mają zawsze wartość cyfry,
bez względu na wartość @var{ibase}. (tj. A = 10.) Dla liczb wielocyfrowych
@code{bc} zamienia wszystkie cyfry wejściowe większe bądź równe
@var{ibase} na wartość @var{ibase}-1. Powoduje to, że liczba @code{FFF}
będzie zawsze największą trzycyfrową liczbą przy danej podstawie systemu dla
wejścia.

Pełne wyrażenia są podobne do występujących w wielu językach wysokiego
poziomu. Ponieważ występuje tylko jeden rodzaj liczb, nie ma reguł
określających użycie różnych typów. Zamiast tego istnieją reguły dotyczące
dokładności wyrażeń. Każde wyrażenie posiada określoną dokładność. Zależy
ona od dokładności pierwotnych liczb, wykonywanego działania i, w wielu
przypadkach, wartości zmiennej @var{scale}. Dopuszczalnymi wartościami
zmiennej @var{scale} są liczby od 0 aż do maksymalnej liczby, jaka może być
reprezentowana jako całkowita (integer) w języku C.

@node Podstawowe wyrażenia, Wyrażenia relacyjne, O wyrażeniach i zmiennych specjalnych, Wyrażenia
@section Podstawowe wyrażenia

W podanych poniżej opisach dopuszczalnych wyrażeń, "wyrażenie" określa
pełne wyrażenie a "@var{zmn}" określa zmienną prostą lub tablicową.
Zmienną prostą jest po prostu

@var{nazwa}

a zmienna tablicowa jest określona jako

@var{nazwa}[@var{wyrażenie}]

Dokładność wyniku jest maksymalną z dokładności użytych w nim wyrażeń, chyba
że podano inaczej.

@table @code
@item - wyrażenie
Wynikiem jest wartość przeciwna do wyrażenia.

@item ++ @var{zmn}
Zmienna jest powiększana o jeden a wynikiem wyrażenia jest ta nowa wartość.

@item -- @var{zmn}
Zmienna jest pomniejszana o jeden a wynikiem wyrażenia jest ta nowa wartość.

@item @var{zmn} ++
Wynikiem wyrażenia jest wartość zmiennej, a następnie zmienna jest
powiększana o jeden.

@item @var{zmn} --
Wynikiem wyrażenia jest wartość zmiennej, a następnie zmienna jest
pomniejszana o jeden.

@item wyrażenie - wyrażenie
Wynikiem tego wyrażenia jest suma obu wyrażeń.

@item wyrażenie - wyrażenie
Wynikiem tego wyrażenia jest różnica obu wyrażeń.

@item wyrażenie * wyrażenie
Wynikiem tego wyrażenia jest iloczyn obu wyrażeń.

@item wyrażenie / wyrażenie
Wynikiem tego wyrażenia jest iloraz obu wyrażeń. Liczba cyfr po kropce
dziesiętnej wyniku jest równa wartości zmiennej @code{scale}.

@item wyrażenie % wyrażenie
Wynikiem tego wyrażenia jest "reszta" z dzielenia obliczana w następujący
sposób. W celu obliczenia a%b, obliczane jest najpierw a/b z dokładnością do
@var{scale} cyfr dziesiętnych. Wynik używany jest do obliczenia
a-(a/b)*b z dokładnością określoną jako maksymalna z @var{scale}+scale(b)
oraz scale(a).  Jeżeli zmienna @var{scale} ustawiona jest na zero, zaś oba
wyrażenia są całkowite to wyrażenie to jest funkcją reszty całkowitej.

@item wyrażenie ^ wyrażenie
Wynikiem tego wyrażenia jest wartość pierwszego z wyrażeń podniesiona do
potęgi określonej przez drugie. Drugie wyrażenie musi być liczbą całkowitą.
(Jeśli drugie wyrażenie nie jest całkowite, to emitowane jest ostrzeżenie a
wyrażenie jest obcinane tak, by otrzymać wartość całkowitą). Liczba cyfr
ułamkowych wyniku wynosi @var{scale}, jeśli wykładnik jest ujemny. Jeżeli
jest on dodatni, to dokładność (liczba cyfr po kropce dziesiętnej) wyniku
stanowi minimum z dokładności pierwszego wyrażenia przemnożonej przez
wartość wykładnika i maksimum z @var{scale} i dokładności pierwszego
wyrażenia. To znaczy:
@example
scale(a^b) = min(scale(a)*b, max(@var{scale}, scale(a))).
@end example
Należy pamiętać, że wyrażenie^0 zawsze zwraca wartość 1.

@item ( wyrażenie )
Nawiasy wymuszają zmianę standardowych priorytetów przy obliczaniu
wyrażenia.

@item @var{zmn} = wyrażenie
Zmiennej przypisywana jest wartość wyrażenia.

@item @var{zmn} <op>= wyrażenie
jest to równoważne zapisowi "@var{zmn} = @var{zmn} <op> wyrażenie",
z wyjątkiem tego, iż część "@var{zmn}" jest wyliczana tylko raz. Może to
być istotne, jeśli "@var{zmn}" jest tablicą.
@end table

@node Wyrażenia relacyjne, Wyrażenia logiczne, Podstawowe wyrażenia, Wyrażenia
@section Wyrażenia relacyjne

Wyrażenia relacyjne są specjalnym rodzajem wyrażeń, zwracającym zawsze
wartość 0 lub 1: zero jeśli relacja jest fałszywa, zaś 1 jeżeli jest prawdziwa.
Mogą one występować w dowolnych dozwolonych wyrażeniach. (POSIX @code{bc}
wymaga, by  wyrażenia relacyjne były używane wyłącznie w instrukcjach
@code{if}, @code{while} i @code{for} oraz aby było w nich użyte tylko jedno
sprawdzenie relacji.)  Operatorami relacji są:

@table @code
@item wyrażenie1 < wyrażenie2
Wynikiem jest jeden jeśli wyrażenie1 jest mniejsze niż wyrażenie2.

@item wyrażenie1 <= wyrażenie2
Wynikiem jest 1 gdy wyrażenie jest mniejsze bądź równe wyrażenie2.

@item wyrażenie1 > wyrażenie2
Wynikiem jest 1 jeśli wyrażenie1 jest większe niż wyrażenie2.

@item wyrażenie1 >= wyrażenie2
Wynikiem jest 1 gdy wyrażenie1 jest większe bądź równe wyrażenie2.

@item wyrażenie1 == wyrażenie2
Wynikiem jest 1 gdy wyrażenie1 jest równe wyrażenie2.

@item wyrażenie1 != wyrażenie2
Wynikiem jest 1 gdy wyrażenie1 nie jest równe wyrażenie2.
@end table

@node Wyrażenia logiczne, Priorytet, Wyrażenia relacyjne, Wyrażenia
@section Wyrażenia logiczne

Dozwolone są także operacje logiczne. (POSIX @code{bc} NIE posiada
operacji logicznych). Wynikami wszystkich operacji logicznych są 0 lub 1
(dla fałszu i prawdy), tak jak dla wyrażeń relacyjnych. Operatorami
logicznymi są:

@table @code
@item !expr
Zaprzeczenie. Wynikiem jest 1 jeśli wyrażenie ma wartość 0.

@item expr && expr
Koniunkcja. Wynikiem jest 1 jeżeli oba wyrażenia są niezerowe.

@item expr || expr
Alternatywa. Wynikiem jest 1 jeśli dowolne z wyrażeń jest niezerowe.
@end table

@node Priorytet, Wyrażenia specjalne, Wyrażenia logiczne, Wyrażenia
@section Priorytet

Wyrażenia posiadają następujący priorytet: (od najniższego do najwyższego)

@example
operator ||, wiązanie lewe
operator &&, wiązanie lewe
operator !, niezwiązany
operatory relacji, wiązanie lewe
operator przypisania, wiązanie prawe
operatory + i -, wiązanie lewe
operatory *, / i %, wiązanie lewe
operator ^, wiązanie prawe
jednoargumentowy operator -, niezwiązany
operatory ++ i --, niezwiązane
@end example

Kolejność wykonywania została dobrana tak, by programy zgodne z POSIX
@code{bc} działały poprawnie. Powoduje to, że operatory relacyjne
i logiczne, użyte w wyrażeniach przypisania, będą wykazywać niecodzienne
zachowywanie.  Rozważ wyrażenie:

@example
a = 3 < 5
@end example

Większość programistów C uważałaby, że przypisze ono wynik operacji "3 < 5"
(wartość 1) zmiennej "a". Tymczasem w @code{bc} nadaje ono wartość 3
zmiennej "a", a następnie porównuje 3 z 5. Używając operatorów relacji
i operatorów logicznych z operatorami przypisania najlepiej jest posłużyć się
nawiasami.

@node Wyrażenia specjalne, , Priorytet, Wyrażenia
@section Wyrażenia specjalne

@code{bc} udostępnia jeszcze kilka innych wyrażeń specjalnych. Związane
są one z funkcjami definiowanymi przez użytkownika i funkcjami
standardowymi.  Wszystkie one mają postać
"@var{nazwa}@code{(}@var{parametry}@code{)}".
@xref{Funkcje}, gdzie opisano funkcje definiowane przez użytkownika.
Funkcjami standardowymi są:

@table @code
@item length ( wyrażenie )
Wynikiem funkcji @code{length} jest liczba cyfr znaczących w wyrażeniu.

@item read ( )
Funkcja ta, będąca rozszerzeniem, odczytuje liczbę ze standardowego wejścia,
niezależnie od miejsca użycia funkcji. Strzeż się -- może to spowodować
kłopoty  przy przeplataniu się danych i programu ze standardowego wejścia.
Najlepszym zastosowaniem tej funkcji jest użycie jej w uprzednio napisanym
programie, który wymaga wprowadzania danych przez użytkownika, ale nigdy
nie pozwala na wprowadzanie kodu programu. Wynikiem działania funkcji
@code{read} jest liczba odczytana ze standardowego wejścia z konwersją
układu liczbowego według aktualnej wartości zmiennej @var{ibase}.

@item scale ( wyrażenie )
Wynikiem funkcji @code{scale} jest liczba cyfr po kropce dziesiętnej w wyrażeniu
będącym jej parametrem.

@item sqrt ( wyrażenie )
Wynikiem funkcji @code{sqrt} jest pierwiastek kwadratowy z wyrażenia. Jeżeli
wyrażenie ma wartość ujemną, to generowany jest błąd wykonania.
@end table

@node Instrukcje, Funkcje, Wyrażenia, Top
@chapter Instrukcje

@menu
* Pseudo-instrukcje::
@end menu

Instrukcje (jak w większości języków algorytmicznych) umożliwiają sterowanie
kolejnością wykonywania wyrażeń. W @code{bc} instrukcje wykonywane są
bezzwłocznie, "tak szybko jak to jest możliwe". Wykonanie odbywa się gdy
napotkano znak nowej linii i istnieje jedna lub więcej pełna instrukcja.
W związku z takim natychmiastowym wykonaniem, znaki nowej linii są bardzo
istotne w @code{bc}. W rzeczywistości, jako organiczniki instrukcji
używane są zarówno znaki nowej linii jak i średniki. Nieprawidłowo
umieszczony znak nowej linii spowoduje błąd składni. Ponieważ znaki nowej
linii rozdzielają instrukcje, możliwe jest ich ukrycie (przed interpretacją)
przy pomocy znaku odwrotnego ukośnika. Sekwencja "\<nl>", gdzie <nl> jest
znakiem nowej linii postrzegana jest przez @code{bc} jako znak zwykłej
spacji zamiast znaku nowej linii.
@c Lista instrukcji jest ciągiem instrukcji rozdzielanych średnikami i
@c znakami nowej linii.
Poniżej umieszczono listę instrukcji @code{bc} i ich
znaczenia:  (elementy umieszczone w nawiasach kwadratowych ([]) są
opcjonalnymi częściami instrukcji.)

@table @var
@item wyrażenie
Instrukcja ta wykonuje dwie rzeczy. jeżeli wyrażenie rozpoczyna się od
"<zmienna> <przypisanie> ...", to jest traktowane jak instrukcja
przypisania. Jeśli wyrażenie nie jest instrukcją przypisania, to wyrażenie
jest wyliczane i drukowane na standardowym wyjściu. Po wydrukowaniu liczby
drukowany jest znak nowej linii. Na przykład, "a=1" jest instrukcją
przypisania zaś "(a=1)" jest wyrażeniem zawierającym przypisanie. Wszystkie
liczby drukowane są przy użyciu systemu pozycyjnego określonego zmienną
@var{obase}. Dopuszczalnymi wartościami @var{obase} są 2 do BC_BASE_MAX.
(@pxref{Zmienne środowiska}). Dla podstaw systemu od 2 do 16 używana jest
zwyczajowa metoda zapisu liczb. Dla podstaw większych od 16 @code{bc}
posługuje się metodą cyfr wieloznakowych wyświetlania liczb, gdzie każda
z kolejnych cyfr wyświetlana jest jako liczba dziesiętna. Cyfry wieloznakowe
oddzielane są odstępami. Każda z cyfr zawiera tyle znaków, ile jest
niezbędnych do przedstawienia dziesiętnie wartości "@var{obase}-1". Ponieważ
liczby mają dowolną dokładność, niektóre z liczb mogą nie dać wydrukować się
w pojedynczym wierszu. Takie długie liczby zostaną podzielone między wiersze
przy zastosowaniu "\" jako ostatniego znaku wiersza. Maksymalną liczbą
znaków drukowanych w wierszu jest 70. Z powodu interaktywneggo charakteru
@code{bc} drukowanie liczby ma efekt uboczny w postaci przypisania
wydrukowanej wartości do specjalnej zmiennej o nazwie @var{last}. Umożliwia
to użytkownikowi odtworzenie ostatnio wydrukowanej wartości bez potrzeby
ponownego wpisywania wyrażenia, które ją wydrukowało. Nadawanie wartości
zmiennej @var{last} jest dozwolone; spowoduje ono zastąpienie ostatnio
wydrukowanej wartości wartością przypisaną. Nowo przypisana wartość
pozostanie aż do wydrukowania kolejnej liczby lub nadania @var{last} innej
wartości. (Niektóre z implementacji mogą dopuszczać użycie pojedynczej
kropki (.), nie będącej częścią liczby, jako skróconej notacji dla
@var{last}.)

@item łańcuch
Na wyjściu drukowany jest łańcuch znakowy. Łańcuchy rozpoczynają się znakiem
cudzysłowu i zawierają wszystkie znaki do następnego znaku cudzysłowu.
Wszystkie znaki, włącznie ze znakami nowej linii, traktowane są dosłownie.
Po wydrukowaniu łańcucha nie jest drukowany znak nowej linii.

@item @code{print} @var{lista}
Instrukcja @code{print} (rozszerzenie) umożliwia użycie innego sposobu
wydruku wyników. @var{Lista} jest listą łańcuchów i wyrażeń oddzielonych
przecinkami.  Każdy łańcuch czy wyrażenie drukowany jest w kolejności
występowania na liście. Nie jest drukowany kończący znak nowej linii
(przejście do następnego wiersza). Wyliczana jest wartość wyrażeń; jest ona
drukowana i przypisywana zmiennej @code{last}. Łańcuchy użyte w instrukcji
print są drukowane na wyjściu i mogą zawierać znaki specjalne. Znaki
specjalne rozpoczynają się znakiem odwrotnego ukośnika ("\"). @code{bc}
rozpoznaje następujące znaki specjalne:  "a" (dzwonek, bell), "b"
(backspace), "f" (wysuw strony, form feed), "n" (nowa linia, newline), "r"
(powrót karetki, carriage return), "q" (cudzysłów, double quote), "t"
(tabulacja, tab) oraz "\" (odwrotny ukośnik, backslash).  Inne znaki
występujące po odwrotnym ukośniku będą ignorowane.

@item @{ lista_instrukcji @}
Jest to polecenie złożone: nawiasy klamrowe służą jako instrukcja
grupowania.  Pozwala na grupowanie wielu instrukcji do wykonania.

@item @code{if} ( wyrażenie ) instrukcja1 [@code{else} instrukcja2]

Instrukcja @code{if} oblicza wyrażenie i wykonuje @var{instrukcję1} bądź
@var{instrukcję2} w zależności od wartości wyrażenia. Jeżeli wyrażenie jest
niezerowe, wykonywana jest @var{instrukcja1}. Jeśli występuje
@var{instrukcja2} a wartością wyrażenia jest 0, to wykonywana jest
@var{instrukcja2}. (Klauzula @code{else} instrukcji @code{if} jest
rozszerzeniem).

@item @code{while} ( wyrażenie ) instrukcja
Instrukcja @code{while} powtarza wykonywanie danej instrukcji póki wyrażenie
jest niezerowe. Oblicza ona wartość wyrażenia przed każdym wykonaniem
instrukcji.  Przerwanie pętli powodowane jest zerową wartością wyrażenia lub
wykonaniem instrukcji @code{break} (przerwania).

@item @code{for} ( [wyr1] ; [wyr2] ; [wyr3] ) instrukcja
Instrukcja @code{for} kontroluje powtarzane wykonanie danej instrukcji.
Przed pętlą obliczane jest @var{wyrażenie1}. @var{Wyrażenie2} jest obliczane
przed każdym wykonaniem instrukcji. Jeśli jest niezerowe, to wykonywana jest
instrukcja.  Jeśli ma ono wartość zero, to pętla jest przerywana. Po każdym
wykonaniu danej instrukcji wyliczana jest wartość @var{wyrażenia3} przed
ponownym wyliczeniem @var{wyrażenia2}. Jeżeli pominięto @var{wyrażenie1} lub
@var{wyrażenie3}, to nic nie jest obliczane w chwili, gdy powinna być
określana ich wartość.  Jeżeli pominięto @var{wyrażenie2}, to jest ono
zastępowane wartością 1. (Wyrażenie opcjonalne stanowią rozszerzenie.
@code{bc} w POSIX-ie wymaga wszystkich trzech wyrażeń.) Poniższy kod jest
równoważny instrukcji @code{for}:

@example
expression1;
while (expression2) @{
   statement;
   expression3;
@}
@end example

@item @code{break}
Instrukcja ta powoduje wymuszone zakończenie ostatniej obejmującej ją
instrukcji @code{while} lub @code{for}.

@item @code{continue}
Instrukcja @code{continue} (rozszerzenie) powoduje rozpoczęcie kolejnej
iteracji przez ostatnią obejmującą ją instukcję @code{for}.

@item @code{halt}
Instrukcja @code{halt} (rozszerzenie) jest instrukcją nakazującą
preprocesorowi @code{bc} zakończenie pracy (ale tylko wtedy gdy
instrukcja ta jest wykonywana).  Na przykład, "if (0 == 1) halt" nie
spowoduje przerwania pracy @code{bc}, gdyż instrukcja @code{halt} nie
będzie wykonana.

@item @code{return}
Zwraca wartość zero jako wynik funkcji.  (@xref{Funkcje}.)

@item @code{return} ( wyrażenie )
Zwraca wartość wyrażenia jako wynik funkcji.  (@xref{Funkcje}.)
Nawiasy nie są wymagane, co jest rozszerzeniem GNU.
@end table

@node Pseudo-instrukcje, , Instrukcje, Instrukcje
@section Pseudo-instrukcje

Te instrukcje nie są instrukcjami w tradycyjnym sensie tego terminu. Nie są
one instrukcjami wykonywanymi. Ich funkcja jest wykonywana podczas
"kompilacji".

@table @code
@item limits
Wypisuje lokalne ograniczenia narzucone przez lokalna wersję @code{bc}.
Jest to rozszerzenie.

@item quit
Po odczycie instrukcji @code{quit} procesor @code{bc} kończy pracę,
niezależnie od tego, gdzie wystąpiła ta instrukcja. Na przykład,
"if (0 == 1) quit" spowoduje zakończenie pracy @code{bc}.

@item warranty
Wypisuje dłuższą notkę na temat gwarancji. Jest to rozszerzenie.
@end table

@node Funkcje, Przykłady, Instrukcje, Top
@chapter Funkcje

@menu
* Funkcje biblioteki matematycznej::
@end menu

Funkcje dostarczają sposobu definiowania obliczeń, które mogą być wykonane
później. Funkcje w @code{bc} zawsze obliczają wartość i zwracają ją do
miejsca wywołania. Definicje funkcji są "dynamiczne" w tym sensie, że funkcja
pozostaje niezdefiniowana dopóki na wejściu nie zostanie odczytana jej
definicja. Definicja ta jest następnie używana dopóki nie zostanie napotkana
inna definicja funkcji o tej samej nazwie. Wówczas nowa definicja zastępuje
starszą. Funkcja definiowana jest następująco:

@example
@code{define} @var{nazwa} @code{(} @var{parametry} @code{)} @code{@{} @var{nowa_linia}
    @var{lista_auto   lista_instrukcji} @code{@}}
@end example

Wywołanie funkcji jest po prostu wyrażeniem postaci
"@code{nazwa} @code{(}@var{parametry}@code{)}".

Parametry są liczbami lub tablicami (rozszerzenie). W definicji funkcji
definiuje się równocześnie jest zero lub więcej jej parametrów przez podanie
ich nazw rozdzielonych przecinkami. Liczby są jedynymi parametrami wywoływanymi
przez wartość. Tylko tablice są wołane przez wskazanie zmiennej.
Tablice podawane są w definicji parametrów przy pomocy notacji
"@var{nazwa}@code{[ ]}". W wywołaniu funkcji parametry rzeczywiste dla
parametrów numerycznych są pełnymi wyrażeniami. Do przekazywania tablic
używana jest ta sama notacja, co przy definiowaniu parametrów typu
tablicowego. Dana tablica przesyłana jest do funkcji przez nazwę
(wskazanie). Ponieważ definicje funkcji są dynamiczne, w trakcie wywoływania
funkcji sprawdzana jest liczba i typy jej parametrów.  Niezgodnośc liczby
parametrów lub ich typów powoduje błąd wykonania. Błąd wykonania pojawi się
także przy próbie wywołania niezdefiniowanej funkcji.

@var{lista_auto} jest opcjonalną listą zmiennych, do użytku "lokalnego".
A oto składnia tej listy (jeśli występuje): "@code{auto} @var{nazwa}, ... ;".
Średnik jest opcjonalny. Każda z @var{nazw} jest nazwą auto-zmiennej.
Tablice mogą być podane przy użyciu takiej samej składni jak w parametrach.
Na początku funkcji wartości tych zmiennych odkładane są na stosie.
Następnie zmienne są inicjowane zerami i używane w czasie wykonywania
funkcji. Przy zakończeniu funkcji zmienne są zdejmowane ze stosu,
tak że przywracana jest ich pierwotna wartość (z momentu wywołania
funkcji). Parametry te są faktycznie zmiennymi auto inicjowanymi wartościami
dostarczonymi w wywołaniu funkcji. Zmienne typu auto różnią się od
tradycyjnych zmiennych lokalnych, gdyż jeśli funkcja A woła funkcję B, to
B może posługiwać się zmiennymi auto funkcji A po prostu używając tych
samych nazw, chyba że funkcja B traktuje je jako zmienne auto. Ponieważ
zmienne auto i parametry składowane są na stosie, to @code{bc} obsługuje
funkcje rekurencyjne.

Ciało funkcji jest listą instrukcji @code{bc}. I znów, jak w części
zasadniczej, instrukcje oddzielane są średnikami lub znakami nowej linii.
Instrukcje return (powrót) powodują zakończenie funkcji i zwrócenie
wartości. Istnieją dwa warianty instrukcji return. Pierwsza postać,
"@code{return}", zwraca wartość 0 do wywołującego wyrażenia. Druga
postać, "@code{return} ( @var{wyrażenie} )", oblicza wartość wyrażenia
i zwraca ją do wyrażenia wołającego. Każda funkcja domyślnie kończy się
niejawną instrukcją "@code{return} (0)". Pozwala to na funkcji na
zakończenie działania i zwrócenie zera bez jawnej instrukcji powrotu.

Funkcje inaczej korzystają ze zmiennej @var{ibase}. Wszystkie stałe
w obrębie ciała funkcji będą konwertowane przy zastosowaniu
wartości @var{ibase} w momencie wywołania funkcji. Zmiany @var{ibase} w
czasie wykonywania funkcji są ignorowane, z wyjątkiem funkcji standardowej
@code{read}, która zawsze do konwersji liczb wykorzystuje bieżącą wartość
@var{ibase}.

Rozszerzeniem GNU @code{bc} jest nieco luźniejszy format dla definicji.
Standard wymaga, by nawias otwierający znajdował się w tym samym wierszu
co słowo kluczowe @code{define}, a wszystkie pozostałe części w kolejnych
wierszach. Opisywana tu wersja @code{bc} zezwala na dowolną ilość znaków
nowej linii przed i po nawiasie otwierającym funkcji.  Na przykład,
dozwolone są poniższe definicje.

@example
   define d (n) @{ return (2*n); @}
   define d (n)
       @{ return (2*n); @}
@end example


@node Funkcje biblioteki matematycznej, , Funkcje, Funkcje
@section Funkcje biblioteki matematycznej

Jeżeli @code{bc} wywoływane jest z opcją @code{-l}, to wstępnie
wczytywana jest biblioteka matematyczna (math library), a domyślna liczba
cyfr dziesiętnych (@var{scale}) ustawiana jest na 20. Funkcje matematyczne
obliczają swe wyniki z dokładnością określoną w momencie ich wywołania.
Bibilioteka matematyczna definiuje następujące funkcje:

@table @code
@item s (@var{x})
Sinus @var{x}, @var{x} podawany jest w radianach.

@item c (@var{x})
Cosinus @var{x}, @var{x} w radianach.

@item a (@var{x})
Arcus tangens @var{x}; arcus tangens zwraca radiany.

@item l (@var{x})
Logarytm naturalny z @var{x}.

@item @var{e} (@var{x})
Funkcja wykładnicza - @var{e} do potęgi @var{x}.

@item @var{j} (@var{n,x})
Funkcja Bessela rzędu @var{n} (całkowitego) z argumentem @var{x}.
@end table

@node Przykłady, Opcje Readline i Libedit, Funkcje, Top
@chapter Przykłady

W powłoce @code{/bin/sh}, poniższe polecenie przypisuje wartość liczby "Pi"
zmiennej środowiska @var{pi}.
@example

pi=$(echo "scale=10; 4*a(1)" | bc -l)

@end example

Poniżej podano definicję funkcji wykładniczej używanej w bibliotece
matematycznej. Funkcja ta napisana jest w  @code{bc} standardu POSIX.

@example

scale = 20

/* wykorzystuje fakt, że e^x = (e^(x/2))^2
   Gdy  x jest dostatecznie małe, używamy szeregu:
     e^x = 1 + x + x^2/2! + x^3/3! + ...
*/

define e(x) @{
  auto  a, d, e, f, i, m, v, z

  /* sprawdzenie znaku x */
  if (x<0) @{
    m = 1
    x = -x
  @}

  /* przewidywane x */
  z = scale;
  scale = 4 + z + .44*x;
  while (x > 1) @{
    f += 1;
    x /= 2;
  @}

  /* inicjowanie zmiennych */
  v = 1+x
  a = x
  d = 1

  for (i=2; 1; i++) @{
    e = (a *= x) / (d *= i)
    if (e == 0) @{
      if (f>0) while (f--)  v = v*v;
      scale = z
      if (m) return (1/v);
      return (v/1);
    @}
    v += e
  @}
@}

@end example

Poniższy kod posługuje się rozszerzonymi cechami @code{bc} do uzyskania
prostego programu liczącego salda książeczki czekowej. Najlepiej byłoby
zachować go w pliku, tak by mógł być wykorzystany wielokrotnie bez potrzeby
każdorazowego przepisywania.

@example

scale=2
print "\enProgram książeczki czekowej!\en"
print "  Pamiętaj, wpłaty są transakcjami ujemnymi.\en"
print "  Koniec - transakcja zerowa.\en\en"

print "Saldo początkowe? "; bal = read()
bal /= 1
print "\n"
while (1) @{
  "bieżące saldo = "; bal
  "transakcja? "; trans = read()
  if (trans == 0) break;
  bal -= trans
  bal /= 1
@}
quit

@end example


Poniżej zamieszczono definicję rekurencyjnej funkcji silni.

@example

define f (x) @{
  if (x <= 1) return (1);
  return (f(x-1) * x);
@}

@end example

@node Opcje Readline i Libedit, GNU bc a inne implementacje, Przykłady, Top
@chapter Opcje Readline i Libedit

GNU @code{bc} może zostać skompilowany (poprzez opcję konfiguracji) tak,
by posługiwał się biblioteką GNU edytora wejścia o nazwie @code{readline}
lub też biblioteką BSD @code{libedit}.  Umożliwia to użytkownikowi edycję
wierszy przed wysłaniem ich do @code{bc}. Pozwala też na wykorzystanie
historii poprzednio wprowadzonych wierszy. Przy wybraniu tej opcji
@code{bc} posiada dodatkową zmienną specjalną. Ta specjalna zmienna,
@var{history}, przechowuje liczbę zachowywanych wierszy historii.
Wartość -1 oznacza, że przechowywana jest nieograniczona liczba wierszy
historii.  Ustawienie wartości @var{history} na liczbę dodatnią ogranicza
liczbę przechowywanych wierszy historii do podanej liczby. Wartość zero
wyłącza funkcję historii wprowadzonych wierszy.  Wartością domyślną jest
100.  Więcej informacji można znaleźć w podręcznikach użytkownika dla
bibliotek GNU @code{readline} i @code{history} oraz BSD
@code{libedit}.  Nie można równocześnie włączyć zarówno @code{readline}
jak i @code{libedit}.

@node GNU bc a inne implementacje, Ograniczenia, Opcje Readline i Libedit, Top
@chapter GNU @code{bc} a inne implementacje

Niniejsza wersja @code{bc} została zbudowana w oparciu o projekt POSIX
P1003.2/D11 i zawiera kilka różnic i rozszerzeń w stosunku do tego dokumentu
i tradycyjnych realizacji.  Nie jest wykonana w tradycyjny sposób,
wykorzystujący polecenie @code{dc}.  Wersja ta jest pojedynczym procesem,
analizującym i uruchamiającym kod binarny będący tłumaczeniem programu.
Istnieje "nieudokumentowana" opcja (-c) powodująca, że program wyświetla kod
binarny na standardowym wyjściu zamiast wykonywania go. Używana była ona
głównie do debuggowania analizatora składni i przy przygotowaniu
biblioteki matematycznej.

Głównym źródłem różnic są rozszerzenia, w których jakaś cecha, możliwość
programu jest rozbudowana w celu dodania funkcjonalności, oraz dodatki, gdzie
dodano nowe możliwości.
Poniżej podano listę różnic i rozszerzeń.

@table @var

@item Zmienna środowiska LANG
Niniejsza wersja nie spełnia standardu POSIX przetwarzania zmiennej
środowiska @env{LANG} i wszystkich zmiennych środowiska rozpoczynających
się na @env{LC_}.

@item nazwy
Tradycyjny i POSIX-owy @code{bc} posiadają jednoliterowe nazwy funkcji,
zmiennych i tablic. Zostały one rozszerzone do nazw wieloznakowych,
rozpoczynających się literą i mogących zawierać litery, cyfry i znaki
podkreślenia.

@item łańcuchy
Łańcuchy nie mogą zawierać znaków NUL. POSIX stwierdza, że wszystkie znaki
muszą być zawarte w łańcuchach.

@item last
POSIX @code{bc} nie posiada zmiennej @var{last}. Niektóre implementacje
@code{bc} używają kropki (.) w podobny sposób.

@item porównania
POSIX @code{bc} dopuszcza porównania wyłącznie w instrukcjach @code{if},
@code{while} oraz w drugim wyrażeniu instrukcji @code{for}.  Dodatkowo,
w każdej z tych instrukcji dopuszczalna jest tylko jedna operacja
porównania (relacji).

@item instrukcja if, klauzula else
POSIX @code{bc} nie posiada klauzuli @code{else}.

@item instrukcja for
POSIX @code{bc} wymaga, by w instrukcji @code{for} występowały wszystkie
wyrażenia.

@item &&, ||, !
POSIX @code{bc}  nie posiada operatorów logicznych.

@item funkcja read
POSIX @code{bc} nie posiada funkcji @code{read}.

@item instrukcja print
POSIX @code{bc} nie posiada instrukcji @code{print}.

@item instrukcja continue
POSIX @code{bc} nie posiada instrukcji @code{continue}.

@item instrukcja return
POSIX @code{bc} wymaga nawiasów wokół zwracanego wyrażenia.

@item parametry tablicowe
POSIX @code{bc} nie obsługuje (obecnie) w pełni parametrów tablicowych.
Gramatyka POSIX zezwala na użycie tablic w definicjach funkcji, ale nie
zapewnia metody przekazania tablicy jako bieżącego parametru. (Jest to
najprawdopodobniej przeoczenie w zdefiniowanej gramatyce.) Tradycyjne
implementacje @code{bc} posiadają jedynie wywołanie parametrów tablicowych
przez wartość.

@item format funkcji
POSIX @code{bc} wymaga, by nawias otwierający był w tym samym wierszu, co
słowo kluczowe @code{define}, zaś instrukcja @code{auto} w następnym wierszu.

@item =+, =-, =*, =/, =%, =^
POSIX @code{bc} nie wymaga, by były zdefiniowane powyższe operatory
przypisania "starego typu". Niniejsza wersja zezwala na takie przypisania
w "starym stylu". Należy skorzystać z instrukcji @code{limits}, by
stwierdzić, czy zainstalowana wersja je rozpoznaje. Jeżeli obsługuje ona
przypisania w "starym stylu", to instrukcja "a =- 1" pomniejszy @code{a}
o jeden zamiast przypisać @code{a} wartość -1.

@item spacje w liczbach
Inne implementacje @code{bc} dopuszczają występowanie spacji w liczbach.
Na przykład, "x=1 3" przypisze wartość 13 zmiennej x. Ta sama instrukcja
spowoduje błąd składni w opisywanej tu wersji @code{bc}.

@item błędy i wykonanie
Opisywana implementacja różni się od innych sposobem, w jaki wykonywany jest
kod w przypadku znalezienia w programie błędów składniowych i innych.
W przypadku napotkania błędu w definicji funkcji, obsługa błędów próbuje
odnależć początek instrukcji i kontynuować analizę składniową
funkcji.
Po znalezieniu błędu w funkcji, nie jest ona możliwa do wywołania i staje
się niezdefiniowana. Błędy składniowe w interaktywnym wykonywaniu kodu
unieważniają bieżący blok wykonania. Blok wykonania jest zakończony
końcem linii pojawiającym się po pełnej sekwencji instrukcji.
Na przykład,

@example
a = 1
b = 2
@end example

posiada dwa bloki wykonania a

@example
@{ a = 1
  b = 2 @}
@end example

ma jeden blok wykonania.
Każdy z błędów wykonania przerywa wykonywanie bieżącego bloku wykonania.
Ostrzeżenie w trakcie wykonywania nie przerywa bieżącego bloku.

@item przerwania
Podczas sesji interaktywnej sygnał SIGINT (zwykle generowany przez znak
control-C z terminala) spowoduje przerwanie bieżącego bloku wykonywania.
Wyświetli on błąd wykonania ("runtime"), wskazujący która funkcja została
przerwana. Po wyczyszczeniu wszystkich struktur (runtime structures)
wykonania, zostanie wyświetlony komunikat informujący użytkownika, że
@code{bc} jest gotów do przyjmowania kolejnych danych. Wszystkie uprzednio
zdefiniowane funkcje pozostają zdefiniowane, zaś wartości wszystkich
zmiennych innych niż zmienne typu auto są wartościami sprzed przerwania.
Podczas procesu oczyszczania struktur danych usuwane są wszystkie zmienne
typu auto oraz parametry funkcji.
W czasie sesji nieinteraktywnej sygnał SIGINT przerywa wykonanie całego
@code{bc}.
@end table

@node Ograniczenia, Zmienne środowiska, GNU bc a inne implementacje, Top
@chapter Ograniczenia

Poniżej podano obecne ograniczenia opisywanego procesora @code{bc}.
Niektóre z nich mogą być zmienione podczas instalacji. Faktyczne
ograniczenia można sprawdzić za pomocą instrukcji @code{limits}
(ograniczenia).

@table @code

@item BC_BASE_MAX
Maksymalna podstawa pozycyjnego układu, w którym wyprowadzane są wyniki
obecnie ustawiona jest na 999. Maksymalną podstawą układu wejściowego jest 16.

@item BC_DIM_MAX
Obecnie ustawione jest arbitralne ograniczenie do 65535 (w wersji
rozpowszechnianej). Twoja instalacja może być inna.

@item BC_SCALE_MAX
Liczba cyfr po kropce dziesiętnej ograniczona jest do INT_MAX cyfr. Także
liczba cyfr przed kropką dziesiętną ograniczona jest do INT_MAX cyfr.

@item BC_STRING_MAX
Maksymalnie w łańcuchu może wystąpić INT_MAX znaków.

@item exponent
Wartość wykładnika w operacji potęgowania (^) ograniczona jest do LONG_MAX.

@item multiply
Procedura mnożenia może dawać nieprawidłowe wyniki jeżeli liczba posiada
więcej niż LONG_MAX / 90 cyfr ogółem. Dla 32 bitowych długich liczb
całkowitych (longint) jest to 23,860,929 cyfr.

@item nazwy zmiennych
Obecnie nie może być więcej niż 32767 unikalnych nazw w każdym z rodzajów:
zmiennych prostych, tablic i funkcji.
@end table

@node Zmienne środowiska, Zgłaszanie błędów, Ograniczenia, Top
@chapter Zmienne środowiska

@code{bc} przetwarza następujące zmienne środowiska:

@table @code

@item POSIXLY_CORRECT
To samo, co opcja @samp{-s}. Tryb zgodności z POSIX.
(@pxref{Opcje wiersza poleceń}).

@item BC_ENV_ARGS
Inny sposób przekazywania argumentów do @code{bc}.  Format jest taki sam,
jak argumentów wiersza poleceń.  Argumenty te przetwarzane są na początku,
więc pliki podane w argumentach środowiska przetwarzane są przed plikami
podanymi jako argumenty wiersza poleceń.  Umożliwia to użytkownikowi
ustawienie "standardowych" opcji i plików, jakie będą przetwarzane przy
każdym wywołaniu @code{bc}.  Pliki podane w zmiennych środowiska zawierają
zwykle definicje funkcji, które użytkownik chce mieć zdefiniowane przy
każdym uruchomieniu @code{bc}.

@item BC_LINE_LENGTH
Powinna to być liczba całkowita (integer) podająca ilość znaków w wierszu
wynikowym.  Obejmuje ona znaki odwrotnego ukośnika i nowej linii dla długich
liczb.
@end table

@node Zgłaszanie błędów, , Zmienne środowiska, Top
@chapter Zgłaszanie błędów

Zgłoszenia błędów proszę nadsyłać na adres @email{bug-bc@@gnu.org}.
Upewnij się, że pole tematu wiadomości zawiera gdzieś słowo ``bc''.

@contents
@bye

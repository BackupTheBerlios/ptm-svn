%& -translate-file=il2-pl
\def\fontprefix{pl}
\input texinfo @c -*-texinfo-*-
@c %**start of header
@setfilename find.info
@settitle Znajdowanie plików
@c For double-sided printing, uncomment:
@c @setchapternewpage odd
@documentencoding ISO-8859-2
@documentlanguage pl
@c %**end of header

@set EDITION 1.1
@set VERSION 4.1
@set UPDATED listopad 1994

@iftex
@finalout
@end iftex

@ifinfo
@format
START-INFO-DIR-ENTRY
* Znajdowanie plików: (find).      Listowanie i działania na plikach
                                   spełniających zadane warunki.

* find: (find)Wywołanie find.         Szuka plików w hierarchii katalogowej.
* locate: (find)Wywołanie locate.     Wyszukuje pliki w bazie danych.
* updatedb: (find)Wywołanie updatedb. Aktualizuje bazę nazw plików.
* xargs: (find)Wywołanie xargs.       Wykonuje polecenie z argumentami
                                      pobranymi ze standardowego wejścia.

END-INFO-DIR-ENTRY
@end format

Niniejszy podręcznik opisuje zestaw narzędzi GNU do znajdowania plików,
które spełniają pewne warunki, i wykonywania na nich różnych działań.

Copyright (C) 1994 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

@ignore
Permission is granted to process this file through TeX and print the
results, provided the printed document carries copying permission
notice identical to this one except for the removal of this paragraph
(this paragraph not being relevant to the printed manual).

@end ignore
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation approved
by the Foundation.
@end ifinfo

@titlepage
@title Znajdowanie plików
@subtitle Wydanie @value{EDITION}, opisujące GNU @code{find} w wersji @value{VERSION}
@subtitle @value{UPDATED}
@author David MacKenzie

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 1994 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation approved
by the Foundation.
@end titlepage

@node Top, Od tłumacza, , (dir)
@comment  node-name,  next,  previous,  up

@ifinfo
Niniejszy podręcznik opisuje zestaw narzędzi GNU do znajdowania plików,
które spełniają pewne warunki, i wykonywania na nich różnych działań.
To jest wydanie @value{EDITION}, opisujące GNU @code{find} w wersji
@value{VERSION}.
@end ifinfo

@c The master menu, created with texinfo-master-menu, goes here.

@menu
* Od tłumacza::                 Parę słów od tłumacza.
* Wprowadzenie::                Podsumowanie zadań opisanych w podręczniku.
* Znajdowanie plików::          Znajdowanie plików spełniających dane warunki.
* Akcje::                       Czynności wykonywane na znalezionych plikach.
* Typowe zadania::              Rozwiązania typowych, praktycznych problemów.
* Bazy nazw plików::            Utrzymywanie baz nazw plików.
* Prawa pliku::                 Jak kontrolować dostęp do plików.
* Informator::                  Podsumowanie sposobów wywołania programów.
* Skorowidz jednostek::         Składowe wyrażeń @code{find}.
@end menu

@unnumbered Od tłumacza
Niniejszy przekład powstał
w ramach @uref{http://ptm.linux.pl/, Projektu Tłumaczenia Manuali}.
Pomocne były istniejące tłumaczenia stron podręcznika systemowego man,
które wykonali:

@itemize @w
@item Przemek Borys (@email{pborys@@p-soft.silesia.linux.org.pl})
@item Wojtek Kotwica (@email{wkotwica@@post.pl})
@item Łukasz Kowalczyk (@email{lukow@@tempac.okwf.fuw.edu.pl})
@end itemize

Zgłoszenia błędów, komentarze i sugestie proszę przesyłać na listę dyskusyjną
Projektu: @email{ptm@@amg.net.pl} lub ewentualnie do autora tłumaczenia.

W.Kotwica (@email{wkotwica@@post.pl})

@unnumberedsec Rozpowszechnianie
To jest nieoficjalne tłumaczenie warunków rozpowszechniania na język polski.
Nie zostało ono opublikowane przez Free Software Foundation
i pod względem prawnym nie stanowi warunków rozpowszechniania -- ustanawia
je wyłącznie oryginalny tekst angielski.  Jednak tłumacz ma nadzieję, że
pomoże ono lepiej zrozumieć warunki rozpowszechniania osobom mówiącym
po polsku.

This is an unofficial translation of the distribution terms into
Polish language. It was not published by the Free Software Foundation, and
does not legally state the distribution terms--only the original English text
does that. However, the translator hopes that it will help Polish language
speakers understand distribution terms better.

Zezwala się na tworzenie i rozpowszechnianie wiernych kopii
tego podręcznika, pod warunkiem, że na wszystkich kopiach zostanie zachowana
informacja o prawach autorskich i niniejsze zezwolenie.

Zezwala się na kopiowanie i rozpowszechnianie zmienionych wersji
tego podręcznika na warunkach jak dla wiernych kopii, pod warunkiem, że
cała praca pochodna będzie rozpowszechniana na warunkach zezwolenia
identycznego jak niniejsze.

Zezwala się na kopiowanie i rozpowszechnianie tłumaczeń tego
podręcznika na inny język, pod wyżej podanymi warunkami dla zmienionych
wersji, z wyjątkiem tego, że niniejsze zezwolenie może być ustanowione
w tłumaczeniu zaakceptowanym przez Fundację.

@node Wprowadzenie
@chapter Wprowadzenie

W niniejszym podręczniku pokazano, jak znajdować pliki, które spełniają
podane kryteria i jak wykonywać na nich rozmaite czynności.  Głównymi
programami używanymi do wykonania tych zadań są @code{find}, @code{locate}
i @code{xargs}. W niektórych z zamieszczonych przykładów wykorzystano
możliwości specyficzne dla wersji GNU tych programów.

GNU @code{find} został pierwotnie napisany przez Erica Deckera, rozszerzenia
wykonali David MacKenzie, Jay Plett i Tim Wood.  GNU @code{xargs} napisał
pierwotnie Mike Rendell, a jego rozszerzenia - David MacKenzie.
GNU @code{locate} i narzędzia mu towarzyszące zostały pierwotnie napisane
przez Jamesa Woodsa, poszerzył je David MacKenzie.
Pomysł @samp{find -print0} i @samp{xargs -0} wyszedł od Dana Bernsteina.
Wiele innych osób wniosło poprawki błędów, drobne usprawnienia i pomocne
sugestie. Dzięki!

Sugestie i zgłoszenia błędów w tych programach należy przesyłać (w języku
angielskim) na adres @email{bug-gnu-utils@@prep.ai.mit.edu}.  W listach
proszę zamieścić numer wersji, który można uzyskać uruchamiając
@samp{find --version}.

@menu
* Zakres::
* Przegląd::
* Wyrażenia find::
@end menu

@node Zakres
@section Zakres

@c For brevity
Dla zachowania zwięzłości, słowo @dfn{plik} w tym podręczniku oznacza
zwykły plik, katalog, dowiązanie symboliczne lub dowolny inny rodzaj węzła,
mający wpis w katalogu.  Pozycja katalogu nazywana jest też @dfn{nazwą pliku}.
Każda nazwa pliku może zawierać część lub wszystkie katalogi ścieżki
prowadzącej do pliku.  Może też nie zawierać ich wcale.  Wszystkie poniższe
zapisy są przykładami tego, co nazywa się tu ,,nazwami plików'':

@example
parser.c
README
./budget/may-94.sc
fred/.cshrc
/usr/local/include/termcap.h
@end example

@dfn{Drzewo katalogowe} to katalog i pliki, które zawiera, wszystkie jego
podkatalogi i pliki w nich zawarte itd.  Może to też być pojedynczy plik
nie będący katalogiem.

Omawiane programy umożliwiają znalezienie, w jednym lub w wielu drzewach
katalogowych, plików, które:

@itemize @bullet
@item
mają nazwy zawierające określony tekst lub pasujące do określonego wzorca,
@item
są dowiązaniami do określonych plików,
@item
były ostatnio używane w określonym okresie,
@item
mają rozmiary mieszczące się w określonym zakresie,
@item
są określonego typu (zwykły plik, katalog, dowiązanie symboliczne, itd.),
@item
są własnością określonego użytkownika lub grupy,
@item
mają określone prawa dostępu,
@item
zawierają tekst pasujący do określonego wzorca,
@item
znajdują się na określonym poziomie drzewa katalogowego,
@item
lub spełniają jakąś kombinację powyższych warunków.
@end itemize

Po znalezieniu poszukiwanych plików (lub plików, które są potencjalnie tymi,
których szukano) można zrobić z nimi coś więcej, niż po prostu utworzyć listę
ich nazw.  Możliwe jest uzyskanie dowolnej kombinacji cech tych plików lub
przetworzenie plików na wiele sposobów, albo pojedynczo albo w grupach
różnych rozmiarów.  Działania, jakie można wykonać na znalezionych plikach
obejmują (choć nie są tych czynności ograniczone):

@itemize @bullet
@item
przeglądanie i edycję
@item
zapisywanie w archiwum
@item
usuwanie lub przemianowanie
@item
zmianę praw dostępu
@item
klasyfikację w grupy
@end itemize

W tym podręczniku opisano, jak wykonać każde z tych zadań, i nie tylko.

@node Przegląd
@section Przegląd

Głównymi programami stosowanymi do tworzenia list plików spełniających
zadane warunki i uruchamiania dla nich poleceń są @code{find}, @code{locate}
i @code{xargs}.  Administratorzy systemu używają dodatkowo polecenia
@code{updatedb}, do tworzenia baz danych, z których korzysta @code{locate}.

@code{find} szuka plików w danej hierarchii katalogów i wypisuje informacje
o tych, które znalazł.  Uruchamiany jest tak:

@example
find @r{[}@var{plik}@dots{}@r{]} @r{[}@var{wyrażenie}@r{]}
@end example

@noindent
A oto typowe zastosowanie @code{find}.  Ten przykład wypisuje nazwy wszystkich
plików w drzewie katalogowym wyrastającym z @file{/usr/src}, których nazwy
kończą się ciągiem znaków @samp{.c} i które są większe niż 100 kilobajtów.

@example
find /usr/src -name '*.c' -size +100k -print
@end example

@code{locate} szuka w specjalnych bazach danych, zawierających nazwy plików,
nazw pasujących do wzorca.  Administrator systemu tworzy te bazy
uruchamiając program @code{updatedb}.  @code{locate} uruchamia się tak:

@example
locate @r{[}@var{opcja}@dots{}@r{]} @var{wzorzec}@dots{}
@end example

@noindent
Ten przykład wypisuje nazwy wszystkich plików z domyślnej bazy nazw plików,
których nazwy kończą się łańcuchem @samp{Makefile} lub @samp{makefile}.
Które z nazw plików są przechowywane w bazie, zależy od tego, w jaki sposób
administrator uruchomił @code{updatedb}.
@example
locate '*[Mm]akefile'
@end example

Nazwa @code{xargs}, wymawiana iks-args (EX-args), oznacza ,,połącz argumenty''.
@code{xargs} buduje i uruchamia wiersze poleceń, za pomocą zbierania razem
argumentów, jakie odczyta ze standardowego wejścia.  Najczęściej argumenty
te są listami nazw plików wygenerowanymi przez @code{find}.
@code{xargs} uruchamiany jest tak:

@example
xargs @r{[}@var{opcja}@dots{}@r{]} @r{[}@var{polecenie} @r{[}@var{argumenty-początkowe}@r{]}@r{]}
@end example

@noindent
Poniższe polecenie przeszukuje pliki wymienione w pliku @file{file-list}
i wypisuje wszystkie te ich linie, które zawierają słowo @samp{typedef}.
@example
xargs grep typedef < file-list
@end example

@node Wyrażenia find
@section Wyrażenia @code{find}

@c   primaries
Wyrażenie wykorzystywane przez @code{find} do wyboru plików składa się
z jednej lub więcej @dfn{jednostek} (@dfn{primaries}), z których każda
jest dla @code{find} odrębnym argumentem wiersza poleceń.  @code{find}
wylicza to wyrażenie za każdym razem, gdy przetwarza plik.  Może ono
zawierać dowolny z poniższych rodzajów jednostek składowych:

@table @dfn
@item opcje
wpływają na całość działania, a nie na przetwarzanie konkretnego pliku;
@item testy
zwracają wartość prawdziwą lub fałszywą, zależnie od cech pliku;
@item akcje
mają skutki uboczne i zwracają wartość prawdziwą lub fałszywą; oraz
@item operatory
łączą pozostałe argumenty i wpływają na to, kiedy i czy będą one wyliczane.
@end table

Operator między dwoma jednostkami można pominąć - domyślnie jest to @samp{-and}.
@xref{Łączenie jednostek za pomocą operatorów}, gdzie opisano metody łączenia
jednostek w bardziej złożone wyrażenia. Jeżeli wyrażenie nie zawiera akcji
innych niż @samp{-prune}, to dla wszystkich plików, dla których dane wyrażenie
jest prawdziwe wykonywane jest @samp{-print} (@pxref{Wypisanie nazwy pliku}).

Opcje działają natychmiast - nie są obliczane dla każdego pliku, w momencie
przejścia do ich pozycji w wyrażeniu.  Stąd też, dla czytelności, najlepiej
umieszczać je na samym początku wyrażenia.

Wiele z jednostek pobiera argumenty, które występują bezpośrednio po nich,
jako następny argument wiersza poleceń @code{find}.  Niektóre argumenty są
nazwami plików, wzorcami lub innymi łańcuchami. Inne są liczbami.  Argumenty
numeryczne można podawać jako

@table @code
@item +@var{n}
dla większych od @var{n},
@item -@var{n}
dla mniejszych od @var{n},
@item @var{n}
dla dokładnie @var{n}.
@end table

@node Znajdowanie plików
@chapter Znajdowanie plików

Domyślnie, @code{find} wypisuje na standardowe wyjście nazwy plików
spełniających zadane warunki.  @xref{Akcje}, gdzie opisano, jak uzyskać
więcej informacji o pasujących plikach.

@menu
* Nazwa::
* Dowiązania::
* Czas::
* Rozmiar::
* Typ::
* Właściciel::
* Prawa::
* Zawartość::
* Katalogi::
* Systemy plików::
* Łączenie jednostek za pomocą operatorów::
@end menu

@node Nazwa
@section Nazwa

A oto metody wyszukiwania plików, których nazwy pasują do określonego wzorca.
@xref{Dopasowywanie wzorców powłoki}, gdzie opisano argumenty typu
@var{wzorzec}, używane w takich testach.

Każdy z tych testów występuje w wersji rozróżniającej wielkość liter i
w wersji nierozróżniającej. Nazwy tych ostatnich zaczynają się od @samp{i}
(case-insensitive).  W porównywaniu nieodróżniającym wielkości
liter wzorce @samp{fo*} i @samp{F??} dopasowują nazwy plików @file{Foo},
@samp{FOO}, @samp{foo}, @samp{fOo}, itp.

@menu
* Wzorce głównej części nazwy::
* Wzorce pełnej nazwy::
* Szybkie wyszukiwanie pełnej nazwy::
* Dopasowywanie wzorców powłoki::   Znaki uogólniające w tych programach.
@end menu

@node Wzorce głównej części nazwy
@subsection Wzorce głównej części nazwy

@deffn Test -name wzorzec
@deffnx Test -iname wzorzec
Prawdziwy, jeśli główna część nazwy pliku (ścieżka z usuniętymi występującymi
na początku katalogami) pasuje do wzorca powłoki @var{wzorzec}.  W przypadku
@samp{-iname} dopasowywanie nie uwzględnia wielkości liter.  Do pominięcia
całego drzewa katalogowego służy opcja @samp{-prune} (@pxref{Katalogi}).
Jako przykład, polecenie znajdujące pliki źródłowe Texinfo
w @file{/usr/local/doc}:

@example
find /usr/local/doc -name '*.texi'
@end example
@end deffn

@node Wzorce pełnej nazwy
@subsection Wzorce pełnej nazwy

@deffn Test -path wzorzec
@deffnx Test -ipath wzorzec
Prawdziwy, jeśli cała nazwa pliku, poczynając od argumentu wiersza poleceń,
pod którym znaleziono plik, pasuje do wzorca powłoki @var{wzorzec}.
W przypadku @samp{-ipath} dopasowywanie nie uwzględnia wielkości liter.
Do pominięcia całego drzewa katalogowego stosuje się opcję @samp{-prune},
zamiast sprawdzać każdy plik drzewa (@pxref{Katalogi}).
@end deffn

@deffn Test -regex wyraż
@deffnx Test -iregex wyraż
Prawdziwy, jeśli cała nazwa pliku pasuje do wyrażenia regularnego @var{wyraż}.
Jest to dopasowanie do pełnej ścieżki, nie szukanie. Na przykład, żeby
dopasować plik o nazwie @file{./fubar3}, można użyć wyrażenia regularnego
@samp{.*bar.} lub @samp{.*b.*3}, ale nie @samp{b.*r3}.
@xref{Regexps, , Syntax of Regular Expressions, emacs, The GNU Emacs Manual},
gdzie opisano składnię wyrażeń regularnych.
W przypadku @samp{-iregex} dopasowywanie nie uwzględnia wielkości liter.
@end deffn

@node Szybkie wyszukiwanie pełnej nazwy
@subsection Szybkie wyszukiwanie pełnej nazwy

Do szybkiego wyszukiwania plików po nazwie, bez konieczności faktycznego
przeglądania katalogów na dysku (co może być powolne), można skorzystać
z programu @code{locate}.  Dla każdego podanego wzorca przeszukuje on jedną
lub kilka baz z nazwami plików i wyświetla te nazwy, które go zawierają.
@xref{}, gdzie dokładniej omówiono wzorce powłoki.

Jeśli wzorzec jest zwykłym łańcuchem -- nie zawiera żadnych metaznaków --
@code{locate} wyświetla wszystkie nazwy plików z bazy zawierające ten
łańcuch.  jeżeli wzorzec zawiera metaznaki, program wyświetla tylko te
nazwy plików, które dokładnie odpowiadają wzorcowi.  Wskutek tego, wzorce
zawierające metaznaki powinny się na ogół zaczynać od @samp{*} i najczęściej
również tak się kończą.  Wyjątkami są wzorce, które mają jawnie dopasowywać
początek lub koniec nazwy pliku.

Polecenie
@example
locate @var{wzorzec}
@end example

jest niemal równoważne poleceniu
@example
find @var{katalogi} -name @var{wzorzec}
@end example

gdzie @var{katalogi} są tymi katalogami, o których dane są zawarte w bazach
nazw plików.  Różnice polegają na tym, że informacje @code{locate} mogą
być nieaktualne oraz na tym, że @code{locate} obsługuje znaki uogólniające
we wzorcach nieco inaczej niż @code{find} (@pxref{Dopasowywanie wzorców powłoki}).

Bazy nazw plików zawierają listy plików istniejących w systemie w momencie
ostatniej aktualizacji baz.  Administrator powinien wybrać nazwę pliku
domyślnej bazy, częstość, z jaką mają być odświeżane bazy, oraz katalogi,
dla których mają zawierać wpisy.

W poniższy sposób wybiera się bazy nazw plików, które mają być
przeszukane przez @code{locate}.  Bazy domyślne zależą od systemu.

@table @code
@item --database=@var{ścieżka}
@itemx -d @var{ścieżka}
Zamiast przeszukiwania domyślnej bazy nazw plików, przeszukiwane będą bazy
ze @var{ścieżki}, która jest listą rozdzielonych dwukropkami nazw plików baz.
Do ustawienia listy przeszukiwanych plików baz można też użyć zmiennej
środowiskowej @code{LOCATE_PATH}.  Jeżeli zostaną zastosowane obie, to opcja
przesłania ustawienia zmiennej środowiskowej.
@end table

@node Dopasowywanie wzorców powłoki
@subsection Dopasowywanie wzorców powłoki

@code{find} i @code{locate} potrafią porównywać nazwy plików, lub części tych
nazw, z wzorcami powłoki.  @dfn{Wzorzec powłoki} jest łańcuchem, który może
zawierać poniższe znaki specjalne, znane jako @dfn{znaki uogólniające}
lub @dfn{metaznaki}.

Wzorce zawierające metaznaki muszą być cytowane, by uchronić je przez
rozwinięciem przez samą powłokę.  Działają zarówno cudzysłowy, jak
i apostrofy; również cytowanie odwrotnym ukośnikiem.

@table @code
@item *
Dopasowuje zero lub więcej znaków.

@item ?
Dopasowuje jeden dowolny znak.

@item [@var{łańcuch}]
Dopasowuje dokładnie jeden znak będący elementem łańcucha @var{łańcuch}.
Nazywa się to @dfn{klasą znaków}.  Dla uproszczenia, @var{łańcuch} może
zawierać zakresy, które składają się z dwu znaków z kreską między nimi.
Na przykład, klasa  @samp{[a-z0-9_]} dopasowuje małą literę, cyfrę lub znak
podkreślenia.  Klasę można zanegować, umieszczając  bezpośrednio po nawiasie
otwierającym znak @samp{!} lub @samp{^}.  Zatem, @samp{[^A-Z@@]} dopasowuje
dowolny znak oprócz dużej litery bądź znaku at (@samp{@@}).

@item \
Usuwa specjalne znaczenie znaku, który po nim następuje.  Działa to nawet
w klasach znaków.
@end table

W testach @code{find} wykonujących dopasowywanie wzorców powłoki
(@samp{-name}, @samp{-path}, itd.) znaki uogólniające wzorca nie dopasowują
kropki @samp{.} występującej na początku nazwy pliku.
W przypadku @code{locate} tak nie jest.  Zatem, @samp{find -name '*macs'}
nie dopasuje pliku o nazwie @file{.emacs}, ale @samp{locate '*macs'} - tak.

Znaki ukośnika nie mają żadnego specjalnego znaczenia w dopasowywaniu wzorców
wykonywanym przez @code{find} i @code{locate}, w przeciwieństwie do powłoki,
gdzie znaki uogólniające ich nie dopasowują.  Stąd też, wzorzec @samp{foo*bar}
może dopasować nazwę pliku @samp{foo3/bar}, a wzorzec @samp{./sr*sc} nazwę
@samp{./src/misc}.

@node Dowiązania
@section Dowiązania

Istnieją dwa sposoby, w jakie mogą być połączone pliki.  @dfn{Dowiązania
symboliczne} (@dfn{symbolic links}) to specjalny rodzaj pliku, którego
zawartość jest fragmentem nazwy innego pliku.  @dfn{Dowiązania twarde}
(@dfn{hard links}) są wieloma wpisami katalogowymi dla tego samego, jednego
pliku -- wszystkie te nazwy plików mają ten sam numer indeksowy węzła
(numer @dfn{i-węzła}, @dfn{inode}) na dysku.

@menu
* Dowiązania symboliczne::
* Dowiązania twarde::
@end menu

@node Dowiązania symboliczne
@subsection Dowiązania symboliczne

@deffn Test -lname wzorzec
@deffnx Test -ilname wzorzec
Prawdziwy, jeśli plik jest dowiązaniem symbolicznym, którego zawartość
pasuje do wzorca powłoki @var{wzorzec}.  W przypadku @samp{-ilname}
dopasowywanie nie uwzględnia wielkości liter.
@xref{Dopasowywanie wzorców powłoki}, gdzie dokładniej omówiono argument 
@var{wzorzec}.  Zatem, listę dowiązań symbolicznych do pliku @file{sysdep.c}
położonych w bieżącym katalogu i jego podkatalogach można uzyskać pisząc:

@example
find . -lname '*sysdep.c'
@end example
@end deffn

@deffn Opcja -follow
Dereferencja dowiązań symbolicznych.
[tłum.: usuwanie pośredniości - działanie na plikach wskazywanych przez
dowiązania, a nie na samych dowiązaniach].
Jeśli podano tę opcję, to występują następujące różnice w zachowaniu się
programu:

@itemize @bullet
@item
podczas przeszukiwania drzew katalogowych @code{find} podąża za dowiązaniami
wskazującymi na katalogi.
@item
@samp{-lname} i @samp{-ilname} zawsze zwracają fałsz.
@item
@samp{-type} zgłasza typy plików wskazywanych przez dowiązania symboliczne
[zamiast typu @code{l} - tych dowiązań].
@item
wymusza @samp{-noleaf} (@pxref{Katalogi}).
@end itemize
@end deffn

@node Dowiązania twarde
@subsection Dowiązania twarde

Aby znaleźć dowiązania twarde, należy najpierw uzyskać numer i-węzła pliku,
którego dowiązań szukamy.  Numer i-węzła pliku i liczbę dowiązań do niego
można poznać uruchamiając @samp{ls -i} lub @samp{find -ls}.  Jeśli plik ma
więcej niż jedno dowiązanie, to pozostałych można szukać podając numer
i-węzła jako argument dla @samp{-inum}.  Jeżeli wyszukiwanie będzie
rozpoczęte w katalogu, w którym są zamontowane inne systemy plików, jak
@file{/usr} w przypadku wielu systemów, to należy dodać opcję @samp{-xdev}.
Takie postępowanie oszczędza niepotrzebnego szukania, gdyż dowiązania twarde
do pliku muszą leżeć na tym samym systemie plików.  @xref{Systemy plików}.

@deffn Test -inum n
Plik ma numer i-węzła równy @var{n}.
@end deffn

Można też szukać plików, które mają określoną liczbę dowiązań.  Robi się to
za pomocą opcji @samp{-links}.  Katalogi mają normalnie dwa dowiązania
twarde: tym drugim jest zawarta w nich pozycja @file{.}.  Jeżeli mają
podkatalogi, każdy z nich ma też dowiązanie twarde o nazwie @file{..}
do swego katalogu nadrzędnego.

@deffn Test -links n
Plik ma @var{n} dowiązań twardych.
@end deffn

@node Czas
@section Czas

Każdy plik ma trzy znaczniki czasu, które dokumentują kiedy ostatnio wykonano
pewne operacje na pliku. Są to czasy:

@enumerate
@item
dostępu (odczytu zawartości pliku);
[access]
@item
zmiany statusu (modyfikacji pliku lub jego atrybutów, [zmiany metainformacji
i-węzła]);
[change]
@item
modyfikacji (zmiany zawartości pliku);
[modify]
@end enumerate

Można szukać plików, których znaczniki czasu mieszczą się w określonym
przedziale wiekowym lub też porównywać je z innymi znacznikami czasu.

@menu
* Zakresy wieku::
* Porównywanie znaczników czasu::
@end menu

@node Zakresy wieku
@subsection Zakresy wieku

Te testy są przydatne głównie z zakresami (@samp{+@var{n}} i @samp{-@var{n}}).

@deffn Test -atime n
@deffnx Test -ctime n
@deffnx Test -mtime n
Prawdziwy, jeśli do danego pliku ostatnio sięgano (lub, odpowiednio, zmieniano
jego status albo modyfikowano zawartość) @var{n}*24 godziny temu.
@end deffn

@deffn Test -amin n
@deffnx Test -cmin n
@deffnx Test -mmin n
Prawdziwy, jeśli do danego pliku ostatnio sięgano (lub, odpowiednio, zmieniano
jego status albo modyfikowano zawartość) @var{n} minut temu.  Te testy
zapewniają precyzyjniejszy pomiar niż @samp{-atime} i s-ka.  Na przykład,
do wylistowania plików w @file{/u/bill}, które były ostatnio odczytywane
od 2 do 6 godzin temu:

@example
find /u/bill -amin +2 -amin -6
@end example
@end deffn

@deffn Opcja -daystart
Mierzy czas od początku dzisiejszego dnia, a nie od 24 godzin temu.
Zatem, do wypisania zwykłych plików ze swojego katalogu domowego, które
zostały zmienione wczoraj, używamy:

@example
find ~ -daystart -type f -mtime 1
@end example
@end deffn

@node Porównywanie znaczników czasu
@subsection Porównywanie znaczników czasu

Zamiast porównywać znaczniki czasu z aktualnym czasem, można porównywać
je ze znacznikiem innego pliku.  Znacznik tego pliku odniesienia może być
aktualizowany przez inny program wtedy, gdy wystąpi jakieś zdarzenie.
Można też, stosując polecenie @code{touch}, ustawić go na jakąś konkretną
stałą datę.  Na przykład, do wypisania plików w @file{/usr} zmodyfikowanych
po 1 lutego bieżącego roku:

@c Idea from Rick Sladkey.
@example
touch -t 02010000 /tmp/stamp$$
find /usr -newer /tmp/stamp$$
rm -f /tmp/stamp$$
@end example

@deffn Test -anewer plik
@deffnx Test -cnewer plik
@deffnx Test -newer plik
Prawdziwy, jeśli do danego pliku ostatnio sięgano (lub, odpowiednio, zmieniano
jego status albo modyfikowano zawartość) później, niż został zmodyfikowany
@var{plik}.  Testy te uwzględniają opcję @samp{-follow} tylko wtedy, gdy
w wierszu poleceń występuje ona przed nimi.  @xref{Dowiązania symboliczne},
gdzie dokładniej opisano @samp{-follow}.  Na przykład, listę plików
zmodyfikowanych od czasu ostatniej modyfikacji @file{/bin/sh} uzyskamy tak:

@example
find . -newer /bin/sh
@end example
@end deffn

@deffn Test -used n
Prawdziwy, jeśli do danego pliku ostatnio sięgano @var{n} dni po ostatniej
zmianie jego statusu.  Przydatne do znajdowania plików, które nie są używane,
i które prawdopodobnie można by zarchiwować lub usunąć, by zaoszczędzić
miejsca na dysku.
@end deffn

@node Rozmiar
@section Rozmiar

@deffn Test -size n@r{[}bckw@r{]}
Prawdziwy, jeśli plik wykorzystuje @var{n} jednostek miejsca, w zaokrągleniu
w górę.  Jednostki to domyślnie bloki 512-bajtowe, ale można to zmienić
dodając do @var{n} jednoznakowy przyrostek:

@table @code
@item b
bloki 512-bajtowe
@item c
bajty
@item k
kilobajty (1024 bajtów)
@item w
2-bajtowe słowa
@end table

Do rozmiaru nie są wliczane bloki niebezpośrednie, ale są wliczane bloki
w plikach rzadkich (sparse), które faktycznie nie są przydzielone.
@end deffn

@deffn Test -empty
Prawdziwy, jeśli plik jest pusty i jest albo zwykłym plikiem albo katalogiem.
Z tego powodu może to być dobry kandydat do usunięcia.  Ten test przydaje się
w połączeniu z @samp{-depth} (@pxref{Katalogi}) i @samp{-exec rm -rf '@{@}' ';'}
(@pxref{Pojedynczy plik}).
@end deffn

@node Typ
@section Typ

@deffn Test -type c
Prawdziwy, jeśli plik jest typu @var{c}:

@table @code
@item b
blokowy [block] (buforowany) specjalny
@item c
znakowy [character] (niebuforowany) specjalny
@item d
katalog [directory]
@item p
potok nazwany [named pipe] (FIFO)
@item f
zwykły plik [regular file]
@item l
dowiązanie symboliczne [symbolic link]
@item s
gniazdo [socket]
@end table
@end deffn

@deffn Test -xtype c
To samo, co @samp{-type}, chyba że plik jest dowiązaniem symbolicznym.
Dla dowiązań symbolicznych: jeśli nie podano @samp{-follow}, to test daje
prawdę jeżeli dany plik jest dowiązaniem do pliku typu @var{c}; jeśli podano
@samp{-follow}, to daje prawdę gdy znakiem @var{c} jest @samp{l}.  Inaczej
mówiąc, w przypadku dowiązań symbolicznych @samp{-xtype} sprawdza typ tych
plików, czego @samp{-type} nie robi.  @xref{Dowiązania symboliczne}, gdzie
bliżej opisano @samp{-follow}.
@end deffn

@node Właściciel
@section Właściciel

@deffn Test -user nazwa_uż
@deffnx Test -group nazwa_gr
Prawdziwy, jeśli plik jest własnością użytkownika @var{nazwa_uż} (należy do
grupy @var{nazwa_gr}).  Dopuszcza się użycie identyfikatora numerycznego.
@end deffn

@deffn Test -uid n
@deffnx Test -gid n
Prawdziwy, jeśli numerycznym identyfikatorem użytkownika (grupy) będącego
właścicielem pliku jest @var{n}.  Te testy, w przeciwieństwie do @samp{-user}
i @samp{-group}, obsługują zakresy (@samp{+@var{n}} i @samp{-@var{n}}).
@end deffn

@deffn Test -nouser
@deffnx Test -nogroup
Prawdziwy, jeśli numerycznemu identyfikatorowi użytkownika pliku nie
odpowiada żaden użytkownik (numerycznemu identyfikatorowi grupy nie odpowiada
żadna grupa).  Przypadki te oznaczają zwykle, że pliki należały do
użytkowników, których potem usunięto z systemu.  Prawdopodobnie powinno się
zmienić właściciela (grupę) takich plików na istniejącego.  Służą do tego
programy @code{chown} i @code{chgrp}.
@end deffn

@node Prawa
@section Prawa

@xref{Prawa pliku}, gdzie opisano, jaką budowę mają prawa pliku
i jak je podawać.

@deffn Test -perm tryb
Prawdziwy, jeśli prawa pliku to dokładnie @var{tryb} (który może być
numeryczny lub symboliczne).  Tryby symboliczne jako punktu wyjścia używają
trybu 0.
Jeżeli @var{tryb} zaczyna się od @samp{-}, to test daje prawdę gdy
@emph{wszystkie} prawa ustawione w @var{trybie} są ustawione dla pliku;
prawa nie ustawione w @var{trybie} są ignorowane.
Jeżeli @var{tryb} zaczyna się od @samp{+}, to test daje prawdę gdy
@emph{którekolwiek} z praw ustawionych w @var{trybie} jest ustawione dla
pliku; prawa nie ustawione w @var{trybie} są ignorowane.
@end deffn

@node Zawartość
@section Zawartość

Do wyszukania plików według ich zawartości można użyć programu @code{grep}.
Na przykład, można dowiedzieć się, które pliki źródłowe w języku C
z bieżącego katalogu zawierają łańcuch znakowy @samp{thing}, pisząc:

@example
grep -l thing *.[ch]
@end example

Jeżeli chcemy ten łańcuch wyszukać również w plikach w podkatalogach, można
połączyć @code{grep} z @code{find} i @code{xargs}, tak:

@example
find . -name '*.[ch]' | xargs grep -l thing
@end example

Opcja @samp{-l} powoduje, że @code{grep} wypisuje tylko nazwy plików
zawierających dany łańcuch, a nie linie które go zawierają.  Argument
określający łańcuch (@samp{thing}) jest w rzeczywistości wyrażeniem
regularnym, więc może zawierać metaznaki.  Metodę można nieco wygładzić,
wykorzystując opcję @samp{-r}, dzięki której @code{xargs} nie będzie
uruchamiać programu @code{grep} jeżeli @code{find} nie da żadnego wyjścia.
Zastosowanie akcji @samp{-print0} programu @code{grep} oraz opcji @samp{-0}
programu @code{xargs} pozwoli na uniknięcie błędnej interpretacji tych nazw
plików, które zawierają spacje:

@example
find . -name '*.[ch]' -print0 | xargs -r -0 grep -l thing
@end example

Informacje o pełniejszej obróbce szukania plików, których zawartość pasuje
do wzorca, znajdują się w podręczniku systemowym programu @code{grep}.

@node Katalogi
@section Katalogi

Poniżej opisano, jak decydować o tym, które katalogi i w jaki sposób
@code{find} ma przeszukiwać.  Te dwie opcje umożliwiają przetwarzanie
poziomego wycinka drzewa katalogowego:

@deffn Opcja -maxdepth poziomy
Program zejdzie nie głębiej niż @var{poziomy} (całkowita nieujemna) poziomów
katalogów poniżej argumentów wiersza poleceń.  @samp{-maxdepth 0} oznacza,
że testy i akcje zostaną zastosowane tylko do argumentów wiersza poleceń.
@end deffn

@deffn Opcja -mindepth poziomy
Nie będą stosowane żadne testy ani akcje na poziomach mniejszych niż
@var{poziomy} (całkowita nieujemna).  @samp{-mindepth 1} oznacza
przetwarzanie wszystkich plików z wyjątkiem argumentów wiersza poleceń.
@end deffn

@deffn Opcja -depth
Przetwarzanie zawartości katalogu przed samym katalogiem.
Warto z tego korzystać podczas tworzenia list plików do archiwacji za pomocą
@code{cpio} lub @code{tar}.  Jeżeli katalog nie ma prawa zapisu dla swojego
właściciela, to zawartość można mimo to odtworzyć z archiwum, gdyż prawa
katalogu są odtwarzane po jego zawartości.
@end deffn

@deffn Akcja -prune
Jeżeli nie podano @samp{-depth}, to prawdziwa; program nie wchodzi w głąb
bieżącego katalogu.  Jeżeli podano @samp{-depth}, fałszywa; bez skutków.
@samp{-prune} wpływa tylko na testy i akcje, które w wyrażeniu występują
po niej, nie na poprzedzające ją.

Na przykład, do pominięcia katalogu @file{src/emacs} i wszystkich plików
i katalogów pod nim oraz wypisania nazw pozostałych znalezionych plików
używamy:

@example
find . -path './src/emacs' -prune -o -print
@end example
@end deffn

@deffn Opcja -noleaf
Nie jest wykonywana optymalizacja polegająca na przyjęciu, że katalogi
zawierają o dwa podkatalogi mniej niż liczba ich dowiązań twardych.
Opcja ta jest potrzebna podczas przeszukiwania systemów plików
niestosujących się do uniksowej konwencji dowiązań katalogów, takich jak
systemy plików CD-ROM lub MS-DOS, czy punkty montowania wolumenów AFS.
Każdy katalog w zwykłym uniksowym systemie plików ma co najmniej dwa
dowiązania twarde: swoją nazwę i wpis @file{.} (kropka).  Dodatkowo,
każdy z jego podkatalogów (jeśli są) ma wpis @file{..} dowiązany do tego
katalogu.  Podczas badania katalogu, @code{find}, po zbadaniu funkcją
@var{stat} o dwa podkatalogi mniej niż wynosi liczba dowiązań tego katalogu,
wie, że reszta wpisów w nim to nie-katalogi (pliki-@dfn{liście} (@dfn{leaf})
drzewa katalogowego).  Jeśli mają być badane tylko nazwy tych plików, nie
ma potrzeby sprawdzać informacji o ich statusie.  Daje to znaczący wzrost
szybkości wyszukiwania.
@end deffn

@node Systemy plików
@section Systemy plików

@dfn{System plików} (@dfn{filesystem}) to część dysku, albo maszyny lokalnej,
albo zamontowany ze zdalnego hosta poprzez sieć.  Przeszukiwanie sieciowych
systemów plików może być powolne, więc często nakazuje się programowi
@code{find}, by ich unikał.

Są dwie metody unikania przeszukiwania określonych systemów plików.
Pierwszą jest wskazanie programowi, by przeszukał tylko jeden system plików:

@deffn Opcja -xdev
@deffnx Opcja -mount
Zakazuje wchodzenia do katalogów położonych na innych systemach plików.
Te opcje to synonimy.
@end deffn

Drugi sposób to sprawdzanie dla każdego pliku typu systemu plików, na którym
się on znajduje, i niezagłębianie się w katalogi, które leżą na systemach
plików niepożądanego typu:

@deffn Test -fstype typ
Prawdziwy, jeśli dany plik leży na systemie plików typu @var{typ}.  Poprawne
typy systemów są różne dla różnych wersji Uniksa.  Oto niepełna lista typów
systemów plików akceptowanych w takich czy innych wersjach Uniksa:
@example
ufs 4.2 4.3 nfs tmp mfs S51K S52K
@end example
Typy systemów plików występujące w danym przypadku można zobaczyć stosując
opcję @samp{-printf} z dyrektywą @samp{%F}.  @xref{Wypisanie informacji o pliku}.
W celu uniknięcia przeszukiwania zdalnych systemów plików @samp{-fstype}
jest zwykle używana z @samp{-prune} (@pxref{Katalogi}).
@end deffn

@node Łączenie jednostek za pomocą operatorów
@section Łączenie jednostek za pomocą operatorów

Operatory budują złożone wyrażenie z testów i akcji.  Operatory to,
w kolejności malejącego priorytetu:

@table @code
@item @asis{( @var{wyr} )}
Wymusza priorytet. Prawdziwe jeśli @var{wyr} jest prawdziwe.

@item @asis{! @var{wyr}}
@itemx @asis{-not @var{wyr}}
Prawdziwe jeśli @var{wyr} jest fałszywe.

@item @asis{@var{wyr1 wyr2}}
@itemx @asis{@var{wyr1} -a @var{wyr2}}
@itemx @asis{@var{wyr1} -and @var{wyr2}}
Koniunkcja, AND. @var{wyr2} nie jest wyliczane jeśli @var{wyr1} jest fałszywe.

@item @asis{@var{wyr1} -o @var{wyr2}}
@itemx @asis{@var{wyr1} -or @var{wyr2}}
Alternatywa, OR. @var{wyr2} nie jest wyliczane jeśli @var{wyr1} jest prawdziwe.

@item @asis{@var{wyr1} , @var{wyr2}}
Lista.  Oba wyrażenia: @var{wyr1} i @var{wyr2} są zawsze wyliczane.
Prawdziwe, jeśli @var{wyr2} jest prawdziwe.  Wartość  @var{wyr1} jest
odrzucana.  Operator listy umożliwia wykonywanie wielu niezależnych operacji
podczas jednego przeglądania, niezależnie od tego, czy pozostałe operacje się
powiodły.
@end table

Dla każdej z nazw plików @code{find} przeszukuje drzewo katalogowe,
zakorzenione w miejscu pliku,
obliczając wyrażenie od lewej do prawej, zgodnie z regułami
priorytetów, do chwili, gdy wynik jest już znany (lewa strona jest fałszywa
dla @samp{-and}, bądź prawdziwa dla @samp{-or}).  Wówczas program przechodzi
do następnej nazwy pliku.

Istnieją dwa inne testy, które mogą się przydać w złożonych wyrażeniach:

@deffn Test -true
Zawsze prawdziwy.
@end deffn

@deffn Test -false
Zawsze fałszywy.
@end deffn

@node Akcje
@chapter Akcje

Jest kilka metod wypisywania informacji o plikach, które spełniają kryteria,
jakie zostały podane w wyrażeniu @code{find}.  Można wypisywać je albo na
standardowym wyjściu, albo do pliku o zadanej nazwie.  Można też wykonywać
polecenia, dla których uzyskane nazwy plików będą argumentami.  Polecenia te
można wykorzystać później jako filtry do wyboru plików.

@menu
* Wypisanie nazwy pliku::
* Wypisanie informacji o pliku::
* Uruchamianie poleceń::
* Dodawanie testów::
@end menu

@node Wypisanie nazwy pliku
@section Wypisanie nazwy pliku

@deffn Akcja -print
Prawdziwe. Wypisuje na standardowym wyjściu pełną nazwę pliku, dodając
po niej znak nowej linii.
@end deffn

@deffn Akcja -fprint plik
Prawdziwe. Wypisuje do pliku @var{plik} pełną nazwę danego pliku, dodając
po niej znak nowej linii.  Jeżeli @var{plik} nie istnieje w chwili
uruchomienia @code{find}, to jest tworzony.  Jeśli istnieje, to jest obcinany
do 0 bajtów.  Nazwy @file{/dev/stdout} i @file{/dev/stderr} są obsługiwane
w specjalny sposób: odnoszą się one do, odpowiednio, standardowego wyjścia
i standardowego wyjścia diagnostycznego (wyjścia błędów).
@end deffn

@node Wypisanie informacji o pliku
@section Wypisanie informacji o pliku

@deffn Akcja -ls
Prawdziwe.  Listuje bieżący plik na standardowym wyjściu używając formatu
@samp{ls -dils}.  Wynik wygląda tak:

@smallexample
204744   17 -rw-r--r--   1 djm      staff       17337 Nov  2  1992 ./lwall-quotes
@end smallexample

Kolejne pola to:

@enumerate
@item
numer i-węzła pliku.  @xref{Dowiązania twarde}, gdzie opisano, jak znaleźć
pliki na podstawie ich numeru i-węzła.

@item
Liczba bloków pliku. Bloki mają wielkość 1K, chyba że ustawiona jest zmienna
środowiskowa @code{POSIXLY_CORRECT} -- wówczas stosowane są bloki 512-bajtowe.
@xref{Rozmiar}, gdzie opisano, jak znaleźć pliki na podstawie ich rozmiaru.

@item
Typ i prawa pliku. Dla zwykłego pliku typ jest pokazywany jako kreska;
pozostały typy są oznaczane literami, takimi samymi, jak stosowane w opcji
@samp{-type} (@pxref{Typ}).  Prawa pliku to odczyt (Read), zapis (Write)
i wykonanie (eXecute), odpowiednio dla właściciela pliku, grupy i dla
pozostałych użytkowników.  Kreska oznacza, że nie dane prawo nie zostało
przyznane.  @xref{Prawa pliku}, gdzie bliżej opisano prawa plików.
@xref{Prawa},  gdzie opisano, jak znaleźć pliki na podstawie ich praw.

@item
Liczba dowiązań twardych do pliku.

@item
Użytkownik, który posiada plik.

@item
Grupa pliku.

@item
Rozmiar pliku w bajtach.

@item
Data ostatniej modyfikacji pliku.

@item
Nazwa pliku.  @samp{-ls} cytuje wszelkie znaki niedrukowalne w nazwach
stosując sekwencje specjalne z odwrotnym ukośnikiem, jak w C.
@end enumerate
@end deffn

@deffn Akcja -fls plik
Prawdziwe.  Jak @samp{-ls}, tylko wypisuje do @var{pliku}, podobnie jak
@samp{-fprint} (@pxref{Wypisanie nazwy pliku}).
@end deffn

@deffn Akcja -printf format
Prawdziwe.  Wypisuje @var{format} na standardowym wyjściu, interpretując
sekwencje specjalne @samp{\} i dyrektywy @samp{%}.  Szerokości pól
i dokładności można wyszczególniać tak, jak w funkcji @code{printf} języka C.
@samp{-printf}, inaczej niż w @samp{-print}, nie dokłada znaku nowej linii
na końcu łańcucha.
@end deffn

@deffn Akcja -fprintf plik format
Prawdziwe.  Jak @samp{-printf}, tylko wypisuje do @var{pliku}, podobnie jak
@samp{-fprint} (@pxref{Wypisanie nazwy pliku}).
@end deffn

@menu
* Sekwencje specjalne::
* Dyrektywy formatu::
* Formaty czasu::
@end menu

@node Sekwencje specjalne
@subsection Sekwencje specjalne

Sekwencje specjalne rozpoznawane przez @samp{-printf} i @samp{-fprintf}:

@table @code
@item \a
Dzwonek (alarm, bell).
@item \b
Backspace.
@item \c
Natychmiastowe zaprzestanie wypisywania na podstawie tego formatu
i wymiecenie wyjścia.
@item \f
Wysuw strony (form feed).
@item \n
Znak nowej linii (newline).
@item \r
Powrót karetki (carriage return).
@item \t
Tabulacja pozioma (horizontal tab).
@item \v
Tabulacja pionowa (vertical tab).
@item \\
Dosłowny odwrotny ukośnik (backslash), @samp{\}.
@end table

Znak @samp{\}, po którym występuje jakiś inny znak jest traktowany
jak zwykły znak, są więc wypisywane oba, zaś na standardowym wyjściu
diagnostycznym wypisywany jest komunikat ostrzegawczy (gdyż
prawdopodobnie była to literówka).

@node Dyrektywy formatu
@subsection Dyrektywy formatu

@samp{-printf} i @samp{-fprintf} rozpoznają następujące dyrektywy formatujące,
służące do wypisywania informacji o przetwarzanym pliku.  W przeciwieństwie
do funkcji @code{printf} języka C, nie udostępniają one specyfikatorów
szerokości pól.

@samp{%%} jest dosłownym znakiem procentu. Znak @samp{%}, po którym występuje
jakiś inny, nie ujęty poniżej znak jest odrzucany (ale sam znak po @samp{%}
jest wypisywany).  W takim przypadku na standardowym wyjściu diagnostycznym
wypisywany jest komunikat ostrzegawczy (gdyż prawdopodobnie była to
literówka).

@menu
* Dyrektywy nazwy::
* Dyrektywy właściciela::
* Dyrektywy rozmiaru::
* Dyrektywy umiejscowienia::
* Dyrektywy czasu::
@end menu

@node Dyrektywy nazwy
@subsubsection Dyrektywy nazwy

@table @code
@item %p
Nazwa pliku.
@item %f
Nazwa pliku z usuniętymi zaczynającymi ją katalogami
(tylko ostatni element nazwy).
@item %h
Katalogi zaczynające nazwę pliku
(wszystko oprócz ostatniego elementu oraz ukośnika przed nim).
@item %P
Nazwa pliku z usuniętą z początku nazwą argumentu wiersza poleceń,
dla którego ją znaleziono.
@item %H
Argument wiersza poleceń, dla którego znaleziono plik.
@end table

@node Dyrektywy właściciela
@subsubsection Dyrektywy właściciela

@table @code
@item %g
Nazwa grupy pliku lub jej numeryczny identyfikator, jeśli grupa nie ma nazwy.
@item %G
Numeryczny identyfikator grupy pliku.
@item %u
Nazwa użytkownika pliku lub jego numeryczny identyfikator, jeśli użytkownik
nie ma nazwy.
@item %U
Numeryczny identyfikator użytkownika pliku.
@item %m
Prawa pliku (ósemkowo).
@end table

@node Dyrektywy rozmiaru
@subsubsection Dyrektywy rozmiaru

@table @code
@item %k
Rozmiar pliku w blokach 1K (zaokrąglony w górę).
@item %b
Rozmiar pliku w blokach 512-bajtowych (zaokrąglony w górę).
@item %s
Rozmiar pliku w bajtach.
@end table

@node Dyrektywy umiejscowienia
@subsubsection Dyrektywy umiejscowienia

@table @code
@item %d
Głębokość położenia pliku w drzewie katalogowym; pliki wymienione w wierszu
poleceń mają głębokość 0.
@item %F
Typ systemu plików, na którym znajduje się plik.  Wartości tej można użyć
jako argumentu @samp{-fstype} (@pxref{Katalogi}).
@item %l
Obiekt wskazywany przez dowiązanie symboliczne (łańcuch pusty jeśli plik
nie jest dowiązaniem symbolicznym).
@item %i
Numer i-węzła pliku (dziesiętnie).
@item %n
Liczba twardych dowiązań do pliku.
@end table

@node Dyrektywy czasu
@subsubsection Dyrektywy czasu

Niektóre z tych dyrektyw korzystają z funkcji @code{ctime} języka C.  Jej
wyjście zależy od bieżących ustawień regionalnych (locale), ale zwykle
[tłum.: przy nieustawionych locale lub anglosaskich] wygląda tak

@example
Wed Nov  2 00:42:36 1994
@end example

@table @code
@item %a
Data ostatniego dostępu do pliku w formacie zwracanym przez funkcję
@code{ctime} C.
@item %A@var{k}
Data ostatniego dostępu do pliku w formacie określonym przez @var{k}
(@pxref{Formaty czasu}). 
@item %c
Data ostatniej zmiany statusu pliku w formacie zwracanym przez funkcję
@code{ctime} C.
@item %C@var{k}
Data ostatniego zmiany statusu w formacie określonym przez @var{k}
(@pxref{Formaty czasu}). 
@item %t
Data ostatniej modyfikacji pliku w formacie zwracanym przez funkcję
@code{ctime} C.
@item %T@var{k}
Data ostatniej modyfikacji w formacie określonym przez @var{k}
(@pxref{Formaty czasu}). 
@end table

@node Formaty czasu
@subsection Formaty czasu

Poniżej podano formaty stosowane dla dyrektyw @samp{%A}, @samp{%C}
i @samp{%T}, wypisujących znaczniki czasu pliku.  Niektóre z formatów mogą
nie być dostępne we wszystkich systemach, z powodu występujących między
systemami różnic w funkcji C @code{strftime}.

@menu
* Elementy czasu::
* Elementy daty::
* Łączone formaty czasu::
@end menu

@node Elementy czasu
@subsubsection Elementy czasu

Następujące dyrektywy formatujące wypisują pojedyncze elementy czasu.

@table @code
@item H
godzina (00..23)
@item I
godzina (01..12)
@item k
godzina ( 0..23)
@item l
godzina ( 1..12)
@item p
lokalne, wynikające z ustawień locale, AM lub PM
@item Z
strefa czasowa (np. EDT) lub nic jeśli nie da się jej określić
@item M
minuta (00..59)
@item S
sekunda (00..61)
@item @@
liczba sekund od 1 stycznia 1970, 00:00 GMT.
@end table

@node Elementy daty
@subsubsection Elementy daty

Następujące dyrektywy formatujące wypisują pojedyncze elementy daty.

@table @code
@item a
lokalna, skrócona nazwa dnia tygodnia (nie..sob)
@item A
lokalna pełna nazwa dnia tygodnia, zmiennej długości (niedziela..sobota)
@item b
@itemx h
lokalna, skrócona nazwa miesiąca (sty..gru)
@item B
lokalna, pełna nazwa miesiąca, zmiennej długości (styczeń..grudzień)
@item m
miesiąc (01..12)
@item d
dzień miesiąca (01..31)
@item w
dzień tygodnia (0..6)
@item j
dzień roku (001..366)
@item U
numer tygodnia w roku z niedzielą jako pierwszym dniem tygodnia (00..53)
@item W
numer tygodnia z poniedziałkiem jako pierwszym dniem tygodnia (00..53)
@item Y
rok (1970@dots{})
@item y
ostatnie dwie cyfry roku (00..99)
@end table

@node Łączone formaty czasu
@subsubsection Łączone formaty czasu

Następujące dyrektywy formatujące wypisują kombinacje elementów daty i czasu.

@table @code
@item r
czas, 12-godzinny (gg:mm:ss [AP]M)
@item T
czas, 24-godzinny (gg:mm:ss [AP]M)
@item X
lokalna reprezentacja czasu (%H:%M:%S)
@item c
lokalna data i czas (sob lis 04 12:02:33 EST 1989)
@item D
data (mm/dd/rr)
@item x
lokalna reprezentacja daty (mm/dd/rr)
@end table

@node Uruchamianie poleceń
@section Uruchamianie poleceń

Listy nazw plików utworzonej przez @code{find} lub @code{locate} można
użyć jako argumentów innych poleceń.  W ten sposób możliwe jest wykonanie
na znalezionych plikach dowolnych akcji.

@menu
* Pojedynczy plik::
* Wiele plików::
* Pytanie::
@end menu

@node Pojedynczy plik
@subsection Pojedynczy plik

Oto jak uruchamiać polecenie z jednym plikiem na raz.
@c   z pojedynczym plikiem;  z jednym plikiem na raz

@deffn Akcja -exec polecenie ;
Wykonuje @var{polecenie}.  Prawdziwe jeśli polecenie zwróci kod zakończenia
zero.  @code{find} uważa wszystkie argumenty po @samp{-exec} za część
podanego polecenia aż do napotkania argumentu składającego się ze średnika
@samp{;}.  Łańcuch @samp{@{@}} zastępuje wszędzie w poleceniu nazwą aktualnie
przetwarzanego pliku.  Obie te konstrukcje powinny być chronione (za pomocą
@samp{\} lub znaków cytowania) przed interpretacją przez powłokę.  Zadane
polecenie jest wykonywane w katalogu, w którym został uruchomiony @code{find}.

Na przykład, do porównania każdego pliku nagłówkowego C w bieżącym katalogu
z plikiem @file{/tmp/master} zastosujemy:

@example
find . -name '*.h' -exec diff -u '@{@}' /tmp/master ';'
@end example
@end deffn

@node Wiele plików
@subsection Wiele plików

Czasami trzeba przetwarzać pliki pojedynczo.  Jednak, jeśli nie jest to
konieczne, to szybciej jest uruchomić polecenie z tyloma plikami na raz,
ile się da, zamiast wykonywać je po razie dla każdego pliku.  Użycie
jednocześnie wielu plików oszczędza czas, jakiego za każdym razem potrzeba
na uruchomienie polecenia.

Do uruchomienia danego polecenia z więcej niż jednym plikiem jednocześnie
stosuje się polecenie @code{xargs}, wywoływane tak:

@example
xargs @r{[}@var{opcja}@dots{}@r{]} @r{[}@var{polecenie} @r{[}@var{argumenty-początkowe}@r{]}@r{]}
@end example

@code{xargs} czyta ze standardowego wejścia argumenty, rozdzielone odstępami
(które można chronić przed powłoką cudzysłowami lub apostrofami albo
odwrotnym ukośnikiem) lub znakami nowej linii.  Wywołuje raz lub
wiele razy zadane @var{polecenie} (domyślnym jest @file{/bin/echo})
z ewentualnymi @var{argumentami-początkowymi}, po których następują argumenty
odczytane ze standardowego wejścia.  Puste linie ze standardowego wejścia są
ignorowane.

Zamiast nazw rozdzielanych odstępami bezpieczniej jest korzystać
z @samp{find -print0} lub @samp{find -fprint0} i przetwarzać wyjście podając
opcję @samp{-0} lub @samp{--null} programom GNU @code{xargs}, GNU @code{tar},
GNU @code{cpio} lub @code{perl}.

Do przetwarzania list argumentów można wykorzystać realizowane przez powłokę
podstawianie wyników poleceń (za pomocą odwrotnych apostrofów, backquotes):

@example
grep -l sprintf `find $HOME -name '*.c' -print`
@end example

Jednak, ta metoda da błąd jeśli długość nazw plików @samp{.c} przekroczy
występujący w systemie operacyjnym limit długości wiersza poleceń.
@code{xargs} unika tego problemu uruchamiając dane polecenie tyle razy, ile
potrzeba bez przekraczania limitu:

@c   gdzie tu xargs?! zapomniane?
@example
find $HOME -name '*.c' -print | grep -l sprintf
@end example

Jeśli jednak polecenie potrzebuje terminala jako standardowego wejścia
(na przykład, @code{less}), konieczne jest użycie metody z podstawianiem
wyników poleceń przez powłokę.

@menu
* Ryzykowna obsługa nazw plików::
* Bezpieczna obsługa nazw plików::
* Ograniczanie rozmiaru polecenia::
* Przeplatanie nazw plików::
@end menu

@node Ryzykowna obsługa nazw plików
@subsubsection Ryzykowna obsługa nazw plików

Ponieważ nazwy plików mogą zawierać cudzysłowy, odwrotne ukośniki, znaki
odstępu, a nawet znaki nowej linii, nie jest bezpieczne przetwarzanie ich
za pomocą @code{xargs} w domyślnym trybie działania.  Ale wobec tego, że
większość nazw plików nie zawiera odstępów, ten problem pojawia się rzadko.
Jeśli wyszukujemy wśród plików, o których wiemy, że mają bezpieczne nazwy,
to nie musimy się tym niepokoić.

@c This example is adapted from:
@c From: pfalstad@stone.Princeton.EDU (Paul John Falstad)
@c Newsgroups: comp.unix.shell
@c Subject: Re: Beware xargs security holes
@c Date: 16 Oct 90 19:12:06 GMT
@c 
W wielu zastosowaniach, jeśli @code{xargs} spartaczy przetwarzanie pliku
z powodu specjalnych znaków w nazwie, może dojść do utraty pewnych danych.
Waga tego problemu zależy od istotności danych i tego, czy ktoś dostrzeże
stratę wystarczająco wcześnie, by je poprawić.  Niemniej jednak, oto skrajny
przypadek kłopotów, jakie może spowodować stosowanie nazw rozdzielanych
odstępami.  Jeżeli poniższe polecenie uruchamia się codziennie z @code{cron},
to pierwszy lepszy użytkownik może usunąć dowolny plik systemu:

@example
find / -name '#*' -atime +7 -print | xargs rm
@end example

Na przykład, można zrobić coś takiego:

@example
eg$ echo > '#
vmunix'
@end example

@noindent
a wówczas @code{cron} usunie @file{/vmunix}, jeśli uruchamia @code{xargs}
z @file{/} jako swoim katalogiem bieżącym.

Inne pliki, na przykład @file{/u/joeuser/.plan}, można by usunąć tak:

@example
eg$ mkdir '#
'
eg$ cd '#
'
eg$ mkdir u u/joeuser u/joeuser/.plan'
'
eg$ echo > u/joeuser/.plan'
/#foo'
eg$ cd ..
eg$ find . -name '#*' -print | xargs echo
./# ./# /u/joeuser/.plan /#foo
@end example

@node Bezpieczna obsługa nazw plików
@subsubsection Bezpieczna obsługa nazw plików

Poniżej podano, jak spowodować, by @code{find} do zwracał nazwy plików
w takiej postaci, by mogły być używane przez inne programy bez ryzyka
przekręcenia czy błędnej interpretacji.  Nazwy plików wygenerowane tą
metodą przetwarza się podając programom GNU @code{xargs}, GNU @code{tar},
GNU @code{cpio} lub @code{perl} opcję @samp{-0} lub @samp{--null}.

@deffn Akcja -print0
Prawdziwe. Wypisuje na standardowym wyjściu pełną nazwę pliku, dodając
po niej znak null (zerowy, oznaczający brak informacji).
@end deffn

@deffn Akcja -fprint0 plik
Prawdziwe.  Jak @samp{-print0}, tylko wypisuje do @var{pliku}, podobnie jak
@samp{-fprint} (@pxref{Wypisanie nazwy pliku}).
@end deffn

@node Ograniczanie rozmiaru polecenia
@subsubsection Ograniczanie rozmiaru polecenia

@code{xargs} pozwala decydować o liczbie argumentów, które przesyła
do danego polecenia za każdym razem, gdy je wywołuje.
Domyślnie, używa do @code{ARG_MAX} - 2k lub 20k (zależy, co jest mniejsze)
znaków na polecenie.  Wykorzystuje tyle linii i argumentów, ile tylko mieści
się w tym limicie.  Poniższe opcje zmieniają te wartości.

@table @code
@item --no-run-if-empty
@itemx -r
Jeżeli standardowe wejście nie zawiera żadnych znaków niepustych, to
dane polecenie nie zostanie uruchomione.  Domyślnie, polecenie jest
uruchamiane jednokrotnie nawet jeśli nie ma danych wejściowych.

@item --max-lines@r{[}=@var{max-linii}@r{]}
@itemx -l@r{[}@var{max-linii}@r{]}
Nakazuje używanie co najwyżej @var{max-linii} niepustych linii wejściowych
dla każdego wiersza poleceń.  Jeżeli pominięto @var{max-linii}, domyślnie 1.
Występujące na końcu odstępy powodują, że linia wejściowa będzie logicznie
kontynuowana w następnej, do celów zliczania linii.  Wymusza @samp{-x}.

@item --max-args=@var{max-arg}
@itemx -n @var{max-arg}
Używanie co najwyżej @var{max-arg} argumentów dla każdego wiersza poleceń.
Jeśli zostanie przekroczony rozmiar (zobacz opcja @samp{-s}),
@code{xargs} użyje mniej argumentów niż nakazano, chyba że podano opcję
@samp{-x}, wówczas zakończy pracę.

@item --max-chars=@var{max-zn}
@itemx -s @var{max-zn}
Używanie co najwyżej @var{max-zn} znaków dla każdego wiersza poleceń,
łącznie z samym poleceniem i argumentami początkowymi oraz znakami null
kończącymi łańcuchy argumentów.

@item --max-procs=@var{max-proc}
@itemx -P @var{max-proc}
Uruchamianie do @var{max-proc} procesów na raz; domyślnie 1.  Jeżeli
@var{max-proc} wynosi 0, to @code{xargs} będzie uruchamiać tyle procesów
jednocześnie, ile się da.  Razem z @samp{-P} powinno się użyć opcji @samp{-n},
@c        chances are that
@samp{-s} lub @samp{-l}, w przeciwnym razie, wedle wszelkich danych,
wskazane polecenie zostanie uruchomione tylko raz.
@end table

@node Przeplatanie nazw plików
@subsubsection Przeplatanie nazw plików

@code{xargs} potrafi wstawić nazwę przetwarzanego pliku pomiędzy argumenty,
podane dla danego polecenia.  Dopóki nie poda się równocześnie opcji
ograniczających rozmiar polecenia (@pxref{Ograniczanie rozmiaru polecenia}),
ten tryb działania jest równoważny @samp{find -exec} (@pxref{Pojedynczy plik}).

@table @code
@item --replace@r{[}=@var{łańc-zastępowany}@r{]}
@itemx -i@r{[}@var{łańc-zastępowany}@r{]}
Zastępuje wystąpienie @var{łańc-zastępowany} w argumentach początkowych
nazwami odczytanymi ze standardowego wejścia.  Dodatkowo, niecytowane odstępy
nie kończą argumentów.  Jeżeli pominięto @var{łańc-zastępowany}, domyślnie
jest nim @samp{@{@}} (jak dla @samp{find -exec}).  Ta opcja wymusza @samp{-x}
i @samp{-l 1}.  Na przykład, posortowanie każdego z plików katalogu
@file{bills}, z pozostawieniem wyników w plikach o tych samych nazwach
z doklejonym @file{.sorted}, można wykonać tak:

@example
find bills -type f | xargs -iXX sort -o XX.sorted XX
@end example

@noindent
Równoważne polecenie, z zastosowaniem @samp{find -exec}, to:

@example
find bills -type f -exec sort -o '@{@}.sorted' '@{@}' ';'
@end example
@end table

@node Pytanie
@subsection Pytanie

W celu zapytania użytkownika, czy wykonać polecenie dla pojedynczego pliku
stosuje się w @code{find} jednostkę @samp{-ok} zamiast @samp{-exec}:

@deffn Akcja -ok polecenie ;
Podobne do @samp{-exec} (@pxref{Pojedynczy plik}), ale najpierw pyta
(na standardowym wyjściu) użytkownika o zgodę.  Jeśli odpowiedź nie zaczyna
się od @samp{y} lub @samp{Y}, nie uruchamia polecenia i zwraca fałsz.
@end deffn

Do pytania użytkownika o potwierdzenie podczas przetwarzania wielu plików
pojedynczym poleceniem używa się niżej podanej opcji @code{xargs}.
Przy stosowaniu tej opcji może być przydatne sterowanie liczbą plików
przetwarzanych w każdym wywołaniu polecenia
(@pxref{Ograniczanie rozmiaru polecenia}).

@table @code
@item --interactive
@itemx -p
Prosi użytkownika o potwierdzenie uruchomienia każdego wiersza poleceń
i odczytuje z terminala linię tekstu.  Uruchamia polecenie tylko wtedy,
gdy odpowiedź zaczyna się od @samp{y} lub @samp{Y}.  Wymusza @samp{-t}.
@end table

@node Dodawanie testów
@section Dodawanie testów

Możliwe jest testowanie takich cech pliku, których nie sprawdzają żadne
z wbudowanych testów @code{find}.  W tym celu należy zastosować @code{xargs}
do uruchomienia programu, który odfiltruje listę plików wypisanych przez
@code{find}.  Jeśli to możliwe, warto wykorzystać wbudowane testy @code{find},
by skrócić listę, dzięki czemu program uruchamiany przez @code{xargs} będzie
miał mniej pracy.  Testy wbudowane w @code{find} będą prawdopodobnie działać
szybciej niż wykonywane przez inne programy.

Na przykład, oto sposób na wypisanie nazw wszystkich binariów z drzewa
katalogowego @file{/usr/local}, z których nie usunięto symboli (unstripped
binaries).  Testy wbudowane pozwalają na uniknięcie uruchamiania @code{file}
dla plików, które nie są zwykłymi plikami lub nie są wykonywalne.

@example
find /usr/local -type f -perm +a=x | xargs file | 
  grep 'not stripped' | cut -d: -f1
@end example

@noindent
Program @code{cut} usuwa wszystko po nazwie pliku z wyjścia utworzonego
przez @code{file}.

@c Idea from Martin Weitzel.
Jeżeli specjalny test chcemy umieścić gdzieś w środku wyrażenia @code{find},
można użyć @samp{-exec} do wywołania programu, który go wykona.  Ponieważ
wartością @samp{-exec} jest kod zakończenia wykonanego programu, wystarczy
napisać program (może to być skrypt powłoki), który testuje specjalną cechę
i kończy pracę ze statusem prawdy (zerowym) lub fałszu (niezerowym).  Warto
umieścić taki specjalny test @emph{po} testach wbudowanych, gdyż
zapoczątkowuje on nowy proces, czego można by uniknąć jeśli wynikiem testów
wbudowanych będzie fałsz.  Tę metodę należy stosować tylko wtedy, gdy
@code{xargs} nie jest wystarczająco elastyczne, gdyż uruchamianie jednego
czy więcej nowych procesów do przetestowania każdego pliku jest wolniejsze
niż użycie @code{xargs} do uruchomienia jednego procesu, który sprawdza wiele
plików.

Oto skrypt powłoki o nazwie @code{unstripped}, który sprawdza czy jego
argument jest plikiem binarnym bez usuniętych symboli:

@example
#!/bin/sh
file $1 | grep 'not stripped' > /dev/null
@end example

Opiera się na tym, że powłoka kończy pracę z kodem zakończenia ostatnio
wykonanego programu, w tym przypadku @code{grep}.  @code{grep} kończy pracę
z kodem prawdy jeśli znalazł jakieś dopasowania, a fałszu, gdy nie.
Poniżej podano przykład zastosowania tego skryptu, przy założeniu, że
umieszczono go w ścieżce wyszukiwania.  Wypisuje listę plików wykonywalnych
bez usuniętych symboli do pliku @file{sbins}, a z usuniętymi do @file{ubins}.

@example
find /usr/local -type f -perm +a=x \
  \( -exec unstripped '@{@}' \; -fprint ubins -o -fprint sbins \)
@end example

@node Typowe zadania
@chapter Typowe zadania

W poniższych sekcjach zawarto rozbudowane przykłady, które zarówno dają
pojęcie o możliwościach opisywanych programów, jak i pokazują, jak
rozwiązywać typowe problemy praktyczne.

@menu
* Przeglądanie i edycja::
* Archiwacja::
* Sprzątanie::
* Dziwne nazwy plików::
* Naprawianie praw::
* Segregowanie plików::
@end menu

@node Przeglądanie i edycja
@section Przeglądanie i edycja

Do przeglądania listy plików spełniających określone warunki, wystarczy
po prostu uruchomić program-przeglądarkę z nazwami plików jako argumentami.
Polecenie ujęte między znaki odwrotnych apostrofów powłoka zastępuje 
tworzonym przez nie wyjściem, zatem całe polecenie wygląda tak:

@example
less `find /usr/include -name '*.h' | xargs grep -l mode_t`
@end example

@noindent
Można zmieniać pliki podając nazwę edytora zamiast nazwy programu do
przeglądania.

@node Archiwacja
@section Archiwacja

Listę plików utworzoną przez @code{find} można przekazać do programu
archiwującego pliki.  Zarówno GNU @code{tar}, jak i @code{cpio} potrafią
czytać listy nazw plików ze standardowego wejścia -- albo rozdzielone
znakami null (bezpieczna metoda) albo odstępami (leniwa, ryzykowna metoda
domyślna).  Chcąc użyć nazw rozdzielonych przez null należy podać tym
programom opcję @samp{--null}.  Archiwum plików można zapisać w pliku,
na taśmie lub przesłać przez sieć do rozpakowania na innej maszynie.

Jednym z typowych zastosowań @code{find} do archiwacji plików jest przesyłanie
listy plików drzewa katalogowego do @code{cpio}.  Należy użyć @samp{-depth},
dzięki czemu jeśli katalog nie ma prawa zapisu dla swojego właściciela,
to zawartość będzie można mimo to odtworzyć z archiwum, gdyż prawa katalogu
są odtwarzane po jego zawartości.  Poniżej podano, jak to zrobić za pomocą
@code{cpio}.  Do archiwacji tylko określonych plików posłuży bardziej
skomplikowane wyrażenie @code{find}.

@example
find . -depth -print0 |
  cpio --create --null --format=crc --file=/dev/nrst0
@end example

To archiwum odtwarza się poleceniem:

@example
cpio --extract --null --make-dir --unconditional \
  --preserve --file=/dev/nrst0
@end example

A takimi poleceniami robi się to samo korzystając z @code{tar}:

@example
find . -depth -print0 |
  tar --create --null --files-from=- --file=/dev/nrst0

tar --extract --null --preserve-perm --same-owner \
  --file=/dev/nrst0
@end example

@c Idea from Rick Sladkey.
Przykład kopiowania katalogu z jednego komputera na inny:

@example
find . -depth -print0 | cpio -0o -Hnewc |
  rsh @var{inna-maszyna} "cd `pwd` && cpio -i0dum"
@end example

@node Sprzątanie
@section Sprzątanie

@c Idea from Jim Meyering.
W tej sekcji podano przykłady usuwania niepotrzebnych plików w rozmaitych
sytuacjach.
Oto polecenie do usuwania plików kopii zapasowych CVS tworzonych, gdy
aktualizacja wymaga scalania:

@example
find . -name '.#*' -print0 | xargs -0r rm -f
@end example

@c Idea from Franc,ois Pinard.
Służy do wysprzątania bałaganu w @file{/tmp}.  Można je umieścić w pliku
uruchamianym przez powłokę w momencie wylogowywania się (@file{.bash_logout},
@file{.logout} lub @file{.zlogout}, zależnie od używanej powłoki).

@example
find /tmp -user $LOGNAME -type f -print0 | xargs -0 -r rm -f
@end example

@c Idea from Noah Friedman.
Do usunięcia starych kopii zapasowych Emacsa i plików autozapisu można
wykorzystać polecenie podobne do podanego poniżej.
W tym przypadku szczególnie ważne jest użycie nazw plików
zakończonych przez null, gdyż pakiety Emacsa, takie jak VM mailer, często
tworzą pliki tymczasowe o nazwach zawierających spacje, jak np.
@file{#reply to David J. MacKenzie<1>#}.

@example
find ~ \( -name '*~' -o -name '#*#' \) -print0 |
  xargs --no-run-if-empty --null rm -vf
@end example

Usuwanie starych plików z @file{/tmp} zwykle wykonuje się wywołaniem
z @code{cron}:

@c Idea from Kaveh Ghazi.
@example
find /tmp /var/tmp -not -type d -mtime +3 -print0 |
  xargs --null --no-run-if-empty rm -f

find /tmp /var/tmp -depth -mindepth 1 -type d -empty -print0 |
  xargs --null --no-run-if-empty rmdir
@end example

Drugie polecenie @code{find} powyżej używa @samp{-depth}, więc czyści
@c  it cleans out empty directories depth-first
puste katalogi najpierw w głąb, mając nadzieję, że nadrzędne staną
się puste i również mogą być usunięte.  Korzysta z @samp{-mindepth}, by
uniknąć usunięcia samego @file{/tmp}, gdyby stało się całkiem puste.

@node Dziwne nazwy plików
@section Dziwne nazwy plików

@c Idea from:
@c From: tmatimar@isgtec.com (Ted Timar)
@c Newsgroups: comp.unix.questions,comp.unix.shell,comp.answers,news.answers
@c Subject: Unix - Frequently Asked Questions (2/7) [Frequent posting]
@c Subject: How do I remove a file with funny characters in the filename ?
@c Date: Thu Mar 18 17:16:55 EST 1993
@code{find} może pomóc w usunięciu lub przemianowaniu pliku o dziwnych
znakach w nazwie.  Czasem zawadzają ludziom pliki mające w nazwie znaki
@c   People are sometimes stymied by files
takie jak spacje, tabulacje, znaki sterujące czy znaki z ustawionym ósmym
bitem [tłum.: np. polskie litery].  Najprostszą metodą usunięcia takich
plików jest:

@example
rm -i @var{jakiś*wzorzec*pasujący*do*kłopotwliwego*pliku}
@end example

Dla każdego pliku pasującego do podanego wzorca @code{rm} pyta
o potwierdzenie usunięcia.  Jeżeli używa się jakiejś starej powłoki, takie
podejście może nie działać jeśli nazwa pliku zawiera znak z ustawionym ósmym
bitem -- powłoka może go obcinać.  Bardziej niezawodną metodą jest:

@example
find . -maxdepth 1 @var{testy} -ok rm '@{@}' \;
@end example

@noindent
gdzie @var{testy} w sposób jednoznaczny identyfikują plik.
Opcja @samp{-maxdepth 1} dla @code{find} zapobiega marnowaniu czasu
na szukanie pliku w podkatalogach.  Jeśli nie ma podkatalogów, można ją
pominąć.  Dobrym sposobem jednoznacznej identyfikacji kłopotliwego pliku
jest znalezienie jego numeru i-węzła; wystarczy użyć

@example
ls -i
@end example

Załóżmy, że mamy plik, którego nazwa zawiera znaki sterujące, i dowiedzieliśmy
się, że jego numer i-węzła to 12345.  To polecenie prosi o potwierdzenie
jego usunięcia:

@example
find . -maxdepth 1 -inum 12345 -ok rm -f '@{@}' \;
@end example

Czasem nie chcemy być pytani, na przykład dlatego, że nazwa pliku zawiera
dziwną sekwencję znaków, która wypisana, zamieszała by na ekranie.
Należy wówczas zamiast @samp{-ok} użyć @samp{-exec}.

Jeżeli zamiast tego chcemy zmienić nazwę pliku, wystarczy użyć @code{mv}
zamiast @code{rm}:

@example
find . -maxdepth 1 -inum 12345 -ok mv '@{@}' @var{nowa-nazwa-pliku} \;
@end example

@node Naprawianie praw
@section Naprawianie praw

Załóżmy, że chcemy się upewnić, iż każdy może zapisywać w katalogach pewnego
drzewa katalogowego.  Oto sposób na znalezienie katalogów nieposiadających
praw zapisu dla użytkownika lub grupy (albo obu), i poprawienie tego:

@example
find . -type d -not -perm -ug=w | xargs chmod ug+w
@end example

@noindent
Można też odwrócić te działania, jeśli chcemy być pewni, że katalogi
@emph{nie} będą miały prawa zapisu dla wszystkich.

@node Segregowanie plików
@section Segregowanie plików

@c Idea from:
@c From: martin@mwtech.UUCP (Martin Weitzel)
@c Newsgroups: comp.unix.wizards,comp.unix.questions
@c Subject: Advanced usage of 'find' (Re: Unix security automating script)
@c Date: 22 Mar 90 15:05:19 GMT
Do posegregowania zbioru plików na kilka grup w oparciu o różne kryteria
można zastosować operator przecinka, dający możliwość wykonania na plikach
kilku niezależnych od siebie testów.  Na przykład:

@example
find / -type d \( -perm -o=w -fprint allwrite , \
  -perm -o=x -fprint allexec \)

echo "Katalogi, do których może pisać każdy:"
cat allwrite
echo ""
echo "Katalogi z prawem przeszukiwania dla każdego:"
cat allexec
@end example

@code{find} musi wykonać tylko jedno badanie drzewa katalogowego (co jest
jedną z najbardziej czasochłonnych części jego pracy).

@node Bazy nazw plików
@chapter Bazy nazw plików

Wykorzystywane przez @code{locate} bazy nazw plików zawierają listy plików,
które istniały w ustalonych drzewach katalogowych podczas ostatniej
aktualizacji tych baz.  Nazwa pliku domyślnej bazy danych ustalana jest
podczas konfiguracji i instalacji @code{locate} i @code{updatedb}.
Częstość, z jaką aktualizowane są bazy, oraz katalogi, dla których zawierają
zapisy, zależą od tego, jak często i z jakimi argumentami uruchamiane jest
@code{updatedb}.

@menu
* Umiejscowienie baz::
* Formaty baz::
@end menu

@node Umiejscowienie baz
@section Umiejscowienie baz

Baz nazw plików może być wiele.  Użytkownicy mogą, posługując się zmienną
środowiskową lub opcją wiersza poleceń, wybrać, które z nich @code{locate}
ma przeszukiwać.  Administrator systemu wyznacza nazwę pliku domyślnej bazy,
częstość odświeżania baz oraz katalogi, dla których będą zawierać wpisy.
Bazy nazw plików są aktualizowane przez uruchomienie programu @code{updatedb},
zwykle nocą.

W środowiskach sieciowych, często ma sens budowanie bazy na korzeniu
każdego z systemów plików, zawierającej wpisy dla tego systemu.
@code{updatedb} jest wówczas dla każdego systemu plików uruchamiane
na tym serwerze, dla którego ten system leży na dysku lokalnym.
Zapobiega to zaśmiecaniu sieci.
Opcje @code{updatedb} pozwalające wybrać, dla których katalogów przechowują
wpisy poszczególne bazy:

@table @code
@item --localpaths='@var{ścieżka}@dots{}'
Niesieciowe katalogi, jakie mają być umieszczone w bazie.
Domyślnie @file{/}.

@item --netpaths='@var{ścieżka}@dots{}'
Sieciowe (NFS, AFS, RFS, itp.) katalogi, jakie mają być umieszczone w bazie.
Domyślnie - brak.

@item --prunepaths='@var{ścieżka}@dots{}'
Katalogi, jakie nie powinny być umieszczone w bazie, a byłyby bez tego
wykluczenia.
Domyślnie @file{/tmp /usr/tmp /var/tmp /afs}.

@item --output=@var{plikbazy}
Plik bazy danych, jaki ma zostać utworzony.
Wartość domyślna zależy od systemu, ale zwykle jest
to @file{/usr/local/var/locatedb}.

@item --netuser=@var{użytkownik}
Użytkownik, w imieniu którego, za pomocą @code{su}, mają być przeszukiwane
katalogi sieciowe.
Domyślnym jest @code{daemon}.
@end table

@node Formaty baz
@section Formaty baz

Bazy nazw plików zawierają listy plików, które istniały w ustalonych
drzewach katalogowych podczas ostatniej aktualizacji tych baz.  Format
baz nazw plików zmieniono począwszy od wersji 4.0 GNU @code{locate},
by umożliwić maszynom o różnym porządku bajtów wspólne użytkowanie baz.
Nowe GNU @code{locate} potrafi czytać zarówno stary, jak i nowy format.
Jednakże starsze wersje @code{locate} i @code{find} dają niepoprawne
wyniki jeśli poda im się bazy w nowym formacie.

@menu
* Nowy format baz::
* Przykładowa baza::
* Stary format baz::
@end menu

@node Nowy format baz
@subsection Nowy format baz

@code{updatedb} uruchamia program o nazwie @code{frcode}, kompresujący
początki (@dfn{front-compress}) listy nazw plików, co redukuje 4 do 5-krotnie
rozmiar bazy.  Kompresja początków (zwana też kodowaniem przyrostowym,
incremental encoding) działa następująco.

Pozycje w bazie danych stanowią posortowaną listę (bez uwzględniania różnic
w wielkości liter, dla wygody użytkowników).  Ponieważ lista jest posortowana,
należy się spodziewać, że każda pozycja będzie mieć wspólny przedrostek
(początkowy łańcuch) z pozycją poprzednią.  Każda pozycja bazy rozpoczyna się
bajtem licznika różnicy offsetu.  Jest to dodatkowa liczba znaków przedrostka
pochodzącego z poprzedniej pozycji bazy, jaka powinna być zastosowana ponad
liczbę znaków, jakiej używa poprzednia pozycja w stosunku do jej z kolei
poprzednika. (Licznik ten może być ujemny.) Po liczniku następuje zakończona
znakiem null końcówka ASCII -- część nazwy, która następuje po wspólnym
przedrostku.

Jeśli licznik różnicy offsetu jest większy niż możliwy do przechowania
w pojedynczym bajcie (+/\-127), to bajt posiada wartość 0x80, a licznik
następuje w słowie dwubajtowym, z bajtem starszym jako pierwszym (sieciowy
porządek bajtów).

Każda baza rozpoczyna się od sztucznej pozycji dla pliku o nazwie
@file{LOCATE02}. @code{locate} sprawdza ten zapis, by upewnić się, że plik
bazy posiada poprawny format; ignoruje te pozycję podczas przeszukiwań.

Bazy danych nie mogą być sklejane (łączone), nawet jeśli ze wszystkich baz
oprócz pierwszej usunięto pierwszą (sztuczną) pozycję. Wynika to stąd, że
licznik różnicy offsetu pierwszego wpisu pochodzącego z drugiej i kolejnych
baz będzie nieprawidłowy.

@node Przykładowa baza
@subsection Przykładowa baza

Przykładowe dane wejściowe do @code{frcode}:
@c ze znakami null zamienionymi na znaki nowej linii:

@example
/usr/src
/usr/src/cmd/aardvark.c
/usr/src/cmd/armadillo.c
/usr/tmp/zoo
@end example

Długość najdłuższego przedrostka wspólnego z poprzednią pozycją:

@example
0 /usr/src
8 /cmd/aardvark.c
14 rmadillo.c
5 tmp/zoo
@end example

Dane wynikowe z @code{frcode}, z końcowymi znakami null zamienionymi na znaki
nowej linii i zmianie liczby bajtów na postać drukowalną:

@example
0 LOCATE02
0 /usr/src
8 /cmd/aardvark.c
6 rmadillo.c
-9 tmp/zoo
@end example

(6 = 14 - 8, a -9 = 5 - 14)

@node Stary format baz
@subsection Stary format baz

Stary format baz jest używany przez uniksowe programy @code{locate}
i @code{find} oraz ich wcześniejsze wydania GNU.  @code{updatedb} tworzy
bazy w tym formacie, gdy otrzyma opcję @samp{--old-format}.

@code{updatedb} w celu utworzenia baz w starym formacie uruchamia programy
o nazwach @code{bigram} i @code{code}.  Stary format różni się od nowego
w następujący sposób.  W nowym formacie każda z pozycji zaczyna się od
licznika różnicy offsetu i kończy się bajtem null.  W starym formacie wartości
bajtu od 0 do 28 wskazują na licznik różnicy offsetu od -14 do 14.  Wartością
bajtu wskazującą, na to, że występuje po niej długi licznik jest 0x1e (30),
nie zaś 0x80. Długie liczniki przechowywane są w porządku bajtów hosta, który
niekoniecznie jest sieciowym porządkiem bajtów, oraz o rozmiarze słowa
integer hosta, zwykle mającym 4 znaki. One także reprezentują licznik
o 14 mniejszy od ich wartości. Wiersze bazy danych nie posiadają bajtu
ogranicznika; początek następnego wiersza wskazywany jest przez jego pierwszy
bajt o wartości <= 30.

Poza tym, zamiast rozpoczynania się fikcyjną pozycją, stary format bazy
rozpoczyna się od 256 bajtowej tablicy zawierającej 128 najczęściej
występujących dwuznaków (bigramów) w liście plików.  Dwuznak w tym kontekście
jest parą sąsiednich bajtów.  Bajty bazy danych posiadające ustawiony
starszy bit są indeksami (z wyczyszczonym starszym bitem) do tablicy dwuznaków.
Kodowanie dwuznaków i liczniki różnicy offsetu powodują, że bazy te są
o 20-25% mniejsze w porównaniu z nowym formatem.  Nie są jednak czysto
8-bitowe.  Każdy z bajtów nazwy pliku, przypadający na zakres używany dla
kodów specjalnych, zastępowany jest w bazie przez znak zapytania, co
nieprzypadkowo stanowi maskę powłoki dopasowującą pojedynczy znak.

@node Prawa pliku
@chapter Prawa pliku

@include perm.texi

@node Informator
@chapter Informator

Poniżej podano krótkie podsumowania składni wiersza poleceń dla programów
omówionych w podręczniku.

@menu
* Wywołanie find::
* Wywołanie locate::
* Wywołanie updatedb::
* Wywołanie xargs::
@end menu

@node Wywołanie find
@section Wywołanie @code{find}

@example
find @r{[}@var{plik}@dots{}@r{]} @r{[}@var{wyrażenie}@r{]}
@end example

@code{find} przeszukuje drzewo katalogowe zakorzenione w każdej z podanych
nazw @var{plików}, poprzez obliczenie dla każdego znalezionego w drzewie
pliku wartości @var{wyrażenia}.

@code{find} uważa pierwszy argument zaczynający się od @samp{-}, @samp{(},
@samp{)}, @samp{,} lub @samp{!} za początek wyrażenia.  Jakiekolwiek
występujące przed nim argumenty są ścieżkami do przeszukania, a wszelkie
po nim -- resztą wyrażenia.  jeżeli nie podano żadnych ścieżek, to używany
jest bieżący katalog.  Jeśli nie podano żadnego wyrażenia, stosowane jest
wyrażenie @samp{-print}.

@code{find} kończy pracę z kodem 0 jeśli wszystkie pliki przetworzono
pomyślnie, a większym od 0 jeśli wystąpi błąd.

@xref{Skorowidz jednostek}, gdzie znajduje się zestawienie wszystkich testów,
akcji i opcji, jakie może zawierać wyrażenie.

@code{find} rozpoznaje też dwie opcje do użytku administracyjnego:

@table @code
@item --help
Wypisuje zestawienie formatu argumentów wiersza poleceń i kończy pracę.

@item --version
Wypisuje numer wersji @code{find} i kończy pracę.
@end table

@node Wywołanie locate
@section Wywołanie @code{locate}

@example
locate @r{[}@var{opcja}@dots{}@r{]} @var{wzorzec}@dots{}
@end example

@table @code
@item --database=@var{ścieżka}
@itemx -d @var{ścieżka}
Zamiast przeszukiwania domyślnej bazy nazw plików, przeszukiwane będą bazy
ze @var{ścieżki}, która jest listą rozdzielonych dwukropkami nazw plików baz.
Do ustawienia listy przeszukiwanych plików baz można też użyć zmiennej
środowiskowej @code{LOCATE_PATH}.  Jeżeli zostaną zastosowane obie, to opcja
przesłania ustawienia zmiennej środowiskowej.

@item --help
Wypisuje zestawienie opcji @code{locate} i kończy pracę.

@item --version
Wypisuje numer wersji @code{locate} i kończy pracę.
@end table

@node Wywołanie updatedb
@section Wywołanie @code{updatedb}

@example
updatedb @r{[}@var{opcja}@dots{}@r{]}
@end example

@table @code
@item --localpaths='@var{ścieżka}@dots{}'
Niesieciowe katalogi, jakie mają być umieszczone w bazie.
Domyślnie @file{/}.

@item --netpaths='@var{ścieżka}@dots{}'
Sieciowe (NFS, AFS, RFS, itp.) katalogi, jakie mają być umieszczone w bazie.
Domyślnie - brak.

@item --prunepaths='@var{ścieżka}@dots{}'
Katalogi, jakie nie powinny być umieszczone w bazie, a byłyby bez tego
wykluczenia.
Domyślnie @file{/tmp /usr/tmp /var/tmp /afs}.

@item --output=@var{plikbazy}
Plik bazy danych, jaki ma zostać utworzony.
Wartość domyślna zależy od systemu, ale zwykle jest
to @file{/usr/local/var/locatedb}.

@item --netuser=@var{użytkownik}
Użytkownik, w imieniu którego, za pomocą @code{su}(1), mają być przeszukiwane
katalogi sieciowe.
Domyślnym jest @code{daemon}.
@end table

@node Wywołanie xargs
@section Wywołanie @code{xargs}

@example
xargs @r{[}@var{opcja}@dots{}@r{]} @r{[}@var{polecenie} @r{[}@var{argumenty-początkowe}@r{]}@r{]}
@end example

@code{xargs} kończy pracę z następującym kodem:

@table @asis
@item 0
jeśli pracę zakończono pomyślnie
@item 123
jeśli wywołanie któregoś polecenia zakończyło się kodem 1-125
@item 124
jeśli polecenie zakończyło pracę zwracając kod 255
@item 125
jeśli polecenie zostało zakończone przez sygnał
@item 126
jeśli nie można było uruchomić polecenia
@item 127
jeśli nie znaleziono polecenia
@item 1
jeśli wystąpił jakiś inny błąd.
@end table

@table @code
@item --null
@itemx -0
Nazwy plików wejściowych są zakończone znakiem o kodzie zero zamiast białym
znakiem, a cudzysłowy i odwrotne ukośniki nie mają specjalnego znaczenia
(wszystkie znaki są brane dosłownie). Wyłącza interpretację łańcucha końca
pliku, który jest traktowany jak każdy inny argument.

@item --eof@r{[}=@var{łańc-eof}@r{]}
@itemx -e@r{[}@var{łańc-eof}@r{]}
Nadaje łańcuchowi końca pliku wartość @var{łańc-eof}.  Jeżeli w linii
wejściowej pojawi się łańcuch końca pliku, to reszta wejścia jest ignorowana.
Jeżeli parametr @var{łańc-eof} nie zostanie podany, żaden łańcuch nie jest
interpretowany jako koniec pliku.  Jeżeli w ogóle nie podano tej opcji,
łańcuchem końca pliku jest @samp{_}.

@item --help
Wypisuje zestawienie opcji @code{xargs} i kończy pracę.

@item --replace@r{[}=@var{łańc-zastępowany}@r{]}
@itemx -i@r{[}@var{łańc-zastępowany}@r{]}
Zastępuje wystąpienie @var{łańc-zastępowany} w argumentach początkowych
nazwami odczytanymi ze standardowego wejścia.  Dodatkowo, niecytowane odstępy
nie kończą argumentów.  Jeżeli pominięto @var{łańc-zastępowany}, domyślnie
jest nim @samp{@{@}} (jak dla @samp{find -exec}).  Ta opcja wymusza @samp{-x}
i @samp{-l 1}.

@item --max-lines@r{[}=@var{max-linii}@r{]}
@itemx -l@r{[}@var{max-linii}@r{]}
Nakazuje używanie co najwyżej @var{max-linii} niepustych linii wejściowych
dla każdego wiersza poleceń.  Jeżeli pominięto @var{max-linii}, domyślnie 1.
Występujące na końcu odstępy powodują, że linia wejściowa będzie logicznie
kontynuowana w następnej, do celów zliczania linii.  Wymusza @samp{-x}.

@item --max-args=@var{max-arg}
@itemx -n @var{max-arg}
Używanie co najwyżej @var{max-arg} argumentów dla każdego wiersza poleceń.
Jeśli zostanie przekroczony rozmiar (zobacz opcja @samp{-s}),
@code{xargs} użyje mniej argumentów niż nakazano, chyba że podano opcję
@samp{-x}, wówczas zakończy pracę.

@item --interactive
@itemx -p
Prosi użytkownika o potwierdzenie uruchomienia każdego wiersza poleceń
i odczytuje z terminala linię tekstu.  Uruchamia polecenie tylko wtedy,
gdy odpowiedź zaczyna się od @samp{y} lub @samp{Y}.  Wymusza @samp{-t}.

@item --no-run-if-empty
@itemx -r
Jeżeli standardowe wejście nie zawiera żadnych znaków niepustych, to
dane polecenie nie zostanie uruchomione.  Domyślnie, polecenie jest
uruchamiane jednokrotnie nawet jeśli nie ma danych wejściowych.

@item --max-chars=@var{max-chars}
@itemx -s @var{max-chars}
Używanie co najwyżej @var{max-zn} znaków dla każdego wiersza poleceń,
łącznie z samym poleceniem i argumentami początkowymi oraz znakami null
kończącymi łańcuchy argumentów.

@item --verbose
@itemx -t
Wypisuje wiersz poleceń na standardowym wyjściu przed jego uruchomieniem.

@item --version
Wypisuje numer wersji @code{xargs} i kończy pracę.

@item --exit
@itemx -x
Kończy pracę jeśli przekroczono rozmiar (zobacz opcja @var{-s}).

@item --max-procs=@var{max-proc}
@itemx -P @var{max-proc}
Uruchamianie do @var{max-proc} procesów na raz; domyślnie 1.  Jeżeli
@var{max-proc} wynosi 0, to @code{xargs} będzie uruchamiać tyle procesów
jednocześnie, ile się da.
@end table

@node Skorowidz jednostek
@unnumbered Skorowidz jednostek @code{find}

Oto lista wszystkich jednostek (testów, akcji i opcji), z których mogą
się składać wyrażenia @code{find} do wyszukiwania plików.
@xref{Wyrażenia find}, gdzie dokładniej opisano wyrażenia.

@printindex fn

@contents
@bye

.\" {PTM/WK/2000-II}
.\" aktualizacja do 2.05a PTM/WK/2002-I
.\"
.\" MAN PAGE COMMENTS to
.\"
.\"	Chet Ramey
.\"	Information Network Services
.\"	Case Western Reserve University
.\"	chet@ins.CWRU.Edu
.\"
.\"	Last Change: Tue Nov 13 12:55:51 EST 2001
.\"
.\" bash_builtins, strip all but Built-Ins section
.if \n(zZ=1 .ig zZ
.if \n(zY=1 .ig zY
.TH BASH 1 "13 listopada 2001" "GNU Bash-2.05a"
.\"
.\" There's some problem with having a `@'
.\" in a tagged paragraph with the BSD man macros.
.\" It has to do with `@' appearing in the }1 macro.
.\" This is a problem on 4.3 BSD and Ultrix, but Sun
.\" appears to have fixed it.
.\" If you're seeing the characters
.\" `@u-3p' appearing before the lines reading
.\" `possible-hostname-completions
.\" and `complete-hostname' down in READLINE,
.\" then uncomment this redefinition.
.\"
.de }1
.ds ]X \&\\*(]B\\
.nr )E 0
.if !"\\$1"" .nr )I \\$1n
.}f
.ll \\n(LLu
.in \\n()Ru+\\n(INu+\\n()Iu
.ti \\n(INu
.ie !\\n()Iu+\\n()Ru-\w\\*(]Xu-3p \{\\*(]X
.br\}
.el \\*(]X\h|\\n()Iu+\\n()Ru\c
.}f
..
.\"
.\" File Name macro.  This used to be `.PN', for Path Name,
.\" but Sun doesn't seem to like that very much.
.\"
.de FN
\fI\|\\$1\|\fP
..
.SH NAZWA
bash \- GNU Bourne-Again SHell
.SH SKŁADNIA
.B bash
.RI [ opcje ]
.RI [ plik ]
.SH COPYRIGHT
.if n Bash is Copyright (C) 1989-2001 by the Free Software Foundation, Inc.
.if t Bash is Copyright \(co 1989-2001 by the Free Software Foundation, Inc.
.SH OPIS
.B Bash
jest zgodnym z \fBsh\fP interpreterem języka poleceń, wykonującym polecenia
ze standardowego wejścia bądź z pliku.
Włączono doń również przydatne cechy zaczerpnięte z powłoki \fIKorna\fP
i powłoki \fIC\fP (\fBksh\fP i \fBcsh\fP).
.PP
.B Bash
w zamierzeniu jest implementacją zgodną z POSIX-ową specyfikacją powłok
i narzędzi --
IEEE POSIX Shell and Tools specification (IEEE Working Group 1003\.2).
.SH OPCJE
Oprócz jednoznakowych opcji powłoki udokumentowanych w opisie wbudowanego
polecenia \fBset\fP, \fBbash\fP przy wywołaniu interpretuje poniższe opcje:
.PP
.PD 0
.TP 10
.BI \-c "\| łańcuch\^"
Jeśli występuje opcja
.BR \-c ,
to polecenia odczytywane są z
.IR łańcucha .
Jeżeli po
.I łańcuchu
istnieją argumenty, to są one przypisywane do argumentów pozycyjnych,
poczynając od
.BR $0 .
.TP
.B \-r
Jeżeli występuje opcja
.BR \-r ,
to powłoka staje się powłoką
.I okrojoną
(restricted). Zobacz poniżej
.SM
.BR "POWŁOKA OKROJONA" .
.TP
.B \-i
Jeżeli występuje opcja
.BR \-i ,
to powłoka jest
.IR interaktywna .
.TP
.B \-s
Jeśli występuje opcja
.B \-s
lub po przetworzeniu opcji nie pozostają żadne argumenty, to polecenia
odczytywane są ze standardowego wejścia. Opcja ta umożliwia na ustawienie
parametrów pozycyjnych podczas wywołania powłoki interaktywnej.
.TP
.B \-D
Na standardowym wyjściu wypisywana jest lista wszystkich podwójnie cytowanych
łańcuchów poprzedzonych znakiem \fB$\fP.
Są to łańcuchy będące przedmiotem tłumaczenia języka, gdy bieżącym ustawieniem
regionalnym (locale) nie jest \fBC\fP ani \fBPOSIX\fP.
Implikuje to opcję \fB\-n\fP; nie zostaną wykonane żadne polecenia.
.TP
.B [\-+]O [\fIopcja_shopt\fP]
\fIopcja_shopt\fP jest jedną z ocpji powłoki akceptowanych przez polecenie
wbudowane \fBshopt\fP (zobacz
.SM
.B "WBUDOWANE POLECENIA POWŁOKI"
poniżej).
Jeśli występuje \fIopcja_shopt\fP, to \fB\-O\fP nadaje wartość tej opcji, zaś
\fB+O\fP unieważnia ją.
Jeżeli nie podano \fIopcji_shopt\fP, to na standardowym wyjściu wypisywane są
nazwy i wartości opcji powłoki akceptowanych przez \fBshopt\fP.
Jeśli opcją wywołania jest \fB+O\fP, tworzone wyjście jest formatowane w taki
sposób, by można było wykorzystać je jako wejście.
.TP
.B \-\-
Zapis
.B \-\-
sygnalizuje koniec opcji i wyłącza dalsze ich przetwarzanie.
Argumenty występujące po
.B \-\-
traktowane są jako nazwy plików i argumenty. Argument
.B \-
jest równoważnikiem \fB\-\-\fP.
.PD
.PP
.B Bash
interpretuje także wiele opcji wieloznakowych.
Jeśli mają zostać rozpoznane, opcje te muszą pojawić się w wierszu poleceń
przed opcjami jednoznakowymi,
.PP
.PD 0
.TP
.B \-\-dump\-po\-strings
Równoważne \fB\-D\fP, ale wyjście jest w formacie pliku
GNU \fIgettext\fP \fBpo\fP (portable object).
.TP
.B \-\-dump\-strings
Równoważnik \fB\-D\fP.
.TP
.B \-\-help
Wyświetla na standardowym wyjściu komunikat o użytkowaniu i pomyślnie
kończy pracę.
.TP
.PD 0
\fB\-\-init\-file\fP \fIplik\fP
.TP
\fB\-\-rcfile\fP \fIplik\fP
.PD
Wykonuje polecenia z podanego
.I pliku
zamiast ze standardowego osobistego pliku inicjującego
.IR ~/.bashrc ,
jeśli powłoka jest interaktywna.
Zobacz
.SM
.B WYWOŁANIE
poniżej.
.TP
.B \-\-login
Sprawia, że
.B bash
działa tak, jakby został wywołany jako powłoka zgłoszeniowa (login shell).
Zobacz
.SM
.B WYWOŁANIE
poniżej.
.TP
.B \-\-noediting
Nie używa biblioteki GNU
.B readline
do odczytu wierszy poleceń w trybie interaktywnym.
.TP
.B \-\-noprofile
Nie odczytuje ani ogólnosystemowego pliku startowego
.FN /etc/profile
ani żadnego z osobistych plików inicjujących
.IR ~/.bash_profile ,
.IR ~/.bash_login
czy
.IR ~/.profile .
Domyślnie,
.B bash
czyta te pliki gdy jest wywołany jako powłoka zgłoszeniowa
(zobacz
.SM
.B WYWOŁANIE
poniżej).
.TP
.B \-\-norc
Nie odczytuje i nie wykonuje osobistego pliku inicjującego
.I ~/.bashrc
jeśli powłoka jest interaktywna. Opcja ta jest domyślnie włączona, jeżeli
powłokę wywołano jako
.BR sh .
.TP
.B \-\-posix
Zmienia zachowanie \fBbash\fP tam, gdzie operacja domyślna różni się od
standardu POSIX 1003.2 tak, by dostosować się do niego (\fItryb posix\fP).
.TP
.B \-\-restricted
Powłoka staje się okrojona (zobacz
.SM
.B "POWŁOKA OKROJONA"
poniżej).
.TP
.ig
.B \-\-rpm-requires
Tworzy listę plików wymaganych do uruchomienia skryptu powłoki. Implikuje
to '-n' i podlega tym samym ograniczeniom, co sprawdzanie błędów podczas
kompilacji;
Nachylone w lewo apostrofy (backticks), testy [] i obliczenia eval nie są
analizowane, więc pewne zależności mogą być pominięte.
..
.TP
.B \-\-verbose
Równoważnik opcji  \fB\-v\fP.
.TP
.B \-\-version
Pokazuje na standardowym wyjściu informację o wersji tego egzemplarza
.B bash
i pomyślnie kończy pracę.
.PD
.SH ARGUMENTY
Jeśli po przetworzeniu opcji pozostają jakieś argumenty, a nie podano ani opcji
.B \-c
ani
.BR \-s ,
to zakłada się, że pierwszy argument jest nazwą pliku zawierającego
polecenia powłoki.
Jeżeli
.B bash
został wywołany w taki sposób, to
.B $0
przypisywana jest nazwa pliku z poleceniami, a parametrom pozycyjnym pozostałe
argumenty.
.B Bash
odczytuje i wykonuje polecenia z tego pliku, a następnie kończy pracę.
Kod zakończenia \fBbash\fPa jest wówczas kodem zakończenia ostatniego
wykonanego polecenia skryptu.
Jeśli nie wykonano żadnego polecenia, to kod zakończenia wynosi 0.
.SH WYWOŁANIE
\fIPowłoka zgłoszeniowa\fP (login shell) to taka, w której pierwszym znakiem
zerowego argumentu jest
.BR \- ,
lub taka, którą uruchomiono z opcją
.BR \-\-login .
.PP
Powłoka \fIinteraktywna\fP to taka, którą uruchomiono bez argumentów
innych niż opcje i bez opcji
.BR \-c ;
zarówno jej standardowe wejście jak
i wyjście powiązane jest z terminalami (tak jak określiła to funkcja
.IR isatty (3)),
albo taka, którą uruchomiono z opcją
.BR \-i .
.SM
Jeśli
.B bash
jest interaktywny, to ustawiane jest
.B PS1
zaś
.B $\-
zawiera
.BR i ;
pozwala to skryptowi powłoki lub plikowi startowemu na sprawdzanie tego stanu.
.PP
Poniższe akapity opisują, jak
.B bash
wykonuje swoje pliki startowe.
Jeśli któryś z tych plików istnieje, ale nie może być odczytany, to
.B bash
zgłasza błąd.
Tyldy (~) w nazwach plików interpretowane są według reguł opisanych poniżej
w części
.B "Interpretacja tyld"
sekcji
.SM
.BR INTERPRETACJA .
.PP
Gdy
.B bash
wywoływany jest jako powłoka zgłoszeniowa lub jako powłoka nie-interaktywna
z opcją \fB\-\-login\fP, w pierwszej kolejności czyta i wykonuje polecenia
z pliku \fI/etc/profile\fP, jeśli takowy istnieje.
Po odczytaniu tego pliku, szuka \fI~/.bash_profile\fP,
\fI~/.bash_login\fP i \fI~/.profile\fP, w tej kolejności, po czym odczytuje
i wykonuje polecenia z pierwszego istniejącego i dającego się odczytać.
Można posłużyć się opcją
.B \-\-noprofile
podczas uruchamiania powłoki, by zakazać takiego zachowania.
.PP
Podczas kończenia pracy powłoki zgłoszeniowej,
.B bash
czyta i wykonuje polecenia z pliku \fI~/.bash_logout\fP, jeśli taki istnieje.
.PP
Jeżeli uruchamiana jest powłoka interaktywna nie będąca powłoką zgłoszeniową,
.B bash
czyta i wykonuje polecenia z \fI~/.bashrc\fP, jeśli taki plik istnieje.
Może to być zakazane za pomocą opcji
.BR \-\-norc .
Opcja \fB\-\-rcfile\fP \fIplik\fP wymusi
odczyt i wykonanie poleceń z \fIpliku\fP zamiast z \fI~/.bashrc\fP.
.PP
Jeśli
.B bash
startuje w trybie nie-interaktywnym, na przykład w celu uruchomienia
skryptu powłoki, to szuka w środowisku zmiennej
.SM
.BR BASH_ENV ,
interpretuje jej wartość, jeśli ją znalazł, i używa otrzymanej wartości
jako nazwy pliku do odczytania i wykonania.
.B Bash
zachowuje się tak, jakby były wykonane następujące polecenia:
.sp .5
.RS
.if t \f(CWif [ \-n "$BASH_ENV" ]; then . "$BASH_ENV"; fi\fP
.if n if [ \-n "$BASH_ENV" ]; then . "$BASH_ENV"; fi
.RE
.sp .5
ale do szukania nazwy pliku nie jest używana wartość zmiennej
.SM
.BR PATH .
.PP
Jeżeli
.B bash
wywołano pod nazwą
.BR sh ,
to próbuje on naśladować zachowanie startowe historycznych wersji
.B sh
tak ściśle jak to jest możliwe, przy równoczesnym spełnianiu standardu POSIX.
Wywołany jako powłoka interaktywna lub powłoka nie-interaktywna z opcją
\fB\-\-login\fP, usiłuje na początku odczytać i wykonać polecenia z
.I /etc/profile
i
.IR ~/.profile ,
w tej kolejności.
W celu zakazania tego zachowania można użyć opcji
.BR \-\-noprofile .
Wywołany jako powłoka interaktywna pod nazwą
.BR sh ,
.B bash
poszukuje zmiennej
.SM
.BR ENV ,
interpretuje jej wartość, jeśli jest zdefiniowana, i posługuje się otrzymaną
wartością jako nazwą pliku, który ma być odczytany i wykonany.
Ponieważ powłoka wywołana jako
.B sh
nie usiłuje czytać ani wykonywać poleceń z jakichkolwiek innych plików
startowych, opcja
.B \-\-rcfile
nie ma żadnych skutków.
Powłoka nie-interaktywna wywołana pod nazwą
.B sh
nie próbuje czytać żadnych plików startowych.
Wywołany jako
.BR sh ,
.B bash
wchodzi w tryb
.I posix
po odczycie plików startowych.
.PP
Gdy
.B bash
uruchomiony jest w trybie
.IR posix ,
jak z opcją
.B \-\-posix
wiersza poleceń, kieruje się standardem POSIX dla plików startowych.
W trybie tym, powłoka interaktywna interpretuje zmienną
.SM
.B ENV
a polecenia odczytywane i wykonywane są z pliku, którego nazwą jest
zinterpretowana wartość.
Nie są czytane inne pliki startowe.
.PP
.B Bash
usiłuje rozstrzygnąć, czy jest uruchomiony przez demona powłoki zdalnej,
zwykle \fIrshd\fP.
Jeżeli stwierdzi, że został uruchomiony przez \fIrshd\fP, to odczytuje
i wykonuje polecenia z \fI~/.bashrc\fP, jeśli plik ten istnieje i daje
się czytać. Nie będzie tego robił wywołany jako \fBsh\fP.
Można posłużyć się opcją
.BR \-\-norc ,
by zakazać tego zachowania oraz opcją
.BR \-\-rcfile ,
by wymusić czytanie innego pliku, ale \fIrshd\fP zazwyczaj nie wywołuje
powłoki z tymi opcjami ani nie pozwala na ich podanie.
.PP
Jeśli powłoka została uruchomiona z efektywnym id użytkownika (grupy) różnym
od id rzeczywistego, a nie podano opcji \fB\-p\fP, to nie są odczytywane
żadne pliki startowe, funkcje powłoki nie są dziedziczone ze środowiska,
zmienna
.SM
.BR SHELLOPTSP ,
jeśli jest taka w środowisku, jest ignorowana
a efektywny identyfikator użytkownika jest ustawiany na jego identyfikator
rzeczywisty.
Jeśli przy wywołaniu podano opcję \fB\-p\fP, to zachowanie startowe jest
takie samo, ale nie jest resetowany efektywny id użytkownika.
.SH DEFINICJE
.PP
W pozostałej części tego dokumentu używane są poniższe definicje.
.PD 0
.TP
.B odstęp
Spacja lub znak tabulacji.
.TP
.B słowo
Sekwencja znaków uważana przez powłokę za pojedynczą jednostkę. Znana też jako
.BR token .
.TP
.B nazwa
Jest to
.I słowo
składające się wyłącznie ze znaków alfanumerycznych i znaków podkreślenia,
i rozpoczynające się znakiem alfabetycznym lub podkreśleniem. Wspominane
również jako
.BR identyfikator .
.TP
.B metaznak
Znak, które, gdy nie jest cytowany, oddziela słowa. Jeden z poniższych:
.br
.RS
.PP
.if t \fB|  &  ;  (  )  <  >  spacja  tab\fP
.if n \fB|  & ; ( ) < > spacja tab\fP
.RE
.PP
.TP
.B operator sterujący
\fItoken\fP pełniący funkcję sterującą. Jest to jeden z poniższych symboli:
.RS
.PP
.if t \fB\(bv\(bv  &  &&  ;  ;;  (  )  |  <nowalinia>\fP
.if n \fB|| & && ; ;; ( ) | <nowalinia>\fP
.RE
.PD
.SH "SŁOWA ZASTRZEŻONE"
\fISłowa zastrzeżone\fP (reserved words) to takie, które mają dla powłoki
specjalne znaczenie.
Następujące słowa są rozpoznawane jako zastrzeżone, gdy nie są cytowane i
występują albo jako pierwsze słowo polecenia prostego (zobacz
.SM
.B GRAMATYKA POWŁOKI
poniżej) albo trzecie słowo poleceń
.B case
lub
.BR for ;
.if t .RS
.PP
.B
.if n ! case  do done elif else esac fi for function if in select then until while { } time [[ ]]
.if t !    case    do    done    elif    else    esac    fi    for    function    if    in    select    then    until    while    {    }    time    [[    ]]
.if t .RE
.RE
.SH "GRAMATYKA POWŁOKI"
.SS Polecenia proste
.PP
\fIPolecenie proste\fP jest sekwencją opcjonalnych przypisań zmiennych,
po której następują rozdzielane przez \fBodstęp\fP słowa i przekierowania,
a zakończoną \fIoperatorem sterującym\fP. Pierwsze słowo określa polecenie,
jakie ma zostać wykonane i jest przekazywane jako argument numer zero.
Pozostałe słowa są przekazywane jako argumenty wywoływanego polecenia.
.PP
Wartością zwracaną \fIpolecenia prostego\fP jest jego kod zakończenia lub
128+\fIn\^\fP jeżeli polecenie przerwane jest sygnałem
.IR n .
.SS Potoki
.PP
\fIPotok\fP jest sekwencją jednego lub więcej poleceń rozdzielonych znakiem
.BR | .
Formatem potoku jest:
.RS
.PP
[\fBtime\fP [\fB\-p\fP]] [ ! ] \fIpolecenie\fP [ \fB|\fP \fIpolecenie2\fP ... ]
.RE
.PP
Standardowe wyjście z
.I polecenia
połączone jest za pośrednictem potoku ze standardowym wejściem
.IR polecenia2 .
Połączenie to wykonywane jest przed możliwymi przekierowaniami podanymi dla
polecenia (zobacz poniżej
.SM
.BR PRZEKIEROWANIE .
.PP
Jeżeli potok poprzedza zastrzeżone słowo
.BR ! ,
to kod zakończenia takiego potoku jest negacją (NOT) kodu
zakończenia ostatniego polecenia. W przeciwnym wypadku, kodem potoku jest
kod zakończenia ostatniego polecenia.
Powłoka oczekuje na zakończenie (terminate) wszystkich poleceń w potoku
przed zwróceniem wartości.
.PP
Jeżeli potok jest poprzedzony słowem zastrzeżonym
.BR time ,
to po jego zakończeniu podawany jest czas wykonywania, jak
również czas użytkownika i czas systemu zużyty na wykonanie.
Opcja \fB\-p\fP zmienia format tworzonych wyników na
określony przez POSIX.
Do sformatowania łańcucha określającego, jak powinna być wyświetlana
informacja o czasach, można ustawić zmienną
.BR TIMEFORMAT ;
zobacz opis
.SM
.B TIMEFORMAT
w
.B "Zmienne powłoki"
poniżej.
.PP
Każde polecenie w potoku uruchamiane jest jako odrębny proces (tj. w
podpowłoce).
.SS Listy
.PP
\fILista\fP jest potokiem lub sekwencją kilku potoków rozdzielonych jednym
z operatorów
.BR ; ,
.BR & ,
.BR &&
lub
.BR \(bv\(bv ,
i opcjonalnie zakończoną jednym ze znaków
.BR ; ,
.BR &
lub
.BR <nowalinia> .
.PP
Spośród tych operatorów listowych,
.B &&
i
.B \(bv\(bv
mają ten sam priorytet, następujące po nich
.B ;
i
.BR &,
również mają równy między sobą priorytet.
.PP
Jeśli polecenie zakończone jest operatorem sterującym
.BR & ,
to powłoka wykonuje je w \fItle\fP (background) w podpowłoce.
Powłoka macierzysta nie oczekuje na zakończenie polecenia, a zwracany
kod wynosi 0. Polecenia oddzielane znakiem średnika
.B ;
wykonywane są sekwencyjnie; powłoka oczekuje na zakończenie
pracy przez każde z nich po kolei. Zwracany kod jest kodem zakończenia
ostatniego wykonanego polecenia.
.PP
Operatory sterujące
.B &&
i
.B \(bv\(bv
oznaczają odpowiednio listy AND i OR. Lista AND
ma postać
.RS
.PP \fIpolecenie1\fP \fB&&\fP \fIpolecenie2\fP
.RE
.PP
.I polecenie2
wykonywane jest wtedy, i tylko wtedy, gdy
.I polecenie1
zwraca zerowy kod zakończenia.
.PP
Lista OR ma postać
.RS
.PP
\fIpolecenie1\fP \fB\(bv\(bv\fP \fIpolecenie2\fP
.PP
.RE
.PP
.I polecenie2
jest wykonywane wtedy, i tylko wtedy, gdy
.I polecenie1
zwraca niezerowy kod zakończenia.
Kod zwracany przez listy AND i OR jest kodem zakończenia ostatniego
wykonanego polecenia listy.
.SS Polecenia złożone
.PP
\fIPolecenie złożone\fP (compound command) jest jednym z poniższych:
.TP
(\fIlista\fP)
\fIlista\fP wykonywana jest w podpowłoce. Przypisania zmiennych i polecenia
wbudowane wpływające na środowisko powłoki nie zachowują swoich skutków po
zakończeniu polecenia. Zwracanym kodem jest kod zakończenia \fIlisty\fP.
.TP
{ \fIlista\fP; }
\fIlista\fP jest po prostu wykonywana w bieżącym środowisku powłoki.
\fIlista\fP musi być zakończona znakiem nowej linii lub średnika. Nazywane
jest to \fIpoleceniem grupowania\fP. Zwracanym kodem jest kod zakończenia
\fIlisty\fP.
Należy pamiętać, że w przeciwieństwie do metaznaków \fB(\fP i \fB\)\fP,
\fB{\fP i \fB}\fP są \fIsłowami zastrzeżonymi\fP i aby zostały rozpoznane
muszą się pojawić tam, gdzie dozwolone jest użycie słów zastrzeżonych.
Ponieważ nie powodują podziału na słowa, muszą być oddzielone od \fIlisty\fP
za pomocą białego znaku.
.TP
((\fIwyrażenie\fP))
\fIwyrażenie\fP interpretowane jest zgodnie z zasadami opisanymi poniżej
w sekcji
.SM
.BR "OBLICZANIE WYRAŻEŃ ARYTMETYCZNYCH" .
Jeśli wartość wyrażenia jest niezerowa, to kodem zwracanym jest 0;
w przeciwnym razie kodem zwracaym jest 1. Jest to ściśle równoważne
konstrukcji \fBlet "\fIwyrażenie\fP"\fR.
.TP
\fB[[\fP \fIwyrażenie\fP \fB]]\fP
Zwraca kod 0 lub 1 w zależności od interpretacji wyrażenia warunkowego
\fIwyrażenie\fP. Wyrażenia złożone są ze składowych (primaries)
opisanych poniżej w opcji
.SM
.BR "WYRAŻENIA WARUNKOWE" .
Na słowach pomiędzy \fB[[\fP a \fB]]\fP nie są wykonywane rozwinięcia
nazw plików ani podział na słowa;
są natomiast wykonywane: interpretacja tyld, parametrów i zmiennych,
interpretacja wyrażeń arytmetycznych, podstawianie wyników poleceń,
podstawianie wyników procesów i usunięcia cytowań.
.if t .sp 0.5
.if n .sp 1
Gdy używane są operatory \fB==\fP i \fB!=\fP, łańcuch na prawo od operatora
traktowany jest jak wzorzec i dopasowywany zgodnie z zasadami opisanymi
poniżej w sekcji \fBDopasowywanie wzorców\fP. Wartością zwracaną jest 0
jeśli łańcuch odpowiednio pasuje lub nie pasuje do wzorca,
zaś 1 w przeciwnym przypadku.
Można zacytować dowolną część wzorca w celu wymuszenia dopasowywania jej
jako łańcucha.
.if t .sp 0.5
.if n .sp 1
Wyrażenia można łączyć przy pomocy następujących operatorów, wymienionych
w kolejności malejącego priorytetu:
.if t .sp 0.5
.if n .sp 1
.RS
.PD 0
.TP
.B ( \fIwyrażenie\fP )
Zwraca wartość \fIwyrażenia\fP.
Może służyć do unieważnienia zwykłej kolejności operatorów.
.TP
.B ! \fIwyrażenie\fP
Prawda jeżeli
.I wyrażenie
jest fałszywe.
.TP
\fIwyrażenie1\fP \fB&&\fP \fIwyrażenie2\fP
Prawda jeśli zarówno
.I wyrażenie1
jak i
.I wyrażenie2
są prawdziwe.
.TP
.if t \fIwyrażenie1\fP \fB\(bv\(bv\fP \fIwyrażenie2\fP
.if n \fIwyrażenie1\fP \fB||\fP \fIwyrażenie2\fP
Prawda jeśli choć jedno spośród
.I wyrażenie1
lub
.I wyrażenie2
jest prawdziwe.
.PD
.LP
Operatory \fB&&\fP i
.if t \fB\(bv\(bv\fP
.if n \fB||\fP
nie wykonują \fIwyrażenia2\fP jeżeli wartość \fIwyrażenia1\fP wystarcza do
określenia wartości, jaka zostanie zwrócona przez całe wyrażenie warunkowe.
.RE
.TP
\fBfor\fP \fInazwa\fP [ \fBin\fP \fIsłowo\fP ] ; \fBdo\fP \fIlista\fP ; \fBdone\fP
Interpretowane są słowa następujące po \fBin\fP, tworząc listę elementów.
Zmiennej \fInazwa\fP nadawana jest kolejno wartość każdego elementu tej
listy i każdorazowo wykonywana jest \fIlista\fP poleceń.  Jeżeli pominięto
\fBin\fP \fIsłowo\fP, to polecenie \fBfor\fP wykonuje \fIlistę\fP po jednym
razie dla każdego ustawionego parametru pozycyjnego
(zobacz
.SM
.B PARAMETRY
poniżej).
Zwracanym kodem jest kod zakończenia ostatniego wykonanego polecenia.
Jeśli interpretacja elementów następujących po \fBin\fP daje w wyniku pustą
listę, to nie są wykonywane żadne polecenia i zwracany jest kod 0.
.TP
\fBfor\fP (( \fIwyr1\fP ; \fIwyr2\fP ; \fIwyr3\fP )) ; \fBdo\fP \fIlista\fP ; \fBdone\fP
Na początku obliczane jest wyrażenie arytmetyczne \fIwyr1\fP, zgodnie
z zasadami opisanymi poniżej w
.SM
.BR "OBLICZANIE WYRAŻEŃ ARYTMETYCZNYCH" .
Następnie wielokrotnie obliczane jest \fIwyr2\fP, aż do osiągnięcia przez
nie wartości zero.
Każdorazowo gdy obliczone \fIwyr2\fP jest niezerowe, wykonywana jest
\fIlista\fP i obliczane jest wyrażenie arytmetyczne \fIwyr3\fP.
Jeśli pominięto któreś z wyrażeń, to zachowuje się ono tak, jakby przyjmowało
wartość 1.
Zwracanym kodem jest kod zakończenia ostatniego wykonanego polecenia
\fIlisty\fP, lub fałsz jeśli któreś z wyrażeń jest niepoprawne.
.TP
\fBselect\fP \fInazwa\fP [ \fBin\fP \fIsłowo\fP ] ; \fBdo\fP \fIlista\fP ; \fBdone\fP
Interpretowana jest lista słów następujących po \fBin\fP, tworząc listę
elementów. Zestaw zinterpretowanych słów wypisywany jest na standardowym wyjściu,
każde poprzedzone liczbą kolejną. Jeśli pominięto \fBin\fP \fIsłowo\fP, to
wypisywane są parametry pozycyjne (zobacz
.SM
.B PARAMETRY
poniżej).
Następnie wyświetlana jest zachęta
.B PS3
i czytany jest wiersz ze standardowego wejścia. Jeżeli wiersz składa się
z liczby odpowiadającej jednemu z wyświetlonych słów, to zmiennej
.I nazwa
przypisywana jest wartość tego słowa.
Jeśli wiersz jest pusty, słowa i zachęta wyświetlane są ponownie. Jeżeli
odczytano EOF, to polecenie kończy pracę. Każda inna wartość
powoduje, że
.I nazwie
zostanie przypisany łańcuch pusty. Odczytany wiersz zachowywany jest w
zmiennej
.BR REPLY .
.I lista
wykonywana jest po każdym wyborze, dopóki nie zostanie wykonane polecenie
.BR break .
Kodem zakończenia
.B select
jest kod zakończenia ostatniego wykonanego polecenia
.IR listy
lub zero jeśli nie wykonano żadnych poleceń.
.TP
\fBcase\fP \fIsłowo\fP \fBin\fP [ [(] \fIwzorzec\fP [ \fB|\fP \fIwzorzec\fP ] \
... ) \fIlista\fP ;; ] ... \fBesac\fP
Polecenie \fBcase\fP najpierw interpretuje \fIsłowo\fP i próbuje dopasować
uzyskany wynik każdego z \fIwzorców\fP po kolei, posługując się tymi samymi
regułami dopasowywania, co dla rozwijania nazw ścieżkowych (zobacz
.B Rozwijanie nazw ścieżkowych
poniżej). Gdy znalezione zostanie dopasowanie, wykonywana jest odpowiadająca
mu \fIlista\fP. Po pierwszym dopasowaniu nie są dokonywane próby dopasowania
pozostałych wzorców. Jeśli żaden ze wzorców nie pasuje do kodem zakończenia
jest zero. W przeciwnym razie jest równy kodowi zakończenia ostatniego
z wykonanych poleceń \fIlisty\fP.
.TP
\fBif\fP \fIlista\fP; \fBthen\fP \fIlista;\fP \
[ \fBelif\fP \fIlista\fP; \fBthen\fP \fIlista\fP; ] ... \
[ \fBelse\fP \fIlista\fP; ] \fBfi\fP
Wykonywana jest
.I lista
występująca po
.BR if .
Jeżeli jej kod zakończenia jest zerowy, to wykonywana jest \fIlista\fP
klauzuli \fBthen\fP. W przeciwnym wypadku, wykonywana jest \fIlista\fP
każdego \fBelif\fP po kolei; jeśli kod zakończenia którejś wynosi 0, to
wykonywana jest \fIlista\fP \fBthen\fP i polecenie jest kończone. Jeżeli
nie wystąpił żaden z powyższych przypadków, to wykonywana jest \fIlista\fP
występująca po klauzuli \fBelse\fP, jeśli takowa istnieje. Kodem
zakończenia jest kod ostatniego wykonanego polecenia listy lub zero jeśli
żaden z warunków nie okazał się prawdziwy.
.TP
.PD 0
\fBwhile\fP \fIlista\fP; \fBdo\fP \fIlista\fP; \fBdone\fP
.TP
\fBuntil\fP \fIlista\fP; \fBdo\fP \fIlista\fP; \fBdone\fP
.PD
Polecenie \fBwhile\fP powtarza wykonywanie \fIlisty\fP podanej po \fBdo\fP
tak długo, jak długo ostatnie polecenie \fIlisty\fP \fBwhile\fP zwraca
zerowy kod zakończenia.  Polecenie \fBuntil\fP działa identycznie jak
\fBwhile\fP, poza tym, że warunek jest zanegowany:
\fBdo\fP \fIlista\fP wykonywane jest tak długo, jak długo ostatnie polecenie
\fIlisty\fP \fBuntil\fP zwraca niezerowy kod zakończenia.
Kod zakończenia poleceń \fBwhile\fP i \fBuntil\fP jest równy kodowi
zakończenia ostatniego z wykonanych poleceń \fIlisty\fP \fBdo\fP lub zeru
jeśli żadne nie zostało wykonane.
.TP
[ \fBfunction\fP ] \fInazwa\fP () { \fIlista\fP; }
Definuje to funkcję nazwaną \fInazwa\fP. \fICiałem\fP funkcji jest
\fIlista\fP poleceń zawarta pomiędzy { i }. Lista ta jest wykonywana w za
każdym razem gdy \fInazwa\fP występuje jako polecenie proste. Kodem
zakończenia funkcji jest kod zakończenia ostatniego z wykonanych poleceń
jej ciała. (Zobacz
.SM
.B FUNKCJE
poniżej.)
.SH KOMENTARZE
W powłoce nie-interaktywnej lub w powłoce interaktywnej, w której włączono
opcję
.B interactive_comments
do opcji wbudowanych
.BR shopt (zobacz
.B "WBUDOWANE POLECENIA POWŁOKI"
poniżej) słowo rozpoczynające się od znaku
.B #
powoduje, że słowo to i wszystkie pozostałe znaki w tym wierszu będą
ignorowane. Powłoka interaktywna bez włączonej opcji
.B interactive_comments
nie pozwala na komentarze. Opcja
.B interactive_comments
jest domyślnie włączona w powłokach interaktywnych.
.SH CYTOWANIE
\fICytowanie\fP służy do usuwania specjalnego znaczenia dla powłoki pewnych
znaków lub słów. Cytowanie można stosować do wyłączania specjalnego
traktowania znaków specjalnych, zapobiegania rozpoznawaniu słów
zastrzeżonych jako takich oraz do zapobiegania podstawianiu parametrów.
.PP
Każdy z \fImetaznaków\fP podanych powyżej w
.SM
.B DEFINICJACH
posiada dla powłoki specjalne znaczenie i musi być cytowany, jeśli ma
oznaczać samego siebie.
.PP
Gdy używane są funkcje interpretacji historii poleceń, znak \fIinterpretacji
historii\fP, zwykle \fB!\fP, musi być cytowany, jeśli chce się uniknąć
interpretacji historii.
.PP
Istnieją trzy mechanizmy cytowania:
.IR "znak specjalny" (escape character) ,
apostrofy (pojedyncze cudzysłowy) i cudzysłowy zwykłe (podwójne).
.PP
Niecytowany odwrotny ukośnik (\fB\e\fP) jest
.IR "znakiem specjalnym" .
Chroni on przed interpretacją dosłowną wartość następującego po nim znaku,
z wyjątkiem <nowejlinii>. Jeśli pojawi się para \fB\e\fP<nowalinia> a sam
odwrotny ukośnik nie jest cytowany, to traktowana jest ona jak kontynuacja
wiersza (to znaczy, usuwana jest ze strumienia wejściowego i w efekcie
ignorowana).
.PP
Ujęcie znaków w apostrofy chroni dosłowne wartości każdego z nich. Apostrof
nie może pojawić się pomiędzy innymi apostrofami, nawet jeśli jest
poprzedzony odwrotnym ukośnikiem.
.PP
Ujęcie znaków w cudzysłowy chroni dosłowne wartości każdego z nich, za
wyjątkiem
.BR $ ,
.BR `
i
.BR \e .
Znaki
.B $
i
.B `
zachowują swe specjalne znaczenie wewnątrz cudzysłowów. Odwrotny ukośnik
zachowuje specjalne znaczenie tylko, gdy występuje po nim jeden z
poniższych znaków:
.BR $ ,
.BR ` ,
\^\fB"\fP\^,
.BR \e
lub
.BR <nowalinia> .
Cudzysłów może być cytowany wewnątrz cudzysłowów przez poprzedzenie go
odwrotnym ukośnikiem.
.PP
Parametry specjalne
.B *
i
.B @
posiadają specjalne znaczenie wewnątrz cudzysłowów (zobacz
.SM
.B PARAMETRY
poniżej).
.PP
Słowa postaci \fB$\fP'\fIłańcuch\fP' traktowane są specjalnie. Słowo
takie interpretowane jako \fIłańcuch\fP, w którym znaki poprzedzone
odwrotnym ukośnikiem zastępowane są według standardu ANSI C. Sekwencje
specjalne z odwrotnym ukośnikiem, jeśli występują, dekodowane są
następująco:
.RS
.PD 0
.TP
.B \ea
alarm (dzwonek)
.TP
.B \eb
backspace
.TP
.B \ee
znak escape
.TP
.B \ef
znak wysuwu strony (form feed)
.TP
.B \en
znak nowej linii (new line)
.TP
.B \er
powrót karetki (carriage return)
.TP
.B \et
tabulacja pozioma (horizontal tab)
.TP
.B \ev
tabulacja pionowa (vertical tab)
.TP
.B \e\e
odwrotny ukośnik (backslash)
.TP
.B \e'
apostrof
.TP
.B \e\fInnn\fP
ośmiobitowy znak, którego wartością jest ósemkowa liczba \fInnn\fP
(jedna do trzech cyfr)
.TP
.B \ex\fInnn\fP
ośmiobitowy znak, którego wartością jest szesnastkowa liczba \fInnn\fP
(jedna do trzech cyfr szesnastkowych)
.PD
.RE
.LP
Przetłumaczony wynik jest pojedynczo cytowany, tak jakby nie było znaku
dolara.
.PP
Ujęty w cudzysłowy łańcuch poprzedzony znakiem dolara (\fB$\fP) spowoduje,
że łańcuch zostanie zinterpretowany zgodnie z bieżącymi ustawieniami
regionalnymi (locale). Jeśli ustawione są one na \fBC\fP lub \fBPOSIX\fP,
to znak dolara jest ignorowany. Jeżeli łańcuch jest tłumaczony i zamieniany,
to zastąpienie jest podwójnie cytowane.
.SH PARAMETRY
.I Parametr
jest elementem przechowującym wartości. Może on być
.IR nazwą ,
liczbą lub jednym ze znaków specjalnych podanych poniżej w sekcji
.BR "Parametry specjalne" .
Dla celów powłoki
.I zmienna
jest parametrem oznaczanym przez
.IR nazwę .
Zmienna posiada \fIwartość\fP i zero lub więcej \fIatrybutów\fP.
Wartość atrybutom przypisuje się za pomocą polecenia wbudowanego
.B declare
(zobacz opis tego polecenia poniżej, w sekcji
.SM
.BR "WBUDOWANE POLECENIA POWŁOKI" ).
.PP
Parametr jest ustawiony jeśli przypisano mu wartość. Łańcuch pusty jest
poprawną wartością. Po ustawieniu zmiennej, może być ona
unieważniona wyłącznie przez użycie wbudowanego polecenia
.B unset
(zobacz poniżej
.SM
.BR "WBUDOWANE POLECENIA POWŁOKI" ).
.PP
Do
.I zmiennej
można wykonać przypisanie przy pomocy instrukcji postaci
.RS
.PP
\fInazwa\fP=[\fIwartość\fP]
.RE
.PP
Jeżeli nie podano
.IR wartości ,
to zmiennej przypisywany jest łańcuch pusty. Wszystkie
.I wartości
przechodzą przez interpretację tyld, podstawianie parametrów, interpretację
zmiennych, podstawianie wyników poleceń,
interpretację wyrażeń arytmetycznych i usuwanie cytowań (zobacz poniżej
.SM
.BR INTERPRETACJA ).
Jeżeli zmienna ma ustawiony atrybut
.BR integer " (całkowita),"
to
.I wartość
podlega interpretacjom wyrażeń arytmetycznych, nawet jeśli nie użyto
interpretacji $((...)). Zobacz poniżej
.BR "Interpretacja wyrażeń arytmetycznych" .
Nie jest wykonywane dzielenie na słowa, z wyjątkiem \fB"$@"\fP, jak
wyjaśniono to poniżej w sekcji
.BR "Parametry specjalne" .
Nie jest wykonywane rozwijanie nazw plików.
Instrukcje przypisania mogą się też pojawiać jako argumenty poleceń
wbudowanych
.BR declare ,
.BR typeset ,
.BR export ,
.BR readonly
i
.BR local .
.SS Parametry pozycyjne
.PP
.I Parametr pozycyjny
to parametr określany cyfrą lub cyframi, innymi niż pojedyncza cyfra 0.
Parametrom pozycyjnym nadawane są wartości argumentów powłoki (w czasie jej
wywołania). Wartości te mogą być ponownie nadawane przy pomocy wbudowanego
polecenia
.BR set .
Do parametrów pozycyjnych nie można wykonać przypisania przy pomocy
instrukcji przypisania.
Parametry pozycyjne są tymczasowo zastępowane podczas wykonywania funkcji
powłoki (zobacz poniżej
.SM
.BR FUNKCJE ).
Jeżeli interpretowany jest parametr pozycyjny określany więcej niż jedną
cyfrą, to musi być ujęty w nawiasy (zobacz poniżej
.BR INTERPRETACJA ).
.SS Parametry specjalne
Powłoka kilka parametrów traktuje specjalnie. Do parametrów tych można się
wyłącznie odwoływać; nie jest dozwolone przypisywanie im wartości.
.PP
.PD 0
.TP
.B *
Interpretowane jest jako parametry pozycyjne, począwszy od pierwszego. Gdy
interpretacja pojawia się wewnątrz cudzysłowów, to parametr ten
interpretowany jest jako pojedyncze słowo z wartościami każdego
z parametrów rozdzielonymi pierwszym znakiem zmiennej specjalnej
.SM
.BR IFS .
To znaczy, "\fB$*\fP" jest równoważne
"\fB$1\fP\fIc\fP\fB$2\fP\fIc\fP\fB...\fP", gdzie
.I c
jest pierwszym znakiem wartości zmiennej
.SM
.BR IFS .
Jeżeli
.SM
.B IFS
nie jest ustawione, to parametry oddzielane są spacjami.
Jeśli
.SM
.B IFS
jest łańcuchem pustym, to parametry są ze sobą połączone bez
rozdzielających je separatorów.
.TP
.B @
Interpretowane jako parametry pozycyjne, począwszy od pierwszego. Gdy
interpretacja pojawia się wewnątrz cudzysłowów, to każdy parametr
interpretowany jest jako odrębne słowo. To znaczy, "\fB$@\fP" jest
równoważne "\fB$1\fP" "\fB$2\fP" ...  Jeśli nie ma żadnych parametrów
pozycyjnych, "\fB$@\fP" i
.B $@
interpretowane są jako nic (tj. są usuwane).
.TP
.B #
Interpretowane jako liczba parametrów pozycyjnych, podana dziesiętnie.
.TP
.B ?
Interpretowane jako kod zakończenia ostatnio wykonanego potoku
pierwszoplanowego.
.TP
.B \-
Interpretowane jako bieżące flagi opcji, takie jakie zostały podane podczas
wywołania, ustawione przy pomocy wbudowanego polecenia
.B set
lub ustawione przez samą powłokę (tak jak opcja
.BR \-i ).
.TP
.B $
Interpretowany jest jako identyfikator procesu powłoki. W podpowłoce (),
interpretowany jest jako ID procesu bieżącej powłoki, nie zaś podpowłoki.
.TP
.B !
Interpretowany jako ID procesu ostatnio wykonywanego polecenia tła
(polecenia asynchronicznego).
.TP
.B 0
Interpretowany jako nazwa powłoki lub skryptu powłoki. Ustawiane jest to na
etapie inicjowania powłoki. Jeżeli
.B bash
wywoływany został z plikiem poleceń, to
.B $0
ustawiane jest na nazwę tego pliku. Jeśli
.B bash
został uruchomiony z opcją
.BR \-c ,
to
.B $0
jest ustawiane na pierwszy argument po łańcuchu, jaki ma zostać wywołany,
jeśli taki występuje. W przeciwnym wypadku, ustawiany jest na nazwę pliku
użytą do wywołania
.BR bash ,
jaką podaje argument zerowy.
.TP
.B _
Podczas uruchamiania powłoki, ustawiany na bezwzględną nazwę powłoki lub
wykonywanego skryptu powłoki przekazanego w liście argumentów.
Następnie, interpretowany jest jako ostatni argument poprzedniego polecenia,
po interpretacji.
Ustawiany również na pełną nazwę pliku każdego polecenia wykonanego
i umieszczonego w środowisku eksportowanym do tego polecenia.
Podczas sprawdzania poczty parametr ten przechowuje nazwę aktualnie
sprawdzanego pliku poczty.
.PD
.SS Zmienne powłoki
.PP
Powłoka ustawia następujące zmienne:
.PP
.PD 0
.TP
.B BASH
Interpretowane jako pełna nazwa pliku użyta do wywołania tego przebiegu
.BR
bash .
.TP
.B BASH_VERSINFO
Zmienna tablicowa tylko do odczytu, której elementy zawierają informacje
o wersji uruchomionego
.BR bash .
Wartości przypisane elementom tablicy są następujące:
.sp .5
.RS
.PD 0
.TP 24
.B BASH_VERSINFO[\fR0\fP]
Główny numer wersji, wydanie (\fIrelease\fP).
.TP
.B BASH_VERSINFO[\fR1\fP]
Poboczny numer wersji (\fIversion\fP).
.TP
.B BASH_VERSINFO[\fR2\fP]
Poziom łat (patch level).
.TP
.B BASH_VERSINFO[\fR3\fP]
Wersja kompilatu (build version).
.TP
.B BASH_VERSINFO[\fR4\fP]
Status wydania (np. \fIbeta1\fP).
.TP
.B BASH_VERSINFO[\fR5\fP]
Wartość \fBMACHTYPE\fP.
.PD
.RE
.TP
.B BASH_VERSION
Interpretowane jako łańcuch opisujący wersję uruchomionego
.BR bash .
.TP
.B COMP_CWORD
Indeks w \fB${COMP_WORDS}\fP słowa zawierającego bieżącą pozycję kursora.
Zmienna ta jest dostępna wyłącznie w funkcjach powłoki wywołanych
przez usługi programowalnego uzupełniania (zobacz poniżej \fBProgramowalne
uzupełnianie\fP).
.TP
.B COMP_LINE
Bieżący wiersz poleceń.
Ta zmienna jest dostępna tylko w funkcjach powłoki i poleceniach zewnętrznych
wywoływanych przez usługi programowalnego uzupełniania (zobacz poniżej
\fBProgramowalne uzupełnianie\fP).
.TP
.B COMP_POINT
Indeks bieżącej pozycji kursora względem początku bieżącego polecenia.
Jeżeli kursor jest na końcu bieżącego polecenia, to wartość tej zmiennej
jest równa \fB${#COMP_LINE}\fP.
Ta zmienna jest dostępna tylko w funkcjach powłoki i poleceniach zewnętrznych
wywoływanych przez usługi programowalnego uzupełniania (zobacz poniżej
\fBProgramowalne uzupełnianie\fP).
.TP
.B COMP_WORDS
Zmienna tablicowa (patrz \fBTablice\fP poniżej) składająca się z pojedynczych
słów z aktualnego wiersza poleceń.
Zmienna ta jest dostępna wyłącznie w funkcjach powłoki wywołanych
przez usługi programowalnego uzupełniania (zobacz poniżej \fBProgramowalne
uzupełnianie\fP).
.TP
.B DIRSTACK
Zmienna tablicowa (zobacz
.B Tablice
poniżej) zawierająca bieżącą zawartość stosu katalogów. Katalogi pojawiają
się na stosie w kolejności, w jakiej są wyświetlane przez wbudowane
.BR dirs .
Przypisanie do elementów tej zmienej tablicowej może posłużyć do zmiany
katalogów już występujących na stosie, ale do dodania i usunięcia katalogów
muszą być użyte wbudowane
.B pushd
i
.BR popd .
Przypisanie wartości tej zmiennej nie zmieni bieżącego katalogu.
Jeśli
.SM
.B DIRSTACK
jest unieważnione, to traci swe specjalne właściwości, nawet jeżeli jest
następnie ponownie ustawione.
.TP
.B EUID
Interpretowane jako efektywny identyfikator bieżącego użytkownika, inicjowane
przy uruchamianiu powłoki. Zmienna ta jest tylko do odczytu.
.TP
.B FUNCNAME
Nazwa aktualnie wykonywanej funkcji powłoki. Zmienna ta istnieje tylko
podczas wykonywania funkcji powłoki.
Próby przypisywania jej wartości nie odnoszą efektu i zwracają kod błędu.
Jeżeli
.SM
.B FUNCNAME
jest unieważnione, to traci swe specjalne właściwości, nawet jeżeli jest
następnie ponownie ustawione.
.TP
.B GROUPS
Zmienna tablicowa zawierająca listę grup, których członkiem jest bieżący
użytkownik. Próby przypisywania jej wartości nie odnoszą efektu i zwracają
kod błędu.
Jeżeli
.SM
.B GROUPS
jest unieważnione, to traci swe specjalne właściwości, nawet jeżeli jest
następnie ponownie ustawione.
.TP
.B HISTCMD
Licznik historii (indeks na liście historii poleceń) bieżącego polecenia.
Jeżeli
.SM
.B HISTCMD
jest unieważnione, to traci swe specjalne właściwości, nawet jeżeli jest
następnie ponownie ustawione.
.TP
.B HOSTNAME
Automatycznie ustawiane na nazwę aktualnego hosta.
.TP
.B HOSTTYPE
Automatycznie ustawiane na łańcuch unikalnie opisujący typ maszyny,
na której jest wykonywany
.BR bash .
Wartość domyślna zależy od systemu.
.TP
.B LINENO
Przy każdym odwołaniu do tego parametru powłoka zastępuje jego wartość
liczbą dziesiętną reprezentującą aktualny kolejny numer wiersza
(poczynając od 1) skryptu lub funkcji. Nie zapewnia się, by wartość ta
miała znaczenie poza skryptem bądź funkcją.
Jeśli
.SM
.B LINENO
jest unieważnione, to traci swe specjalne właściwości, nawet jeżeli jest
następnie ponownie ustawione.
.TP
.B MACHTYPE
Automatycznie ustawiane na łańcuch w pełni opisujący typ systemu,
na którym jest wykonywany
.BR bash ,
w standardowym formacie GNU \fIcpu-firma-system\fP.
Wartość domyślna zależy od systemu.
.TP
.B OLDPWD
Poprzedni katalog roboczy ustawiony poleceniem
.BR cd .
.TP
.B OPTARG
Wartość ostatniego, będącego opcją, argumentu przetworzonego przez
wbudowane polecenie
.B getopts
(zobacz poniżej
.SM
.BR "WBUDOWANE POLECENIA POWŁOKI" ).
.TP
.B OPTIND
Numer (indeks) następnego argumentu, jaki ma zostać przetworzony przez
wbudowane polecenie
.B getopts
(zobacz poniżej
.SM
.BR "WBUDOWANE POLECENIA POWŁOKI" ).
.TP
.B OSTYPE
Automatycznie ustawiane na łańcuch opisujący system operacyjny, w którym
jest wykonywany
.BR bash .
Wartość domyślna zależy od systemu.
.TP
.B PIPESTATUS
Zmienna tablicowa (zobacz
.B Tablice
poniżej) zwierająca listę kodów zakończenia z procesów w ostatnio
wykonywanym potoku pierwszoplanowym (który może zawierać pojedyncze
polecenie).
.TP
.B PPID
Identyfikator procesu macierzystego powłoki. Zmienna ta jest tylko do
odczytu.
.TP
.B PWD
Bieżący katalog roboczy, ustawiony poleceniem
.BR cd .
.TP
.B RANDOM
Za każdym razem, gdy następuje odwołanie do tego parametru, generowana jest
całkowita liczba losowa z zakresu od 0 do 32767. Sekwencję liczb losowych
można zainicjować przypisując wartość do
.SM
.BR RANDOM .
Jeżeli
.SM
.B RANDOM
jest unieważniona, to traci swe specjalne właściwości, nawet jeżeli jest
następnie ponownie ustawione.
.TP
.B REPLY
Ustawiona na wiersz wejścia odczytany wbudowanym poleceniem
.B read
jeśli nie podano żadnych jego argumentów.
.TP
.B SECONDS
Każdorazowo, gdy występuje odwołanie do tego parametru, zwracana jest
liczba sekund, jakie upłynęły od wywołania powłoki. Jeżeli do
.SM
.B SECONDS
zostanie przypisana wartość, to wartość zwracana przez kolejne odwołania
równa liczbie sekund od czasu przypisania plus przypisana wartość.
Jeżeli
.SM
.B SECONDS
jest unieważnione, to traci swe specjalne właściwości, nawet jeżeli jest
następnie ponownie ustawione.
.TP
.B SHELLOPTS
Lista, rozdzielonych dwukropkami, włączonych opcji powłoki. Każde słowo
listy jest poprawnym argumentem opcji
.B \-o
wbudowanego polecenia
.B set
(zobacz
.SM
.B "WBUDOWANE POLECENIA POWŁOKI"
poniżej). Opcje pojawiające się w
.SM
.B SHELLOPTS
to te, które są zgłaszane jako włączone
.RI ( on )
przez \fBset \-o\fP.
Jeśli zmienna ta istnieje w środowisku podczas uruchamiania
.BR bash,
to każda z opcji powłoki występująca na tej liście zostanie włączona przed
odczytem jakichkolwiek plików startowych.
Jest to zmienna tylko do odczytu.
.TP
.B SHLVL
Inkrementowana każdorazowo, gdy uruchamiane jest kolejne wystąpienie
.BR bash.
.TP
.B UID
Interpretowane jako identyfikator bieżącego użytkownika, inicjowane przy
uruchamianiu powłoki. Zmienna ta jest tylko do odczytu.
.PD
.PP
Poniższe zmienne są używane przez powłokę. W niektórych przypadkach
.B bash
przypisuje im domyślne wartości; przypadki te są odnotowane niżej.
.PP
.PD 0
.TP
.B BASH_ENV
Jeżeli parametr ten jest ustawiony podczas wykonywania przez \fBbash\fP
skryptu, to jego wartość interpretowana jest jako nazwa pliku zawierającego
polecenia do zainicjowania powłoki, jak w
.IR ~/.bashrc .
Wartość
.SM
.B BASH_ENV
podlega interpretacji parametrów, podstawianiu wyników poleceń
i interpretacjom wyrażeń arytmetycznych przed interpretacją jej jako nazwy
pliku.
Zmienna
.SM
.B PATH
nie jest używana do znalezienia pliku o powstałej w ten sposób nazwie.
.TP
.B CDPATH
Ścieżka wyszukiwania dla polecenia
.BR cd .
Jest to lista rozdzielonych dwukropkami katalogów, w których powłoka szuka
katalogów docelowych podanych przez polecenie
.BR cd .
Przykładową wartością jest ,,.:~:/usr''.
.TP
.B COLUMNS
Używana przez polecenie wbudowane \fBselect\fP do wyznaczenia szerokości
terminala przy wypisywaniu list wyboru. Ustawiana automatycznie po
otrzymaniu SIGWINCH.
.TP
.B COMPREPLY
Zmienna tablicowa, z której \fBbash\fP czyta możliwe uzupełnienia tworzone
przez funkcję powłoki wywołaną przez usługę programowalnego uzupełniania
(zobacz poniżej \fBProgramowalne uzupełnianie\fP).
.TP
.B FCEDIT
Domyślny edytor dla wbudowanego polecenia
.BR fc .
.TP
.B FIGNORE
Lista rozdzielonych dwukropkami przyrostków, jakie mają być ignorowane
podczas uzupełniania nazw plików (zobacz
.SM
.B READLINE
poniżej).
Nazwa pliku o przyrostku pasującym do jednej z pozycji
.SM
.B FIGNORE
wyłączana jest z listy dopasowanych nazw plików.
Przykładową wartością jest ,,.o:~''.
.TP
.B GLOBIGNORE
Lista rozdzielonych dwukropkami wzorców definiujących zestaw nazw plików,
jakie mają być ignorowane podczas rozwijania nazw plików.
Jeżeli plik pasujący do wzorca rozwijającego nazwę ścieżkową pasuje również
do któregoś z wzorców w
.SM
.BR GLOBIGNORE ,
to jest on usuwany z listy dopasowanych.
.TP
.B HISTCONTROL
Jeżeli posiada wartość
.IR ignorespace ,
to wiersze rozpoczynające się od znaku
.B spacji
nie są wprowadzane do listy historii. Jeśli posiada wartość
.IR ignoredups ,
to wiersze pasujące do ostatniego wiersza historii nie są wprowadzane.
Wartość
.I ignoreboth
łączy obie te możliwości.
Jeśli zmienna ta nie jest zdefiniowana lub ma wartość inną od powyższych,
to wszystkie wiersze przeczytane przez analizator składni zachowywane są
w liście historii, stosownie do wartości
.BR HISTIGNORE .
Funkcja tej zmiennej jest zastąpiona przez
.BR HISTIGNORE .
Drugi i kolejne wiersze złożonego polecenia wielowierszowego nie są
sprawdzane i są dodawane do historii bez względu na wartość
.TP
.B HISTFILE
Nazwa pliku, w którym zachowywana jest historia poleceń (zobacz
.SM
.B HISTORIA
poniżej).
Wartością domyślną jest \fI~/.bash_history\fP. Jeśli ustawienie tej
zmiennej zostanie skasowane, to historia poleceń nie będzie
zachowana po zakończeniu pracy powłoki interaktywnej.
.TP
.B HISTFILESIZE
Maksymalna liczba wierszy zawartych w pliku historii. Podczas
przypisywania wartości tej zmiennej, jeżeli jest to niezbędne, plik
historii jest obcinany tak, by nie zawierał więcej wierszy.
Domyślną wartością jest 500.
Plik historii jest także obcinany do tego rozmiaru po zapisaniu go
w czasie kończenia pracy przez powłokę interaktywną.
.TP
.B HISTIGNORE
Lista rozdzielonych dwukropkami wzorców służących do decydowania, jakie
wiersze poleceń powinny być zachowane w liście historii. Każdy z wzorców
zakotwiczony jest na początku wiersza i musi pasować do całego wiersza
(nie jest dodawane żadne niejawne `\fB*\fP'). Każdy z wzorców sprawdzany
jest z bieżącym wierszem po wykonaniu kontroli określonych przez
.BR HISTCONTROL .
Oprócz zwykłych znaków dopasowywania wzorców używanych przez powłokę,
`\fB&\fP' dopasowuje poprzedni wiersz historii. Literał `\fB&\fP' można
uzyskać poprzedzając go odwrotnym ukośnikiem;
odwrotny ukośnik jest usuwany przed próbą dopasowania.
Druga i kolejne wiersze złożonego polecenia wielowierszowego nie są
sprawdzane i są dodawane do historii bez względu na wartość
.BR HISTIGNORE .
.TP
.B HISTSIZE
Liczba poleceń do zapamiętania w historii poleceń (zobacz
.SM
.B HISTORIA
poniżej).
Wartością domyślną jest 500.
.TP
.B HOME
Katalog domowy bieżącego użytkownika; domyślny argument wbudowanego
polecenia \fBcp\fP.
Wartość tej zmiennej wykorzystywana jest też przy wykonywaniu interpretacji
tyld.
.TP
.B HOSTFILE
Zawiera nazwę pliku o tym samym formacie co
.FN /etc/hosts ,
który pownien być czytany, gdy powłoka potrzebuje uzupełnić nazwę hosta.
Listę możliwych uzupełnień można zmieniać podczas pracy powłoki.
Następnym razem, gdy wykonywana jest próba uzupełnienia nazwy hosta
.B bash
dodaje zawartość nowego pliku do już istniejącej listy.
Jeżeli
.SM
.B HOSTFILE
jest ustawione, ale nie posiada wartości, \fBbash\fP usiłuje uzyskać listę
możliwych uzupełnień nazw hostów czytając
.FN /etc/hosts .
Gdy
.SM
.B HOSTFILE
jest unieważniane, lista hostów jest czyszczona.
.TP
.B IFS
Wewnętrzny Separator Pól
.RI ( "Internal Field Separator" )
używany do podziału na słowa po interpretacjach i dzielenia wierszy na słowa
we wbudowanym poleceniu
.BR read .
Jego domyślną wartością jest ,,<spacja><tabulacja><nowalinia>''.
.TP
.B IGNOREEOF
Steruje działaniem powłoki interaktywnej przy otrzymaniu przez nią znaku
.SM
.B EOF
jako jedynego znaku wejścia. Jeżeli jest ustawiona, to jej wartość jest
liczbą kolejnych znaków
.SM
.B EOF
jakie muszą być wpisane jako pierwsze znaki wiersza wprowadzania przed
zakończeniem pracy przez
.BR bash .
Jeśli zmienna ta istnieje, ale nie zawiera wartości numerycznej lub nie ma
wartości, to wartością domyślną jest 10. Jeżeli nie istnieje, to
.SM
.B EOF
wskazuje powłoce koniec wprowadzanych danych.
.TP
.B INPUTRC
nazwa pliku startowego dla
.BR readline ,
unieważniająca domyślną
.FN ~/.inputrc
(zobacz
.SM
.B READLINE
poniżej).
.TP
.B LANG
Służy do wyznaczania kategorii locale dla wszystkich kategorii
nie wyszczególnionych przez zmienne rozpoczynające się od znaków \fBLC_\fP.
.TP
.B LC_ALL
Zmienna ta unieważnia wartość \fBLANG\fP i wszelkich innych zmiennych
\fBLC_\fP określających kategorie locale.
.TP
.B LC_COLLATE
Ta zmienna wyznacza kolejność (collation order) używaną przy sortowaniu
wyników rozwijania nazw plików, decyduje też o zachowaniu wielu wyrażeń,
klas równoważnych i sekwencje sortowania (collating sequences) w rozwijaniu
nazw plików i dopasowywaniu wzorców.
.TP
.B LC_CTYPE
Ta zmienna decyduje o interpretacji znaków i zachowaniu się klas znaków
wewnątrz rozwijania nazw plików i dopasowywania wzorców.
.TP
.B LC_MESSAGES
Ta zmienna decyduje o ustawieniu locale używanym do tłumaczenia
ujętych w cudzysłowy łańcuchów poprzedzonych znakiem \fB$\fP.
.TP
.B LC_NUMERIC
Ta zmienna określa kategorię locale używaną do formatowania liczb.
.TP
.B LINES
Używana przez polecenie wbudowane \fBselect\fP do wyznaczenia długości kolumn
przy wypisywaniu list wyboru.
Ustawiana automatycznie po otrzymaniu SIGWINCH.
.TP
.B MAIL
Jeżeli parametrowi temu jest przypisana nazwa pliku, a nie jest
ustawiona zmienna
.SM
.BR MAILPATH ,
to
.B bash
informuje użytkownika o nadejściu poczty do podanego pliku.
.TP
.B MAILCHECK
Określa jak często (w sekundach)
.B bash
sprawdza pocztę. Domyślnie jest to 60 sekund. Gdy nadchodzi pora
sprawdzenia poczty, powłoka wykonuje to przed wyświetleniem głównej
zachęty.
Jeśli zmienna ta nie jest ustawiona, to powłoka wyłącza sprawdzanie
poczty.
.TP
.B MAILPATH
Lista rozdzielonych dwukropkami nazw plików, w jakich ma być sprawdzana
poczta. Można podać komunikat, jaki ma zostać wyświetlony, gdy do danego
pliku przybędzie wiadomość pocztowa, przez oddzielenie nazwy pliku od
komunikatu znakiem '?'.
Użyte w tekście komunikatu, \fB$_\fP interpretowane jest jako nazwa bieżącego
pliku pocztowego.
Przykład:
.RS
.PP
\fBMAILPATH\fP='/var/mail/bfox?"You have mail":~/shell\-mail?"$_ has mail!"'
.PP
.B Bash
zapewnia tej zmiennej wartość domyślną, ale położenie plików
pocztowych użytkownika, jakim się posługuje zależy od systemu
(np. /var/mail/\fB$USER\fP).
.RE
.TP
.B OPTERR
Jeżeli ustawiono na wartość 1,
.B bash
wyświetla komunikaty o błędach generowanych przez wbudowane polecenie
.B getopts
(zobacz
.SM
.B WBUDOWANE POLECENIA POWŁOKI
poniżej).
.SM
.B OPTERR
inicjowane jest na 1 każdorazowo, gdy wywoływana jest powłoka lub
wykonywany jest skrypt powłoki.
.TP
.B PATH
Ścieżka wyszukiwania poleceń. Jest to lista rozdzielanych dwukropkami
katalogów, w których powłoka szuka poleceń (zobacz
.SM
.B WYKONYWANIE POLECEŃ
poniżej). Domyślna ścieżka zależy od systemu i ustawiana jest przez
administratora instalującego
.BR bash .
Powszechną wartością jest
.if t \f(CW/usr/gnu/bin:/usr/local/bin:/usr/ucb:/bin:/usr/bin:.\fP.
.if n ,,/usr/gnu/bin:/usr/local/bin:/usr/ucb:/bin:/usr/bin:.''.
.TP
.B POSIXLY_CORRECT
Jeśli podczas uruchamiania \fBbash\fP w środowisku istnieje ta zmienna,
to powłoka przed odczytem plików startowych wchodzi w \fItryb posix\fP,
tak jakby przy jej wywołaniu podano opcję
.BR \-\-posix .
Jeśli zmienna ta zostanie ustawiona podczas pracy powłoki, to \fBbash\fP
włącza \fItryb posix\fP, tak jakby zostało wykonane polecenie
.if t \f(CWset -o posix\fP.
.if n \fIset -o posix\fP.
.TP
.B PROMPT_COMMAND
Jeżeli jest ustawiona, to jej wartość jest wykonywana jwko polecenie przed
każdym wysłaniem zachęty głównej.
.TP
.B PS1
Wartość tego parametru jest interpretowana (zobacz poniżej
.SM
.BR ZACHĘTA )
i używana jako główny łańcuch zachęty. Jego wartością domyślną jest
,,\fB\es\-\ev\e$ \fP''.
.TP
.B PS2
Wartość tego parametru jest interpretowana jak
.B PS1
i używana jako wtórny (secondary) łańcuch zachęty. Domyślnie jest to
,,\fB> \fP''.
.TP
.B PS3
Wartość tego parametru służy jako zachęta w poleceniu
.B select
(zobacz powyżej
.SM
.BR "GRAMATYKA POWŁOKI" ).
.TP
.B PS4
Wartość tego parametru interpretowana jest jak
.B PS1
i wypisywana przed każdym poleceniem wyświetlanym przez
.B bash
podczas śledzenia wykonywania.
.\" during an execution trace.
Pierwszy znak
.SM
.BR PS4 ,
w razie potrzeby, powtarzany jest wielokrotnie, by wskazać wiele pozionów
zagnieżdżenia.
Domyślnie jest to ,,\fB+ \fP''.
.TP
.B TIMEFORMAT
Wartość tego parametru służy jako łańcuch formatu określającego, jak
powinna być wyświetlana informacja o czasach dla potoków poprzedzonych
słowem zastrzeżonym
.BR time .
Znak \fB%\fP rozpoczyna sekwencję specjalną, która jest interpretowana jako
wartość czasu lub inna informacja. Sekwencje specjalne i ich znaczenie są
następujące; nawiasy kwadratowe opisują części opcjonalne.
.sp .5
.RS
.PD 0
.TP 10
.B %%
Literał \fB%\fP.
.TP
.B %[\fIp\fP][l]R
Czas, jaki upłynął, w sekundach.
.TP
.B %[\fIp\fP][l]U
Liczba sekund, jakie CPU zużył w trybie użytkownika.
.TP
.B %[\fIp\fP][l]S
Liczba sekund, jakie CPU zużył w trybie systemowym.
.TP
.B %P
Procent wykorzystania CPU, liczony jako (%U + %S) / %R.
.PD
.RE
.IP
Opcjonalne \fIp\fP jest cyfrą określającą \fIdokładność\fP (precision),
liczbę cyfr ułamkowych po kropce dziesiętnej.
Wartość zero powoduje, że nie będzie wyświetlana ani kropka dziesiętna ani
część ułamkowa.
Mogą być podane co najwyżej trzy miejsca po kropce dziesiętnej;
wartości \fIp\fP większe od 3 zmieniane są na 3.
Jeżeli nie podano \fIp\fP, to używana jest wartość 3.
.IP
Opcjonalne \fIBl\fP określa dłuższy (longer) format wyników, zawierający
minuty, w postaci \fIMM\fPm\fISS\fP.\fIFF\fPs.
O tym, czy występuje ułamkowa część sekund decyduje wartość \fIp\fP.
.IP
Jeżeli zmienna ta nie jest ustawiona, to \fBbash\fP działa tak,
jakby miała ona wartość \fB$'\enreal\et%3lR\enuser\et%3lU\ensys\t%3lS'\fP.
Jeżeli jej wartością jest pusty łańcuch, to nie jest wyświetlana żadna
informacja o czasach (timing).
Podczas wyświetlania łańcucha formatu dodawany jest kończący znak
nowej linii.
.TP
.B TMOUT
Jeśli ustawione na wartość większą od zera, to wartość ta jest
interpretowana jako liczba sekund określającą czas, przez jaki powłoka
ma czekać na wprowadzenie danych po wyświetleniu zachęty.
.B Bash
kończy pracę po odczekaniu tego czasu jeśli dane nie pojawiły się.
.TP
.B auto_resume
Zmienna ta steruje sposobem interakcji powłoki z użytkownikiem
i sposobem kontroli zadań. Jeżeli jest ustawiona, to
jednowyrazowe polecenia proste bez przekierowań traktowane są jako
aspirujące do wznowienia istniejącego zatrzymanego zadania. Nie pozwala się
na żadną dwuznaczność; jeśli jest więcej niż jedno zadanie rozpoczynające
się od wpisanego łańcucha, wybierane jest zadanie, do którego ostatnio
sięgano.
.I Nazwa
zatrzymanego zadania, w tym kontekście, jest wierszem poleceń użytym do
jego uruchomienia.
Jeśli posiada wartość
.IR exact ,
to podany łańcuch musi pasować dokładnie do nazwy zatrzymanego zadania;
Jeśli jest ustawione na
.IR substring ,
to podany łańcuch powinien pasować do podłańcucha nazwy zatrzymanego
zadania.
Wartość
.I substring
zapewnia funkcjonalność analogiczną do identyfikatora zadania
.B %?
(zobacz
.SM
.B STEROWANIE ZADANIAMI
poniżej).
Jeśli ustawiono inną wartość, to podany łańcuch musi być przedrostkiem nazwy
zatrzymanego zadania; zapewnia to funkcjonalność analogiczną do
identyfikatora zadania
.BR % .
.TP
.B histchars
Dwa lub trzy znaki sterujące interpretacją historii i podziałem na leksemy
(zobacz poniżej
.SM
.BR "INTERPRETACJA HISTORII" ).
Pierwszy znak jest znakiem
.IR interpretacji historii ,
sygnalizującym początek interpretacji historii, zwykle `\fB!\fP'.
Drugi znak jest znakiem
.I szybkiego podstawiania ,
("quick substitution"), służącym jako skrót do powtórnego uruchamiania
poprzednio wprowadzonego polecenia, podstawiającym w poleceniu jeden łańcuch
za inny.
Domyślnym znakiem szybkiego podstawiania jest `\fB^\fP'.
Opcjonalny, trzeci znak jest znakiem wskazującym, że pozostała część
wiersza, w którym występuje on jako pierwszy znak słowa, jest komentarzem.
Zwykle znakiem tym jest `\fB#\fP'. Znak komentarza historii powoduje, że
dla pozostałych słów wiersza podstawianie historii jest pomijane.
Niekoniecznie powoduje to traktowanie reszty wiersza jako komentarza
przez analizator składni powłoki.
.PD
.SS Tablice
.B Bash
udostępnia zmienne tablicowe jednowymiarowe. Jako tablica może zostać użyta
dowolna zmienna; wbudowane
.B declare
jawnie explicitly zadeklaruje tablicę. Nie ma maksymalnego rozmiaru tablic,
ani wymagania, by wszystkie jej elementy były indeksowane czy przypisywane
w sposób ciągły. Tablice indeksowane są przy pomocy liczb całkowitych,
począwszy od zera.
.PP
tablica tworzona jest automatycznie jeśli wykonywane jest przypisanie
do jakiejś zmiennej przy pomocy składni
\fInazwa\fP[\fIwskaźnik\fP]=\fIwartość\fP.
.I Wskaźnik
tablicy traktowany jest jako wyrażenie arytmetyczne, które musi po
interpretacji dać liczbę większą bądź równą zero. Chcąc jawnie zadeklarować
tablicę, użyj
.B declare \-a \fInazwa\fP
(zobacz
.SM
.B WBUDOWANE POLECENIA POWŁOKI
poniżej).
.B declare \-a \fInazwa\fP[\fIwskaźnik\fP]
jest również akceptowane; \fIwskaźnik\fP jest wówczas ignorowany.
Dla zmiennej tablicowej można podać atrybuty przy pomocy wbudowanych
.B declare
i
.BR readonly .
Każdy z atrybutów stosowany jest do wszystkich elementów tablicy.
.PP
Przypisania do tablic wykonywane są przy pomocy przypisań złożonych postaci
\fInazwa\fP=\fB(\fPwartość\fI1\fP ... wartość\fIn\fP\fB)\fP, gdzie
każda \fIwartość\fP ma postać [\fIwskaźnik\fP]=\fIłańcuch\fP. Wymagany jest
wyłącznie \fIłańcuch\fP. Jeżeli podano opcjonalne nawiasy i wskaźnik, to
wartość jest przypisywana wskazanemu elementowi tablicy; w przeciwnym
wypadku wartość przypisywana jest elementowi o indeksie o jeden większym od
ostatniego elementu z przypisaną wartością. Indeksy ropoczynają się od
zera.
Składnia ta jest akceptowana także przez wbudowane
.BR declare .
Przypisania do pojedynczych elementów tablicy można wykonywać przy pomocy
składni
\fInazwa\fP[\fIwskaźnik\fP]=\fIwartość\fP wprowadzonej powyżej.
.PP
Do elementu tablicy można odwoływac się używając
${\fInazwa\fP[\fIwskaźnik\fP]}. Nawiasy są wymagane, by uniknąć konfliktów
z rozwijaniem nazw plików. Jeśli \fIwskaźnikiem\fP jest \fB@\fP lub \fB*\fP,
to powyższe słowo interpretowane jest jako wszystkie elementy \fInazwy\fP.
Wskaźniki te różnią się tylko wtedy, gdy słowo pojawia się w cudzysłowach.
Jeśli słowo ujęto w cudzysłowy, to ${\fInazwa\fP[*]} interpretowane jest
jako pojedyncze słowo o wartości wszystkich elementów tablicy rozdzielonych
pierwszym znakiem zmiennej specjalnej
.SM
.BR IFS ,
zaś ${\fInazwa\fP[@]} interpretuje każdy z elementów \fInazwa\fP jako
odrębne słowo. Jeśli brak jest elementów tablicy, to ${\fInazwa\fP[@]}
interpretowane jest jako nic. Jest to zachowanie analogiczne do
interpretacji parametrów specjalnych \fB*\fP i \fB@\fP (zobacz powyżej
.BR "Parametry specjalne" ).
${#\fInazwa\fP[\fIwskaźnik\fP]} interpretowane jest jako długość
${\fInazwa\fP[\fIwskaźnik\fP]}. Jeśli \fIwskaźnikiem\fP jest \fB*\fP lub
\fB@\fP, to interpretacją jest liczba elementów w tablicy.
Odwoływania się do zmiennej tablicowej bez podania wskaźnika jest
równoważne odwołaniu do elementu numer zero.
.PP
Do niszczenia tablic służy wbudowane polecenie
.BR unset .
\fBunset\fP \fInazwa\fP[\fIwskaźnik\fP] niszczy element tablicy o indeksie
\fIwskaźnik\fP.
\fBunset\fP \fInazwa\fP, gdzie \fInazwa\fP jest tablicą, lub
\fBunset\fP \fInazwa\fP[\fIwskaźnik\fP], gdzie \fIwskaźnikiem\fP jest
\fB*\fP lub \fB@\fP, usuwa całą tablicę.
.PP
Każde z wbudowanych
.BR declare ,
.B local
i
.B readonly
akceptuje opcję
.B \-a
do określania tablic. Wbudowane
.B read
akceptuje opcję
.B \-a
do przypisywania tablicy listy słów przeczytanych ze standardowego wejścia.
.B set
i
.B declare
wyświetlają wartości tablicowe w sposób umożliwiający ponowne ich użycie
w przypisaniach.
.SH INTERPRETACJA
Interpretacja wykonywana jest na wierszu poleceń po jego podziale na słowa.
Istnieje siedem rodzajów wykonywanych interpretacji:
.I interpretacja nawiasów
(brace expansion),
.I interpretacja tyld
(tilde expansion),
.I podstawianie parametrów i interpretacja zmiennych
(parameter and variable expansion),
.I podstawienie wyników poleceń
(command substitution),
.I interpretacja wyrażeń arytmetycznych
(arithmetic expansion),
.I podział na słowa
(word splitting)
i
.I rozwinięcie nazw plików
(pathname expansion).
.PP
Kolejność interpretacji: interpretacja nawiasów, interpretacja tyld,
podstawianie parametrów, interpretacja zmiennych i wyrażeń arytmetycznych
i podstawianie wyników poleceń (wykonywane od lewej do prawej),
podział na słowa i rozwijanie nazw ścieżkowych.
.PP
Na systemach potrafiących to obsłużyć, istnieje dodatkowa dostępna
interpretacja: \fIpodstawienie wyników procesów\fP (process substitution).
.PP
Tylko interpretacja nawiasów, dzielenie na słowa i rozwinięcie nazw plików
mogą zmienić liczbę słów interpretowanego wyrażenia; pozostałe interpretacje
rozwijają pojedyncze słowo w pojedyncze słowo.
Jedynymi wyjątkami są interpretacje
"\fB$@\fP" i "\fB${\fP\fInazwa\fP\fB[@]}\fP"
wyjaśnione powyżej (zobacz
.SM
.BR PARAMETRY ).
.SS Interpretacja nawiasów
.PP
.I "Interpretacja nawiasów"
jest mechanizmem, przez który mogą być generowane dowolne łańcuchy.
Mechanizm ten przypomina \fIrozwinięcia nazw plików\fP, ale generowane
nazwy plików nie muszą określać plików istniejących. Wzorce, mające
podlegać interpretacji nawiasów mają postać opcjonalnej
.IR preambuły ,
po której występują serie separowanych przecinkami łańcuchów pomiędzy parą
nawiasów klamrowych, po których następuje opcjonalny
.IR dopisek (postscript).
Preambuła stanowi przedrostek dla każdego z łańcuchów zawartych
w nawiasach, a dopisek dodawany jest do każdego łańcucha wynikowego,
przy interpretacji od lewej do prawej.
.PP
Interpretacja nawiasów może być zagnieżdżana. Wyniki każdego
zinterpretowanego łańcucha nie są sortowane; zachowywana jest kolejność od
lewej do prawej. Na przykład, a\fB{\fPd,c,b\fB}\fPe interpretowane
jest jako `ade ace abe'.
.PP
Interpretacja nawiasów wykonywana jest przed innymi rodzajami
interpretacji, a znaki o specjalnym znaczeniu dla innych interpretacji
są zachowywane w wyniku. Jest ściśle tekstowa.
.\"  It is strictly textual.
.B Bash
nie stosuje żadnej interpretacji składniowej do kontekstu interpretacji
czy tekstu pomiędzy nawiasami.
.PP
Poprawnie zbudowana interpretacja nawiasów musi zawierać niecytowany nawias
otwierający i zamykający i co najmniej jeden niecytowany przecinek.
Wszelkie niepoprawnie skonstruowane interpretacje nawiasów są pozostawiane
bez zmian.
\fB{\fP lub \fB,\fP można cytować przy pomocy odwrotnego ukośnika, co
chroni je przed przyjmowaniem za część wyrażenia nawiasowego.
Dla uniknięcia konfliktu z interpretacją parametrów, łańcuch \fB${\fP
nie jest traktowany jako spełniający warunki interpretacji nawiasów.
.PP
Typowym zastosowaniem tej konstrukcji jest skrót, wtedy gdy wspólny
przedrostek łańcuchów do utworzenia jest dłuższy niż w powyżej podanym
przykładzie, np.:
.RS
.PP
mkdir /usr/local/src/bash/{old,new,dist,bugs}
.RE
lub
.RS
chown root /usr/{ucb/{ex,edit},lib/{ex?.?*,how_ex}}
.RE
.PP
Interpretacja nawiasów wprowadza niewielką niezgodność z historycznymi
wersjami
.BR sh .
.B sh
nie traktuje nawiasów otwierających i zamykających w specjalny sposób gdy
pojawiają się one jako część słowa, i zachowuje je w wyniku.
W
.B bash
konsekwencją interpretacji nawiasów jest usuwanie nawiasów ze słów.
Na przykład, słowo wprowadzone do
.B sh
jako
.I plik{1,2}
pojawi się w identycznej postaci na wyjściu. To samo słowo po interpretacji
przez
.B bash
daje
.IR "plik1 plik2" .
Jeżeli pożądana jest ścisła zgodność z
.BR sh ,
uruchom
.B bash
z opcją
.B +B
lub wyłącz interpretację nawiasów przy pomocy opcji
.B +B
polecenia
.B set
(zobacz
.SM
.B WBUDOWANE POLECENIA POWŁOKI
poniżej).
.SS Interpretacja tyldy
.PP
Jeżeli słowo rozpoczyna się niecytowanym znakiem tyldy (`\fB~\fP'), to
wszystkie znaki poprzedzające pierwszy niecytowany ukośnik (lub wszystkie
znaki, gdy nie ma ukośnika) uważane są za \fIprzedrostek tyldy\fP
(tilde-prefix).
Jeżeli żaden ze znaków w przedrostku tyldy nie jest cytowany, to jego znaki
następujące po znaku tyldy traktowane są jako możliwa \fInazwa logowania\fP
(login name).
Jeśli ta nazwa logowania jest łańcuchem pustym, to tylda zastępowana jest
wartością parametru powłoki
.SM
.BR HOME .
Jeżeli
.SM
.B HOME
nie jest ustawione, to podstawiany jest za nie katalog domowy użytkownika
uruchamiającego powłokę.
W przeciwnym wypadku, przedrostek tyldy zastępowany jest katalogiem
domowym skojarzonym z określoną nazwą logowania.
.PP
Jeśli przedrostkiem tyldy jest `~+', to jest on zastępowany wartością
zmiennej
.SM
.BR PWD powłoki.
Jeśli przedrostkiem tyldy jest `~\-', to jest on zastępowany wartością
zmiennej powłoki
.SM
.BR OLDPWD ,
jeśli jest ona ustawiona.
Jeżeli występujące w przedrostku po tyldzie znaki składają się
z liczby \fIN\fP, opcjonalnie poprzedzonej przez `+' lub `\-', to
przedrostek tyldy zastępowany jest odpowiednim elementem stosu katalogów,
jaki zostałby wyświetlony przez wbudowane
.BR dirs ,
wywołane z przedrostkiem tyldy jako argumentem.
Jeżeli w przedrostku tyldy znaki występujące po tyldzie składają się z
liczby bez początkowego `+' lub `\-', to przyjmowane jest `+'.
.PP
Jeśli nazwa logowania jest nieprawidłowa lub interpretacja tyldy nie
powiodła się, to słowo z tyldą pozostaje niezmienione.
.PP
Każde z przypisań do zmiennej sprawdzane jest na obecność niecytowanych
przedrostków tyldy występujących bezpośrednio po
.B :
lub
.BR = .
W tych przypadkach również jest wykonywana jest interpretacja tyldy.
Na skutek tego, można posługiwać się nazwami plików z tyldami w przypisaniach
do
.SM
.BR PATH ,
.SM
.BR MAILPATH
i
.SM
.BR CDPATH ,
a powłoka przypisze zinterpretowaną wartość.
.SS Podstawianie parametrów
.PP
Znak `\fB$\fP' wprowadza podstawianie parametrów, podstawianie
wyników poleceń i interpretację wyrażeń arytmetycznych. Podlegająca
interpretacji nazwa parametru lub symbol mogą być ujęte w nawiasy klamrowe,
które są opcjonalne, ale służą do ochrony interpretowanej zmiennej przed
znakami, jakie występują bezpośrednio po niej, a które mogłyby zostać
zinterpretowane jako część nazwy.
.PP
Gdy używane są nawiasy, pasującym nawiasem kończącym jest pierwszy
`\fB}\fP', nie chroniony przez odwrotny ukośnik, nie znajdujący się
wewnątrz cytowanego łańcucha ani osadzony w wyrażeniu arytmetycznym,
podstawieniu wyniku polecenia czy podstawieniu parametru.
.PP
.PD 0
.TP
${\fIparametr\fP}
Podstawiana jest wartość \fIparametru\fP. Nawiasy wymagane są gdy
.I parametr
jest parametrem pozycyjnym o więcej niż jednej cyfrze,
lub gdy po
.I parametrze
występuje znak, który nie powinien być interpretowany jako część jego
nazwy.
.PD
.PP
Jeżeli pierwszym znakiem \fIparametru\fP jest wykrzyknik, to
rozpoczyna on poziom zagnieżdżenia zmiennej pośredniej.
.\" a level of variable indirection is introduced.
\fBBash\fP posługuje się wartością zmiennej utworzonej z reszty
\fIparametru\fP jako nazwą zmiennej; zmienna ta jest następnie
interpretowana a w dalszym podstawianiu używana jest otrzymana wartość
zamiast wartości samego \fIparametru\fP.
Znane jest to jako \fIinterpretacja pośrednia\fP (indirect expansion).
Wyjątkiem jest tu interpretacja ${!\fIprzedrostka\fP*} opisana poniżej.
.PP
W każdym z poniższych przypadków, \fIsłowo\fP podlega interpretacji tyldy,
podstawianiu parametrów, podstawianiu wyników poleceń i interpretacji
wyrażeń arytmetycznych. Gdy nie przeprowadza interpretacji podłańcuchów,
\fBbash\fP sprawdza czy parametr nie jest pusty lub nieustawiony;
.PP
.PD 0
.TP
${\fIparametr\fP\fB:\-\fP\fIsłowo\fP}
\fBUżywa wartości domyślnych\fP. Jeżeli
.I parametr
jest nieustawiony lub pusty, to podstawiane jest zinterpretowane
.IR słowo .
W przeciwnym razie, podstawiana jest wartość
.IR parametru .
.TP
${\fIparametr\fP\fB:=\fP\fIsłowo\fP}
\fBPrzypisuje wartości domyślne\fP.
Jeżeli
.I parametr
jest nieustawiony lub pusty, to jest mu
przypisywane zinterpretowane
.IR słowo .
Następnie podstawiana jest wartość
.IR parametru .
Nie można w ten sposób przypisywać wartości parametrom pozycyjnym ani
parametrom specjalnym.
.TP
${\fIparametr\fP\fB:?\fP\fIsłowo\fP}
\fBWyświetla błąd jeśli pusty lub nieustawiony\fP.
Jeżeli
.I parametr
jest nieustawiony lub pusty, to na standardowe wyjście błędów zapisywane
jest zinterpretowane
.I słowo
(lub komunikat o takim wyniku, jeśli brak
.IR słowa ).
Jeśli powłoka nie jest interaktywna, to kończy pracę.
W przeciwnym wypadku, podstawiana jest wartość \fIparametru\fP.
.TP
${\fIparametr\fP\fB:+\fP\fIsłowo\fP}
\fBUżywa wartości alternatywnej\fP.
Jeżeli
.I parametr
jest nieustawiony lub pusty, to nic nie jest podstawiane, w przeciwnym
razie podstawiane jest zinterpretowane
.IR słowo.
.TP
.PD 0
${\fIparametr\fP\fB:\fP\fIoffset\fP}
.TP
${\fIparametr\fP\fB:\fP\fIoffset\fP\fB:\fP\fIdługość\fP}
.PD
\fBInterpretacja podłańcuchów\fP.
Interpretuje co najwyżej \fIdługość\fP znaków \fIparametru\fP poczynając
od znaków określonych przez \fIoffset\fP. Jeśli pominięto \fIdługość\fP,
to interpretuje podłańcuch \fIparametru\fP poczynając od znaku określonego
przez \fIoffset\fP. \fIdługość\fP i \fIoffset\fP są wyrażeniami
arytmetycznymi (zobacz
.SM
.B
OBLICZANIE WYRAŻEŃ ARYTMETYCZNYCH
poniżej).
\fIdługość\fP musi dawać w wyniku liczbę większą bądź równą zero.
Jeżeli \fIoffset\fP daje w wyniku liczbę mniejszą od zera, to uzyskana
wartość używana jest jako offset liczony od końca wartości \fIparametru\fP.
Jeżeli \fIparametrem\fP jest \fB@\fP, to wynikiem jest \fIdługość\fP
parametrów pozycyjnych, począwszy od \fIoffset\fP. Jeżeli \fIparametr\fP
jest nazwą tablicy indeksowanej przez @ lub *, to wynikiem jest
\fIdługość\fP członków tablicy począwszy od ${\fIparametr\fP[\fIoffset\fP]}.
Indeksowanie podłańcucha rozpoczyna się od zera, chyba że używane są
parametry pozycyjne, wówczas indeksowanie zaczyna się od 1.
.TP
${\fB!\fP\fIprzedrostek\fP\fB*\fP}
rozwija się w listę nazw tych zmiennych, których nazwy rozpoczynają się
od \fIprzedrostka\fP, rozdzielonych od siebie pierwszym znakiem zmiennej
specjalnej
.SM
.BR IFS .
.TP
${\fB#\fP\fIparametr\fP}
Podstawiana jest długość, w znakach, wartości \fIparametru\fP.
Jeżeli
.I parametrem
jest
.B *
lub
.BR @ ,
wartość podstawiana jest liczbą parametrów pozycyjnych.
Jeżeli
.I parametr
jest nazwą tablicy o indeksowanej przez
.B *
lub
.BR @ ,
wartość podstawiana jest liczbą elementów tablicy.
.TP
.PD 0
${\fIparametr\fP\fB#\fP\fIsłowo\fP}
.TP
${\fIparametr\fP\fB##\fP\fIsłowo\fP}
.PD
.I słowo
jest interpretowane tworząc wzorzec, tak samo jak przy rozwijaniu nazw
plików. Jeżeli wzorzec pasuje do początku wartości
.IR parametru ,
to wynikiem interpretacji jest zinterpretowana wartość
.I parametru
z usuniętym najkrótszym (przypadek ,,\fB#\fP'') lub najdłuższym (przypadek
,,\fB##\fP'') pasującym wzorcem.
Jeżeli
.I parametrem
jest
.B @
lub
.BR * ,
to operacja usunięcia wzorca stosowana jest do każdego po kolei parametru
pozycyjnego, zaś wynikiem interpretacji jest powstała lista.
Jeśli
.I parametr
jest zmienną tablicową indeksowaną przez
.B @
lub
.BR * ,
operacja usuwania wzorca jest przeprowadzana po kolei na każdym elemencie
tablicy, zaś wynikiem interpretacji jest powstała lista.
.TP
.PD 0
${\fIparametr\fP\fB%\fP\fIsłowo\fP}
.TP
${\fIparametr\fP\fB%%\fP\fIsłowo\fP}
.PD
.I słowo
jest interpretowane tworząc wzorzec, tak samo jak przy rozwijaniu nazw
plików. Jeżeli wzorzec pasuje do końcowej części zinterpretowanego
.IR parametru ,
wynikiem interpretacji jest zinterpretowana  wartość
.I parametru
z usuniętym najkrótszym (przypadek ,,\fB%\fP'') lub najdłuższym (przypadek
,,\fB%%\fP'') pasującym wzorcem.
Jeżeli
.I parametrem
jest
.B @
lub
.BR * ,
to operacja usunięcia wzorca stosowana jest do każdego po kolei parametru
pozycyjnego, zaś wynikiem interpretacji jest powstała lista.
Jeśli
.I parametr
jest zmienną tablicową indeksowaną przez
.B @
lub
.BR * ,
operacja usuwania wzorca jest przeprowadzana po kolei na każdym elemencie
tablicy, zaś wynikiem interpretacji jest powstała lista.
.TP
.PD 0
${\fIparametr\fP\fB/\fP\fIwzorzec\fP\fB/\fP\fIłańcuch\fP}
.TP
${\fIparametr\fP\fB//\fP\fIwzorzec\fP\fB/\fP\fIłańcuch\fP}
.PD
\fIwzorzec\fP jest interpretowany tworząc wzorzec, tak samo jak przy
rozwijaniu nazw plików.
Interpretowany jest \fIparametr\fP, a najdłuższe dopasowanie \fIwzorca\fP
do jego zinterpretowanej wartości zastępowane jest
\fIłańcuchem\fP. W pierwszej postaci, zastępowane jest tylko pierwsze
dopasowanie. Druga postać powoduje zastąpienie wszystkich dopasowań
\fIwzorca\fP \fIłańcuchem\fP.
Jeżeli \fIwzorzec\fP rozpoczyna się od \fB#\fP, to musi pasować do początku
zinterpretowanej wartości \fIparametru\fP.
Jeżeli \fIpattern\fP rozpoczyna się od \fB%\fP, to musi pasować do końca
zinterpretowanej wartości \fIparametru\fP.
Jeśli \fIłańcuch\fP jest pusty, to dopasowania \fIwzorca\fP są usuwane
a \fB/\fP występujące po \fIwzorcu\fP można pominąć.
Jeżeli
.I parametrem
jest
.B @
lub
.BR * ,
to operacja podstawiania stosowana jest do każdego po kolei parametru
pozycyjnego, zaś wynikiem interpretacji jest powstała lista.
Jeśli
.I parametr
jest zmienną tablicową indeksowaną przez
.B @
lub
.BR * ,
operacja podstawiania jest przeprowadzana po kolei na każdym elemencie
tablicy, zaś wynikiem interpretacji jest powstała lista.
.SS Podstawianie wyników poleceń
.PP
\fIPodstawianie wyników poleceń\fP (command substitution) pozwala na
zastępowanie nazwy polecenia wyjściem (wynikiem) z jego działania.
Posiada dwie postaci:
.PP
.RS
.PP
\fB$(\fP\fIpolecenie\fP\|\fB)\fP
.RE
lub
.RS
\fB`\fP\fIpolecenie\fP\fB`\fP
.RE
.PP
.B Bash
wykonuje interpretację wykonując \fIpolecenie\fP i zastępując podstawiane
polecenie jego utworzonym standardowym wyjściem, z usuniętymi końcowymi
znakami nowej linii.
Zawarte wewnątrz wyniku znaki nowej linii nie są usuwane, ale nogą być
usunięte podczas podziału na słowa.
Podstawienie wyniku polecenia \fB$(cat \fIplik\fP)\fR można zastąpić
równoważnym, ale szybszym \fB$(< \fIplik\fP)\fR.
.PP
Gdy używane jest podstawianie w starym stylu, z użyciem odwrotnych
apostrofów, odwrotny ukośnik zachowuje swe znaczenie dosłowne, z wyjątkiem
przypadków, gdy poprzedza on
.BR $ ,
.BR `
lub
.BR \e .
Pierwszy odwrotny apostrof (`) nie poprzedzony odwrotnym ukośnikiem kończy
podstawianie wyniku polecenia.
Podczas posługiwania się postacią $(\^\fIpolecenie\fP\|), polecenie tworzą
wszystkie znaki pomiędzy nawiasami; żaden nie jest traktowany specjalnie.
.PP
Podstawianie wyników poleceń może być zagnieżdżane. W celu zagnieżdżenia
postaci z odwrotnymi apostrofami zabezpiecz wewnętrzne przed interpretacją
używając odwrotnych ukośników.
.PP
Jeżeli podstawianie pojawia się wewnątrz cudzysłowów, to na wynikach nie
jest przeprowadzany podział na słowa ani rozwinięcie nazw plików.
.SS Interpretacja wyrażeń arytmetycznych
.PP
Interpretacja wyrażeń arytmetycznych pozwala na obliczanie wyrażeń
arytmetycznych i podstawianie wyniku. Format interpretacji arytmetycznej:
.RS
.PP
\fB$((\fP\fIwyrażenie\fP\fB))\fP
.RE
.PP
.I wyrażenie
traktowane jest tak, jakby było ujęte w cudzysłowy, ale cudzysłów wewnątrz
nawiasów nie jest traktowany specjalnie.
Wszystkie tokeny w wyrażeniu podlegają interpretacji parametrów,
interpretacji łańcuchów, podstawianiu wyników poleceń i usuwaniu
cudzysłowów.
.PP
Interpretacja przeprowadzana jest zgodnie z zasadami podanymi poniżej w
sekcji
.SM
.BR "OBLICZENIA ARYTMETYCZNE" .
Jeżeli
.I wyrażenie
jest nieprawidłowe,
.B bash
wypisuje komunikat o niepowodzeniu i nie występuje żadne podstawienie.
.SS Podstawianie wyników procesów (Process substitution)
.PP
\fIPodstawianie wyników procesów\fP obsługiwane jest na systemach
obsługujących potoki nazwane (\fIFIFO\fP) lub metodę \fB/dev/fd\fP
nazywania otwartych plików.
Przybiera ono postać
\fB<(\fP\fIlista\^\fP\fB)\fP
lub
\fB>(\fP\fIlista\^\fP\fB)\fP.
Proces \fIlista\fP uruchamiany jest z wejściem i wyjściem podłączonym do
\fIFIFO\fP lub jakiegoś pliku w \fB/dev/fd\fP. W wyniku interpretacji
nazwa tego pliku przesyłana jest jako argument bieżącego polecenia.
Jeżeli posłużono się postacią \fB>(\fP\fIlista\^\fP\fB)\fP, zapis do pliku
będzie stanowić wejście dla \fIlisty\fP. Jeżeli posłużono się postacią
\fB<(\fP\fIlista\^\fP\fB)\fP, plik przekazany jako argument powinien zostać
odczytany w celu uzyskania wyjścia \fIlisty\fP.
.PP
Gdy jest to możliwe, podstawianie wyników procesu wykonywane jest
równocześnie z interpretacją parametrów i zmiennych, podstawianiem wyników
poleceń i interpretacją wyrażeń arytmetycznych.
.SS Podział na słowa
.PP
Powłoka przeszukuje wyniki interpretacji parametrów, podstawiania poleceń
i interpretacji wyrażeń arytmetycznych, które nie pojawiają się wewnątrz
cudzysłowów, w celu przeprowadzenia
.IR "podziału na słowa" .
.PP
Powłoka traktuje każdy znak
.SM
.B IFS
jak separator i w miejscu ich występowania dzieli na słowa wyniki innych
interpretacji.
Jeżeli
.SM
.B IFS
nie jest ustawione lub jego wartością jest dokładnie
.BR <spacja><tab><nowalinia> ,
wartość domyślna, to do podziału na słowa służy dowolna sekwencja znaków
.SM
.BR IFS .
Jeżeli
.SM
.B IFS
posiada wartość inną niż domyślna, to sekwencje białych znaków
.B spacji
i
.B tabulacji
są ignorowane na początku i końcu słowa, dopóki biały znak występuje
w wartości
.SM
.BR IFS
(biały znak
.SM
.BR IFS ).
Inne znaki w
.SM
.B IFS
nie będące białymi znakami
.SM
.BR IFS ,
łącznie z dowolnymi przyległymi białymi znakami
.SM
.BR IFS ,
ograniczają pole.
Sekwencja białych znaków
.SM
.B IFS
jest również traktowana jako ogranicznik.
Jeśli
.SM
.B IFS
jest łańcuchem pustym, to nie występuje podział na słowa.
.PP
Jawnie puste argumenty (\^\f3"\^"\fP lub \^\f3'\^'\fP\^) są pozostawiane.
Niecytowane argumenty puste niejawnie, wynikające z interpretacji
parametrów nie posiadających wartości, są usuwane.
Jeśli parametr bez wartości interpretowany jest wewnątrz cudzysłowów, to
wynikiem jest argument pusty i jest on zachowywany.
.\" retained
.PP
Zauważ, że jeśli nie występuje interpretacja, to nie jest również
wykonywany podział.
.SS Rozwijanie nazw plików (Pathname Expansion)
.PP
Po podziale na słowa, jeżeli nie ustawiona została opcja
.BR \-f ,
przegląda każde słowo w poszukiwaniu znaków
.BR * ,
.BR ?
i
.BR [ .
Jeśli pojawia się jeden z nich, to słowo uważane jest za
.I wzorzec
i zastępowane jest posortowaną alfabetycznie listą nazw plików pasujących
do wzorca.
Jeżeli nie znaleziono pasujących nazw a wyłączona jest opcja
.B nullglob
powłoki, słowo pozostawiane jest bez zmian.
Jeżeli
.B nullglob
jest włączone, a nie znaleziono dopasowań, to słowo jest usuwane.
Jeżeli włączona jest opcja
.B nocaseglob
powłoki, to dopasowywanie wzorca wykonywane jest bez zwracania uwagi
na wielkość liter.
Gdy do rozwinięcia nazw plików używa się wzorca, to znak
.B ,,.''
na początku nazwy lub bezpośrednio po ukośniku musi zostać dopasowany
dosłownie, chyba że ustawiono opcję
.B dotglob
powłoki.
Podczas dopasowywania nazwy pliku znak ukośnika musi zawsze zostać
dopasowany dosłownie.
W pozostałych przypadkach, kropka
.B ,,.''
nie jest traktowana specjalnie.
Zobacz poniżej opis
.B shopt
w sekcji
.SM
.BR "WBUDOWANE POLECENIA POWŁOKI" ,
gdzie znajdziesz omówienie opcji powłoki
.BR nocaseglob ,
.BR nullglob
i
.BR dotglob .
.PP
Do ograniczenia zestawu nazw plików pasujących do
.IR wzorca
można wykorzystać zmienną powłoki
.SM
.BR GLOBIGNORE .
Jeżeli
.SM
.B GLOBIGNORE
jest ustawione, każda z pasujących nazw plików pasująca również do jednego
ze wzorców w
.SM
.B GLOBIGNORE
jest usuwana z listy dopasowań.
Nazwy plików
.B ,,.''
i
.B ,,..''
są zawsze ignorowane, nawet gdy
.SM
.B GLOBIGNORE
jest ustawione. Jednakże, ustawienie
.SM
.B GLOBIGNORE
skutkuje włączeniem opcji
.BR dotglob ,
tak że będą dopasowywane wszystkie inne nazwy plików rozpoczynające się od
kropki.
W celu uzyskania starego zachowania, ignorującego nazwy zaczynające się
.BR ,,.'' ,
jednym ze wzorców w
.SM
.BR GLOBIGNORE
należy zrobić
.B ,,.*'' .
Opcja
.B dotglob
jest wyłączana, gdy kasowane jest
.SM
.B GLOBIGNORE .
.PP
\fBDopasowanie wzorca\fP
.PP
Każdy znak pojawiający się we wzorcu, różnych od specjalnych znaków wzorca
opisanych poniżej, dopasowuje sam siebie. Znak NUL nie może wystąpić we
wzorcu. Specjalne znaki wzorca muszą być cytowane, jeżeli mają być
dopasowane dosłownie.
.PP
Specjalne znaki wzorca mają następujące znaczenie:
.PP
.PD 0
.TP
.B *
Dopasowuje dowolny łańcuch, łącznie z łańcuchem pustym.
.TP
.B ?
Dopasowuje dowolny pojedynczy znak.
.TP
.B [...]
Dopasowuje jeden z ujętych w nawiasy kwadratowe znaków. Para znaków
rozdzielona myślnikiem opisuje
\fIwyrażenie zakresu\fP;
dopasowywany jest nim dowolny znak, który przy sortowaniu leksykalnym,
z zastosowaniem bieżącego ustawienia locale i zestawu znaków,
wypada między tymi dwoma znakami, włącznie z nimi.
Jeżeli pierwszym znakiem występującym po
.B [
jest
.B !
lub
.BR ^ ,
to dopasowywany jest dowolny znak nie zawarty w nawiasach.
Kolejność sortowania znaków w wyrażeniach zakresu określona jest przez
bieżące ustawienie locale i wartość zmiennej środowiskowej \fBLC_COLLATE\fP,
jeśli istnieje.
Znak
.B \-
można dopasować włączając go jako pierwszy lub ostatni ze znaków zestawu.
Znak
.B ]
można dopasować włączając go jako pierwszy znak zestawu.
.br
.if t .sp 0.5
.if n .sp 1
Wewnątrz
.B [
i
.BR ] ,
można podawać \fIklasy znaków\fP (character classes), używając składni
\fB[:\fP\fIklasa\fP\fB:]\fP, gdzie \fIklasa\fP jest jedną z poniższych klas
zdefiniowanych w standardzie POSIX.2:
.PP
.RS
.B
.if n alnum alpha ascii blank cntrl digit graph lower print punct space upper xdigit
.if t alnum   alpha   ascii   blank   cntrl   digit   graph   lower   print   punct   space   upper   xdigit
.br
Klasa znaków dopasowuje dowolny znak należący do tej klasy.
.br
.if t .sp 0.5
.if n .sp 1
Wewnątrz
.B [
i
.BR ] ,
można podać \fIklasę równoważności\fR, używając składni
\fB[=\fP\fIz\fP\fB=]\fP, która dopasowuje wszystkie znaki o tej samej
wadze sortowania (zdefiniowaną w bieżącym ustawieniu locale) co znak
\fIz\fP.
.br
.if t .sp 0.5
.if n .sp 1
Wewnątrz
.B [
i
.BR ] ,
składnia \fB[.\fP\fIsymbol\fP\fB.]\fP dopasowuje symbol sortowania
(collating symbol) \fIsymbol\fP.
.RE
.PD
.PP
Jeżeli przy pomocy wbudowanego \fBshopt\fP włączono opcję \fBextglob\fP,
to rozpoznawane jest kilka rozszerzonych operatorów dopasowania wzorców.
W poniższym opisie, \fIlista-wzorców\fP jest listą złożoną z jednego lub
więcej wzorców rozdzielonych znakiem \fB|\fP.
Wzorce złożone można konstruować przy pomocy jednego lub więcej poniższych
pod-wzorców:
.sp 1
.PD 0
.RS
.TP
\fB?(\fP\^\fIlista-wzorców\^\fP\fB)\fP
Dopasowuje zero lub jedno wystąpienie zadanych wzorców
.TP
\fB*(\fP\^\fIlista-wzorców\^\fP\fB)\fP
Dopasowuje zero lub więcej wystąpień zadanych wzorców
.TP
\fB+(\fP\^\fIlista-wzorców\^\fP\fB)\fP
Dopasowuje jedno lub więcej wystąpień zadanych wzorców
.TP
\fB@(\fP\^\fIlista-wzorców\^\fP\fB)\fP
Dopasowuje dokładnie jeden z zadanych wzorców
.TP
\fB!(\fP\^\fIlista-wzorców\^\fP\fB)\fP
Dopasowuje cokolwiek prócz jednego z zadanych wzorców
.RE
.PD
.SS Usunięcie cytowań
.PP
Po poprzednich interpretacjach, wszystkie niecytowane wystąpienia znaków
.BR \e ,
.BR '
i \^\f3"\fP\^, które nie wynikły z jednej z powyższych interpretacji, są
usuwane.
.SH PRZEKIEROWANIE
Przed wykonaniem polecenia, jego wejście i wyjście mogą zostać
.I przekierowane
przy pomocy specjalnej notacji interpretowanej przez powłokę.
Przekierowań można też używać do otwierania i zamykania plików dla
środowiska wykonywania bieżącej powłoki. Poniższe operatory przekierowania
mogą występować przed lub pojawiać się gdziekolwiek wewnątrz
.I polecenia prostego
lub występować po
.IR poleceniu.
Przekierowania przetwarzane są w kolejności występowania, od lewej
do prawej.
.PP
W poniższych opisach, jeśli pominięto deskryptor pliku, a pierwszym znakiem
operatora przekierowania  jest
.BR < ,
przekierowanie dotyczy standardowego wejścia (deskryptor pliku 0).
Jeżeli pierwszym znakiem operatora przekierowania jest
.BR > ,
przekierowanie dotyczy standardowego wyjścia (deskryptor pliku 1).
.PP
Słowo następujące do operatorze przekierowania w poniższych opisach
podlega, chyba że podano inaczej, interpretacji nawiasów, interpretacji
tyldy, interpretacji parametrów, podstawianiu wyników poleceń,
interpretacji wyrażeń arytmetycznych, usuwaniu cytowań, rozwijaniu nazw
plików i podziałowi na słowa.
Jeśli zinterpretowane zostanie jako więcej niż jedno słowo, to
.B bash
zgłosi błąd.
.PP
Zauważ, że kolejność przekierowań jest znacząca. Na przykład, polecenie
.RS
.PP
ls \fB>\fP dirlist 2\fB>&\fP1
.RE
.PP
kieruje zarówno standardowe wyjście jak i wyjście diagnostyczne (stderr)
do pliku
.IR dirlist ,
podczas gdy polecenie
.RS
.PP
ls 2\fB>&\fP1 \fB>\fP dirlist
.RE
.PP
kieruje tylko standardowe wyjście do pliku
.IR dirlist ,
gdyż wyjście błędów zostało zduplikowane jako standardowe wyjście przed
przekierowaniem wyjścia do
.IR dirlist .
.PP
\fBBash\fP obsługuje kilka nazw plików w sposób specjalny gdy są one
użyte w przekierowaniach. Opisano to w poniższej tablicy:
.RS
.PP
.PD 0
.TP
.B /dev/fd/\fIfd\fP
Jeżeli \fIfd\fP jest poprawną liczbą całkowitą, to duplikowany jest
deskryptor pliku \fIfd\fP.
.TP
.B /dev/stdin
Duplikowany jest deskryptor pliku 0.
.TP
.B /dev/stdout
Duplikowany jest deskryptor pliku 1.
.TP
.B /dev/stderr
Duplikowany jest deskryptor pliku 2.
.TP
.B /dev/tcp/\fIhost\fP/\fIport\fP
Jeśli \fIhost\fP jest poprawną nazwą hosta lub adresem internetowym,
a \fIport\fP jest liczbą całkowitą określającą numer portu lub nazwą usługi,
to \fBbash\fP usiłuje otworzyć połączenie TCP do odpowiedniego gniazda.
.TP
.B /dev/udp/\fIhost\fP/\fIport\fP
Jeśli \fIhost\fP jest poprawną nazwą hosta lub adresem internetowym,
a \fIport\fP jest liczbą całkowitą określającą numer portu lub nazwą usługi,
to \fBbash\fP usiłuje otworzyć połączenie UDP do odpowiedniego gniazda.
.PD
.RE
.PP
Nieudane otwarcie lub utworzenie pliku powoduje niepowodzenie
przekierowania.
.SS Przekierowanie wejścia
.PP
Przekierowanie wejścia powoduje otwarcie do odczytu pliku, którego nazwa
wynika z interpretacji
.IR słowa .
Odczyt będzie wykonywany z deskryptora pliku
.I n
lub standardowego wejścia (zerowy deskryptor pliku) jeśli nie podano
.IR n .
.PP
Ogólny format przekierowania wejścia:
.RS
.PP
[\fIn\fP]\fB<\fP\fIsłowo\fP
.RE
.SS Przekierowanie wyjścia
.PP
Przekierowanie wyjścia powoduje otwarcie do zapisu pliku, którego nazwa
wynika z interpretacji
.IR słowa .
Zapis będzie wykonywany z deskryptora pliku
.I n
lub standardowego wyjścia (deskryptor pliku 1) jeśli nie podano
.IR n .
Jeżeli plik nie istnieje jest tworzony; jeżeli istnieje obcinany jest
do rozmiaru zerowego.
.PP
Ogólny format przekierowania wyjścia:
.RS
.PP
[\fIn\fP]\fB>\fP\fIsłowo\fP
.RE
.PP
Jeżeli operatorem przekierowania jest
.BR > ,
a została włączona opcja
.B noclobber
wbudowanego polecenie
.BR set ,
to przekierowanie nie powiedzie się jeżeli plik o nazwie wynikającej
z interpretacji \fIsłowa\fP istnieje i jest zwykłym plikiem.
Jeżeli operatorem przekierowania jest
.BR >| ,
albo operatorem jest
.B >
przy niewłączonej opcji
.BR noclobber ,
to wykonywana jest próba przekierowania, nawet jeśli plik \fIsłowo\fP
istnieje.
.SS Dołączanie przekierowanego wyjścia
.PP
Przekierowanie wyjścia w ten sposób powoduje, że plik o nazwie wynikającej
z interpretacji
.I słowa
zostanie otwarty do dołączania (append).
Dołączanie będzie wykonywane z deskryptora pliku
.I n
lub standardowego wyjścia (deskryptor pliku 1) jeśli nie podano
.IR n .
Jeżeli plik nie istnieje jest tworzony.
.PP
Ogólny format dołączania wyjścia:
.RS
.PP
[\fIn\fP]\fB>>\fP\fIsłowo\fP
.RE
.PP
.SS Przekierowanie standardowego wyjścia i wyjścia błędów
.PP
.B Bash
pozwala, przy pomocy tej konstrukcji, przekierować standardowe
wyjście (deskryptor pliku 1) i standardowe wyjście błędów (deskryptor
plików 2) do pliku, którego nazwą jest zinterpretowane
.IR słowo .
.PP
Istnieją dwie postaci takiego przekierowania:
.RS
.PP
\fB&>\fP\fIsłowo\fP
.RE
i
.RS
\fB>&\fP\fIsłowo\fP
.RE
.PP
Spośród nich, zalecaną jest pierwsza forma.
Jest ona semantycznie równoważna
.RS
.PP
\fB>\fP\fIsłowo\fP 2\fB>&\fP1
.RE
.SS Dokumenty włączone (Here Documents)
.PP
Ten typ przekierowania instruuje powłokę, by czytała wejście z bieżącego
źródła aż do napotkania wiersza zawierającego tylko
.I słowo
(bez żadnych kończących odstępów).
Wszystkie wiersze przeczytane do tego momentu są następnie używane jako
standardowe wejście polecenia.
.PP
Format dokumentów włączonych jest następujący:
.RS
.PP
.nf
\fB<<\fP[\fB\-\fP]\fIsłowo\fP
        \fIdokument włączony\fP
\fIogranicznik\fP
.fi
.RE
.PP
Na
.I słowie
nie jest wykonywana interpretacja parametrów, podstawiania wyników poleceń,
rozwijanie nazw plików ani interpretacja wyrażeń arytmetycznych.
Jeżeli jakieś znaki w
.I słowie
są cytowane, to
.I ogranicznik
jest wynikiem usunięcia cytowań ze
.IR słowa ,
a wiersze w dokumencie włączonym nie są interpretowane.
Jeżeli \fIsłowo\fP nie jest cytowane, wszystkie wiersze dokumentu
włączonego podlegają interpretacji parametrów, podstawianiu poleceń
i interpretacji wyrażeń arytmetycznych. W tym ostatnim przypadku,
sekwencja
.B \e<nowalinia>
jest ignorowana, a do cytowania znaków
.BR \e ,
.BR $
i
.BR `
musi być użyte
.BR \e .
.PP
Jeżeli operatorem przekierowania jest
.BR <<\- ,
to wszystkie początkowe znaki tabulacji są obcinane z wierszy wejściowych
i wiersza zawierającego
.IR ogranicznik .
Pozwala to na ustawienie naturalnych wcięć dla dokumentów włączonych
w skryptach powłoki.
.SS "Powielanie deskryptorów plików"
.PP
Operator przekierowania
.RS
.PP
[\fIn\fP]\fB<&\fP\fIsłowo\fP
.RE
.PP
służy do powielania deskryptorów plików wejściowych.
Jeżeli
.I słowo
zinterpretowane zostanie jako jedna lub więcej cyfr, to deskryptor pliku
oznaczony przez
.I n
czyniony jest kopią tego deskryptora.
Jeżeli cyfry w
.I słowie
nie określają otwartego dla wejścia deskryptora, pojawia się błąd
przekierowania.
Jeżeli
.I słowo
zinterpretowane jest jako
.BR \- ,
deskryptor pliku
.I n
jest zamykany. Jeżeli
.I n
nie zostało określone, to stosowane jest standardowe wejście (deskryptor
pliku 0).
.PP
Operator
.RS
.PP
[\fIn\fP]\fB>&\fP\fIsłowo\fP
.RE
.PP
podobnie, służy do powielania deskryptorów standardowego wyjścia.
Jeżeli nie określono
.IR n ,
stosowane jest standardowe wyjście (deskryptor pliku 1).
Jeżeli cyfry w
.I słowie
nie określają deskryptora pliku otwartego do wyjścia, pojawia się błąd
przekierowania.
W przypadku specjalnym, jeżeli pominięto \fIn\fP, a \fIsłowo\fP nie jest
interpretowane jako jedna lub więcej cyfr, to przekierowywane są standardowe
wyjście i standardowe wyjście błędów, jak opisano poprzednio.
.SS "Otwieranie deskryptorów plików do odczytu i zapisu"
.PP
Operator przekierowania
.RS
.PP
[\fIn\fP]\fB<>\fP\fIsłowo\fP
.RE
.PP
powoduje, że plik o nazwie wynikłej z interpretacji
.I słowa
zostanie otwarty do odczytu i zapisu.
Odczyt i zapis będą wykonywane z deskryptora pliku
.I n
lub standardowego wejścia (deskryptor pliku 0) jeśli nie podano
.IR n .
Jeżeli plik nie istnieje jest tworzony.
.SH ALIASY
\fBAliasy\fP (czyli synonimy) pozwalają na zastąpienie słowa łańcuchem, gdy
zostanie ono użyte jako pierwsze słowo w poleceniu prostym.
Powłoka utrzymuje listę aliasów, które mogą być ustawiane i unieważniane przy
pomocy wbudowanych poleceń
.B alias
i
.B unalias
(zobacz poniżej
.SM
.BR "WBUDOWANE POLECENIA POWŁOKI" ).
Dla pierwszego słowa każdego polecenia, jeśli nie jest cytowane, następuje
sprawdzenie, czy posiada ono alias. Jeżeli tak, to słowo to jest
zastępowane tekstem aliasu. Nazwa aliasu i zastępujący ja tekst mogą
zawierać dowolne poprawne wejście powłoki, łącznie z
.IR metaznakami
podanymi powyżej, z wyjątkiem tego, że nazwy aliasów nie mogą zawierać
znaku równości \fI=\fP. Pierwsze słowo tekstu zastępującego jest z kolei
sprawdzane na aliasy, ale słowo identyczne z interpretowanym właśnie
aliasem nie jest interpretowane powtórnie. Oznacza to, że można mieć alias
.B ls
do
.BR "ls \-F" ,
na przykład, a
.B bash
nie będzie usiłował rekurencyjnie interpretować zastępującego tekstu.
jeżeli ostatnim znakiem wartości aliasu jest
.IR odstęp ,
to następne słowo polecenia występujące po aliasie ma również sprawdzaną
interpretację aliasów.
.PP
Aliasy są tworzone i pokazywane poleceniem
.BR alias ,
a usuwane poleceniem
.BR unalias .
.PP
Nie ma żadnego mechanizmu posługiwania się argumentami w tekście
zastępującym. Jeśli potrzebne są argumenty, powinna zostać użyta funkcja
powłoki (zobacz poniżej
.SM
.BR FUNKCJE ).
.PP
Aliasy nie są interpretowane, gdy powłoka nie jest interaktywna, chyba że
ustawiono opcję powłoki
.B expand_aliases
przy pomocy
.B shopt
(zobacz opis
.B shopt
w sekcji
.SM
.B WBUDOWANE POLECENIA POWŁOKI
poniżej).
.PP
Reguły dotyczące definiowania i używania aliasów są nieco zagmatwane.
.\" somewhat confusing.
.B Bash
zawsze czyta co najmniej jeden pełny wiersz z wejścia przed wykonaniem
jakichkolwiek poleceń tego wiersza. Aliasy interpretowane są w czasie
odczytu polecenia, nie podczas jego wykonywania. Z tego powodu, definicja
aliasu występująca w tym samym wierszu, co inne polecenie nie zadziała
aż do przeczytania następnego wiersza wejścia.
Na polecenia występujące po definicji aliasu, w tym samym wierszu, nowy
alias nie ma wpływu.
Zachowanie to ujawnia się także podczas wykonywania funkcji.
Aliasy interpretowane są w czasie odczytu definicji funkcji, nie zaś
podczas jej wykonywania, gdyż sama definicja funkcji stanowi polecenie
złożone. W skutek tego aliasy zdefiniowane w funkcji nie są dostępne,
aż do chwili po wykonaniu funkcji.
Dla bezpieczeństwa, zawsze umieszczaj definicje aliasów w odrębnym wierszu
i nie używaj
.B alias
w poleceniach złożonych.
.PP
Prawie w każdym zastosowaniu aliasy są wyparte przez funkcje powłoki.
.SH FUNKCJE
Punkcja powłoki, zdefiniowana jak opisano powyżej, w sekcji
.SM
.BR "GRAMATYKA POWŁOKI" ,
przechowuje szereg poleceń do późniejszego wykonania.
Gdy nazwa funkcji powłoki używana jest jako nazwa polecenia prostego,
wykonywana jest lista poleceń związanych z tą nazwą funkcji.
Funkcje wykonywane są w kontekście bieżącej powłoki; do ich interpretacji
nie jest tworzony żaden nowy proces (zauważ różnicę w stosunku do wykonania
skryptu powłoki).
Podczas wykonywania funkcji, przekazane jej argumenty stają się parametrami
pozycyjnymi. Aktualizowany jest specjalny parametr
.BR # ,
tak by odzwierciedlał zmianę. Parametr pozycyjny 0 nie jest zmieniany.
Zmienna
.SM
.B FUNCNAME
podczas wykonywania funkcji ustawiana jest na jej nazwę.
Wszystkie inne aspekty środowiska wykonywania powłoki są identyczne
między funkcją i jej wywołującym, z wyjątkiem tego, że nie jest
dziedziczona pułapka (trap)
.SM
.B DEBUG
(zobacz opis wbudowanego
.B trap
poniżej, w sekcji
.SM
.B "WBUDOWANE POLECENIA POWŁOKI" ).
.PP
Zmienne lokalne dla funkcji mogą być deklarowane przy pomocy wbudowanego
polecenia
.BR local .
Zwykle zmienne i ich wartości są wspólne dla funkcji i jej wołającego.
.PP
Jeżeli w funkcji wywoływane jest wbudowane polecenie
.BR return ,
funkcja kończy działanie i wykonywanie wznawiane jest od
następnego polecenia po wywołaniu funkcji. Gdy funkcja kończy działanie,
parametrom pozycyjnym i parametrowi specjalnemu
.B #
przywracane są wartości, jakie posiadały one przed wykonaniem funkcji.
.PP
Listę nazw i definicji funkcji można uzyskać przy pomocy opcji
.B \-f
wbudowanych poleceń
.B declare
lub
.BR typeset .
Opcja
.B \-F
poleceń
.B declare
lub
.B typeset
podaje same nazwy funkcji.
Funkcje można eksportować, tak że będą one automatycznie
zdefiniowane w podpowłokach. Wykonuje się to przy pomocy opcji
.B \-f
wbudowanego polecenia
.BR export .
.PP
Funkcje mogą być rekurencyjne. Nie ma narzuconego ograniczenia na
liczbę rekurencyjnych wywołań.
.SH "OBLICZANIE WYRAŻEŃ ARYTMETYCZNYCH"
Powłoka pozwala, pod pewnymi warunkami, na obliczanie wartości wyrażeń
arytmetycznych (zobacz wbudowane polecenie \fBlet\fP i \fBInterpretacja
wyrażeń arytmetycznych\fP).
Obliczenia wykonywane są na długich liczbach całkowitych (long integer), bez
kontroli przepełnienia (overflow), mimo iż dzielenie przez 0 jest
przechwytywane i oznaczane jako błąd.
Operatory i ich priorytety oraz sposób ich dołączania
.\" associativity
są takie same jak w języku C.
Poniższa lista operatorów pogrupowana jest w poziomy operatorów o
jednakowym priorytecie.
Poziomy podano w kolejności malejącego priorytetu.
.PP
.PD 0
.TP
.B \fIid\fP++ \fIid\fP\-\-
post-inkrementacja i post-dekrementacja zmiennej
.TP
.B ++\fIid\fP \-\-\fIid\fP
pre-inkrementacja i pre-dekrementacja zmiennej
.TP
.B \- +
jednoargumentowy minus i plus
.TP
.B ! ~
negacja logiczna i bitowa
.TP
.B **
potęgowanie
.TP
.B * / %
mnożenie, dzielenie, reszta z dzielenia
.TP
.B + \-
dodawanie, odejmowanie
.TP
.B << >>
lewo i prawostronne przesunięcie bitowe
.TP
.B <= >= < >
porównanie
.TP
.B == !=
równości i nierówność
.TP
.B &
bitowa koniunkcja (AND)
.TP
.B ^
bitowa alternatywa wyłączna (XOR)
.TP
.B |
bitowa alternatywa (OR)
.TP
.B &&
logiczna koniunkcja (AND)
.TP
.B ||
logiczna alternatywa (OR)
.TP
.B \fIwyraż\fP?\fIwyraż\fP:\fIwyraż\fP
obliczenie warunkowe (conditional evaluation)
.TP
.B = *= /= %= += \-= <<= >>= &= ^= |=
przypisanie
.TP
.B \fIwyraż1\fP , \fIwyraż2\fP
przecinek
.PD
.PP
.PP
Jako operandy dozwolone są zmienne powłoki; interpretacja parametrów
przeprowadzana jest przed obliczeniem wyrażenia.
Wewnątrz wyrażenia, do zmiennych powłoki można się też odwoływać przez
nazwę, bez użycia składni interpretacji parametrów.
Gdy wystąpi odwołanie się do zmiennej, jej wartość obliczana jest jako
wyrażenie arytmetyczne.
Zmienna powłoki nie musi mieć włączonego atrybutu liczby całkowitej by mogła
być użyta w wyrażeniu.
.PP
Stałe z początkowym 0 interpretowane są jako liczby ósemkowe. Początkowe 0x lub
0X oznacza liczbę szesnastkową. W pozostałych przypadkach liczby mają
postać [\fIpodstawa#\fP]n, gdzie \fIpodstawa\fPjest liczbą dziesiętną
pomiędzy 2 a 64 reprezentującą podstawę układu pozycyjnego, zaś \fIn\fP
liczbą w układzie o tej podstawie.
Jeśli pominięto \fIpodstawa#\fP, to używana jest podstawa 10.
Cyfry większe niż 9 reprezentowane są przez małe litery, wielkie litery,
@ i _, w tej kolejności.
Jeżeli \fIpodstawa\fP jest mniejsza bądź równa 36, to do zapisu liczb
pomiędzy 10 a 35 można używać zamiennie małych i wielkich liter.
.PP
Operatory interpretowane są w kolejności priorytetu. Podwyrażenia
w nawiasach obliczane są jako pierwsze i mogą unieważnić podane wyżej reguły
priorytetów.
.SH "WYRAŻENIA WARUNKOWE"
Wyrażenia warunkowe używane są przez polecenie złożone \fB[[\fP oraz
polecenia wbudowane \fBtest\fP i \fB[\fP do testowania atrybutów pliku
i wykonywania porównań łańcuchowych i arytmetycznych.
Wyrażenia złożone są z poniższych jedno- i dwuargumentowych składowych.
Jeśli któryś z argumentów \fIplikowych\fP jednej z składowych jest w postaci
\fI/dev/fd/n\fP, to sprawdzany jest deskryptor pliku \fIn\fP.
Jeżeli argument \fIplik\fP którejś składowej jest jednym z
\fI/dev/stdin\fP, \fI/dev/stdout\fP lub \fI/dev/stderr\fP, to sprawdzany
jest, odpowiednio, deskryptor 0, 1 lub 2.
.sp 1
.PD 0
.TP
.B \-a \fIplik\fP
Prawda jeśli \fIplik\fP istnieje.
.TP
.B \-b \fIplik\fP
Prawda jeśli \fIplik\fP istnieje i jest blokowym plikiem specjalnym.
.TP
.B \-c \fIplik\fP
Prawda jeśli \fIplik\fP istnieje i jest znakowym plikiem specjalnym.
.TP
.B \-d \fIplik\fP
Prawda jeśli \fIplik\fP istnieje jest katalogiem.
.TP
.B \-e \fIplik\fP
Prawda jeśli \fIplik\fP istnieje.
.TP
.B \-f \fIplik\fP
Prawda jeśli \fIplik\fP istnieje i jest plikiem zwykłym.
.TP
.B \-g \fIplik\fP
Prawda jeśli \fIplik\fP istnieje i ma ustawiony bit set-group-id.
.TP
.B \-h \fIplik\fP
Prawda jeśli \fIplik\fP istnieje i jest dowiązaniem symbolicznym.
.TP
.B \-k \fIplik\fP
Prawda jeśli \fIplik\fP istnieje i ma ustawiony bit ochrony (sticky bit).
.TP
.B \-p \fIplik\fP
Prawda jeśli \fIplik\fP istnieje i jest potokiem nazwanym (FIFO).
.TP
.B \-r \fIplik\fP
Prawda jeśli \fIplik\fP istnieje i daje się czytać.
.TP
.B \-s \fIplik\fP
Prawda jeśli \fIplik\fP istnieje i ma rozmiar większy niż zero.
.TP
.B \-t \fIfd\fP
Prawda jeśli deskryptor pliku
.I fd
jest otwarty i odnosi się do terminala.
.TP
.B \-u \fIplik\fP
Prawda jeśli \fIplik\fP istnieje i ma ustawiony bit set-user-id.
.TP
.B \-w \fIplik\fP
Prawda jeśli \fIplik\fP istnieje i daje się doń zapisać.
.TP
.B \-x \fIplik\fP
Prawda jeśli \fIplik\fP istnieje i jest wykonywalny.
.TP
.B \-O \fIplik\fP
Prawda jeśli \fIplik\fP istnieje i jego właścicielem jest efektywny
id użytkownika.
.TP
.B \-G \fIplik\fP
Prawda jeśli \fIplik\fP istnieje i jego właścicielem jest efektywny
id grupy.
.TP
.B \-L \fIplik\fP
Prawda jeśli \fIplik\fP istnieje i jest dowiązaniem symbolicznym.
.TP
.B \-S \fIplik\fP
Prawda jeśli \fIplik\fP istnieje i jest gniazdem.
.TP
.B \-N \fIplik\fP
Prawda jeśli \fIplik\fP istnieje i być zmieniany od czasu ostatniego jego
odczytu.
.TP
\fIplik1\fP \-\fBnt\fP \fIplik2\fP
Prawda jeśli \fIplik1\fP jest nowszy (według daty modyfikacji) od
\fIpliku2\fP.
.TP
\fIplik1\fP \-\fBot\fP \fIplik2\fP
Prawda jeśli \fIplik1\fP jest starszy niż \fIplik2\fP.
.TP
\fIplik1\fP \fB\-ef\fP \fIplik2\fP
Prawda jeśli \fIplik1\fP i \fIplik2\fP mają ten sam numer urządzenia
i i-węzła.
.TP
.B \-o \fInazwa_opcji\fP
Prawda jeśli opcja powłoki
.I nazwa_opcji
jest włączona.
Zobacz zestawienie opcji w opisie opcji
.B \-o
wbudowanego
.BR set ,
poniżej.
.TP
.B \-z \fIłańcuch\fP
Prawda jeśli długość \fIłańcucha\fP wynosi zero.
.TP
.B \-n \fIłańcuch\fP
.TP
\fIłańcuch\fP
Prawda jeśli
.I łańcuch
ma długość niezerową.
.TP
\fIłańcuch1\fP \fB==\fP \fIłańcuch2\fP
Prawda jeśli łańcuchy są równe. Zamiast \fB==\fP można użyć
\fB=\fP.
.TP
\fIłańcuch1\fP \fB!=\fP \fIłańcuch2\fP
Prawda jeśli łańcuchy nie są równe.
.TP
\fIłańcuch1\fP \fB<\fP \fIłańcuch2\fP
Prawda jeśli \fIłańcuch1\fP przy sortowaniu występowałby przed
\fIłańcuchem2\fP według bieżącego ustawienia locale.
.TP
\fIłańcuch1\fP \fB>\fP \fIłańcuch2\fP
Prawda jeśli \fIłańcuch1\fP przy sortowaniu występowałby po
\fIłańcuchu2\fP według bieżącego ustawienia locale.
.TP
.I \fIarg1\fP \fBOP\fP \fIarg2\fP
.SM
.B OP
jest jednym z
.BR \-eq ,
.BR \-ne ,
.BR \-lt ,
.BR \-le ,
.BR \-gt
lub
.BR \-ge .
Te arytmetyczne operatory dwuargumentowe zwracają prawdę jeśli \fIarg1\fP
jest odpowiednio równe (eq), nie równe (ne), mniejsze niż (lt), mniejsze
bądź równe (le), większe niż (gt) lub większe bądź równe (ge) \fIarg2\fP.
.I Arg1
i
.I arg2
mogą być dodatnimi lub ujemnymi liczbami całkowitymi.
.PD
.SH "INTERPRETACJA POLECEŃ PROSTYCH"
Gdy wykonywane jest polecenie proste, powłoka wykonuje następujące
interpretacje, przypisania i przekierowania, od lewej do prawej.
.IP 1.
Słowa oznaczone przez analizator składni jako przypisania zmiennych
(poprzedzające nazwę polecenia) i przekierowania zachowywane są do
późniejszego przetworzenia.
.IP 2.
Słowa, nie będące przypisaniami zmiennych ani przekierowaniami są
interpretowane. Jeżeli po interpretacji pozostaną jakieś słowa, to
pierwsze z nich przyjmowane jest za nazwę polecenia a pozostałe za
argumenty.
.IP 3.
Wykonywane są przekierowania, jak opisano powyżej w sekcji
.SM
.BR PRZEKIEROWANIE .
.IP 4.
W każdym przypisaniu zmiennej tekst po znaku równości \fB=\fP
podlega interpretacji tyldy, interpretacji parametrów, podstawianiu wyników
poleceń, interpretacji wyrażeń arytmetycznych i usuwaniu cudzysłowów,
zanim zostanie przypisany do zmiennej.
.PP
Jeżeli nie otrzymano żadnej nazwy polecenia, to przypisania zmienncyh
dotyczą środowiska aktualnej powłoki. W przeciwnim razie, zmienne
są dodawane do środowiska wykonywanego polecenia i nie mają wpływu na
środowisko bieżącej powłoki. jeżeli któreś z przypisań usiłuje nadać
wartość zmiennej read-only, pojawia się błąd, a polecenie kończy pracę
z niezerowym kodem.
.PP
Jeżeli nie otrzymano żadnej nazwy polecenia, wykonywane są przekierowania,
ale nie mają one wpływu na bieżące środowisko powłoki. Błąd przekierowania
powoduje, że polecenie kończy pracę z niezerowym kodem.
.PP
Jeżeli po interpretacji istnieje nazwa polecenia, to wykonywanie odbywa się
jak opisano poniżej. W przeciwnym wypadku, polecenie kończy pracę.
Jeżeli jednym z wykonanych kroków było podstawienie wyników polecenia, to
zwracany kod zakończenia jest kodem ostatniego wykonanego podstawienia
polecenia. Jeśli nie wystąpiło podstawianie poleceń, to polecenie kończy
pracę z kodem zerowym.
.SH "WYKONYWANIE POLECEŃ"
Po podziale polecenia na słowa, jeśli jego wynikiem jest polecenie proste z
opcjonalną listą argumentów, podejmowane są poniższe akcje.
.PP
Jeśli polecenie nie zawiera ukośników, powłoka usiłuje je zlokalizować.
jeżeli istnieje funkcja powłoki o tej nazwie, wywoływana jest ta funkcja,
jak opisano powyżej w sekcji
.SM
.BR FUNKCJE .
Jeżeli nazwa nie pasuje do funkcji, powłoka szuka jej na liście poleceń
wbudowanych. Jeżeli nie znaleziono pasujące, to jest ono wywoływane.
.PP
Jeżeli nazwa nie jest ani funkcją powłoki ani poleceniem wbudowanym i nie
zawiera ukośników, to
.B bash
przeszukuje każdy element z
.SM
.B PATH
usiłując znaleźć katalog zawierający plik wykonywalny o takiej nazwie.
.B Bash
posługuje się tablicą mieszającą (hash table) do zapamiętywania pełnych
nazw plików wykonywalnych (zobacz
.B hash
w
.SM
.B "WBUDOWANE POLECENIA POWŁOKI"
poniżej).
Pełne przeszukiwanie katalogów z
.SM
.B PATH
wykonywane jest tylko wtedy, gdy polecenia nie znaleziono w tablicy mieszającej.
Jeżeli poszukiwanie nie powiodło się, powłoka wypisuje komunikat o błędzie
i zwraca kod zakończenia równy 127.
.PP
Jeżeli poszukiwanie było pomyślne lub jeśli nazwa polecenia zawiera jeden
lub więcej ukośników, powłoka wykonuje zadany program w odrębnym środowisku
wykonania.
Argumentowi 0 przypisywana jest podana nazwa, a pozostałym argumentom
polecenia podane argumenty, jeśli były takowe.
.PP
Jeżeli wykonanie to nie powiedzie się, gdyż plik nie ma formatu
wykonywalnego, a nie jest katalogiem, to zakłada się, że jest on
\fIskryptem powłoki\fP, plikiem zawierającym polecenia powłoki.
Powoływana jest podpowłoka do jego wykonania. Powłoka ta reinicjuje
się, zatem efekt jest taki, jakby do obsługi skryptu została wywołana nowa
powłoka, z wyjątkiem tego, że położenia poleceń zapamiętane przez
rodzica (zobacz
.B hash
poniżej w
.SM
.B WBUDOWANE POLECENIA POWŁOKI
są zachowywane przez potomka.
.PP
Jeżeli program jest plikiem o zawartości rozpoczynającej się od
.BR #! ,
to reszta pierwszego wiersza określa interpreter dla tego programu.
Powłoka uruchamia podany interpreter na systemach operacyjnych, które
same nie obsługują tego formatu wykonywalnego. Argumenty dla interpretera
składają się z pojedynczego opcjonalnego argumentu występującego po nazwie
interpretera w pierwszym wierszu programu, następującej po nim nazwy
programu i następujących po niej argumentów polecenia, jeśli były takowe.
.SH ŚRODOWISKO WYKONYWANIA POLECEŃ
Powłoka posiada \fIśrodowisko wykonywania\fP (execution environment),
składające się z:
.sp 1
.IP \(bu
otwarte pliki odziedziczone przez powłokę przy wywołaniu, zmodyfikowane
przez przekierowania przekazane do wbudowanego polecenia \fBexec\fP
.IP \(bu
bieżący katalog roboczy ustawiony przez \fBcd\fP, \fBpushd\fP lub
\fBpopd\fP, albo odziedziczony przez powłokę przy wywołaniu
.IP \(bu
maskę trybut tworzonych plików ustawioną przez \fBumask\fP albo
odziedziczoną po rodzicu powłoki
.IP \(bu
bieżące pułapki ustawione przez \fBtrap\fP
.IP \(bu
parametry powłoki ustawione przez przypisania zmiennych przy pomocy \fBset\fP
albo odziedziczone ze środowiska rodzica powłoki
.IP \(bu
funkcje powłoki zdefiniowane podczas wykonywania lub odziedziczone
ze środowiska rodzica powłoki
.IP \(bu
opcje włączone przy wywołaniu (albo domyślnie albo przy pomocy argumentów
wiersza poleceń) albo przez \fBset\fP
.IP \(bu
opcje włączone przez \fBshopt\fP
.IP \(bu
aliasy powłoki zdefiniowane przy pomocy \fBalias\fP
.IP \(bu
różne id procesów, łącznie z identyfikatorami zadań tła, wartość \fB$$\fP
i wartość \fB$PPID\fP
.PP
Gdy ma zostać wykonane polecenie proste inne niż funkcja powłoki
lub polecenie wbudowane, wywoływane jest w odrębnym środowisku wykonania,
skłądających się z poniższych elementów. Jeśli nie podano inaczej, wartości
dziedziczone są z powłoki.
.sp 1
.IP \(bu
otwarte pliki powłoki, plus modyfikacje i dodatki określone przez
przekierowania polecenia
.IP \(bu
bieżący katalog roboczy
.IP \(bu
maska trybu tworzonych plików
.IP \(bu
zmienne powłoki oznaczone do wyeksportowania, razem ze zmiennymi
wyeksportowanymi do polecenia, przekazane w środowisku.
.IP \(bu
pułapki przechwycone przez powłokę resetowane są do wartości
odziedziczonych przez nią od rodzica, a pułapki ignorowane przez powłokę
są ignorowane.
.PP
Polecenie wywołane w odrębnym środowisku nie może wpływać na środowisko
wykonywania powłoki.
.PP
Podstawienia wyników poleceń i polecenia asynchroniczne wywoływane są w
środowisku podpowłoki, które jest kopią środowiska powłoki, z wyjątkiem
tego, że pułapki przechwycone przez powłokę są resetowane do wartości,
jakie powłoka odziedziczyła po rodzicu podczas wywołania. Polecenia
wbudowane wywoływane jako część potoku również wykonywane są w środowisku
podpowłoki. Zmiany wykonane w środowisku podpowłoki nie mogą wpływać na
środowisko wykonywania powłoki.
.PP
Jeżeli po poleceniu występuje \fB&\fP, a nie uaktywniono sterowania zadaniami,
to domyślnym standardowym wejściem dla tego polecenia jest pusty plik
\fI/dev/null\fP. W przeciwnym razie wywoływane polecenie dziedziczy
deskryptory plików po wołającej powłoce, zmodyfikowane przekierowaniami.
.SH ŚRODOWISKO
Poczas wywoływania program otrzymuje tablicę łańcuchów zwaną
.IR środowiskiem (environment).
jest to lista par
\fInazwa\fP\-\fIwartość\fP, o postaci
.IR "nazwa\fR=\fPwartość" .
.PP
Powłoka pozwala na manipulowanie środowiskiem na kilka sposobów. Przy
wywołaniu, przeszukuje ona własne środowisko i tworzy parametr dla każdej
znalezionej nazwy, automatycznie zaznaczając go do
.I wyeksportowania
do procesów potomnych. Wykonywane polecenia dziedziczą środowisko.
Polecenia
.B export
i
.B declare \-x
pozwalają na dodawanie i usuwanie ze środowiska parametrów i funkcji.
Jeżeli w środowisku zmieniana jest wartość parametru, to nowa wartość
staje się częścią środowiska, zastępując starą. Środowisko dziedziczone
przez każde wykonywane polecenie składa się z początkowego środowiska
powłoki, którego wartości mogą być w powłoce zmieniane, minus ewentualne
pary usunięte poleceniem
.BR unset ,
plus dodane poprzez polecenia
.B export
i
.BR "declare \-x" .
.PP
Środowisko dla dowolnego
.I polecenia prostego
czy funkcji może być tymczasowo powiększone przez poprzedzenie polecenia
przypisaniem parametrów, jak opisano powyżej w sekcji
.SM
.BR PARAMETRY .
Te instrukcje przypisania mają wpływ wyłącznie na środowisko postrzegane
przez to polecenie.
.PP
Jeżeli ustawiona jest opcja
.B \-k
(zobacz poniżej opis wbudowanego polecenia
.BR set ),
to
.I wszystkie
przypisania parametrów umieszczane są w środowisku polecenia, a nie tylko
te, które poprzedzają nazwę polecenia.
.PP
Gdy
.B bash
wywołuje polecenie zewnętrzne, zmienna
.B _
ustawiana jest na pełną nazwę pliku polecenia i przekazywana temu poleceniu
w jego środowisku.
.SH "KOD ZAKOŃCZENIA"
Dla celów powłoki, polecenie, które zakończyło pracę z zerowym kodem
zakończenia, powiodło się. Zerowy kod oznacza powodzenie. Niezerowy kod
oznacza niepowodzenie. Gdy polecenie kończy pracę z błędem krytycznym \fIN\fP,
\fIbash\fP posługuje się wartością 128+\fBN\fP jako kodem zakończenia.
.PP
Jeżeli nie znaleziono polecenia, proces potomny powołany do jego wykonania
zwraca kod 127. Jeżeli polecenie zostało znalezione, ale nie jest
wykonywalne, kod zakończenia wynosi 126.
.PP
Jeżeli polecenie nie powiodło się z powodu błędu podczas interpretacji lub
przekierowania, kod zakończenia jest większy od zera.
.PP
Wbudowane polecenia powłoki zwracają kod 0 (\fItrue\fP prawda) jeśli się
powiodły, i niezerowy (\fIfalse\fP fałsz) jeśli podczas ich wykonywania
pojawił się błąd.
Wszystkie polecenia wbudowane zwracają kod 2 dla wskazania niepoprawnego
użycia.
.PP
Sam \fBBash\fP zwraca kod zakończenia ostatniego wykonanego polecenia,
chyba że pojawi się błąd składni, wówczas kończy pracą z wartością
niezerową. Zobacz też poniżej polecenie wbudowane \fBexit\fP.
.SH SYGNAŁY
Gdy \fBbash\fP jest interaktywny, przy braku jakichkolwiek pułapek (przechwytywania
sygnałów), ignoruje on
.SM
.B SIGTERM
(tak, że \fBkill 0\fP nie zabija powłoki interaktywnej),
a
.SM
.B SIGINT
jest przechwytywany i obsługiwany (tak, że wbudowane polecenie \fBwait\fP
daje się przerwać).
We wszystkich przypadkach, \fBbash\fP ignoruje
.SM
.BR SIGQUIT .
Jeżeli działa kontrola zadań,
.B bash
ignoruje
.SM
.BR SIGTTIN ,
.SM
.BR SIGTTOU
i
.SM
.BR SIGTSTP .
.PP
Zadania synchroniczne uruchomione przez \fBbash\fP mają procedury obsługi
sygnałów (signal handlers) ustawione na wartości odziedziczone przez powłokę
po rodzicu. Jeżeli nie pracuje kontrola zadań, to polecenia asynchroniczne
ignorują również
.SM
.B SIGINT
i
.SM
.BR SIGQUIT .
Polecenia uruchamiane wskutek podstawiania poleceń ignorują generowane
z klawiatury sygnały kontroli zadań
.SM
.BR SIGTTIN ,
.SM
.BR SIGTTOU
i
.SM
.BR SIGTSTP .
.PP
Powłoka domyślnie kończy pracę po otrzymaniu
.SM
.BR SIGHUP .
Przed zakończeniem, powłoka interaktywna rozsyła otrzymany
.SM
.B SIGHUP
do wszystkich zadań, pracujących lub zatrzymanych.
Do zatrzymanych zadań wysyłany jest
.SM
.B SIGCONT
by upewnić się, że otrzymują
.SM
.BR SIGHUP .
Chcąc uniknąć wysłania sygnału przez powłokę do konkretnego zadania,
należy usunąć je z tablicy zadań przy pomocy wbudowanego polecenia
.B disown
(zobacz poniżej
.SM
.BR "WBUDOWANE POLECENIA POWŁOKI" )
lub oznakować, by nie otrzymywało
.SM
.BR SIGHUP ,
posługując się
.BR "disown \-h" .
.PP
Jeżeli przy pomocy
.B shopt
została ustawiona opcja
.B huponexit
powłoki,
.B bash
wysyła
.SM
.B SIGHUP
do wszystkich zadań, gdy kończy pracę interaktywna powłoka zgłoszeniowa.
.PP
Gdy \fBbash\fP podczas oczekiwania na ukończenie polecenia otrzymuje
sygnał, dla którego ustawiono pułapkę, pułapka ta nie zostanie wykonana aż
do zakończenia pracy polecenia.
Gdy \fBbash\fP oczekuje na polecenie asynchroniczne za pośrednictwem
wbudowanego \fBwait\fP, odbiór sygnału, dla którego ustawiono przechwytywanie
spowoduje, że wbudowane \fBwait\fP natychmiast skończy pracę z kodem
większym od 128, po czym natychmiast zostanie wywołana pułapka.
.SH "KONTROLA ZADAŃ"
.I Kontrola zadań
odnosi się do możliwości selektywnego zatrzymywania (\fIzawieszania\fP -
suspend) wykonywania procesów i późniejszej kontynuacji (\fIwznawiania\fP -
resume) ich wykonywania. Użytkownik zwykle wykorzystuje to udogodnienie za
pośrednictwem interaktywnego interfejsu obsługiwanego wspólnie przez
systemowy sterownik terminala i
.BR bash .
.PP
Powłoka kojarzy z każdym potokiem
.IR zadanie .
Przechowuje tablicę aktualnie wykonywanych zadań, którą można przeglądać
za pomocą polecenia
.BR jobs .
Gdy
.B bash
uruchamia zadanie asynchronicznie (w
.IR tle ),
wypisuje wiersz w rodzaju:
.RS
.PP
[1] 25647
.RE
.PP
wskazujący, że zadanie to ma numer 1 a ID ostatniego procesu w potoku
związanym z zadaniem wynosi 25647.
Wszystkie procesy w jednym potoku należą do tego samego zadania.
.B Bash
posługuje się abstrakcją (abstraction)
.I zadania
jako podstawą kontroli zadań.
.PP
Dla ułatwienia implementacji interfejsu użytkownika do kontroli zadań,
system operacyjny utrzymuje pojęcie \fIID grupy procesów bieżącego
terminala\fP
(current terminal process group ID).
Elementy tej grupy procesów (procesy, których ID grupy procesów jest równy
ID grupy procesów bieżącego terminala) otrzymują generowane z klawiatury
sygnały, takie jak
.SM
.BR SIGINT .
Mówimy, że procesy te pracują
.IR pierwszoplanowo .
Procesy
.I tła
to takie, których ID grupy procesów różni się od terminala; procesy takie
są odporne na sygnały pochodzące z klawiatury.
Tylko procesom pierwszoplanowym wolno czytać z lub pisać na terminalu.
Do procesów tła usiłujących czytać (pisać) z terminala wysyłany jest
przez sterownik terminala sygnał
.SM
.BR "SIGTTIN (SIGTTOU)" ,
który, jeśli nie zostanie przechwycony, wstrzymuje proces.
.PP
Jeżeli system operacyjny, na którym działa
.B bash
obsługuje kontrolę zadań,
.B bash
zawiera funkcje do jej wykorzystywania.
Naciśnięcie klawisza
.I wstrzymania
(zwykle
.BR ^Z ,
Control-Z) podczas pracy procesu powoduje, że proces ten zostanie zatrzymany
a sterowanie zostanie zwrócone do
.BR bash .
Naciśnięcie klawisza
.I opóźnione wstrzymanie
(zwykle
.BR ^Y ,
Control-Y) powoduje, że proces zostanie zatrzymywany gdy będzie usiłował
czytać wejście z terminala, a sterowanie powróci do
.BR bash .
Użytkownik może następnie zmieniać stan takiego zadania, posługując się
poleceniem
.B bg
do kontynuacji zadania w tle,
.B fg
do kontynuacji na pierwszym planie lub poleceniem
.B kill
do zabicia zadania.
\fB^Z\fP działa natychmiast i ma efekt uboczny: powoduje
odrzucenie oczekującego wyjścia i wprowadzonych, a nieprzetworzonych
naciśnięć klawiszy (typeahead).
.PP
Istnieje kilka sposobów wskazywania zadania w powłoce.
Znak
.B %
poprzedza nazwę zadania. Zadanie numer
.I n
można wskazać jako
.BR %n .
Zadanie może być też określone przez użycie przedrostka nazwy użytej do
jego uruchomienia lub podłańcucha, jaki występuje w jego wierszu poleceń.
Na przykład,
.B %ce
odnosi się do zatrzymanego zadania
.BR ce .
Jeśli przedrostek pasuje do więcej niż jednego zadania,
.B bash
zgłasza błąd. Z drugiej strony, użycie
.BR %?ce ,
wskazuje na zadanie zawierające podłańcuch
.B ce
w swym wierszu poleceń. Jeżeli łańcuch pasuje do więcej niż jednego
zadania,
.B bash
zgłasza błąd. Symbole
.B %%
i
.B %+
określają rozumiane przez powłokę
.\" shell's notion of the
.IR "bieżące zadanie" ,
będące ostatnim zadaniem zatrzymanym, gdy było na pierwszym planie lub
uruchomionym w tle.
Do
.I "poprzedniego zadania"
można odwoływać się przy pomocy
.BR %\- .
W wyjściu odnoszącym się do zadań (np. wyjście polecenia
.BR jobs ),
bieżące zadanie jest zawsze zaznaczone znakiem
.BR + ,
a zadanie poprzednie
.BR \- .
.PP
Do przywrócenia zadania na pierwszy plan można posłużyć się po prostu jego
nazwą:
.B %1
jest synonimem dla
,,\fBfg %1\fP'',
przywracającego zadanie 1 z tła na pierwszy plan.
Podobnie,
,,\fB%1 &\fP''
wznawia zadanie 1 w tle, równoważnie do
,,\fBbg %1''\fP''.
.PP
Powłoka natychmiast dowiaduje się czy zadanie zmieniło stan.
Normalnie,
.B bash
czeka ze zgłoszeniem zmian do momentu, gdy ma wyświetlić zachętę, by nie
przerywać innego wyjścia. Jeżeli włączono opcję
.B \-b
wbudowanego polecenia
.BR set ,
.B bash
zgłasza takie zmiany natychmiast.
Dla każdego kończącego pracę procesu potomnego wykonywana jest ewentualna
pułapka przechwytująca
.SM
.BR SIGCHLD .
.PP
Jeżeli wykonano próbę zakończenia pracy
.B bash
przy istniejących zatrzymanych zadaniach, powłoka wypisuje komunikat
ostrzegawczy. Można wówczas posłużyć się poleceniem
.B jobs
do sprawdzenia ich stanu. Jeżeli wykonywana jest druga próba zakończenia
pracy bez wystąpienia wtrąconego między nie polecenia, powłoka
nie wypisuje kolejnego ostrzeżenia a zatrzymane zadania są przerywane.
.SH ZACHĘTA POWŁOKI
Przy wykonywaniu interaktywnym
.B bash
wyświetla główny symbol zachęty (primary prompt)
.SM
.B PS1
kiedy jest gotowa na odczyt polecenia, zaś wtórną (secondary) zachętę
.SM
.B PS2
kiedy potrzebuje więcej danych z wejścia do uzupełnienia polecenia.
.B Bash
pozwala na dostosowywanie tych łańcuchów zachęty poprzez wstawianie
pewnej ilości znaków specjalnych rozpoczynających się odwrotnym
ukośnikiem, które są dekodowane jak następuje:
.RS
.PD 0
.TP
.B \ea
znak dzwonka ASCII (07)
.TP
.B \ed
data w formacie "DzieńTyg Miesiąc Dzień" format (np., "Tue May 26")
.TP
.B \ee
znak escape ASCII (033)
.TP
.B \eh
nazwa hosta do pierwszej kropki `.'
.TP
.B \eH
nazwa hosta
.TP
.B \ej
liczba zadań aktualnie obsługiwanych przez powłokę
.TP
.B \el
główna część nazwy urządzenia terminala powłoki
.TP
.B \en
znak nowej linii
.TP
.B \er
powrót karetki
.TP
.B \es
nazwa powłoki, główna część nazwy
.B $0
(fragment występujący po ostatnim ukośniku)
.TP
.B \et
bieżący czas w formacie 24-godzinnym GG:MM:SS
.TP
.B \eT
bieżący czas w formacie 12-godzinnym GG:MM:SS
.TP
.B \e@
bieżący czas w 12-godzinnym formacie am/pm
.TP
.B \eA
bieżący czas w 24-godzinnym formacie GG:MM
.TP
.B \eu
nazwa bieżącego użytkownika (username)
.TP
.B \ev
wersja programu \fBbash\fP (np. 2.00)
.TP
.B \eV
wydanie \fBbash\fP, wersja+poziom łat (np., 2.00.0)
.TP
.B \ew
bieżący katalog roboczy
.TP
.B \eW
główna część nazwy bieżącego katalogu roboczego
.TP
.B \e!
numer tego polecenia w historii
.TP
.B \e#
numer polecenia tego polecenia
.TP
.B \e$
Jeżeli efektywnym UID jest 0, to
.BR # ,
w przeciwnym razie
.B $
.TP
.B \e\fInnn\fP
znak odpowiadający szesnastkowej liczbie \fInnn\fP
.TP
.B \e\e
odwrotny ukośnik
.TP
.B \e[
początek sekwencji znaków niedrukowalnych, która może służyć do osadzenia
w zachęcie sekwencji sterujących terminalem
.TP
.B \e]
koniec sekwencji znaków niedrukowalnych
.PD
.RE
.PP
Numer polecenia i numer w historii są zwykle różne: numer polecenia
w historii jest jego pozycją na liście historii, która może obejmować
polecenia odtworzone z pliku historii
(zobacz poniżej
.SM
.BR HISTORIA ),
podczas gdy numer polecenia jest pozycją w sekwencji poleceń wykonanych
w obecnej sesji powłoki.
Po zdekodowaniu, łańcuch jest interpretowany poprzez interpretację
parametrów, podstawianie wyników poleceń, interpretację wyrażeń
arytmetycznych, interpretację łańcuchów i usuwanie cytowań, zgodnie
z wartością opcji
.B promptvars
powłoki (zobacz opis polecenia
.B shopt
w sekcji
.SM
.B "WBUDOWANE POLECENIA POWŁOKI"
poniżej).
.SH READLINE
Jest to biblioteka obsługująca odczytywanie wejścia podczas posługiwania się
powłoką interaktywną, chyba że przy wywołaniu powłoki podano opcję
.BR \-\-noediting .
Domyślnie, polecenia edycji wiersza są podobne do występujących w emacsie.
Dostępny jest także interfejs edycji wiersza w stylu vi.
By wyłączyć edycję wiersza po uruchomieniu powłoki, użyj opcji
.B +o emacs
lub
.B +o vi
wbudowanego polecenia
.B set
(zobacz
.SM
.B WBUDOWANE POLECENIA POWŁOKI
poniżej).
.SS "Notacja Readline"
.PP
W tej sekcji, do zapisu naciśnięć klawiszy używana jest notacja w stylu
emacsa. Klawisze kontrolne zapisywane są jako  C\-\fIklawisz\fR, np., C\-n
oznacza Control\-N. Podobnie,
.I meta
klawisze zapisywane są jako M\-\fIklawisz\fR, zatem M\-x oznacza Meta\-X.
(Na klawiaturach bez klawisza
.I meta
M\-\fIx\fP oznacza ESC \fIx\fP, tj. naciśnij klawisz Escape a następnie
klawisz
.IR x .
Czyni to ESC the \fIprzedrostkiem meta\fP (meta prefix).
Kombinacja M\-C\-\fIx\fP oznacza ESC\-Control\-\fIx\fP,
lub naciśnij klawisz Escape, następnie przytrzymaj klawisz Control podczas
naciskania klawisza
.IR x .)
.PP
Poleceniom readline można podawać numeryczne
.IR argumenty ,
które normalnie działają jako licznik powtórzeń.
Czasami jednak, znaczący jest znak argumentu. Przekazanie ujemnego argumentu
poleceniu, które działa w przód (np. \fBkill\-line\fP) powoduje, że będzie
ono działać odwrotnym kierunku (wstecz).
Polecenia, których zachowanie z argumentami odbiega od podanego odnotowano
poniżej.
.PP
Gdy polecenie opisano jako \fIusuwające\fP (killing) tekst, tekst ten jest
zachowywany to ewentualnego późniejszego odzyskania (\fIprzywołania\fP
yanking). Kolejne usunięcia powodują, że tekst jest zbierany w jedną
całość, którą można odzyskać naraz. Polecenia nie usuwające tekstu
oddzielają kawałki tekstu w stosie usuwania (killing ring).
.SS "Inicjalizacja Readline"
.PP
Readline dostosowywane jest przy pomocy poleceń umieszczanych w pliku
inicjującym (plik \fIinputrc\fP).
Nazwa tego pliku brana jest z wartości zmiennej
.SM
.BR INPUTRC .
Jeżeli zmienna ta nie jest ustawiona, domyślną nazwą jest
.IR ~/.inputrc .
Gdy startuje program używający biblioteki readline, odczytywany jest plik
inicjujący, po czym ustawiane są przypisania klawiszy i zmienne.
Istnieje tylko kilka podstawowych konstrukcjii dozwolonych w pliki
inicjacji readline.
Puste wiersze są ignorowane.
Wiersze rozpoczynające się od \fB#\fP są komentarzami.
Wiersze rozpoczynające się od \fB$\fP wskazują konstrukcje warunkowe.
Inne wiersze wyznaczają przypisania klawiszy i ustawienia zmiennych.
.PP
Domyślne przypisania klawiszy można zmienić przy pomocy pliku
.IR inputrc .
Inne programy posługujące się tą biblioteką mogą dodawać własne polecenia
i przypisania.
.PP
Na przykład, umieszczenie
.RS
.PP
M\-Control\-u: universal\-argument
.RE
lub
.RS
C\-Meta\-u: universal\-argument
.RE
w
.I inputrc
spowodowałoby, że M\-C\-u wywoływałoby polecenie readline
.IR universal\-argument .
.PP
Rozpoznawane są następujące symboliczne nazwy znaków:
.IR RUBOUT ,
.IR DEL ,
.IR ESC ,
.IR LFD ,
.IR NEWLINE ,
.IR RET ,
.IR RETURN ,
.IR SPC ,
.IR SPACE
i
.IR TAB .
.PP
Oprócz nazw poleceń readline pozwala przypisywać klawisze do łańcucha.
Łańcuch ten zostanie wstawiony po naciśnięciu klawisza (\fImakro\fP).
.SS "Przypisania klawiszy Readline"
.PP
Składnia przypisań klawiszy sterujących w pliku
.I inputrc
jest prosta. Wymagana jest wyłącznie nazwa polecenia lub tekst makra
i sekwencja klawiszy, do której powinno być przypisane. Klawisze mogą być
podane na dwa sposoby:
jako symboliczna nazwa klawisza, może być z przedrostkami \fIMeta\-\fP
lub \fIControl\-\fP, lub jako sekwencja klawiszy.
.PP
Przy użyciu postaci \fBnazwa-klaw\fP:\^\fInazwa-funkcji\fP lub \fImakro\fP,
.I nazwa-klaw
jest nazwą klawisza zapisaną w jęz.angielskim. Na przykład:
.sp
.RS
Control-u: universal\-argument
.br
Meta-Rubout: backward-kill-word
.br
Control-o: "> output"
.RE
.LP
W powyższym przykładzie,
.I C\-u
przypisane jest do funkcji
.BR universal\-argument ,
.I M\-DEL
przypisane jest do funkcji
.BR backward\-kill\-word
a
.I C\-o
przypisane do uruchamiania makra wyrażonego po prawej (to jest,
wstawiania tekstu
.if t \f(CW> output\fP
.if n ,,> output''
w wiersz).
.PP
W drugiej postaci, \fB"sekw-klaw"\fP:\^\fInazwa-funkcji\fP lub \fImakro\fP,
.B sekw-klaw
różni się od
.B nazwa-klaw
powyżej tym, że przez umieszczenie sekwencji w cudzysłowach można podać
łańcuchy oznaczające całą sekwencję klawiszy. Można posłużyć się niektórymi
kombinacjami klawiszy w stylu GNU Emacs-a, jak w poniższym przykładzie,
nie są jednak rozpoznawane symboliczne nazwy znaków:
.sp
.RS
"\eC\-u": universal\-argument
.br
"\eC\-x\eC\-r": re\-read\-init\-file
.br
"\ee[11~": "Klawisz funkcyjny 1"
.RE
.PP
W tym przykładzie,
.I C\-u
jest ponownie przypisane do funkcji
.BR universal\-argument .
.I "C\-x C\-r"
przypisane jest do funkcji
.BR re\-read\-init\-file ,
zaś
.I "ESC [ 1 1 ~"
przypisane jest do wstawienia tekstu
.if t \f(CWKlawisz funkcyjny 1\fP.
.if n ,,Klawisz funkcyjny 1''.
Oto pełny zestaw sekwencji specjalnych w stylu GNU Emacs
.RS
.PD 0
.TP
.B \eC\-
przedrostek control
.TP
.B \eM\-
przedrostek meta
.TP
.B \ee
znak escape
.TP
.B \e\e
odwrotny ukośnik
.TP
.B \e"
dosłowny cudzysłów "
.TP
.B \e'
dosłowny apostrof '
.RE
.PD
.PP
Oprócz sekwencji specjalnych w stylu GNU Emacsa, dostępny jest drugi zestaw
sekwencji z użyciem odwrotnego ukośnika:
.RS
.PD 0
.TP
.B \ea
alarm (dzwonek)
.TP
.B \eb
backspace
.TP
.B \ed
delete
.TP
.B \ef
wysuw strony (form feed)
.TP
.B \en
nowa linia (newline)
.TP
.B \er
powrót karetki (carriage return)
.TP
.B \et
tabulacja pozioma (horizontal tab)
.TP
.B \ev
tabulacja pionowa (vertical tab)
.TP
.B \e\fInnn\fP
ośmiobitowy znak, którego wartością jest ósemkowa liczba \fInnn\fP
(jedna do trzech cyfr)
.TP
.B \ex\fIHH\fP
ośmiobitowy znak, którego wartością jest szesnastkowa liczba \fInnn\fP
(jedna lub dwie cyfry szesnastkowe)
.RE
.PD
.PP
Podczas wprowadzania tekstu makra, do wskazania jego definicji muszą być
użyte pojedyncze lub podwójne cudzysłowy.
Zakłada się, że tekst niecytowany jest nazwą funkcji.
W ciele makra interpretowane są sekwencje specjalne z użyciem odwrotnego
ukośnika opisane powyżej. odwrotny ukośnik cytuje dowolny inny znak
w tekście makra, łącznie z " i '.
.PP
.B Bash
umożliwia wyświetlanie i zmianę bieżących przypisań klawiszy readline
za pomocą wbudowanego polecenia
.BR bind .
Tryb edycji można przełączać podczas używania interaktywnego przez posłużenie
się opcją
.B \-o
wbudowanego polecenia
.B set
(zobacz poniżej
.SM
.BR "WBUDOWANE POLECENIA POWŁOKI" ).
.SS "Zmienne Readline"
.PP
Readline posiada zmienne, których można używać do dodatkowego dostosowania
jej zachowania. Zmienna może być ustawiana w pliku
.I inputrc
przy pomocy instrukcji postaci
.RS
.PP
\fBset\fP \fInazwa\-zmiennej\fP \fIwartość\fP
.RE
.PP
Z wymienionymi niżej wyjątkami, zmienne readline mogą przyjmować wartości
.B On
lub
.BR Off .
A oto zmienne i ich wartości domyślne:
.PP
.PD 0
.TP
.B bell\-style (audible)
Kontroluje, co dzieje się gdy readline chce użyć sygnału dźwiękowego
terminala. Jeśli ustawiona na \fBnone\fI, readline nigdy nie emituje sygnału.
Jeśli ustawiona na \fBvisible\fP, readline posługuje się "widzialnym
dzwonkiem" (visible bell), jeśli jest dostępny.
Jeżeli ustawiona na \fBaudible\fP, readline usiłuje uzyskać sygnał dźwiękowy
z terminala.
.TP
.B comment\-begin (,,#'')
Łańcuch wstawiany, gdy wykonywane jest polecenie
.B insert\-comment
readline.
Polecenie to jest przypisane do
.B M\-#
w trybie emacs, zaś do
.B #
w trybie vi.
.TP
.B completion\-ignore\-case (Off)
Jeżeli ustawiona na \fBOn\fP, readline wykonuje dopasowywanie i uzupełnianie
nazw plików bez rozróżniania wielkości liter.
.TP
.B completion\-query\-items (100)
Określa, kiedy użytkownik jest pytany o oglądanie takiej liczby możliwych
uzupełnień tworzonych przez polecenie \fBpossible\-completions\fP.
Może być ustawiona na dowolną liczbę całkowitą większą lub równą zero.
Jeżeli liczba możliwych uzupełnień jest większa bądź równa wartości tej
zmiennej, to użytkownik jest pytany czy chce je oglądnąć; w przeciwnym razie
są one po prostu pokazywane na terminalu.
.TP
.B convert\-meta (On)
Jeśli ustawione na \fBOn\fP, readline będzie zamieniał znaki z ustawionym
ósmym bitem na sekwencje klawiszy ASCII przez obcięcie ósmego bitu i
poprzedzenie znakiem escape (w efekcie, używając escape jako
\fIprzedrostka meta\fP).
.TP
.B disable\-completion (Off)
Jeśli ustawione na \fBOn\fP, readline zabroni uzupełniania słów. Znaki
uzupełniania zostaną wstawione w wiersz tak, jakby zostały przypisane do
\fBself-insert\fP.
.TP
.B editing\-mode (emacs)
Kontroluje czy readline rozpoczyna pracę z zestawem przypisań klawiszy
podobnym do \fIemacs\fP czy do \fIvi\fP.
.B editing\-mode
może być ustawiane albo na
.B emacs
albo na
.BR vi .
.TP
.B enable\-keypad (Off)
Gdy jest ustawione na \fBOn\fP, readline będzie usiłować włączyć
numeryczny blok klawiatury (application keypad) przy wywołaniu.
Niektóre systemy potrzebują tego do włączenia klawiszy strzałek.
.TP
.B expand\-tilde (Off)
Jeżeli ustawione na \fBon\fP, podczas próby uzupełniania słów readline
wykonuje interpretację tyldy.
.TP
.B history-preserve-point
Ustawione na \fBon\fP powoduje, że kod obsługi historii poleceń usiłuje
w każdym wierszu poleceń odzyskanym za pomocą \fBprevious-history\fP
lub \fBnext-history\fP umieścić punkt (bieżącą pozycję kursora) w tym
samym miejscu.
.TP
.B horizontal\-scroll\-mode (Off)
Ustawione na \fBOn\fP powoduje, że readline do wyświetlania posługuje się
pojedynczym wierszem. Jeśli wejście jest dłuższe niż szerokość ekranu,
to jego zawartość jest wówczas przewijana w poziomie w pojedynczym wierszu
ekranu, zamiast zawijania do następnego wiersza.
.TP
.B input\-meta (Off)
Jeśli ustawiona na \fBOn\fP, readline dopuści ośmiobitowe wejście (to znaczy,
nie będzie obcinać ósmego bitu z odczytywanych znaków), bez względu na to,
.\" the high bit
co twierdzi terminal o możliwości obsługi. Nazwa
.B meta\-flag
jest synonimem tej zmiennej.
.TP
.B isearch\-terminators (,,C\-[C\-J'')
Łańcuch znaków, który powinien przerywać wyszukiwanie krokowe
(incremental search) bez późniejszego wykonywania znaku jako polecenia.
Jeżeli zmiennej tej nie nadano wartości, to wyszukiwanie krokowe będą
przerywać \fIESC\fP i \fIC\-J\fP.
.TP
.B keymap (emacs)
Ustawia bieżące mapowanie klawiatury readline. Zestawami poprawnych mapowań
są
.IR emacs ,
.IR emacs\-standard ,
.IR emacs\-meta ,
.IR emacs\-ctlx ,
.IR vi ,
.I vi\-command\fP
i
.IR vi\-insert .
\fIvi\fP jest równoważnikiem dla \fIvi\-command\fP; \fIemacs\fP jest
równoważne \fIemacs\-standard\fP. Domyślną wartością jest
.IR emacs ;
wartość
.B editing\-mode
również wpływa na domyślne mapowanie.
.TP
.B mark\-directories (On)
Jeżeli ustawione na \fBOn\fP, to uzupełniane nazwy katalogów mają dołączany
końcowy ukośnik.
.TP
.B mark\-modified\-lines (Off)
Jeżeli ustawione na \fBOn\fP, wiersze historii, które zostały zmienione
wyświetlane są z poprzedzającą je gwiazdką (\fB*\fP).
.TP
.B match\-hidden\-files (On)
Ta zmienna, gdy jest ustawiona na \fBOn\fP, powoduje, że readline wykonując
uzupełnianie nazw plików dopasowuje pliki, których nazwy zaczynają się od
kropki `.' (pliki ukryte), chyba że użytkownik podał taką początkową kropkę
w nazwie, jaka ma być uzupełniona.
.TP
.B output\-meta (Off)
Jeżeli ustawione na \fBOn\fP, readline wyświetla znaki z ustawionym ósmym
bitem wprost zamiast jako sekwencje specjalne z meta-przedrostkiem.
.TP
.B print\-completions\-horizontally (Off)
Jeżeli ustawione na \fBOn\fP, readline wyświetla dopasowane uzupełnienia
w kolejności alfabetycznej poziomo, zamiast w dół ekranu.
.TP
.B show\-all\-if\-ambiguous (Off)
Zmienia to domyślne zachowanie funkcji uzupełniania. Jeżeli jest
ustawione na
.BR on ,
to słowa mające więcej niż jedno możliwe uzupełnienie powodują, że
natychmiast zostaną podane dopasowania zamiast wyemitowania sygnału
dźwiękowego.
.TP
.B visible\-stats (Off)
Jeżeli ustawione na \fBOn\fP, to przy wyświetlaniu możliwych uzupełnień
do nazwy pliku zostanie dołączony znak określający typ pliku wskazywany
przez \fIstat\fP(2).
.PD
.SS "Konstrukcje warunkowe Readline"
.PP
Readline implementuje udogodnienie podobne duchem do funkcji kompilacji
warunkowej preprocesora C, pozwalające na wykonywanie przypisań klawiszy
i ustawień zmiennych w zależności od wyniku testów. Używane są cztery
dyrektywy analizatora składni.
.IP \fB$if\fP
Konstrukcja
.B $if
pozwala na wykonanie przypisań klawiszy w oparciu o tryb edycji, używany
terminal lub aplikację korzystającą z readline. Tekst testu rozciąga się
do końca wiersza; do jego wydzielenia nie są wymagane żadne znaki.
.RS
.IP \fBmode\fP
Postać \fBmode=\fP dyrektywy \fB$if\fP służy do sprawdzania czy readline
jest w trybie emacs czy vi. Może być wykorzystywana, na przykład, w połączeniu
z poleceniem \fBset keymap\fP, do ustawienia przypisań w mapowaniach
\fIemacs\-standard\fP i \fIemacs\-ctlx\fP tylko jeśli readline uruchamia się
w trybie emacs.
.IP \fBterm\fP
Postać \fBterm=\fP można wykorzystywać do włączenia specyficznych dla
terminala przypisań klawiszy, być może do przypisania wyjścia dla sekwencji
klawiszy funkcyjnych terminala. Słowo po prawej stronie
.B =
sprawdzane jest z zarówno pełną nazwą terminala, jaki i częścią jego nazwy
przed pierwszym \fB\-\fP. Umożliwia to, na przykład, dopasowanie przez
.I sun
zarówno
.I sun
jak i
.IR sun\-cmd .
.IP \fBaplikacja\fP
Konstrukcja \fBaplikacja\fP służy do włączania ustawień specyficznych
dla aplikacji. Każdy program korzystający z biblioteki readline ustawia
nazwę aplikacji (\fIapplication name\fP), a plik inicjujący może
sprawdzić czy ma ona jakąś szczególną wartość.
Może to być używane do przypisywania sekwencji klawiszy funkcjom przydatnym
w danym programie. Na przykład, poniższe polecenie dodaje sekwencję klawiszy
wykonującą w bash cytowanie bieżącego lub poprzedniego słowa:
.sp 1
.RS
.nf
\fB$if\fP Bash
# Cytuj bieżące lub poprzednie słowo
"\eC\-xq": "\eeb\e"\eef\e""
\fB$endif\fP
.fi
.RE
.RE
.IP \fB$endif\fP
Polecenie to, jak widać w poprzednim przykładzie, kończy wykonywanie
polecenia \fB$if\fP.
.IP \fB$else\fP
Polecenia w tej gałęzi dyrektywy \fB$if\fP wykonywane są gdy nie powiedzie
się sprawdzenie warunku.
.IP \fB$include\fP
Dyrektywa ta pobiera jako argument pojedynczą nazwę pliku i odczytuje
polecenia i przypisania z tego pliku. Na przykład, poniższa dyrektywa
odczytałaby \fI/etc/inputrc\fP:
.sp 1
.RS
.nf
\fB$include\fP \^ \fI/etc/inputrc\fP
.fi
.RE
.SS Wyszukiwanie
.PP
Readline zapewnia polecenia do wyszukiwania w historii poleceń
(zobacz poniżej
.SM
.BR HISTORIA )
wierszy zawierających zadany łańcuch.
Istnieją dwa tryby wyszukiwania:
.I krokowy
(incremental) i
.IR nie-niekrokowy (non-incremental).
.PP
Wyszukiwania krokowe rozpoczynają się przed zakończeniem wpisywania przez
użytkownika szukanego tekstu.
Po wpisaniu każdego znaków szukanego łańcucha readline wyświetla następną
pozycję historii pasującą do wpisanego do tej pory łańcucha.
Wyszukiwanie krokowe wymaga tylko tylu znaków ile potrzebne jest do
znalezienia pożądanej pozycji historii.
Znaki występujące w wartości zmiennej \fBisearch-terminators\fP służą
do przerwania wyszukiwania krokowego.
Jeżeli zmienna ta nie ma przypisanej wartości, to wyszukiwanie przerywają
znaki Escape i Control-J.
Control-G porzuca wyszukiwanie krokowe i przywraca pierwotny wiersz.
Gdy przerwie się wyszukiwanie, pozycja historii zawierająca poszukiwany
łańcuch staje się bieżącym wierszem.
.PP
W celu odnalezienia innych pasujących pozycji, należy nacisnąć odpowiednio
Control-S lub Control-R.
Wyszukuje to wstecz lub w przód kolejną pasującą do dotychczas wpisanego
łańcucha pozycję historii.
Wszystkie inne sekwencje klawiszy przypisane do polecenia readline przerywają
wyszukiwanie i wykonują zadane polecenie.
Na przykład, znak \fInowej linii\fP przerywa wyszukiwanie i akceptuje
wiersz, wykonując skutkiem tego polecenie z listy historii.
.PP
Readline pamięta łańcuch użyty w ostatnim wyszukiwaniu krokowym. Jeżeli
Control-R zostanie naciśnięte dwa razy, bez wprowadzenia pomiędzy
naciśnięciami innych znaków definiujących nowy łańcuch szukania,
to wykorzystywany jest uprzednio zapamiętany łańcuch.
.PP
Wyszukiwania nie-krokowe czytają cały szukany łańcuch przed rozpoczęciem
wyszukiwania pasujących wierszy historii. Łańcuch może być wpisany przez
użytkownika lub być częścią zawartości bieżącego wiersza.
.SS "Nazwy poleceń Readline"
.PP
Poniżej podano listę nazw poleceń i domyślnych sekwencji klawiszy, do
których są one przypisane.
Nazwy poleceń bez towarzyszącej sekwencji klawiszy są domyślnie nieprzypisane.
W poniższych opisach, \fIpunkt\fP oznacza bieżącą pozycję kursora, zaś
\fIzaznaczenie\fP do pozycji kursora zapamiętanej przez polecenie
\fBset\-mark\fP.
Tekst pomiędzy punktem a zaznaczeniem nazywany jest \fIobszarem\fP.
.SS Polecenia ruchu
.PP
.PD 0
.TP
.B beginning\-of\-line (C\-a)
Przesuwa na początek bieżącego wiersza.
.TP
.B end\-of\-line (C\-e)
Przesuwa na koniec wiersza.
.TP
.B forward\-char (C\-f)
Przesuwa o znak w przód.
.TP
.B backward\-char (C\-b)
Przesuwa o znak wstecz.
.TP
.B forward\-word (M\-f)
Przesuwa na koniec następnego słowa. Słowa złożone są ze znaków
alfanumerycznych (liter i cyfr).
.TP
.B backward\-word (M\-b)
Przesuwa na początek bieżącego, lub poprzedniego, słowa. Słowa złożone są
ze znaków alfanumerycznych (liter i cyfr).
.TP
.B clear\-screen (C\-l)
Czyści ekran pozostawiając bieżący wiersz na górze ekranu. Z argumentem,
odświeża bieżący wiersz bez czyszczenia ekranu.
.TP
.B redraw\-current\-line
Odświeża bieżący wiersz.
.PD
.SS Polecenia operujące na historii
.PP
.PD 0
.TP
.B accept\-line (Newline, Return)
Akceptuje wiersz bez względu na to, gdzie znajduje się kursor. Jeżeli
wiersz ten nie jest pusty, to dodaje go do listy historii stosownie do
stanu zmiennej
.SM
.BR HISTCONTROL .
Jeżeli wiersz jest zmienionym wierszem historii, to odtwarza wiersz
historii do stanu pierwotnego.
.TP
.B previous\-history (C\-p)
Śprowadza poprzednie polecenie z listy historii, przesuwając się wstecz listy.
.TP
.B next\-history (C\-n)
Ściąga następne polecenie z listy historii, przesuwając się do przodu na
liście.
.TP
.B beginning\-of\-history (M\-<)
Przesuwa na pierwszy wiersz w historii.
.TP
.B end\-of\-history (M\->)
Przesuwa na koniec historii wprowadzania, tj. obecnie wprowadzanego
wiersza.
.TP
.B reverse\-search\-history (C\-r)
Wyszukuje wstecz poczynając od bieżącego wiersza i przesuwając się, w razie
potrzeby, 'w górę' historii. Jest to wyszukiwanie krokowe.
.TP
.B forward\-search\-history (C\-s)
Wyszukuje w przód poczynając od bieżącego wiersza i przesuwając się, w
razie potrzeby, 'w dół' historii. Jest to wyszukiwanie krokowe.
.TP
.B non\-incremental\-reverse\-search\-history (M\-p)
Wyszukuje wstecz poczynając od bieżącego wiersza posługując się
wyszukiwaniem nie-krokowym podanego przez użytkownika łańcucha.
.TP
.B non\-incremental\-forward\-search\-history (M\-n)
Wyszukuje w przód poczynając od bieżącego wiersza posługując się
wyszukiwaniem nie-krokowym podanego przez użytkownika łańcucha.
.TP
.B history\-search\-forward
Wyszukuje w przód w historii łańcucha znaków pomiędzy początkiem bieżącego
wiersza a punktem.
Jest to wyszukiwanie nie-krokowe.
.TP
.B history\-search\-backward
Wyszukuje wstecz w historii łańcucha znaków pomiędzy początkiem bieżącego
wiersza a bieżącą pozycją kursora (\fIpunkt\fP).
Jest to wyszukiwanie nie-krokowe.
.TP
.B yank\-nth\-arg (M\-C\-y)
Wstawia pierwszy argument poprzedniego polecenia (zwykle drugie słowo
z poprzedniego wiersza) w punkt (bieżącą pozycję kursora). Z argumentem
.IR n ,
wstawia \fIn\fP-te słowo poprzedniego polecenia (słowa w poprzednim
poleceniu zaczynają się od słowa 0). Argument ujemny wstawia \fIn\fP-te
słowo od końca poprzedniego polecenia.
.TP
.B
yank\-last\-arg (M\-.\^, M\-_\^)
Wstawia ostatni argument poprzedniego polecenia (ostatnie słowo poprzedniej
pozycji historii). Z argumentem, zachowuje się dokładnie tak, jak
\fByank\-nth\-arg\fP.
Kolejne wywołania \fByank\-last\-arg\fP przesuwają wstecz listy historii,
wstawiając po kolei ostatni argument każdego wiersza.
.TP
.B shell\-expand\-line (M\-C\-e)
Interpretuj wiersz, jak czyni to powłoka. Wykonuje to aliasy
i interpretację historii, jak również interpretację słów powłoki. Zobacz
.SM
.B INTERPRETACJA HISTORII
poniżej.
.TP
.B history\-expand\-line (M\-^)
Wykonuje interpretację powłoki w odniesieniu do bieżącego wiersza.
Zobacz
.SM
.B INTERPRETACJA HISTORII
poniżej.
.TP
.B magic\-space
Wykonuje interpretację powłoki w odniesieniu do bieżącego wiersza i wstawia
spację.
Zobacz
.SM
.B INTERPRETACJA HISTORII
poniżej.
.TP
.B alias\-expand\-line
Wykonuje interpretację aliasów w odniesieniu do bieżącego wiersza.
Zobacz
.SM
.B ALIASY
powyżej.
.TP
.B history\-and\-alias\-expand\-line
Wykonuje interpretację historii i aliasów w odniesieniu do bieżącego
wiersza.
.TP
.B insert\-last\-argument (M\-.\^, M\-_\^)
Synonim \fByank\-last\-arg\fP.
.TP
.B operate\-and\-get\-next (C\-o)
Akceptuje do wykonania bieżący wiersz i ściąga do edycji następny
względem bieżącego wiersz z historii. Argumenty są ignorowane.
.PD
.SS Polecenia zmiany tekstu
.PP
.PD 0
.TP
.B delete\-char (C\-d)
Usuwa znak w punkcie (pod kursorem).
Jeżeli punkt jest początkiem wiersza, nie ma żadnych znaków w wierszu,
a ostatni wpisany znak został przypisany do \fBdelete\-char\fP, to zwraca
.SM
.BR EOF .
.TP
.B backward\-delete\-char (Rubout)
Usuwa znak przed kursorem. Jeżeli podano argument numeryczny, zachowuje
usunięty tekst na stosie usunięć.
.\" on the kill ring.
.TP
.B forward\-backward\-delete\-char
Usuwa znak pod kursorem, chyba że kursor znajduje się na końcu wiersza,
wówczas usuwany jest znak przed kursorem.
.TP
.B quoted\-insert (C\-q, C\-v)
Dodaje następny znak do wiersza dosłownie. W ten sposób wstawiane są znaki
takie, jak na przykład \fBC\-q\fP.
.TP
.B tab\-insert (C\-v TAB)
Wstawia znak tabulacji.
.TP
.B self\-insert (a,\ b,\ A,\ 1,\ !,\ ...)
Wstawia wpisany znak.
.TP
.B transpose\-chars (C\-t)
Zamienia miejscami znak sprzed punktu ze znakiem w punkcie, równocześnie
przesuwając punkt w przód. Jeżeli punkt jest na końcu wiersza to
zamienia to miejscami dwa znaki przed punktem. Argumenty ujemne nie skutkują.
.TP
.B transpose\-words (M\-t)
Zamienia miejscami słowo sprzed punktu ze słowem za punktem, przesuwając
równocześnie punkt za przesunięte sprzed niego słowo.
Jeżeli punkt jest na końcu wiersza to zamienia to miejscami dwa ostanie słowa
wiersza.
.TP
.B upcase\-word (M\-u)
Zamienia na wielkie litery bieżące (lub następne) słowo. Z argumentem ujemnym
zamienia na wielkie litery poprzednie słowo, ale nie przesuwa punktu.
.TP
.B downcase\-word (M\-l)
Zamienia na małe litery bieżące (lub następne) słowo. Z argumentem ujemnym
zamienia na małe litery poprzednie słowo, ale nie przesuwa punktu.
.TP
.B capitalize\-word (M\-c)
Zamienia na kapitaliki (pierwsza litera wielka, pozostałe małe) bieżące
(następne) słowo. Z argumentem ujemnym zamienia na kapitaliki poprzednie
słowo, ale nie przesuwa punktu.
.PD
.SS Usuwanie i wklejanie
.PP
.PD 0
.TP
.B kill\-line (C\-k)
Usuwa tekst od punktu do końca wiersza.
.TP
.B backward\-kill\-line (C\-x Rubout)
Usuwa wstecz do początku wiersza.
.TP
.B unix\-line\-discard (C\-u)
Usuwa wstecz od punktu do początku wiersza. Usuwany tekst jest zachowywany
na stosie usunięć.
.\" Nie ma żadnej faktycznej różnicy między tym a backward-kill-line
.TP
.B kill\-whole\-line
Usuwa wszystkie znaki bieżącego wiersza, bez względu na położenie punktu.
.TP
.B kill\-word  (M\-d)
Usuwa od punktu do końca bieżącego słowa, lub jeśli użyte pomiędzy
słowami, do końca następnego słowa. Granice słów są takie same, jak używane
przez \fBforward\-word\fP.
.TP
.B backward\-kill\-word (M\-Rubout)
Usuwa słowo sprzed punktu. Granice słów są takie same, jak używane
przez \fBbackward\-word\fP.
.TP
.B unix\-word\-rubout (C\-w)
Usuwa słowo sprzed punktu, jako separatora słów używając białych znaków.
Usunięty tekst zachowywany jest na stosie usunięć.
.TP
.B delete\-horizontal\-space (M\-\e)
Usuwa wszystkie spacje i tabulatory wokół punktu.
.TP
.B kill\-region
Usuwa tekst w bieżącym obszarze.
.TP
.B copy\-region\-as\-kill
Kopiuje tekst obszaru do bufora usuwania.
.TP
.B copy\-backward\-word
Kopiuje słowo sprzed punktu do bufora usuwania.
Granice słów są takie same, jak dla \fBbackward\-word\fP.
.TP
.B copy\-forward\-word
Kopiuje słowo występujące po punkcie do bufora usuwania.
Granice słów są takie same, jak dla \fBforward\-word\fP.
.TP
.B yank (C\-y)
Wkleja wierzchołek stosu usunięć do bufora w punkcie (w miejscu kursora).
.TP
.B yank\-pop (M\-y)
Obraca stos usunięć i wkleja nowy wierzchołek. Działa tylko następując po
.B yank
lub
.BR yank\-pop .
.PD
.SS Argumenty numeryczne
.PP
.PD 0
.TP
.B digit\-argument (M\-0, M\-1, ..., M\-\-)
Dodaje tę cyfrę do już składanego argumentu lub rozpoczyna nowy argument.
M\-\- rozpoczyna argument ujemny.
.TP
.B universal\-argument
Jest to inna metoda podawania argumentu.
Jeżeli po tym poleceniu występuje jedna lub więcej cyfr, z opcjonalnym
początkowym znakiem minus, to cyfry te definiują argument.
Jeżeli po poleceniu występują cyfry, to powtórne wykonanie
.B universal\-argument
kończy argument numeryczny, ale w przeciwnym wypadku jest ignorowane.
W przypadku specjalnym, jeżeli bezpośrednio po tym poleceniu występuje
znak nie będący ani cyfrą ani znakiem minus, to argument licznik dla
następnego polecenia mnożony jest przez cztery.
Argument licznik [zwykle powtórzeń] wynosi początkowo cztery, toteż
wykonanie tej funkcji po raz pierwszy nadaje mu wartość cztery, po raz
drugi szesnaście, i tak dalej.
.PD
.SS Uzupełnianie
.PP
.PD 0
.TP
.B complete (TAB)
Usiłuje przeprowadzić uzupełnianie tekstu przed punktem.
.B Bash
próbuje uzupełniania traktując tekst kolejno: jako zmienną (jeżeli tekst
zaczyna się od \fB$\fP), nazwę użytkownika (jeśli tekst zaczyna się od
\fB~\fP), nazwę hosta (i jeśli tekst zaczyna się od \fB@\fP) lub polecenie
(łącznie z aliasami i funkcjami). Jeżeli żadne z powyższych nie daje
dopasowania, to próbowane jest uzupełnianie nazw plików.
.TP
.B possible\-completions (M\-?)
Pokazuje możliwe uzupełnienia tekstu przed punktem.
.TP
.B insert\-completions (M\-*)
Wstawia przed punktem wszystkie uzupełnienia tekstu, które zostałyby
wygenerowane przez \fBpossible\-completions\fP.
.TP
.B menu\-complete
Podobne do \fBcomplete\fP, ale zastępuje słowo, jakie ma zostać
uzupełnione pojedynczym uzupełnieniem z listy możliwych.
Powtarzane wykonanie \fBmenu\-complete\fP powoduje krokowe przechodzenie
przez listę możliwych uzupełnień i wstawianie każdego z nich po kolei
(zamiast uzupełnianego słowa).
Na końcu listy uzupełnień emitowany jest sygnał dźwiękowy (zależny od
ustawienia \fBbell\-style\fP) i przywracany jest pierwotny tekst.
Argument \fIn\fP przesuwa \fIn\fP pozycji w przód na liście dopasowań;
do przesuwania się wstecz można użyć argumentu ujemnego. Polecenie
w zamierzeniu ma być przypisane do klawisza \fBTAB\fP, ale domyślnie
nie jest przypisane.
.TP
.B delete\-char\-or\-list
Usuwa znak pod kursorem, jeśli nie jest to początek bądź koniec wiersza
(jak \fBdelete\-char\fP). Na końcu wiersza, zachowuje się identycznie jak
\fBpossible\-completions\fP. To polecenie jest domyślnie nieprzypisane.
.TP
.B complete\-filename (M\-/)
Usiłuje wykonać uzupełnianie nazw plików na tekście sprzed kursora.
.TP
.B possible\-filename\-completions (C\-x /)
Pokazuje możliwe uzupełnienia tekstu sprzed kursora, traktując go jak nazwę
pliku.
.TP
.B complete\-username (M\-~)
Usiłuje wykonać uzupełnianie tekstu sprzed kursora, traktując go jak nazwę
użytkownika.
.TP
.B possible\-username\-completions (C\-x ~)
Pokazuje możliwe uzupełnienia tekstu sprzed kursora, traktując go jak nazwę
użytkownika.
.TP
.B complete\-variable (M\-$)
Usiłuje wykonać uzupełnianie tekstu sprzed kursora, traktując go jak
zmienną powłoki.
.TP
.B possible\-variable\-completions (C\-x $)
Pokazuje możliwe uzupełnienia tekstu sprzed kursora, traktując go jak
zmienną powłoki.
.TP
.B complete\-hostname (M\-@)
Usiłuje wykonać uzupełnianie tekstu sprzed kursora, traktując go jak
nazwę hosta.
.TP
.B possible\-hostname\-completions (C\-x @)
Pokazuje możliwe uzupełnienia tekstu sprzed kursora, traktując go jak
nazwę hosta.
.TP
.B complete\-command (M\-!)
Usiłuje uzupełnić tekst sprzed punktu, traktując go jak nazwę polecenia.
Uzupełnianie polecenia próbuje dopasować tekst kolejno do aliasów, słów
zastrzeżonych, funkcji powłoki, poleceń wbudowanych powłoki i wreszcie
nazw plików wykonywalnych.
.TP
.B possible\-command\-completions (C\-x !)
Pokazuje możliwe uzupełnienia tekstu sprzed kursora, traktując go jak
nazwę polecenia.
.TP
.B dynamic\-complete\-history (M\-TAB)
Usiłuje uzupełnić tekst sprzed kursora, w celu odnalezienia
możliwych uzupełnień porównując go z wierszami listy historii.
.TP
.B complete\-into\-braces (M\-{)
Wykonuje uzupełnianie nazwy pliku i wstawia listę możliwych uzupełnień ujętą
w nawiasy klamrowe, tak że jest ona dostępna dla powłoki (zobacz powyżej
.BR "Interpretacja nawiasów" ).
.PD
.SS Makra klawiaturowe
.PP
.PD 0
.TP
.B start\-kbd\-macro (C\-x (\^)
Rozpoczyna zachowywanie wpisywanych znaków w bieżącym makrze klawiaturowym.
.TP
.B end\-kbd\-macro (C\-x )\^)
Zatrzymuje zachowywanie wpisywanych znaków w bieżącym makrze klawiaturowym
i przechowuje definicję.
.TP
.B call\-last\-kbd\-macro (C\-x e)
Ponownie wykonuje zdefiniowane makro klawiaturowe, powodując
pojawianie się znaków makra tak, jakby zostały wpisane z klawiatury.
.PD
.SS Różne
.PP
.PD 0
.TP
.B re\-read\-init\-file (C\-x C\-r)
Odczytuje zawartość pliku \fIinputrc\fP i dołącza wszystkie
znalezione tam przypisania klawiszy i zmiennych.
.TP
.B abort (C\-g)
Zaniechuje bieżącego polecenia edycji i emituje sygnał dźwiękowy terminala
(zgodnie z ustawieniami
.BR bell\-style ).
.TP
.B do\-uppercase\-version (M\-a, M\-b, M\-\fIx\fP, ...)
Jeżeli poprzedzony przedrostkiem meta znak \fIx\fP jest małą literą,
uruchamia plecenie, które jest przypisane do odpowiedniej wielkiej litery.
.TP
.B prefix\-meta (ESC)
Poprzedź przedrostkiem meta następny wpisany znak.
.SM
.B ESC
.B f
jest równoważne
.BR Meta\-f .
.TP
.B undo (C\-_, C\-x C\-u)
Krokowe cofnięcie operacji, pamiętane odrębnie dla każdego wiersza.
.TP
.B revert\-line (M\-r)
Cofa wszystkie zmiany wykonane na tym wierszu. Podobne do wykonania
polecenia
.B undo
wystarczająco wiele razy, by przywrócić wiersz do stanu początkowego.
.TP
.B tilde\-expand (M\-&)
Wykonuje interpretację tyldy w odniesieniu do bieżącego słowa.
.TP
.B set\-mark (C\-@, M\-<space>)
ustawia znacznik (mark) w bieżącym punkcie. Jeżeli podano argument
numeryczny, znacznik jest ustawiany na takiej pozycji.
.TP
.B exchange\-point\-and\-mark (C\-x C\-x)
Zamień punkt ze znacznikiem. Aktualna pozycja kursora ustawiana jest na
zapamietaną, a dotychczasowa pozycja zachowywana jako znacznik.
.TP
.B character\-search (C\-])
Odczytywany jest znak a punkt przesuwa się na następne wystąpienie tego
znaku. Licznik ujemny wyszukuje poprzednie wystąpienia.
.TP
.B character\-search\-backward (M\-C\-])
Odczytywany jest znak a punkt przesuwa się na poprzednie wystąpienie tego
znaku. Licznik ujemny wyszukuje kolejne wystąpienia.
.TP
.B insert\-comment (M\-#)
Na początek bieżąceg wiersza wstawiana jest wartość zmiennej
.B comment\-begin
readline,
a wiersz jest akceptowany tak, jakby wprowadzono znak nowej linii.
Domyślna wartość \fBcomment\-begin\fP powoduje, że polecenie to czyni
bieżący wiersz komentarzem powłoki.
.TP
.B glob\-expand\-word (C\-x *)
Słowo sprzed kursora traktowane jest jak wzorzec rozwijania nazw plików
i wstawiana jest lista pasujących nazw, zastępując słowo-wzorzec.
.TP
.B glob\-list\-expansions (C\-x g)
Wyświetlana jest lista rozwinięć, jakie zostałyby utworzone przez
.BR glob\-expand\-word,
a wiersz jest ponownie wyświetlany.
.TP
.B dump\-functions
Wypisuje do strumienia wyjściowego readline wszystkie funkcje i ich
przypisania klawiszy. Jeżeli podano argument numeryczny, wyjście jest
formatowane w taki sposób, by można zrobić je częścią pliku \fIinputrc\fP.
.TP
.B dump\-variables
Wypisuje do strumienia wyjściowego readline wszystkie ustawialne zmienne
readline i ich wartości. Jeżeli podano argument numeryczny, wyjście jest
formatowane w taki sposób, by można zrobić je częścią pliku \fIinputrc\fP.
.TP
.B dump\-macros
Wypisuje wszystkie sekwencje klawiszy readline przypisane do makr
i łańcuchy jakie dają w wyniku.  Jeżeli podano argument numeryczny,
wyjście  jest formatowane w taki sposób, by można zrobić je częścią pliku
\fIinputrc\fP.
.TP
.B display\-shell\-version (C\-x C\-v)
Wyświetla informację o wersji aktualnego egzemplarza
.BR bash .
.PD
.SS Programowalne uzupełnianie
.PP
Gdy następuje próba uzupełnienia słowa dla argumentu polecenia, dla którego
zdefiniowano specyfikację uzupełniania (completion specification,
\fIcompspec\fP) przy pomocy wbudowanego polecenia \fBcomplete\fP (zobacz
.SM
.B "WBUDOWANE POLECENIA POWŁOKI"
poniżej), wywoływane są usługi programowalnego uzupełniania.
.PP
Po pierwsze, identyfikowana jest nazwa polecenia.
Jeżeli dla tego polecenia zdefiniowano compspec, to compspec jest używane
do utworzenia listy możliwych uzupełnień słowa.
Jeżeli słowo polecenia jest pełną nazwą ścieżkową, to najpierw szukane jest
compspec dla pełnej nazwy.
Jeśli nie zostanie odnalezione, to następuje próba znalezienia compspec dla
części występującej po ostatnim ukośniku.
.PP
Po odnalezieniu compspec, jest ono używane do utworzenia listy pasujących
słów.
Jeżeli compspec nie zostało znalezione, to wykonywane jest domyślne
uzupełnianie \fBbash\fPa, jak opisano powyżej w \fBUzupełnianie\fP.
.PP
Na początek, używane są akcje określone przez compspec. Zwracane są wyłącznie
dopasowania poprzedzone dopasowywanym słowem.
Gdy do uzupełniania nazw plików lub katalogów użyto opcji
.B \-f
lub
.BR \-d ,
do filtrowania dopasowań wykorzystywana jest zmienna powłoki
.SM
.BR FIGNORE .
.PP
W następnej kolejności tworzone są ewentualne uzupełnienia określone przez
wzorzec rozwinięcia nazw plików opcji \fB\-G\fP.
Słowa tworzone przez wzorzec nie muszą pasować do uzupełnianego słowa.
Zmienna powłoki
.SM
.B GLOBIGNORE
nie jest używana do filtrowania dopasowań, ale zmienna
.SM
.B FIGNORE
jest używana.
.PP
Następnie, brany jest pod uwagę łańcuch podany jako argument opcji \fB\-W\fP.
Łańcuch jest najpierw rozbijany przy zastosowaniu znaków ze zmiennej
specjalnej
.SM
.B IFS
jako separatorów.
Honorowane jest cytowanie powłoki.
Później każde ze słów interpretowane jest z wykorzystaniem
interpretacji nawiasów, interpretacji tyld, podstawiania parametrów,
interpretacji zmiennych i wyrażeń arytmetycznych, podstawiania wyników
poleceń i rozwijania nazw ścieżkowych, jak opisano powyżej w sekcji
.SM
.BR INTERPRETACJA .
Wyniki są rozbijane z zastosowaniem reguł opisanych powyżej w sekcji
\fBPodział na słowa\fP.
Wyniki interpretacji są dopasowywane przedrostkiem z uzupełnianym słowem,
a pasujące słowa stają się możliwymi uzupełnieniami.
.PP
Po utworzeniu tych dopasowań, wywoływana jest funkcja lub polecenie
określone opcjami \fB\-F\fP i \fB\-C\fP.
Podczas wywoływania polecenia czy funkcji, zmiennym
.SM
.B COMP_LINE
i
.SM
.B COMP_POINT
przypisywane są wartości, jak opisano to powyżej w sekcji \fBZmienne
powłoki\fP.
Jeżeli wywoływana jest funkcja powłoki, ustawiane są również zmienne
.SM
.B COMP_WORDS
i
.SM
.BR COMP_CWORD .
Kiedy wywoływana jest funkcja czy polecenie, pierwszym argumentem staje się
nazwa polecenia, którego argumenty są uzupełniane, drugim argumentem \-\-
uzupełniane słowo, a trzecim słowo poprzedzające w wierszu poleceń słowo
aktualnie uzupełniane.
Nie jest wykonywane żadne filtrowanie utworzonych uzupełnień stosownie do
uzupełnianego słowa. Funkcja czy polecenie mają pełną swobodę tworzenia
dopasowań.
.PP
W pierwszej kolejności wywoływana jest funkcja określona przez \fB\-F\fP.
Do tworzenia dopasowań może ona korzystać z dowolnych możliwości powłoki,
łącznie z opisanym poniżej poleceniem wbudowanym \fBcompgen\fP.
Funkcja musi umieścić możliwe uzupełnienia w zmiennej tablicowej
.SM
.BR COMPREPLY .
.PP
Następnie, wywoływane jest polecenie określone opcją \fB\-C\fP, działające
w środowisku równoważnym podstawianiu poleceń.
Powinno ono wypisać listę uzupełnień, po jednym w wierszu, na standardowe
wyjście.
Jeżeli jest to niezbędne, do utworzenia znaku nowej linii można użyć
odwróconego ukośnika.
.PP
Po utworzeniu wszelkich możliwych uzupełnień, do listy tej stosowany jest
filtr określony opcją \fB\-X\fP.
Filtr jest takim wzorcem, jak używany przy rozwijaniu nazw ścieżkowych.
Znak \fB&\fP we wzorcu zastępowany jest tekstem uzupełnianego słowa.
Literał \fB&\fP można otrzymać poprzedzając go odwrotnym ukośnikiem;
odwrotny ukośnik zostanie usunięty przed próbą dopasowania.
Wszystkie uzupełnienia pasujące do wzorca będą usunięte z listy.
Początkowy \fB!\fP daje zaprzeczenie wzorca. Będą wówczas usuwane uzupełnienia
nie pasujące do wzorca.
.PP
Na koniec, do każdego elementu listy dodawane są przedrostek i przyrostek
określone opcjami \fB\-P\fP i \fB\-S\fP, a wynik zwracany jest do kodu
uzupełniania readline jako lista możliwych uzupełnień.
.PP
Jeśli poprzednio zastosowane działania nie utworzyły żadnych dopasowań,
zaś przy definiowaniu compspec podano opcję \fB\-o dirnames\fP polecenia
\fBcomplete\fP, to dokonywana jest próba uzupełnienia nazwy katalogu.
.PP
Domyślnie, jeżeli znaleziono compspec, to cokolwiek ono utworzy zwracane
jest do kodu uzupełniającego jako pełny zestaw możliwych uzupełnień.
Nie są próbowane domyślne uzupełnienia \fBbash\fP, a domyślne uzupełnianie
nazw ścieżkowych przez readline jest wyłączone.
Jeśli przy definiowaniu compspec podano opcję \fB\-o default\fP polecenia
\fBcomplete\fP, to jeżeli compspec nie utworzy żadnych uzupełnień, wykonane
zostanie domyślne uzupełnianie z readline.
.SH HISTORIA
Jeżeli włączona jest opcja
.B \-o history
wbudowanego polecenia
.BR set ,
to powłoka zapewnia dostęp do \fIhistorii poleceń\fP, listy poleceń
poprzednio wprowadzonych.
Wartość zmiennej \fBHISTSIZE\fP wykorzystywana jest jako liczba poleceń
do zachowania na liście historii.
Zachowywany jest tekst ostatnich
.SM
.B HISTSIZE
poleceń (domyślnie 500. Powłoka
przechowuje każde polecenie na liście przed podstawieniem wartości
parametrów i zmiennych (zobacz powyżej
.SM
.BR INTERPRETACJA ),
ale przed wykonaniem interpretacji historii, w zależności od wartości
zmiennych powłoki
.SM
.B HISTIGNORE
i
.SM
.BR HISTCONTROL .
.PP
Przy uruchamianiu, historia inicjowana jest z pliku o nazwie wskazanej
zmienną
.SM
.B HISTFILE
(domyślnie \fI~/.bash_history\fP). Plik o nazwie wziętej z wartości
.SM
.B HISTFILE
jest obcinany, jeśli zachodzi potrzeba, by zawierał nie więcej wierszy niż
określono to wartością zmiennej
.SM
.BR HISTFILESIZE .
Podczas kończenia pracy powłoki interaktywnej, ostatnie
.SM
.B $HISTSIZE
wierszy kopiowane jest z listy historii do
.SM
.BR $HISTFILE .
Jeżeli włączona jest opcja powłoki
.B histappend
(zobacz opis
.B shopt
w sekcji
.SM
.B "WBUDOWANE POLECENIA POWŁOKI"
poniżej), to wiersze są dodawane na koniec pliku historii, w przeciwnym
razie plik historii jest nadpisywany.
Jeżeli
.SM
.B HISTFILE
nie jest ustawione lub plik historii nie daje się zapisać, to historia nie
jest zachowywana. Po zapisaniu, plik historii jest obcinany, by nie zawierał
więcej niż
.SM
.B HISTFILESIZE
wierszy. Jeśli
.SM
.B HISTFILESIZE
nie jest ustawione, to obcinanie nie jest wykonywane.
.PP
Do edycji lub ponownego wykonania części listy historii można korzystać
z wbudowanego polecenia
.B fc
(zobacz
.SM
.B WBUDOWANE POLECENIA POWŁOKI
poniżej).
Wbudowanego polecenia
.B history
można używać do wyświetlania lub zmiany listy historii i manipulacji plikiem
historii.
Podczas posługiwania się edycją wiersza poleceń, w każdym z trybów edycji
umożliwiających dostęp do listy historii, dostępne są polecenia przeszukiwania.
.PP
Powłoka umożliwia kontrolę nad tym, jakie polecenia są zachowywane na liście.
Można ustawić zmienne
.SM
.B HISTCONTROL
i
.SM
.BR HISTIGNORE,
co spowoduje, że powłoka będzie zachowywać tylko podzbiór wprowadzonych
poleceń.
Opcja powłoki
.BR cmdhist ,
jeżeli jest włączona, powoduje, że powłoka będzie usiłować zachować każdy
wiersz polecenia wielowierszowego w tej samej pozycji historii, dodając,
gdzie jest to niezbędne, średniki, by zachować poprawność składni.
Opcja powłoki
.B lithist
powoduje, że powłoka będzie zachowywać polecenia z osadzonymi znakami nowej
linii zamiast średników. Zobacz opis wbudowanego
.B shopt
poniżej, w sekcji
.SM
.BR "WBUDOWANE POLECENIA POWŁOKI" ,
gdzie znajdziesz informacje o ustawianiu i kasowaniu opcji powłoki.
.SH "INTERPRETACJA HISTORII"
.PP
Powłoka obsługuje funkcję interpretacji historii, podobną do interpretacji
historii w
.BR csh .
Ta sekcja opisuje dostępne możliwości składni. Funkcja ta jest domyślnie
włączona dla powłok interaktywnych i może być wyłączona przy pomocy opcji
.B \+H
wbudowanego polecenia
.B set
(zobacz poniżej
.SM
.BR "WBUDOWANE POLECENIA POWŁOKI" ).
Powłoki nie-interaktywne domyślnie nie wykonują interpretacji historii.
.PP
Interpretacja historii wprowadza słowa z listy historii do strumienia
wejściowego, ułatwiając powtarzanie poleceń lub poprawianie szybkie błędów
w poprzednich poleceniach.
.PP
Interpretacja historii przeprowadzana jest bezpośrednio po przeczytaniu
pełnego wiersza, przed jego podziałem na słowa przez powłokę.
Odbywa się w dwu częściach.
Pierwszą jest określenie, który wiersz z listy historii ma zostać użyty
podczas podstawiania.
Drugą stanowi wybór części tego wiersza do włączenia w bieżący.
Wybrany z historii wiersz jest \fIzdarzeniem\fP (event), a jego części
na których wykonywane są działania są \fIsłowami\fP.
Dostępne są różne \fImodyfikatory\fP do manipulowania wybranymi słowami.
Wiersz rozbijany jest na słowa w ten sam sposób jak podczas odczytu
wejścia, tak że kilka słów separowanych \fImetaznakami\fP ujętych
w cudzysłowy traktowanych jest jak jedno słowo.
Interpretacja historii wprowadzana są obecnością znaku rozwijającego
historię, którym domyślnie jest \^\fB!\fP\^.
Cytować ten znak mogą wyłącznie odwrotny ukośnik (\^\fB\e\fP\^)
i pojedyncze cudzysłowy.
.PP
Kilka opcji powłoki ustawianych przy pomocy
.B shopt
może służyć do śledzenia działania interpretacji historii.
Jeżeli opcja
.B histverify
powłoki jest włączona (zobacz opis wbudowanego
.BR shopt )
i używane jest
.BR readline ,
to podstawienia historii nie są natychmiast przesyłane do analizatora
składni (parsera) powłoki.
Zamiast tego, zinterpretowany wiersz jest ponownie ładowany do bufora
edycyjnego
.B readline
w celu dalszej modyfikacji.
Jeżeli wykorzystywane jest
.B readline
i włączona jest opcja
.BR histreedit ,
to zakończone niepowodzeniem podstawienie historii zostanie ponownie
załadowane do bufora edycyjnego
.B readline
w celu poprawienia.
Opcją
.B \-p
wbudowanego polecenia
.B history
można posłużyć się do oglądnięcia, co zrobi interpretacja historii
przed jej zastosowaniem.
Opcji
.B \-s
wbudowanego polecenia
.B history
można użyć w celu dodania poleceń na koniec listy historii bez faktycznego
ich wykonania, tak że będą dostępne dla następnych przywołań.
.PP
Powłoka pozwala na kontrolowanie różnych znaków stosowanych przez mechanizm
interpretacji historii (zobacz opis
.B histchars
powyżej, w sekcji
.BR "Zmienne powłoki" ).
.SS Desygnatory zdarzeń (Event Designators)
.PP
Desygnator zdarzenia jest odwołaniem do pozycji wiersza poleceń na liście
historii.
.PP
.PD 0
.TP
.B !
Rozpoczyna podstawianie historii, z wyjątkiem sytuacji, gdy występuje
po nim odstęp, znak nowej linii, = lub (.
.TP
.B !\fIn\fR
Wskazuje na
.IR n -ty
wiersz poleceń.
.TP
.B !\-\fIn\fR
Wskazuje na wiersz poleceń bieżący minus
.IR n .
.TP
.B !!
Wskazuje na poprzednie polecenie. jest to synonim `!\-1'.
.TP
.B !\fIłańcuch\fR
Wskazuje na ostatnie poleceniem rozpoczynające się od
.IR łańcucha .
.TP
.B !?\fIłańcuch\fR\fB[?]\fR
Wskazuje na ostatnie polecenie zawierające
.IR łańcuch .
Kończące \fB?\fP można pominąć jeśli bezpośrednio po
.I łańcuchu
występuje znak nowej linii.
.TP
.B \d\s+2^\s-2\u\fIłańcuch1\fP\d\s+2^\s-2\u\fIłańcuch2\fP\d\s+2^\s-2\u
Szybkie podstawianie. Powtarza ostatnie polecenie, wymieniając
.I łańcuch1
na
.IR łańcuch2 .
Rónoważnik
,,!!:s/\fIłańcuch1\fP/\fIłańcuch\fP/''
(zobacz poniżej \fBModyfikatory\fP).
.TP
.B !#
Cały wiersz poleceń wpisany do tego momentu.
.PD
.SS Desygnatory słów (Word Designators)
.PP
Desygnatory słów służą do wybierania ze zdarzenia żądanych słów.
Dwukropek
.B :
oddziela określenie zdarzenia od desygnatora słowa. Może być pominięty
jeśli desygnator słowa rozpoczyna się od
.BR ^ ,
.BR $ ,
.BR * ,
.BR \-
lub
.BR % .
Słowa numerowane są od początku wiersza, przy czym pierwsze ma
numer 0 (zero).  Słowa są wstawiane do bieżącego wiersza, rozdzielane
pojedynczymi spacjami.
.PP
.PD 0
.TP
.B 0 (zero)
Słowo zerowe. Dla powłoki jest to słowo polecenia.
.TP
.I n
\fIn\fR-te słowo.
.TP
.B ^
Pierwszy argument. To znaczy, słowo 1.
.TP
.B $
Ostatni argument.
.TP
.B %
Słowo dopasowane przez ostatnie wyszukanie `?\fIłańcuch\fR?'.
.TP
.I x\fB\-\fPy
Zakres słów; `\-\fIy\fR' jest skróconym `0\-\fIy\fR'.
.TP
.B *
Wszystkie słowa prócz zerowego. jest to synonim dla `\fI1\-$\fP'.
Nie jest błędem użycie
.B *
jeśli w zdarzeniu jest tylko jedno słowo; w tym przypadku zwracany jest
łańcuch pusty.
.TP
.B x*
Skrót od \fIx\-$\fP.
.TP
.B x\-
Skrót od \fIx\-$\fP podobnie jak \fBx*\fP, ale pomija ostatnie słowo.
.PD
.PP
jeśli desygnator słowa podano bez określenia zdarzenia, za zdarzenie
przyjmowane jest poprzednie polecenie.
.SS Modyfikatory
.PP
Po opcjonalnym desygnatorze słowa może pojawić się sekwencja jednego lub
więcej poniższych modyfikatorów, każdy poprzedzony dwukropkiem `:'.
.PP
.PD 0
.PP
.TP
.B h
Usuwa końcową składową nazwy pliku, pozostawiając tylko początek.
.TP
.B t
Usuwa wszystkie początkowe składowe nazwy pliku, pozostawiając koniec.
.TP
.B r
Usuwa kończący przyrostek postaci \fI.xxx\fP, pozostawiając główną część
nazwy (basename).
.TP
.B e
Usuwa wszystko prócz końcowego przyrostka.
.TP
.B p
Wypisuje nowe polecenie, ale go nie wykonuje.
.TP
.B q
Cytuje podstawiane słowa, zabezpieczając je przed dalszym podstawianiem.
.TP
.B x
Cytuje podstawiane słowa jak
.BR q ,
ale rozbija na słowa w miejscach
.B odstępów
i znaków nowej linii.
.TP
.B s/\fIstary\fP/\fInowy\fP/
Zastępuje
.I nowym
pierwsze wystąpienie
.I starego
w wierszu zdarzenia. Zamiast / może zostać użyty dowolny ogranicznik.
Końcowy ogranicznik jest opcjonalny jeżeli jest ostatnim znakiem wiersza
zdarzenia. Separator może być cytowany w
.I nowym
i
.I starym
przy pomocy pojedynczego odwrotnego ukośnika. Jeżeli w
.IR nowym
pojawia się &, to jest zastępowany
.IR starym .
Pojedynczy odwrotny ukośnik będzie cytował &. Jeżeli
.I stary
jest pusty, to ustawiany jest na ostatni podstawiany
.I stary
lub, jeśli nie było poprzednich podstawień historii, ostatni
.I łańcuch
w wyszukiwaniu
.BR !?\fIłańcuch\fR\fB[?]\fR .
.TP
.B &
Powtarza poprzednie podstawienie.
.TP
.B g
Powoduje, że zmiany zostaną zastosowane do całego wiersza zdarzenia.
Używany w połączeniu z `\fB:s\fP' (np. `\fB:gs/\fIold\fP/\fInew\fP/\fR')
lub `\fB:&\fP'. Jeśli użyty z `\fB:s\fP', to zamiast / można posłużyć się
dowolnym separatorem, a ostatni separator jest opcjonalny jeżeli jest
ostatnim znakiem wiersza zdarzenia.
.PD
.SH "WBUDOWANE POLECENIA POWŁOKI"
.\" początek bash_builtins
.zZ
.PP
Jeśli nie podano inaczej, każde z poleceń wbudowanych opisanych
w niniejszej sekcji jako akceptujące opcje poprzedzone
.B \-
akceptuje również symbol
.B \-\-
określający koniec opcji.
.sp .5
.PD 0
.TP
\fB:\fP [\fIargumenty\fP]
.PD
Bez efektów; polecenie to nie robi niczego poza interpretacją
.I argumentów
i wykonaniem ewentualnych podanych przekierowań. Zwracany jest zerowy kod
zakończenia.
.TP
.PD 0
\fB .\| \fP \fIplik\fP [\fIargumenty\fP]
.TP
\fBsource\fP \fIplik\fP [\fIargumenty\fP]
.PD
Odczytuje i wykonuje polecenia z zadanego
.I pliku
w aktualnym środowisku powłoki i zwraca kod zakończenia ostatniego
wykonanego polecenia z tego
.IR pliku .
Jeżeli nazwa
.I pliku
nie zawiera ukośnika, to do znalezienia katalogu go zawierającego używana
jest zmienna
.SM
.BR PATH .
Plik poszukiwany w
.SM
.B PATH
nie musi być wykonywalny.
Jeśli \fBbash\fP nie jest w \fItrybie posix\fP, wówczas
jeżeli nie znaleziono pliku w
.SM
.BR PATH ,
to przeszukiwany jest katalog bieżący.
Jeśli we wbudowanym poleceniu
.B shopt
wyłączona jest opcja
.BR sourcepath ,
to
.SM
.B PATH
nie jest przeszukiwane.
jeśli podano jakieś \fIargumenty\fP, to stają się one parametrami
pozycyjnymi podczas wykonywania \fIpliku\fP. W przeciwnym razie argumenty
pozycyjne pozostają bez zmian.
Kod zakończenia jest kodem ostatniego zakończonego przez skrypt
polecenia (0 jeśli nie wykowano żadnego polecenia), a fałszem jeżeli
nie znaleziono
.I pliku
lub nie można go odczytać.
.TP
\fBalias\fP [\fB\-p\fP] [\fInazwa\fP[=\fIwartość\fP] ...]
\fBAlias\fP bez argumentów bądź z opcją
.B \-p
wypisuje na standardowym wyjściu listę aliasów w postaci
\fBalias\fP \fInazwa\fP=\fIwartość\fP.
Jeśli nie dostarczono argumenty, to definiowany jest alias (synonim)
dla każdej \fInazwy\fP, dla której podano \fIwartość\fP.
Początkowa spacja w \fIwartości\fP powoduje, że podczas interpretacji aliasu
następne słowo będzie sprawdzane na podstawianie aliasów.
Dla każdej \fInazwy\fP z listy argumentów, dla której nie podano
\fIwartości\fP, wypisywana jest nazwa i wartość aliasu.
\fBAlias\fP zwraca prawdę, chyba że podano \fInazwę\fP, dla której nie
został zdefiniowany żaden alias.
.TP
\fBbg\fP [\fIspec_zad\fP]
Wznawia w tle zawieszone zadanie \fIspec_zad\fP, tak jakby zostało
ono uruchomione z
.BR & .
Jeśli \fIspec_zad\fP nie występuje, to używane jest
\fIbieżące zadanie\fP, określone tak, jak je pojmuje powłoka.
.B bg
.I spec_zad
zwraca 0, chyba że uruchomiono je przy wyłączonej kontroli zadań
(job control) lub uruchomiono z włączoną kontrolą zadań, jeśli
nie znaleziono \fIspec_zad\fP lub uruchomiono bez kontroli zadań.
.TP
.PD 0
\fBbind\fP [\fB\-m\fP \fIkeymap\fP] [\fB\-lpsvPSV\fP]
.TP
\fBbind\fP [\fB\-m\fP \fIkeymap\fP] [\fB\-q\fP \fIfunkcja\fP] [\fB\-u\fP \fIfunkcja\fP] [\fB\-r\fP \fIsekw_klaw\fP]
.TP
\fBbind\fP [\fB\-m\fP \fIkeymap\fP] \fB\-f\fP \fIplik\fP
.TP
\fBbind\fP [\fB\-m\fP \fIkeymap\fP] \fB\-x\fP \fIsekw_klaw\fP:\fIpolec_powłoki\fP
.TP
\fBbind\fP [\fB\-m\fP \fIkeymap\fP] \fIsekw_klaw\fP:\fInazwa_funkcji\fP
.PD
Wyświetla bieżące ustawienia przypisań (bindings) klawiszy i funkcji
.B readline
lub przypisuje sekwencję klawiszy to funkcji lub makra
.BR readline .
Składnia tych przypisań jest identyczna jak dla
.IR .inputrc ,
ale każde z przypisań musi być przesłane jako osobny argument;
np., '"\eC\-x\eC\-r": re\-read\-init\-file'. Opcje, jeśli je podano, mają
następujące znaczenie:
.RS
.PD 0
.TP
.B \-m \fIkeymap\fP
Wykorzystuje
.I keymap
jako mapę klawiszy, do której mają być zastosowane następne przypisania.
Akceptowanymi nazwami
.I map klawiszy
są
.IR emacs ,
.IR emacs\-standard ,
.IR emacs\-meta ,
.IR emacs\-ctlx ,
.IR vi ,
.IR vi\-move ,
.I vi\-command
i
.IR vi\-insert .
\fIvi\fP równoważne jest \fIvi\-command\fP; \fIemacs\fP jest równoważne
\fIemacs\-standard\fP.
.TP
.B \-l
Podaje nazwy wszystkich funkcji \fBreadline\fP.
.TP
.B \-p
Wyświetla nazwy funkcji i przypisania w taki sposób, że mogą być ponownie
odczytane.
.TP
.B \-P
Podaje bieżące przypisania i nazwy funkcji \fBreadline\fP.
.TP
.B \-v
Wyświetla nazwy i wartości zmiennych \fBreadline\fP w taki sposób, że mogą
być ponownie odczytane.
.TP
.B \-V
Podaje bieżące nazwy i wartości zmiennych \fBreadline\fP.
.TP
.B \-s
Wyświetla sekwencje klawiszy \fBreadline\fP przypisane do makr i łańcuchy
jakie one wysyłają w taki sposób, że mogą być ponownie odczytane.
.TP
.B \-S
Wyświetla sekwencje klawiszy \fBreadline\fP przypisane do makr i łańcuchy
jakie one wysyłają.
.TP
.B \-f \fIplik\fP
Czyta przypisania klawiszy z \fIpliku\fP.
.TP
.B \-q \fIfunkcja\fP
Podaje, które klawisze wywołują podaną \fIfunkcję\fP.
.TP
.B \-u \fIfunkcja\fP
Odwołuje przypisania wszystkich klawiszy przypisanych do danej \fIfunkcji\fP.
.TP
.B \-r \fIsekw_klaw\fP
Usuwa bieżące przypisania dla \fIsekwencji klawiszy\fP.
.TP
.B \-x \fIsekw_klaw\fP:\fIpolec_powłoki\fP
Powoduje, że za każdym naciśnięciem \fIsekwencji klawiszy\fP zostanie
wykonane \fIpolecenie powłoki\fP.
.PD
.PP
Zwracana jest wartość 0, chyba że podano nierozpoznaną opcję lub pojawił się
błąd.
.RE
.TP
\fBbreak\fP [\fIn\fP]
Opuszcza pętlę
.BR for ,
.BR while ,
.BR until
lub
.BR select .
Jeżeli podano \fIn\fB, przerywa działanie do \fIn\fP-tego poziomu.
.I n
musi być \(>= 1. Jeżeli
.I n
jest większe od liczby obejmujących polecenie pętli, to kończone są
wszystkie obejmujące pętle. Wartością zwracaną jest 0, chyba że powłoka nie
wykonuje pętli podczas wykonania
.BR break .
.TP
\fBbuiltin\fP \fIwbudowane\fP [\fIargumenty\fP]
Wykonuje zadane polecenie wbudowane powłoki, przesyłając mu
.IR argumenty i zwraca jego kod zakończenia.
Przydatne podczas definiowania funkcji o nazwie tożsamej z nazwą
wbudowanego polecenia powłoki, zachowując funkcjonalność polecenia
wbudowanego wewnątrz funkcji.
Wbudowane \fBcd\fP jest powszechnie redefiniowane w ten sposób.
Kodem zakończenia jest fałsz jeśli
.I wbudowane
nie jest wbudowanym poleceniem powłoki.
.TP
\fBcd\fP [\fB\-LP\fP] [\fIkatalog\fP]
Zmienia bieżący katalog roboczy na \fIdir\fP. Zmienna
.SM
.B HOME
jest domyślnym
.IR katalogiem .
Zmienna
.SM
.B CDPATH
definiuje ścieżkę przeszukiwań dla katalogu zawierającego
.IR katalog .
Alternatywne nazwy katalogów w
.SM
.B CDPATH
rozdzielane są dwukropkiem (:)> Pusta nazwa katalogu w
.SM
.B CDPATH
jest tym samym, co katalog bieżący, tj. ,,\fB.\fP''. Jeżeli
.I katalog
rozpoczyna się ukośnikiem (/), to
.SM
.B CDPATH
nie jest używane. Opcja
.B \-P
nakazuje użycie fizycznej struktury katalogów zamiast podążania za
dowiązaniami symbolicznymi (zobacz też opcja
.B \-P
wbudowanego polecenia
.BR set );
Opcja
.B \-L
wymusza podążanie za dowiązaniami symbolicznymi.
Argument
.B \-
jest równoważny
.SM
.BR $OLDPWD .
Wartością zwracaną jest prawda jeśli pomyślnie zmieniono katalog; w
przeciwnym przypadku fałsz.
.TP
\fBcommand\fP [\fB\-pVv\fP] \fIpolecenie\fP [\fIarg\fP ...]
Uruchamia
.I polecenie
z
.I argumentami
zakazując zwykłego wyszukiwania funkcji przez powłokę.
Wykonywane są wyłącznie polecenia wbudowane i polecenia znalezione w
.SM
.BR PATH .
Jeżeli podano opcję
.BR \-p ,
wyszukiwanie
.I polecenia
wykonywane jest przy użyciu domyślnej
.BR PATH ,
która gwarantuje znalezienie wszystkich standardowych narzędzi.
Jeśli użyto albo opcji
.B \-V
albo
.BR \-v ,
to wypisywany jest opis
.IR polecenia .
Opcja
.B \-v
powoduje, że zostanie wyświetlone pojedyncze słowo wskazujące polecenie
lub nazwę pliku, użyte do wywołania
.IR polecenia ;
opcja
.B \-V
tworzy bardziej rozgadany opis.
Jeżeli podano opcję
.B \-V
lub
.BR \-v ,
to kodem zakończenia jest 0 gdy odnaleziono
.I polecenie,
zaś 1 gdy nie. Jeśli nie podano żadnej z tych opcji i pojawił się błąd
lub nie można znależć
.IR polecenia ,
to kod zakończenia wynosi 127. W przeciwnym wypadku kodem zakończenia
wbudowanego polecenia
.B command
jest kod zakończenia
.IR polecenia .
.TP
\fBcompgen\fP [\fIopcja\fP] [\fIsłowo\fP]
Tworzy możliwe dopasowania uzupełnień dla \fIsłowa\fP zgodnie
z \fIopcjami\fP, które mogą być dowolnymi z opcji akceptowanych przez
wbudowane polecenie
.BR complete ,
z wyjątkiem \fB\-p\fP i \fB\-r\fP, i wypisuje dopasowania na standardowe
wyjście.
Przy stosowaniu opcji \fB\-F\fP lub \fB\-C\fP, różne zmienne powłoki
ustawiane przez usługi programowalnego uzupełniania, gdy są dostępne,
nie będą mieć użytecznych wartości.
.sp 1
Dopasowania będą tworzone w ten sam sposób, jakby kod uzupełniania
programowalnego tworzył je wprost ze specyfikacji uzupełniania z tymi samymi
flagami.
Jeżeli podano \fIsłowo\fP, to wyświetlone zostaną wyłącznie uzupełnienia
doń pasujące.
.sp 1
Wartością zwracaną jest prawda, chyba że podano niepoprawną opcję lub
nie zostały utworzone żadne dopasowania.
.TP
.PD 0
\fBcomplete\fP [\fB\-abcdefgjkvu\fP] [\fB\-o\fP \fIopcjacomp\fP] [\fB\-A\fP \fIakcja\fP] [\fB\-G\fP \fIwzglob\fP] [\fB\-W\fP \fIlistasłów\fP] [\fB\-P\fP \fIprzedrostek\fP] [\fB\-S\fP \fIprzyrostek\fP]
.br
[\fB\-X\fP \fIwzfiltr\fP] [\fB\-F\fP \fIfunkcja\fP] [\fB\-C\fP \fIpolecenie\fP] \fInazwa\fP [\fInazwa ...\fP]
.TP
\fBcomplete\fP \fB\-pr\fP [\fInazwa\fP ...]
.PD
Określa, w jaki sposób będą uzupełniane argumenty dla każdej z \fInazw\fP.
Jeżeli podano opcję \fB\-p\fP, lub nie podano żadnych opcji,
to wypisywane są istniejące specyfikacje uzupełniania - w sposób, który
pozwala na ich ponowne wykorzystanie jako wejścia.
Opcja \fB\-r\fP usuwa specyfikację uzupełniania dla każdej z \fInazw\fP, lub
jeśli \fInazw\fP nie podano, wszystkie specyfikacje uzupełniania.
.sp 1
Proces stosowania tych specyfikacji uzupełnień podczas prób uzupełniania
słów omówiono powyżej w sekcji \fBProgramowalne uzupełnianie\fP.
.sp 1
Pozostałe opcje, jeśli je podano, mają niżej opisane znaczenie.
Argumenty opcji \fB\-G\fP, \fB\-W\fP i \fB\-X\fP (i, jeśli to niezbędne,
\fB\-P\fP i \fB\-S\fP) powinny być cytowane dla ochrony przed interpretacją
jaka wystąpi zanim zostanie wywołane polecenie
.BR complete .
.RS
.PD 0
.TP 8
\fB\-o\fP \fIopcjacomp\fP
Wartość \fIopcjacomp\fP reguluje kilka aspektów zachowania się compspec
wykraczających poza zwykłe tworzenie uzupełnień.
\fIopcjacomp\fP przyjmuje jedną z wartości:
.RS
.TP 8
.B default
Stosuje domyślne uzupełnianie readline jeśli compspec nie utworzy żadnych
dopasowań.
.TP 8
.B dirnames
Wykonuje uzupełnianie nazw katalogów jeśli compspec nie utworzy żadnych
dopasowań.
.TP 8
.B filenames
Powiadamia readline, że compspec tworzy nazwy plików, zatem może
wykonać przetwarzanie specyficzne dla takich nazw (jak dodanie ukośnika
do nazw katalogów czy usunięcie końcowych spacji). Zaprojektowane do
stosowania z funkcjami powłoki.
.RE
.TP 8
\fB\-A\fP \fIakcja\fP
\fIakcja\fP może być jedną z poniższych, tworzących listę możliwych
dopasowań:
.RS
.TP 8
.B alias
Nazwy aliasów. Można też podać jako \fB\-a\fP.
.TP 8
.B arrayvar
Nazwy zmiennych tablicowych.
.TP 8
.B binding
Nazwy przypisań klawiszy \fBreadline\fP.
.TP 8
.B builtin
Nazwy wbudowanych poleceń powłoki. Można też podać jako \fB\-b\fP.
.TP 8
.B command
Nazwy poleceń. Można też podać jako \fB\-c\fP.
.TP 8
.B directory
Nazwy katalogów. Można też podać jako \fB\-d\fP.
.TP 8
.B disabled
Nazwy wyłączonych poleceń wbudowanych powłoki.
.TP 8
.B enabled
Nazwy włączonych poleceń wbudowanych powłoki.
.TP 8
.B export
Nazwy wyeksportowanych zmiennych powłoki. Można też podać jako \fB\-e\fP.
.TP 8
.B file
Nazwy plików. Można też podać jako \fB\-f\fP.
.TP 8
.B function
Nazwy funkcji powłoki.
.TP 8
.B group
Nazwy grup. Można też podać jako \fB\-g\fP.
.TP 8
.B helptopic
Tematy pomocy akceptowane przez wbudowane polecenie \fBhelp\fP.
.TP 8
.B hostname
Nazwy hostów, pobrane z pliku określonego przez zmienną powłoki
.SM
.BR HOSTFILE .
.TP 8
.B job
Nazwy zadań, jeżeli aktywne jest sterowanie zadaniami. Można też podać
jako \fB\-j\fP.
.TP 8
.B keyword
Zastrzeżone słowa powłoki. Można też podać jako \fB\-k\fP.
.TP 8
.B running
Nazwy działających zadań, jeżeli aktywne jest sterowanie zadaniami.
.TP 8
.B setopt
Dozwolone argumenty opcji \fB\-o\fP polecenia wbudowanego \fBset\fP.
.TP 8
.B shopt
Nazwy opcji powłoki, takie, jakie akceptuje polecenie wbudowane \fBshopt\fP.
.TP 8
.B signal
Nazwy sygnałów.
.TP 8
.B stopped
Nazwy zatrzymanych zadań, jeśli aktywne jest sterowanie zadaniami.
.TP 8
.B user
Nazwy użytkowników. Można też podać jako \fB\-u\fP.
.TP 8
.B variable
Nazwy wszystkich zmiennych powłoki. Można też podać jako \fB\-v\fP.
.RE
.TP 8
\fB\-G\fP \fIwzglob\fP
Wzorzec rozwijania nazw plików \fIwzglob\fP jest rozwijany, tworząc
listę możliwych uzupełnień.
.TP 8
\fB\-W\fP \fIlistasłów\fP
\fIlistasłów\fP jest rozbijana przy zastosowaniu znaków ze zmiennej
specjalnej
.SM
.B IFS
jako separatorów, a każde ze słów wynikowych jest interpretowane.
Możliwe uzupełnienia są elementami listy wynikowej, pasującymi
do uzupełnianego słowa.
.TP 8
\fB\-C\fP \fIpolecenie\fP
\fIpolecenie\fP wykonywane jest w środowisku podpowłoki, a jego wyjście
używane jest jako możliwe uzupełnienia.
.TP 8
\fB\-F\fP \fIfunkcja\fP
Funkcja powłoki \fIfunkcja\fP wykonywana jest w bieżącym środowisku powłoki.
Po jej zakończeniu, możliwe uzupełnienia pobierane są z wartości zmiennej
tablicowej
.SM
.BR COMPREPLY .
.TP 8
\fB\-X\fP \fIwzfiltr\fP
\fIwzfiltr\fP jest wzorcem używanym do rozwijania nazw plików.
Stosowany jest do listy możliwych uzupełnień utworzonej przez poprzedzające
go opcje i argumenty, a każde pasujące do niego uzupełnienie jest usuwane
z listy.
Początkowy \fB!\fP w \fIwzfiltr\fP powoduje negację wzorca; usuwane są wówczas
uzupełnienia nie pasujące do \fIwzfiltr\fP.
.TP 8
\fB\-P\fP \fIprzedrostek\fP
Po zastosowaniu wszystkich innych opcji na początku każdego możliwego
uzupełnienia jest dodawany \fIprzedrostek\fP.
.TP 8
\fB\-S\fP \fIprzyrostek\fP
Po zastosowaniu wszystkich innych opcji na końcu każdego możliwego
uzupełnienia jest dołączany \fIprzyrostek\fP.
.PD
.PP
Wartością zwracana jest prawda, chyba że podano niepoprawną opcję,
podano bez argumentu \fInazwa\fP opcję inną niż \fB\-p\fP lub \fB\-r\fP,
usiłowano usunąć specyfikację uzupełniania dla \fInazwy\fP, dla której
nie istnieje żadna specyfikacja, albo też podczas dodawania specyfikacji
uzupełniania wystąpił błąd.
.RE
.TP
\fBcontinue\fP [\fIn\fP]
Wznawia następną iterację obejmującej je pętli
.BR for ,
.BR while ,
.BR until
lub
.BR select .
Jeżeli podano
.IR n ,
wznawia \fIn\fP-tą obejmującą pętlę.
.I n
musi być \(>= 1. Jeżeli
.I n
jest większe niż liczba obejmujących pętli, to wznawiana jest ostatnia
z pętli (,,najwyższa''). Wartość zwracana wynosi 0, chyba że powłoka nie
wykonuje pętli podczas wykonywania
.BR continue .
.TP
.PD 0
\fBdeclare\fP [\fB\-afFirx\fP] [\fB\-p\fP] [\fInazwa\fP[=\fIwartość\fP]]
.TP
\fBtypeset\fP [\fB\-afFirx\fP] [\fB\-p\fP] [\fInazwa\fP[=\fIwartość\fP]]
.PD
Deklaruje zmienne i/lub nadaje im atrybuty.
Jeśli nie podano żadnych \fInazw\fP, wyświetla wartości zmiennych.
Opcja
.B \-p
będzie wyświetlać atrybuty i wartości każdej
.IR nazwy .
Gdy używane jest
.BR \-p ,
ignorowane są dodatkowe opcje.
Opcja
.B \-F
zabrania wyświetlania definicji funkcji; wypisywane są tylko nazwy
i atrybuty funkcji.
Opcja
.B \-F
implikuje
.BR \-f .
Poniższych opcji można użyć do ograniczenia wyników do zmiennych
o określonym atrybucie lub do nadania zmiennym atrybutów:
.RS
.PD 0
.TP
.B \-a
Każda z \fInazw\fP jest zmienną tablicową (zobacz
.B Tablice
powyżej).
.TP
.B \-f
Używa wyłącznie nazw funkcji.
.TP
.B \-i
Zmienna jest traktowana jak całkowita; gdy zmiennej jest przypisywana
wartość, wykonywana jest interpretacja wyrażeń arytmetycznych
(zobacz
.SM
.BR "OBLICZANIE WYRAŻEŃ ARYTMETYCZNYCH" ).
.TP
.B \-r
Powoduje, że dane \fInazwy\fP stają się tylko-do-odczytu (readonly).
Nazwom tym nie można przypisać wartości następnymi poleceniami przypisania.
Nie można też ich usunąć za pomocą unset.
.TP
.B \-x
Zaznacza \fInazwę\fP do wyeksportowania przez środowisko do kolejnych
poleceń.
.PD
.PP
Użycie `+' zamiast `\-'
wyłącza atrybut, z wyjątkiem tego, że \fB+a\fP nie może być używane do
niszczenia zmiennej tablicowej. Użyte w funkcji, powodują, że każda z
\fInazw\fP staje się lokalna, jak przy pomocy polecenia
.BR local .
Zwracana jest wartość 0, chyba że napotkano niepoprawną opcję, próbę
zdefiniowania funkcji przy pomocy
.if n ,,\-f foo=bar'',
.if t \f(CW\-f foo=bar\fP,
przypisania wartości zmiennej readonly,
przypisania wartości zmiennej tablicowej bez użycia składni przypisania
złożonego (zobacz
.B Tablice
powyżej),
jedna z \fInazw\fP nie jest poprawną nazwą zmiennej powłoki,
usiłowano wyłączyć status readonly dla zmiennej tylko do odczytu,
wyłączyć status tablicy dla zmiennej tablicowej
albo próbowano wyświetlić nieistniejącą funkcję przy pomocy \fB\-f\fP.
.RE
.TP
.B dirs [\fB\-clpv\fP] [+\fIn\fP] [\-\fIn\fP]
Bez opcji wyświetla listę aktualnie zapamiętanych katalogów.
Domyślnie wyświetlana jest ona w pojedynczym wierszu, z nazwami katalogów
rozdzielonymi spacjami.
Katalogi dodawane są do listy poleceniem
.B pushd
polecenie
.B popd
usuwa pozycje z listy.
.RS
.PD 0
.TP
\fB+\fP\fIn\fP
Wyświetla \fIn\fPtą pozycję licząc od lewej na liście pokazywanej przez
.B dirs
przy wywołaniu bez opcji; początkową jest zero.
.TP
\fB\-\fP\fIn\fP
Wyświetla \fIn\fPtą pozycję licząc od prawej na liście pokazywanej
przez
.B dirs
przy wywołaniu bez opcji; początkową jest zero.
.TP
.B \-c
Czyści stos katalogów usuwając wszystkie jego pozycje.
.TP
.B \-l
Tworzy dłuższy listing; domyślnie format listingu posługuje się tyldą do
oznaczania katalogu domowego.
.TP
.B \-p
Wypisuje stos katalogów po jednej pozycji na wiersz.
.TP
.B \-v
Wypisuje stos katalogów po jednej pozycji na wiersz,
poprzedzając każdą z nich jej pozycją (indeksem) w stosie.
.PD
.PP
Wartością zwracaną jest 0, chyba że podano nieprawidłową opcję lub
\fIn\fP wskazuje poza koniec stosu katalogów.
.RE
.TP
\fBdisown\fP [\fB\-ar\fP] [\fB\-h\fP] [\fIzadanie\fP ...]
Bez opcji, każde z podanych
.I zadań
usuwane jest z tablicy zadań aktywnych.
Jeśli użyto opcji \fB\-h\fP, każde
.I zadanie
nie jest usuwane z tablicy, ale jest jako takie zaznaczane, tak że
do zadania nie jest wysyłany sygnał
.SM
.B SIGHUP
jeśli powłoka otrzymuje
.SM
.BR SIGHUP .
Jeśli nie podano
.I zadania
i nie użyto ani opcji
.B \-a
ani
.BR \-r ,
to używane jest \fIzadanie bieżące\fP.
Jeżeli podano
.IR zadanie ,
opcja
.B \-a
oznacza usunięcie lub zaznaczenie wszystkich zadań;
opcja
.B \-r
bez argumentu
.I zadania
ogranicza akcję do działających zadań.
Wartością zwracaną jest 0, chyba że
.I zadanie
nie określa poprawnego zadania.
.TP
\fBecho\fP [\fB\-neE\fP] [\fIargument\fP ...]
Wyświetla \fIargument\fPy, rozdzielone spacjami, zakończone znakiem nowej
linii. Kodem zakończenia jest zawsze 0.
Jeżeli podano \fB\-n\fP, to nie jest wysyłany kończący znak nowej linii.
Jeżeli podano opcję \fB\-e\fP, włączana jest interpretacja podanych niżej
znaków specjalnych. Opcja \fB\-E\fP wyłącza interpretację tych znaków,
nawet na systemach, gdzie są one domyślnie interpretowane.
Do dynamicznego sprawdzania, czy \fBecho\fP interpretuje domyślnie te znaki,
czy nie, służy opcja powłoki \fBxpg_echo\fP.
.B echo
nie interpretuje
.B \-\-
jako oznaczenia końca opcji.
.B echo
interpretuje następujące sekwencje specjalne:
.RS
.PD 0
.TP
.B \ea
dzwonek (alert)
.TP
.B \eb
backspace
.TP
.B \ec
pomiń kończący znak nowej linii
.TP
.B \ee
znak escape
.TP
.B \ef
wysuw strony (form feed)
.TP
.B \en
znak nowej linii (new line)
.TP
.B \er
powrót karetki (carriage return)
.TP
.B \et
tabulacja pozioma (horizontal tab)
.TP
.B \ev
tabulacja pionowa (vertical tab)
.TP
.B \e\e
odwrotny ukośnik (backslash)
.TP
.B \e\fInnn\fP
ośmiobitowy znak, którego wartością jest ósemkowa liczba \fInnn\fP
(jedna do trzech cyfr)
.TP
.B \ex\fIHH\fP
ośmiobitowy znak, którego wartością jest szesnastkowa liczba \fInnn\fP
(jedna lub dwie cyfry szesnastkowe)
.PD
.RE
.TP
\fBenable\fP [\fB\-adnps\fP] [\fB\-f\fP \fIplik\fP] [\fInazwa\fP ...]
Włącza i wyłącza wbudowane polecenia powłoki.
Wyłączenie poleceń wbudowanych umożliwia wykonanie polecenia dyskowego
mającego tę samą nazwę, co wbudowane, bez podawania jego pełnej
nazwy ścieżkowej, mimo iż powłoka normalnie szuka
poleceń wbudowanych przed poleceniami dyskowymi.
Jeżeli posłużono się opcją \fB\-n\fP, wyłączana jest każda z \fInazw\fP;
w przeciwnym razie \fInazwy\fB są włączone.
Na przykład, chcąc użyć pliku binarnego
.B test
znalezionego przez
.SM
.B PATH
zamiast wersji wbudowanej w powłokę, należy uruchomić
.if t \f(CWenable -n test\fP.
.if n ,,enable -n test''.
Opcja
.B \-f
oznacza załadowanie nowego polecenia wbudowanego
.I nazwa
z obiektu dzielonego (shared object)
.IR plik ,
na systemach obsługujących dynamiczne ładowanie.
Opcja
.B \-d
usunie polecenie wbudowane załadowane poprzednio przez
.BR \-f .
Jeżeli nie podano żadnych argumentów \fInazwa\fP lub jeśli podano opcję
.BR \-p ,
wypisywana jest lista poleceń wbudowanych powłoki.
Bez innych argumentów opcyjnych, lista ta składa się ze wszystkich
włączonych poleceń wbudowanych.
Jeśli podano \fB\-n\fP, wypisywane są tylko wyłączone polecenia
wbudowane.
Jeżeli podano \fB\-a\fP, wypisywana lista zawiera wszystkie polecenia
wbudowane, ze wskazaniem przy każdym czy jest ono włączone czy też nie.
Jeżeli podano \fB\-s\fP, wyjście ograniczone jest do POSIXowych
,,\fIspecjalnych\fP'' poleceń wbudowanych.
Wartością zwracaną jest 0, chyba że
.I nazwa
nie jest poleceniem wbudowanym powłoki lub wystąpił błąd podczas
ładowania nowego polecenia wbudowanego z obiektu dzielonego.
.TP
\fBeval\fP [\fIargument\fP ...]
\fIArgument\fPy są czytane i łączone w pojedyncze polecenie.
Polecenie to jest następnie odczytywane i wykonywane przez powłokę, zaś
jego kod zakończenia jest zwracany jako wartość
.BR eval .
Jeżeli nie na żadnych
.IR argumentów ,
lub wszystkie argumenty są puste,
.B eval
zwraca 0.
.TP
\fBexec\fP [\fB\-cl\fP] [\fB\-a\fP \fInazwa\fP] [\fIpolecenie\fP [\fIargumenty\fP]]
Jeżeli podano
.IR polecenie ,
zastępuje ono powłokę.
Nie tworzony jest żaden nowy proces.
.I Argumenty
stają się argumentami \fIpolecenia\fP.
Jeśli podano opcję
.BR \-l ,
umieszcza kreskę na początku zerowego argumentu przesyłanego do
.IR polecenia .
Tak samo, jak robi to
.IR login (1).
Opcja
.B \-c
powoduje, że
.I polecenie
zostanie wykonane z pustym środowiskiem. Jeżeli podano
.BR \-a ,
powłoka przesyła do wykonywanego polecenia
.I nazwę
jako zerowy argument. Jeżeli
.I polecenie
z jakiegoś powodu nie może zostać wykonane, to powłoka nie-interaktywna
kończy pracę, chyba że włączona jest opcja powłoki
.BR execfail,
wówczas zwraca niepowodzenie.
Powłoka interaktywna zwraca niepowodzenie jeśli plik nie może zostać
wykonany.
Jeżeli nie podano
.IR polecenia ,
przekierowania skutkują w bieżącej powłoce, a kodem zakończenia
jest 0. W przypadku błędu przekierowania kod zakończenia wynosi 1.
.\" any redirections take effect in the current shell,
.TP
\fBexit\fP [\fIn\fP]
Powoduje, że powłoka kończy pracę z kodem równym \fIn\fP. Jeśli pominięto
.IR n ,
kodem zakończenia jest kod ostatniego wykonanego polecenia.
Przed końcem pracy powłoki wykonywane jest przechwycenie sygnału
.SM
.BR EXIT .
.TP
.PD 0
\fBexport\fP [\fB\-fn\fP\^] [\fInazwa\fP[=\fIsłowo\fP]] ...
.TP
.B export \-p
.PD
Podane
.I nazwy
zaznaczane są do automatycznego wyeksportowania do środowiska następnych
wykonywanych poleceń. Jeśli podano opcję
.BR \-f ,
to
.I nazwy
odnoszą się do funkcji.
Jeżeli nie podano żadnych
.I nazw
lub jeżeli podano opcję
.BR \-p ,
to wypisywana jest lista wszystkich eksportowanych w tej powłoce nazw.
Opcja
.B \-n
powoduje usunięcie cechy eksportowania z podanych zmiennych.
.B export
zwraca zerowy kod zakończenia, chyba że napotkano nieprawidłową opcję,
jedna z \fInazw\fP nie jest poprawną nazwą zmiennej powłoki lub
podano
.B \-f
z
.IR nazwą ,
która nie jest funkcją.
.TP
.PD 0
\fBfc\fP [\fB\-e\fP \fInazwa_e\fP] [\fB\-nlr\fP] [\fIpierwsze\fP] [\fIostatnie\fP]
.TP
\fBfc\fP \fB\-s\fP [\fIwzorzec\fP=\fIzastąpienie\fP] [\fIpolecenie\fP]
.PD
Polecenie poprawiania (Fix Command).
W pierwszej postaci, z listy historii wybierany jest zakres poleceń od
.I pierwszego
do
.IR ostatniego .
.I Pierwsze
i
.I ostatnie
mogą być podawane jako łańcuch (do odnalezienia ostatniego polecenia
rozpoczynającego się tym łańcuchem) lub jako liczba (indeks w liście
historii, gdzie liczba ujemna używana jest jako offset od numeru bieżącego
polecenia), Jeżeli nie określono
.IR ostatniego ,
to jest ono ustawiane na bieżące polecenie w przypadku listowania (tak że
.if n ,,fc \-l \-10''
.if t \f(CWfc \-l \-10\fP
wypisuje ostatnich 10 poleceń) i na
.I pierwsze
w pozostałych przypadkach.
Jeżeli nie określono
.IR pierwszego ,
polecenia to jest ono ustawiane na poprzednie polecenie w przypadku edycji
a na \-16 przy listowaniu.
.sp 1
Opcja
.B \-n
wstrzymuje wyświetlanie numerów poleceń podczas listowania.
Opcja
.B \-r
odwraca kolejność poleceń.
Jeżeli podano opcję
.BR \-l ,
to polecenia listowane są na standardowym wyjściu. W przeciwnym razie
dla pliku zawierającego te polecenia wywoływany jest edytor podany przez
.IR nazwa_e .
Jeżeli nie podano
.IR nazwa_e ,
używana jest wartość
.SM
.BR FCEDIT ,
a wartość
.SM
.B EDITOR
jeśli nie ustawiono
.SM
.BR FCEDIT .
Jeżeli nie ustawiono żadnej z nich używany, jest
.FN vi .
Po zakończeniu edycji, wysyłane edytowane polecenia są wyświetlane przez
echo i wykonywane.
.sp 1
W drugiej postaci, \fIpolecenie\fP jest ponownie wykonywane po każdej
wymianie wystąpienia \fIwzorca\fP przez \fIzastąpienie\fP.
Przydatnym aliasem do wykorzystania z tą formą jest
.if n ,,r=fc -s'',
.if t \f(CWr='fc \-s'\fP,
tak, że napisanie
.if n ,,r cc''
.if t \f(CWr cc\fP
uruchamia ostatnie polecenie rozpoczynające się od
.if n ,,cc''
.if t \f(CWcc\fP
a napisanie
.if n ,,r''
.if t \f(CWr\fP
ponownie wykonuje ostatnie polecenie.
.sp 1
Jeżeli użyta została pierwsza postać, to wartością zwracaną jest 0, chyba
że napotkano nieprawidłową opcję lub
.I pierwszy
albo
.I ostatni
określają wiersze historii spoza zakresu.
Jeżeli podano opcję
.BR \-e ,
wartością zwracaną jest wartość ostatniego wykonanego polecenia lub
niepowodzenie jeśli pojawił się błąd tymczasowego pliku poleceń.
Jeżeli użyta została druga postać, to zwracanym kodem jest kod ponownie
wykonanego polecenia, chyba że
.I polecenie
nie określa poprawnego wiersza poleceń -- wówczas
.B fc
zwraca porażkę.
.TP
\fBfg\fP [\fIzadanie\fP]
Wznawia
.I zadanie
na pierwszym planie i czyni je zadaniem bieżącym.
Jeżeli nie podano
.IR zadania ,
używane jest \fIbieżące zadanie\fP w pojęciu powłoki.
Wartością zwracaną jest wartość polecenia umieszczonego na pierwszym planie,
lub porażka jeżeli
.B fb
uruchomiono przy wyłączonej kontroli zadań, lub uruchomiono je przy włączonej
kontroli zadań, ale
.I zadanie
nie określa prawidłowego zadania lub
.I zadanie
określa zadanie, które zostało uruchomione bez kontroli zadań.
.TP
\fBgetopts\fP \fIłańcuch_opcji\fP \fInazwa\fP [\fIargumenty\fP]
.B getopts
używane jest przez procedury powłoki do analizy parametrów pozycyjnych.
.I łańcuch opcji
zawiera znaki opcji, jakie mają być rozpoznawane; jeżeli po znaku
występuje dwukropek, to oczekuje się, że opcja będzie posiadać argument,
który powinien być od niej oddzielony białym znakiem.
Jako znaki opcji mogą wystąpić dwukropek i znak zapytania.
Przy każdym wywołaniu
.B getopts
umieszcza następną opcję w zmiennej powłoki
.IR nazwa ,
inicjując
.I nazwę
jeśli nie istniała. Indeks następnego argumentu do przetwarzania umieszczany
jest w zmiennej
.SM
.BR OPTIND .
.SM
.B OPTIND
inicjowany jest na 1 za każdym razem, gdy wywoływana jest powłoka lub skrypt
powłoki. Gdy opcja wymaga argumentu,
.B getopts
umieszcza go w zmiennej
.SM
.BR OPTARG .
Powłoka nie resetuje
.SM
.B OPTIND
automatycznie; musi być on resetowany ręcznie pomiędzy wielokrotnymi
odwołaniami do
.B getopts
w tym samym wywołaniu powłoki, jeśli używany ma być nowy zestaw parametrów.
.sp 1
Po napotkaniu końca opcji, \fBgetopts\fP kończy pracę zwracając wartość
większą od zera.
\fBOPTIND\fP ustawiane jest na indeks pierwszego argumentu nie będącego
opcją, zaś \fBnazwa\fP ustawiana jest na ?.
.sp 1
.B getopts
normalnie analizuje parametry pozycyjne, ale jeśli w
.IR argumentach ,
podano więcej argumentów, to
.B getopts
przetwarza je zamiast parametrów pozycyjnych.
.sp 1
.B getopts
może zgłaszać błędy na dwa sposoby. Jeżeli pierwszym znakiem
.I łańcucha opcji
jest dwukropek, to stosowane jest
.I ciche
(silent) zgłaszanie błędów. Przy zwykłej pracy komunikaty diagnostyczne
wypisywane są przy napotkaniu nieprawidłowych opcji lub brakujących argumentów
opcji.
Jeżeli zmienna
.SM
.B OPTERR
ustawiona jest na 0, nie będą wyświetlane żadne komunikaty błędów, nawet
jeśli pierwszym znakiem
.I łańcucha opcji
nie jest dwukropek.
.sp 1
Przy napotkaniu nieprawidłowej opcji
.B getopts
umieszcza ? w
.I nazwie
i, jeśli nie pracuje w trybie cichym, wypisuje komunikat błędu i kasuje
.SM
.BR OPTARG .
Jeżeli
.B getopts
pracuje w trybie cichym, to znaleziony znak opcji umieszczany jest w
.SM
.B OPTARG
i nie jest wypisywany żaden komunikat diagnostyczny.
.sp 1
Jeśli nie znaleziono wymaganego argumentu, a
.B getopts
nie pracuje w trybie cichym, w
.I nazwa
umieszczany jest znak zapytania (\^\fB?\fP\^), kasowane jest
.SM
.B OPTARG
i wyświetlany jest komunikat błędu.
Jeżeli
.B getopts
pracuje w trybie cichym, to w
.I nazwie
umieszczany jest dwukropek (\^\fB:\fP\^), a
.SM
.B OPTARG
ustawiane jest na znaleziony znak opcji.
.sp 1
.B getopts
zwraca prawdę, jeśli znaleziono określoną lub nie określoną opcję.
Zwraca fałsz jeżeli napotkano koniec opcji lub pojawił się błąd.
.TP
\fBhash\fP [\fB\-r\fP] [\fB\-p\fP \fIplik\fP] [\fB\-t\fP] [\fInazwa\fP]
Dla każdej
.I nazwy
określana i zapamiętywana jest pełna nazwa plikowa polecenia wyszukanego w
katalogach
.B $PATH .
Jeżeli podano opcję
.BR \-p ,
nie jest wykonywane przeszukanie ścieżki, a
.I plik
używane jest jako pełna nazwa pliku polecenia.
Opcja
.B \-r
powoduje, że powłoka zapomina wszystkie zapamiętane wcześniej miejsca.
Jeśli podano opcję
.BR \-t ,
to wypisywana jest odpowiadająca \fInazwie\fP pełna nazwa pliku.
Jeżeli przy więcej niż jednym argumencie \fInazwy\fP podano \fB\-t\fP,
to przed każdą przechowywaną pełną nazwą wypisywana jest \fInazwa\fP.
Jeżeli nie podano żadnych argumentów, to wypisywana jest informacja o
zapamiętanych poleceniach.
Kodem zwracanym jest prawda, chyba że nie odnaleziono
.I nazwy
lub podano nieprawidłową opcję.
.TP
\fBhelp\fP [\fB\-s\fP] [\fIwzorzec\fP]
Wyświetla pomocne informacje o poleceniach wbudowanych. Jeżeli podano
.IR wzorzec ,
to
.B help
daje szczegółową pomoc dotyczącą wszystkich poleceń pasujących do
.IR wzorca ;
w przeciwnym razie wypisywana jest pomoc dla wszystkich poleceń wbudowanych
i struktur sterujących powłoki.
Opcja \fB\-s\fP ogranicza wyświetlaną informację do krótkiego opisu składni.
Zwracany jest kod 0, chyba że żadne z poleceń nie pasuje do
.IR wzorca .
.TP
.PD 0
\fBhistory [\fIn\fP]
.TP
\fBhistory\fP \fB\-c\fP
.TP
\fBhistory \-d\fP \fIoffset\fP
.TP
\fBhistory\fP \fB\-anrw\fP [\fIplik\fP]
.TP
\fBhistory\fP \fB\-p\fP \fIarg\fP [\fIarg ...\fP]
.TP
\fBhistory\fP \fB\-s\fP \fIarg\fP [\fIarg ...\fP]
.PD
Bez żadnych opcji, wyświetla listę historii poleceń z numerami wierszy.
Wiersze ukazane z
.B *
zostały zmienione. Argument
.I n
pokazuje jedynie ostatnich
.I n
wierszy. Jeżeli podano \fIplik\fP, to używany jest on jako nazwa pliku
historii; jeśli nie, to używana jest wartość
.SM
.BR HISTFILE .
Opcje, jeżeli je podano, mają następujące znaczenie:
.RS
.PD 0
.B \-c
Czyści listę historii usuwając wszystkie jej pozycje.
.TP
\fB\-d\fP \fIoffset\fP
Usuwa wpis historii z pozycji \fIoffset\fP.
.TP
.B \-a
Dodaje ,,nowe'' wiersze (wprowadzone od początku bieżącej sesji \fBbash\fP)
do pliku historii.
.TP
.B \-n
Wczytuje do bieżącej listy wiersze jeszcze nie przeczytane z pliku
historii. Są to wiersze dołączone do pliku historii od chwili rozpoczęcia
bieżącej sesji pracy \fBbash\fP.
.TP
.B \-r
Czyta zawartość pliku historii i posługuje się nią jako bieżącą
listą historii.
.TP
.B \-w
Zapisuje bieżącą listę do pliku historii, nadpisując jego zawartość.
.TP
.B \-p
Na zadanych \fIargumentach\fP wykonuje podstawianie historii (history
substitution). Wyświetla wyniki na standardowym wyjściu.
Nie zachowuje wyników na liście.
Każdy z \fIargumentów\fP musi być cytowany, by wyłączyć normalną
interpretację historii.
.TP
.B \-s
Zachowuje
.I argumenty
na liście historii jako pojedynczą pozycję. Przed dodaniem
.I argumentów
z listy usuwane jest ostatnie polecenie.
.PD
.PP
Wartością zwracaną jest 0, chyba że napotkano nieprawidłową opcję lub
podczas odczytu czy zapisu pliku historii pojawił się błąd, podano
niepoprawny argument \fIoffset\fP opcji \fB\-d\fP, lub nie powiodła się
interpretacja historii podanej jako argument \fB\-p\fP.
.RE
.TP
.PD 0
\fBjobs\fP [\fB\-lnprs\fP] [ \fIzadanie\fP ... ]
.TP
\fBjobs\fP \fB\-x\fP \fIpolecenie\fP [ \fIargumenty\fP ... ]
.PD
Pierwsza postać podaje aktywne zadania. Opcje mają następujące znaczenie:
.RS
.PD 0
.TP
.B \-l
Oprócz zwykłej informacji podaje identyfikatory procesów.
.TP
.B \-p
Listuje tylko ID procesu lidera grupy procesów zadania.
.TP
.B \-n
Wyświetla wyłącznie informację o zadaniach, które zmieniły status od
chwili, gdy użytkownik był ostatnio powiadamiany o ich statusie.
.TP
.B \-r
Ogranicz wyniki do zadań pracujących.
.TP
.B \-s
Ogranicz wyniki do zadań zatrzymanych.
.PD
.PP
Jeżeli podano
.IR zadanie ,
wyniki ograniczane są do informacji o tym zadaniu.
Kodem zwracanym jest 0, chyba że napotkano nieprawidłową opcję
lub podano nieprawidłowe
.IR zadanie .
.PP
Jeżeli podano opcję
.BR \-x ,
to
.B jobs
zastępuje wszelkie
.I zadania
znalezione w
.I poleceniu
lub
.I argumentach
odpowiednim ID grupy procesów, wykonuje
.I polecenie
przesyłając mu
.IR argumenty ,
i zwraca jego kod zakończenia.
.RE
.TP
.PD 0
\fBkill\fP [\fB\-s\fP \fIsigspec\fP | \fB\-n\fP \fIsignum\fP | \fB\-\fP\fIsigspec\fP] [\fIpid\fP | \fIjobspec\fP] ...
.TP
\fBkill\fP \fB\-l\fP [\fIsigspec\fP | \fIexit_status\fP]
.PD
Wysyła sygnały określony przez
.I sigspec
lub
.I signum
do procesu określonego przez
.I pid
lub
.IR jobspec .
.I sigspec
jest albo nazwą sygnału, jak np.
.SM
.B SIGKILL
albo numerem sygnału;
.I signum
jest numerem sygnału. Jeżeli
.I sigspec
jest nazwą sygnału, to może ona zostać podana z przedrostkiem
.SM
.B SIG
lub bez niego.
Jeśli nie podano
.IR sigspec ,
to przyjmuje się
.SM
.BR SIGTERM .
Opcja
.B \-l
listuje nazwy sygnałów.
Jeżeli przy podanym
.B \-l
użyto jakichś argumentów, to listowane są sygnały odpowiadające tym
argumentom, a kodem zwracanym jest 0.
Argument \fIexit_status\fP opcji
.B \-l
jest liczbą określającą numer sygnału lub kod zakończenia procesu
przerwanego przez sygnał.
.B kill
zwraca prawdę, jeśli przynajmniej jeden z sygnałów został pomyślnie
przesłany, lub fałsz, jeśli pojawił się błąd lub napotkano niepoprawną
opcję.
.TP
\fBlet\fP \fIarg\fP [\fIarg\fP ...]
Każdy
.I argument
jest wyrażeniem arytmetycznym, jakie ma zostać zinterpretowane (zobacz
.SM
.BR "OBLICZANIE WYRAŻEŃ ARYTMETYCZNYCH" ).
Jeżeli ostatni z nich interpretowany jest jako zero, to
.B let
zwraca 1; w przeciwnym wypadku zwracane jest 0.
.TP
\fBlocal\fP [\fIopcja\fP] [\fInazwa\fP[=\fIwartość\fP] ...]
Dla każdego argumentu tworzona jest zmienna lokalna o nazwie
.I nazwa
i jest jej przypisywana
.IR wartość .
\fIOpcją\fP może być każda z opcji akceptowanych przez \fBdeclare\fP.
Gdy
.B local
używane jest wewnątrz funkcji, powoduje, że zmienna
.I nazwa
ma zasięg widzialności ograniczony do tej funkcji i jej potomków.
Bez operandów,
.B local
wysyła listę zmiennych lokalnych na standardowe wyjście. Błędem jest użycie
.B local
poza funkcją.
Zwracany jest kod 0, chyba że
.B local
zostanie użyte poza funkcją lub podano nieprawidłową
.IR nazwę ,
albo \fInazwa\fP jest zmienną tylko do odczytu.
.TP
.B logout
Kończy pracę powłoki zgłoszeniowej.
.TP
\fBpopd\fP [\-\fBn\fP] [+\fIn\fP] [\-\fIn\fP]
Usuwa pozycje ze stosu katalogów. Bez argumentów, usuwa katalog
z wierzchołka stosu i wykonuje
.B cd
do nowego katalogu na wierzchołku.
Argumenty, jeśli występują, mają następujące znaczenie:
.RS
.PD 0
.TP
\fB+\fP\fIn\fP
Usuwa \fIn\fPtą pozycję, licząc od lewej, listy pokazywanej przez
.BR dirs ,
zaczynając od zera. Na przykład
.if n ,,popd +0''
.if t \f(CWpopd +0\fP
usuwa pierwszy katalog, a
.if n ,,popd +1''
.if t \f(CWpopd +1\fP
drugi.
.TP
\fB\-\fP\fIn\fP
Usuwa \fIn\fPtą pozycję, licząc od prawej, listy pokazywanej przez
.BR dirs ,
zaczynając od zera. Na przykład ,,popd -0'' usuwa ostatni katalog,
,,popd -1'' przedostatni.
.TP
.B \-n
Nie wykonuje zwykłej zmiany katalogu podczas usuwania katalogów ze stosu,
tak że zmieniana jest tylko zawartość stosu.
.PD
.PP
Jeżeli polecenie
.B popd
powiedzie się, to wykonywane jest również
.BR dirs ,
a kodem zwracanym jest 0.
.B popd
zwraca fałsz jeśli napotkano nieprawidłową opcję, stos katalogów jest
pusty, podano nieistniejącą pozycję stosu lub nie udała się zmiana
katalogu.
.RE
.TP
\fBprintf\fP \fIformat\fP [\fIargumenty\fP]
Zapisuje sformatowane \fIargumenty\fP na standardowe wyjście przy pomocy
zadanego \fIformatu\fP.
\fIformat\fP jest łańcuchem znakowym zawierającym trzy rodzaje obiektów:
zwykłe znaki, które są po prostu kopiowane na standardowe wyjście,
sekwencje specjalne, które są konwertowane i kopiowane na standardowe
wyjście, i specyfikacje formatu, z których każda powoduje wypisanie
następnego kolejnego \fIargumentu\fP.
Oprócz standardowych formatów \fIprintf\fP(1), \fB%b\fP powoduje, że
\fBprintf\fP interpretuje sekwencje specjalne w odpowiednim \fIargumencie\fP,
zaś \fB%q\fP powoduje, że \fBprintf\fP wysyła odpowiedni \fIargument\fP
w formacie, jaki może być ponownie wykorzystany jako wejście powłoki.
.sp 1
W razie potrzeby \fIformat\fP wykorzystywany jest ponownie, aż do
obsłużenia wszystkich \fIargumentów\fP.
Jeżeli \fIformat\fP wymaga większej ilości
\fIargumentów\fP niż podano, to dodatkowe specyfikacje formatu zachowują
się tak, jakby dostarczono im odpowiednio wartość zerową lub łańcuch pusty.
Zwracana jest wartość zero w przypadku powodzenia, niezerowa przy porażce.
.TP
.PD 0
\fBpushd\fP [\fB\-n\fP] [\fIkatalog\fP]
.TP
\fBpushd\fP [\fB\-n\fP] [+\fIn\fP] [\-\fIn\fP]
.PD
Dodaje katalog na wierzchołek stosu katalogów, albo obraca stos, czyniąc
nowy wierzchołek stosu bieżącym katalogiem roboczym.
Bez argumentów, zamienia miejscami dwa najwyższe katalogi stosu
[wierzchołek i następny] i zwraca 0, chyba że stos jest pusty.
Argumenty, jeśli je podano, mają następujące znaczenie:
.RS
.PD 0
.TP
\fB+\fP\fIn\fP
Obraca stos, tak że \fIn\fPty katalog (licząc od lewej listy pokazywanej
przez
.BR dirs ,
poczynając od zera)
staje się wierzchołkiem.
.TP
\fB\-\fP\fIn\fP
Obraca stos, tak że \fIn\fPty katalog (licząc od prawej listy pokazywanej
przez
.BR dirs ,
poczynając od zera)
staje się wierzchołkiem.
.TP
.B \-n
Nie wykonuje zwykłej zmiany katalogu podczas dodawania katalogów do stosu,
tak że zmieniany jest tylko stos.
.TP
.I katalog
Odkłada
.I katalog
na wierzchołek stosu, czyniąc go nowym bieżącym katalogiem roboczym.
.PD
.PP
Jeżeli polecenie
.B pushd
powiodło się, to wykonywane jest również
.BR dirs .
Jeżeli używana jest pierwsza postać
.BR pushd ,
to zwracane jest 0, chyba że nie udało się cd na
.IR katalog .
Przy drugiej postaci,
.B pushd
zwraca 0, chyba że stos katalogów jest pusty, podano nieistniejący element
stosu lub nie powiodła się zmiana katalogu na zadany nowy katalog
bieżący.
.RE
.TP
\fBpwd\fP [\fB\-LP\fP]
Wypisuje bezwzględną nazwę pliku bieżącego katalogu roboczego.
Pokazana nazwa nie zawiera żadnych dowiązań symbolicznych jeśli
podano opcję
.B \-P
albo
włączona jest opcja
.B \-o physical
wbudowanego polecenia
.BR set .
Jeśli użyto opcji
.BR \-L ,
wypisana nazwa ścieżkowa może zawierać dowiązania symboliczne.
Zwracany kod wynosi 0, chyba że podczas odczytu nazwy bieżącego katalogu
pojawi się błąd lub podano nieprawidłową opcję.
.TP
\fBread\fP [\fB\-ers\fP] [\fB\-t\fP \fItimeout\fP] [\fB\-a\fP \fIanazwa\fP] [\fB\-p\fP \fIzachęta\fP] [\fB\-n\fP \fInznak\fP] [\fB\-d\fP \fIsep\fP] [\fInazwa\fP ...]
Ze standardowego wejścia czytany jest pojedynczy wiersz, a jego pierwsze
słowo jest przypisywane do pierwszej
.IR nazwy ,
drugie słowo do drugiej
.I nazwy
i tak dalej, przy czym pozostałe na koniec słowa i rozdzielające je
separatory przypisane zostaną do ostatniej
.IR nazwy .
Jeżeli ze standardowego wejścia przeczytano mniej słów niż podanych zostało
nazw, to pozostałym nazwom przypisywane są puste wartości.
Do podziału wiersza na słowa wykorzystywane są znaki z
.SM
.BR IFS .
Znaku odwrotnego ukośnika (\fB\e\fP) można użyć do usunięcia specjalnego
znaczenia następnego czytanego znaku oraz do oznaczenia kontynuacji wiersza.
Opcje, jeśli je podano, mają następujące znaczenie:
.RS
.PD 0
.TP
.B \-a \fIanazwa\fP
Słowa są przypisywane do kolejnych indeksów zmiennej tablicowej
.IR anazwa ,
poczynając od 0.
.I anazwa
jest kasowana przed przypisaniem nowych wartości.
Inne argumenty \fInazwa\fP są ignorowane.
.TP
.B \-d \fIsep\fP
Pierwszy znak \fIsep\fP służy do zakończenia wiersza wejścia, zamiast
znaku nowej linii.
.TP
.B \-e
Jeżeli standardowe wejście pochodzi z terminala, to do uzyskania wiersza
używane jest
.B readline
(zobacz
.SM
.B READLINE
powyżej).
.TP
.B \-n \fInznak\fP
\fBread\fP powraca po przeczytaniu \fInznak\fP znaków, zamiast czekać na
cały wiersz wejścia.
.TP
.B \-p \fIzachęta\fP
Wyświetla \fIzachętę\fP (prompt) na standardowym wyjściu błędów,
bez kończącego znaku nowej linii, przed próbą odczytu wejścia.
Zachęta wyświetlana jest tylko jeśli wejście pochodzi z terminala.
.TP
.B \-r
Odwrotny ukośnik nie działa jako znak specjalny. Traktowany jest jako część
wiersza. W szczególności, para odwrotny ukośnik-znak nowej linii nie może
być wykorzystana jako kontynuacja wiersza.
.TP
.B \-s
Tryb cichy. Jeżeli wejście pochodzi z terminala, to znaki nie są powtarzane
(bez echa).
.TP
.B \-t \fItimeout\fP
Powoduje, że \fBread\fP zwraca niepowodzenie, jeśli w ciągu \fItimeout\fP
sekund nie zostanie przeczytany pełny wiersz wejścia.
Opcja ta nie działa, jeżeli odczyt nie jest prowadzony z terminala
lub potoku.
.PD
.PP
Jeśli nie podano żadnych
.IR nazw ,
odczytany wiersz przypisywany jest zmiennej
.SM
.BR REPLY .
Zwracany kod wynosi 0, chyba że napotkano koniec pliku lub \fBread\fP
przekroczy czas oczekiwania.
.RE
.TP
\fBreadonly\fP [\fB\-apf\fP] [\fInazwa\fP ...]
.PD
Podane
\fInazwy\fP oznaczane są jako readonly; wartości tych
.I nazw
nie mogą być zmieniane następującymi później przypisaniami.
Jeśżli podano opcję
.BR \-f ,
oznaczane są funkcje o nazwach odpowiadających
.IR nazwom .
Opcja
.B \-a
ogranicza zmienne do tablic.
Jeśli nie podano argumentów
.I nazw
lub jeśli podano opcję
.BR \-p ,
wypisywane jest zestawienie wszystkich nazw o atrybucie readonly.
Opcja
.B \-p
powoduje, że wyniki będą wyświetlane w formacie, który może być ponownie
wykorzystany jako wejście.
Zwracany jest kod równy 0, chyba że napotkano nieprawidłową opcję,
jedna z
.I nazw
nie jest poprawną nazwą zmiennej powłoki lub podano
.B \-f
z
.IR nazwą ,
która nie jest funkcją.
.TP
\fBreturn\fP [\fIn\fP]
Powoduje, że funkcja kończy pracę zwracając wartość określoną przez
.IR n .
Jeśli pominięto
.IR n ,
kodem zakończenia jest kod ostatniego polecenia wykonanego w ciele funkcji.
Jeżeli zostanie użyte poza funkcją, ale podczas wykonywania skryptu przez
polecenie
.B .
(\fBsource\fP), powoduje zatrzymanie wykonywania tego skryptu przez powłokę
i zwrócenie albo
.I n
albo kodu zakończenia ostatniego wykonanego w skrypcie polecenia.
Jeżeli zostanie użyte poza funkcją i nie podczas wykonywania skryptu
przez \fB.\fP\^, zwracany jest fałsz.
.TP
\fBset\fP [\fB\-\-abefhkmnptuvxBCHP\fP] [\fB\-o\fP \fIopcja\fP] [\fIarg\fP ...]
Bez opcji, wyświetlane są nazwa i wartość każdej ze zmiennych powłoki,
w formacie który może być ponownie wykorzystany jako wejście.
Wyniki są sortowane zgodnie z bieżącymi ustawieniami locale.
Gdy podane są opcje, ustawiają one lub kasują atrybuty powłoki.
Argumenty pozostałe po przetworzeniu opcji traktowane są jako wartości
parametrów pozycyjnych i przypisywane, kolejno, do
.BR $1 ,
.BR $2 ,
.B ...
.BR $\fIn\fP .
Opcje, jeśli je podano, mają następujące znaczenie:
.RS
.PD 0
.TP 8
.B \-a
Automatycznie zaznacza zmienione lub utworzone zmienne i funkcje
do wyeksportowania ich do środowiska kolejnych poleceń.
.TP 8
.B \-b
Natychmiast podaje status zakończonych zadań drugoplanowych,
zamiast czynić to przed następną podstawową zachętą. Działa
.\" this is effective only
tylko jeśli włączona jest kontrola zadań.
.TP 8
.B \-e
Zakończ natychmiast jeśli \fIpolecenie proste\fP (zobacz
.SM
.B GRAMATYKA POWŁOKI
powyżej) kończy pracę z kodem niezerowym. Powłoka nie kończy pracy, jeśli
polecenie, które się nie powiodło jest częścią pętli
.I until
lub
.IR while ,
częścią instrukcji
.IR if ,
częścią listy
.B &&
lub
.B \(bv\(bv
lub wartość zwrócona przez polecenie została odwrócona przez
.BR ! .
Przed zakończeniem pracy powłoki wykonywana jest pułapka
na sygnał \fBERR\fP, jeśli była ustawiona.
.TP 8
.B \-f
Wyłącza rozwijanie nazw plików.
.TP 8
.B \-h
Zapamiętuje położenie poleceń przy wyszukiwania ich do wykonania.
Domyślnie włączone.
.TP 8
.B \-k
Wszystkie argumenty występujące w postaci instrukcji przypisania
umieszczane są w środowisku polecenia, nie zaś tylko te, które poprzedzają
nazwę polecenia.
.TP 8
.B \-m
Tryb monitorowania. Włączona jest kontrola zadań. Opcja ta jest
domyślnie włączona dla powłok interaktywnych na systemach ją obsługujących
(zobacz
.SM
.B STEROWANIE ZADANIAMI
powyżej). Procesy drugoplanowe działają w odrębnej grupie procesów
a po ich zakończeniu wypisywany jest wiersz zawierający ich kod zakończenia.
.TP 8
.B \-n
Odczytuje polecenia, ale nie ich nie wykonuje. Może być wykorzystane do
sprawdzenia błędów składni w skrypcie powłoki. Ignorowane przez powłoki
interaktywne.
.TP 8
.B \-o \fInazwa\-opcji\fP
Nazwą opcji może być jedna z poniższych:
.RS
.TP 8
.B allexport
To samo, co
.BR \-a .
.TP 8
.B braceexpand
To samo, co
.BR \-B .
.TP 8
.B emacs
Użyj interfejsu edycji wiersza poleceń w stylu emacsa. Włączone domyślnie,
jeśli powłoka jest interaktywna, chyba że została uruchomiona z opcją
.BR \-\-noediting .
.TP 8
.B errexit
To samo, co
.BR \-e .
.TP 8
.B hashall
To samo, co
.BR \-h .
.TP 8
.B histexpand
To samo, co
.BR \-H .
.TP 8
.B history
Włącza historię poleceń, jak opisano powyżej w sekcji
.SM
.BR HISTORII .
Opcja ta jest domyślnie włączona w powłokach interaktywnych.
.TP 8
.B ignoreeof
Efekt jest taki, jakby zostało wykonane polecenie powłoki
.if t \f(CWIGNOREEOF=10\fP
.if n ,,IGNOREEOF=10''
(zobacz powyżej
.BR "Zmienne powłoki" ).
.TP 8
.B keyword
To samo, co
.BR \-k .
.TP 8
.B monitor
To samo, co
.BR \-m .
.TP 8
.B noclobber
To samo, co
.BR \-C .
.TP 8
.B noexec
To samo, co
.BR \-n .
.TP 8
.B noglob
To samo, co
.BR \-f .
.TP
.B nolog
Obecnie ignorowane.
.TP 8
.B notify
To samo, co
.BR \-b .
.TP 8
.B nounset
To samo, co
.BR \-u .
.TP 8
.B onecmd
To samo, co
.BR \-t .
.TP 8
.B physical
To samo, co
.BR \-P .
.TP 8
.B posix
Zmienia zachowanie
.B bash
tam, gdzie domyślne działanie różni się od standardu
POSIX 1003.2, tak by spełniać standard (\fItryb posix\fP).
.TP 8
.B privileged
To samo, co
.BR \-p .
.TP 8
.B verbose
To samo, co
.BR \-v .
.TP 8
.B vi
Używa interfejsu edycji wiersza poleceń w stylu vi.
.TP 8
.B xtrace
To samo, co
.BR \-x .
.sp .5
.PP
Jeżeli podano
.B \-o
bez \fInazwy\-opcji\fP, to wypisywane są wartości bieżących opcji.
Jeżeli podano
.B +o
bez \fInazwy\-opcji\fP, na standardowym wyjściu wyświetlana jest seria
poleceń
.B set
potrzebnych do odtworzenia aktualnych ustawień opcji.
.RE
.TP 8
.B \-p
Włącza tryb
.I uprzywilejowany
(privileged). W tym trybie pliki
.SM
.B $ENV
i
.SM
.B $BASH_ENV
nie są przetwarzane, funkcje powłoki nie są dziedziczone
ze środowiska, a zmienna
.SM
.BR SHELLOPTS,
jeśli występuje w środowisku, jest ignorowana.
Jeśli powłoka została uruchomiona z efektywnym id użytkownika (grupy)
różnych od id rzeczywistego a nie podano opcji \fB\-p\fP, to podejmowane są
opisane wyżej akcje a efektywny id użytkownika jest ustawiany na
identyfikator rzeczywisty. Jeżeli przy uruchamianiu podano opcję \fB\-p\fP,
to efektywny identyfikator użytkownika nie jest resetowany.
Wyłączenie tej opcji powoduje, że identyfikatory efektywne użytkownika
i grupy zostaną ustawione na identyfikatory rzeczywiste.
.TP 8
.B \-t
Kończy pracę po przeczytaniu i wykonaniu jednego polecenia.
.TP 8
.B \-u
Podczas interpretacji parametrów traktuje nieustawione zmienne jako błąd.
Jeżeli wykonywana jest próba interpretacji nieustawionej zmiennej, to
powłoka wypisuje komunikat o błędzie i, jeśli nie jest interaktywna, kończy
pracę z niezerowym kodem.
.TP 8
.B \-v
Wypisuje wiersze wejściowe powłoki przy ich odczytywaniu.
.TP 8
.B \-x
Po interpretacji każdego \fIpolecenia prostego\fP, wyświetla zinterpretowaną
wartość
.SM
.BR PS4 ,
po której następuje polecenie i jego zinterpretowane argumenty.
.TP 8
.B \-B
Powłoka wykonuje interpretacją nawiasów (zobacz
.B Interpretacja nawiasów
powyżej). Domyślnie włączone.
.TP 8
.B \-C
Jeśli włączone,
.B bash
nie nadpisuje istniejącego pliku przy użyciu operatorów przekierowania
.BR > ,
.B >&
i
.BR <> .
Można to ominąć tworząc pliki wyjściowe przy użyciu operatora przekierowania
.B >|
zamiast
.BR > .
.TP 8
.B \-H
Włącza zastępowanie historii w stylu
.BR ! .
Opcja ta jest domyślnie włączona dla powłoki interaktywnej.
.TP 8
.B \-P
Jeżeli jest ustawiona, to powłoka nie podąża za dowiązaniami symbolicznymi
podczas wykonywania poleceń zmieniających bieżący katalog roboczy, jak
.BR cd .
Używa zamiast tego fizycznej struktury katalogów. Domyślnie,
.B bash
podąża za logicznym łańcuchem katalogów podczas wykonywania poleceń
zmieniających bieżący katalog roboczy.
.TP 8
.B \-\-
Jeżeli po tej opcji nie występują żadne argumenty, to parametry pozycyjne
są kasowane. W przeciwnym razie, parametry pozycyjne ustawiane są na
\fIargument\fPy, nawet jeśli niektóre z nich zaczynają się od znaku
.BR \- .
.TP 8
.B \-
Sygnalizuje koniec opcji, powodując przypisanie wszystkich pozostałych
\fIargument\fPów do parametrów pozycyjnych.
Opcje
.B \-x
i
.B \-v
są wyłączane.
Jeżeli nie ma \fIargumentów\fP, to parametry pozycyjne pozostają bez zmian.
.PD
.PP
Opcje są domyślnie wyłączone, chyba że wskazano inaczej.
Użycie + zamiast \- spowoduje, że opcje te zostaną wyłączone.
Opcje mogą także zostać określone jako argumenty wywołania powłoki.
Bieżący zestaw opcji można znaleźć w
.BR $\- .
Zwracanym kodem jest zawsze prawda, chyba że napotkano nieprawidłową opcję.
.RE
.TP
\fBshift\fP [\fIn\fP]
Parametrom pozycyjne od \fIn\fP+1 ... zmieniają nazwy
.B $1
.B ....
parametry reprezentowane przez liczby \fB$#\fP w dół do \fB$#\fP\-\fIn\fP+1
są usuwane.
.I n
musi być liczbą nieujemną mniejszą lub równą \fB$#\fP.
Jeżeli
.I n
wynosi 0, parametry nie są zmieniane.
Jeżeli nie podano
.IR n ,
zakłada się, że wynosi 1.
Jeżeli
.I n
jest większe od \fB$#\fP, parametry pozycyjne nie są zmieniane.
Kod zakończenia jest większy od zera jeżeli
.I n
jest większe od
.B $#
lub mniejsze od zera; w przeciwnym wypadku 0.
.TP
\fBshopt\fP [\fB\-pqsu\fP] [\fB\-o\fP] [\fInazwa_opcji\fP ...]
Przełącza wartości zmiennych sterujących opcjonalnym zachowaniem powłoki.
Bez żadnych opcji, albo z opcją
.BR \-p ,
wyświetlana jest lista wszystkich dających się ustawić opcji, ze wskazaniem
dla każdej czy jest ona ustawiona czy nie.
Opcja \fB\-p\fP powoduje, że wyniki będą wyświetlane w postaci dającej się
ponownie wykorzystać jako wejście.
Pozostałe opcje mają następujące znaczenie:
.RS
.PD 0
.TP
.B \-s
Włącz (ustaw) każdą \fInazwę_opcji\fP.
.TP
.B \-u
Wyłącz (usuń) każdą \fInazwę_opcji\fP.
.TP
.B \-q
Zaniechaj zwykłego wyświetlania (tryb cichy); zwracany kod wskazuje na
to czy \fInazwa_opcji\fP jest ustawiona czy nie ustawiona.
Jeżeli z
.B \-q
podano wiele argumentów \fInazw_opcji\fP, to zwracanym kodem jest zero, gdy
wszystkie \fInazwy_opcji\fP są włączone; w przeciwnym razie kod jest
niezerowy.
.TP
.B \-o
Ogranicza wartości \fInazwy_opcji\fP do wartości zdefiniowanych dla opcji
.B \-o
wbudowanego polecenia
.BR set .
.PD
.PP
Jeżeli użyto albo
.B \-s
albo
.B \-u
bez argumentów \fInazw_opcji\fP, wyświetlanie ogranicza się do tych opcji,
które, odpowiednio, są ustawione bądź nieustawione.
Jeżeli nie wskazano inaczej, opcje \fBshopt\fP są domyślnie wyłączone (nie
ustawione).
.PP
Przy listowaniu opcji zwracany jest kod zerowy jeśli wszystkie
\fInazwy_opcji\fP są włączone, niezerowy w przeciwnym wypadku. Przy
ustawianiu lub kasowaniu opcji zwracany jest zerowy kod, chyba że
\fInazwa_opcji\fP nie jest poprawną opcją powłoki.
.PP
Lista opcji \fBshopt\fP obejmuje:
.if t .sp .5v
.if n .sp 1v
.PD 0
.TP 8
.B cdable_vars
Jeśli jest ustawiona, to nie będący katalogiem argument wbudowanego
polecenia
.B cd
uważany jest za nazwę zmiennej; wartością tej zmiennej jest katalog,
na który ma nastąpić zmiana.
.TP 8
.B cdspell
Jeśli jest ustawiona, to pomniejsze błędy w pisowni składowej katalogu
w poleceniu
.B cd
będą poprawiane.
Sprawdzenie takich błędów obejmuje znaki zamienione miejscami, znaki
pominięte i pojedyncze zbędne znaki. Jeżeli znaleziono poprawkę, wypisywana
jest poprawna nazwa pliku a polecenie kontynuuje działanie.
.\" the command proceeds.
Opcja ta jest wykorzystywana tylko przez powłoki interaktywne.
.TP 8
.B checkhash
Jeśli jest ustawiona, \fBbash\fP sprawdza przed próbą wykonania polecenia
znalezionego w tablicy mieszającej, czy polecenie to istnieje. Jeżeli
już nie istnieje, to wykonywane jest zwykłe przeszukiwanie ścieżki.
.TP 8
.B checkwinsize
Jeżeli jest ustawione, \fBbash\fP sprawdza rozmiar okna po każdym poleceniu
i, jeśli zachodzi potrzeba, aktualizuje wartość
.SM
.B LINES
i
.SM
.BR COLUMNS .
.TP 8
.B cmdhist
Jeżeli jest ustawione,
.B bash
usiłuje zapisać wszystkie wiersze polecenia wielowierszowego w tej samej
pozycji historii. Pozwala to na łatwą ponowną edycję poleceń obejmujących
wiele wierszy.
.TP 8
.B dotglob
Jeżeli jest ustawione, to
.B bash
do wyników rozwinięcia nazw plików włącza także nazwy plików rozpoczynające
się kropką `.'.
.TP 8
.B execfail
Jeżeli jest ustawione, to powłoka nie-interaktywna nie zakończy pracy
nie mogąc wykonać pliku określonego jako argument wbudowanego polecenia
.BR exec .
Powłoka interaktywna nie kończy pracy, jeśli
.B exec
zawiedzie.
.TP 8
.B expand_aliases
Jeżeli jest ustawiona, aliasy są interpretowane jak opisano powyżej w
.SM
.BR ALIASY .
Opcja ta jest włączona domyślnie dla powłok interaktywnych.
.TP 8
.B extglob
Jeśli jest włączona, włączane są rozszerzone funkcje dopasowywania
wzorców opisane powyżej w \fBRozwijanie nazw plików\fP.
.\" extended pattern matching features
.TP 8
.B histappend
Jeżeli jest ustawiona, to do pliku o nazwie wskazanej zmienną
.B HISTFILE
podczas kończenia pracy przez powłokę dodawana jest lista historii, zamiast
nadpisywania tego pliku listą.
.TP 8
.B histreedit
Jeżeli jest ustawione, a używane jest
.BR readline ,
to użytkownik ma możliwość ponownej edycji nieudanego podstawienia historii
historii.
.\" failed history substitution.
.TP 8
.B histverify
Jeżeli jest ustawione, a używane jest
.BR readline ,
to wyniki podstawiania historii nie są natychmiast przesyłane do
analizatora powłoki. Zamiast tego, wiersz wynikowy ładowany jest do bufora
edycyjnego \fBreadline\fP, pozwalając na dalsze zmiany.
.TP 8
.B hostcomplete
Jeżeli jest ustawione, a używane jest
.BR readline ,
\fBbash\fP będzie usiłować wykonać uzupełnianie nazwy hosta podczas
uzupełniania słowa zawierającego \fB@\fP (zobacz
.B Uzupełnianie
w
.B READLINE
powyżej).
Domyślnie włączone.
.TP 8
.B huponexit
Jeżeli jest ustawione, to \fBbash\fP wyśle
.SM
.B SIGHUP
do wszystkich zadań podczas kończenia pracy interaktywnej powłoki
zgłoszeniowej.
.TP 8
.B interactive_comments
Jeśli jest włączone, pozwala by słowo rozpoczynające się od
.B #
powodowało pominięcie tego słowa i wszystkich pozostałych znaków wiersza
w powłoce interaktywnej (zobacz powyżej
.SM
.BR KOMENTARZE).
Opcja domyślnie włączona.
.TP 8
.B lithist
Jeśli jest ustawione, a włączona jest opcja
.BR cmdhist ,
to polecenia wielowierszowe zachowywane są w historii w miarę możliwości
z osadzonymi znakami nowej linii zamiast przy użyciu średników jako
separatorów.
.TP 8
.B login_shell
Powłoka ustawia tę opcję jeśli zostanie uruchomiona jako zgłoszeniowa
(zobacz
.SM
.B WYWOŁANIE
powyżej).
Ta wartość nie może być zmieniona.
.TP 8
.B mailwarn
Jeżeli jest ustawione, zaś do pliku, w którym sprawdza pocztę \fBbash\fP
sięgano od czasu ostatniego sprawdzania, to zostanie wyświetlony komunikat
,,The mail in \fIplikpoczty\fP has been read'' (Poczta w \fIplikpoczty\fP
została przeczytana).
.TP 8
.B no_empty_cmd_completion
Jeśli jest ustawione, i stosowane jest
.BR readline ,
to
.B bash
nie będzie usiłował szukać w \fBPATH\fP możliwych uzupełnień, gdy
próba uzupełniania wystąpi w pustym wierszu.
.TP 8
.B nocaseglob
Jeśli zostało ustawione, to
.B bash
przy rozwijaniu nazw plików dopasowuje je nie zwracając uwagi na
wielkość liter (zobacz
.B Rozwijanie nazw plików
powyżej).
.TP 8
.B nullglob
Jeśli jest ustawione, to,
.B bash
pozwala by wzorce nie dopasowujące żadnych plików (zobacz
.B Rozwijanie nazw plików
powyżej)
rozwijały się w łańcuch pusty, zamiast na same siebie.
.TP 8
.B progcomp
Jeżeli jest ustawione, to włączone są usługi programowalnego uzupełniania
(zobacz powyżej \fBProgramowalne uzupełnianie\fP). Domyślnie włączone.
.TP 8
.B promptvars
Jeżeli jest ustawione, to łańcuchy zachęty podlegają interpretacji
zmiennych i podstawianiu parametrów po interpretacji zachęty opisanej w
.SM
.B ZACHĘTA
powyżej. Opcja ta jest domyślnie włączona.
.TP 8
.B restricted_shell
Powłoka ustawia tę opcję jeśli została uruchomiona w trybie okrojonym
(zobacz
.SM
.B "POWŁOKA OKROJONA"
poniżej).
Wartość ta nie może być zmieniona.
Nie jest ona resetowana podczas odczytu plików startowych, pozwalając im
na odkrycie czy powłoka jest okrojona czy nie.
.TP 8
.B shift_verbose
Jeżeli jest ustawiona, to wbudowane
.B shift
wypisuje komunikat o błędzie gdy liczba przesunięć (przez shift) przekracza
liczbę parametrów pozycyjnych.
.TP 8
.B sourcepath
Jeśli jest ustawiona, to polecenie wbudowane
\fBsource\fP (\fB.\fP) posługuje się wartością
.SM
.B PATH
do znalezienia katalogu zawierającego plik podany jako argument.
Opcja domyślnie włączona.
.TP 8
.B xpg_echo
Jeżeli jest ustawiona, to dla wbudowanego polecenia \fBecho\fP włączane jest
domyślne interpretowanie sekwencji specjalnych z odwrotnym ukośnikiem.
.RE
.TP
\fBsuspend\fP [\fB\-f\fP]
Zawiesza wykonywanie tej powłoki do otrzymania przez nią sygnału
.SM
.BR SIGCONT .
Opcja
.B \-f
mówi, by nie narzekać, jeśli użyto \fBsuspend\fP w powłoce zgłoszeniowej;
po prostu zawiesić mimo to. Kodem zwracanym jest 0, chyba że powłoka jest
powłoką zgłoszeniową i nie podano opcji
.BR \-f ,
lub gdy nie jest włączona kontrola zadań.
.TP
.PD 0
\fBtest\fP \fIwyraż\fP
.TP
\fB[\fP \fIwyraż\fP \fB]\fP
Zwraca kod 0 lub 1 w zależności od interpretacji wyrażenia warunkowego
.IR wyraż .
każdy operator i operand musi być odrębnym argumentem.
Wyrażenia składając się ze składowych opisanych powyżej w
.SM
.BR "WYRAŻENIA WARUNKOWE" .
.if t .sp 0.5
.if n .sp 1
Wyrażenia mogą być łączone przy użyciu poniższych operatorów, podanych
w kolejności malejącego priorytetu.
.RS
.PD 0
.TP
.B ! \fIwyraż\fP
Prawda jeśli
.I wyraż
jest fałszem.
.TP
.B ( \fIwyraż\fP )
Zwraca wartość \fIwyraż\fP.
Może być stosowane do obejścia zwykłej kolejności operatorów.
.TP
\fIwyraż1\fP \-\fBa\fP \fIwyraż2\fP
Prawda jeśli oba:
.I wyraż1
i
.I wyraż2
są prawdziwe.
.TP
\fIwyraż1\fP \-\fBo\fP \fIwyraż2\fP
Prawda jeśli
.I wyraż1
lub
.I wyraż2
jest prawdziwe.
.PD
.PP
\fBtest\fP i \fB[\fP interpretują wyrażenia warunkowe posługując się zestawem
reguł opartych o liczbę argumentów.
.if t .sp 0.5
.if n .sp 1
.PD 0
.TP
0 argumentów
Wyrażenie jest fałszywe.
.TP
1 argument
Wyrażenie jest prawdziwe wtedy i tylko wtedy gdy argument nie jest
pusty (null).
.TP
2 argumenty
Jeśli pierwszym argumentem jest \fB!\fP, to wyrażenie jest prawdziwe wtedy
i tylko wtedy gdy drugi argument jest pusty. Jeśli pierwszy argument jest
jednym z jednoargumentowych operatorów warunkowych podanych powyżej w
.SM
.BR "WYRAŻENIA WARUNKOWE" ,
to wyrażenie jest prawdziwe jeżeli test jednoargumentowy jest prawdziwy.
Jeżeli pierwszy argument nie jest poprawnym jednoargumentowym operatorem
warunkowym, to wyrażenie ma wartość fałsz.
.TP
3 argumenty
jeżeli drugi argument jest jednym z dwuargumentowych operatorów
warunkowych podanych powyżej w
.SM
.BR "WYRAŻENIA WARUNKOWE" ,
to wynik wyrażenia jest wynikiem dwuargumentowego testu
z zastosowaniem pierwszego i trzeciego argumentu jako operandów.
Jeśli pierwszym argumentem jest \fB!\fP, to wartość stanowi negację testu
dwuargumentowego przy użyciu drugiego i trzeciego argumentu.
Jeśli pierwszym argumentem jest dokładnie \fB(\fP a trzecim argumentem
dokładnie \fB)\fP, to wynik jest jednoargumentowym testem drugiego
argumentu.
W pozostałych przypadkach wyrażenie jest fałszywe.
Operatory \fB\-a\fP i \fB\-o\fP w tym przypadku uważane są za
dwuargumentowe.
.TP
4 argumenty
Jeśli pierwszym argumentem jest \fB!\fP, to wynik jest negacją
trójargumentowego wyrażenia złożonego z pozostałych argumentów.
W przeciwnym wypadku, wyrażenie jest poddawanie analizie składni
i interpretowane zgodnie z priorytetami przy zastosowaniu reguł podanych
powyżej.
.TP
5 lub więcej argumentów
Wyrażenie jest poddawanie analizie składni i interpretowane zgodnie
z priorytetami przy zastosowaniu reguł podanych powyżej.
.RE
.PD
.TP
.B times
Wypisuje sumaryczne czasy użytkownika i systemu dla powłoki i procesów z
niej uruchomionych. Kodem zwracanym jest 0.
.TP
\fBtrap\fP [\fB\-lp\fP] [\fIargument\fP] [\fIsigspec\fP ...]
Polecenie
.I argument
ma zostać odczytane i wykonane, gdy powłoka otrzyma sygnał(y)
.IR sigspec .
Jeśli nie występuje
.I argument
lub jest to
.BR \- ,
to wszystkie podane sygnały resetowane są do swych wartości pierwotnych
(wartości, jakie miały przy wejściu do powłoki).
Jeżeli
.I argument
jest łańcuchem pustym, to sygnał określony przez każde
.I sigspec
jest ignorowany przez powłokę i polecenia, jakie ona wywołuje.
Jeżeli nie wystąpił
.I argumentu
a podano
.BR \-p ,
wyświetlane są polecenia związane z przechwyceniem każdego z sygnałów
.IR sigspec .
Jeżeli nie podano żadnych argumentów lub jeśli podano tylko
.BR \-p ,
to
.B trap
wypisuje listę poleceń związanych z każdym z numerów sygnałów.
Każde
.I sigspec
jest albo nazwą sygnału zdefiniowaną w <\fIsignal.h\fP
albo numerem sygnału.
Jeżeli
.I sigspec
jest sygnałem
.SM
.B EXIT
(0), to polecenie
.I argument
wykonywane jest przy kończeniu pracy przez powłokę. Jeżeli
.I sigspec
jest równe
.SM
.BR DEBUG ,
to polecenie
.I argument
wykonywane jest po każdym \fIpoleceniu prostym\fP (zobacz
.SM
.B GRAMATYKA POWŁOKI
powyżej).
Jeśli
.I sigspec
to
.SM
.BR ERR ,
wówczas polecenie
.I argument
wykonywane jest każdorazowo gdy polecenie proste zwróci niezerowy
kod zakończenia.
Pułapka zastawiona na
.SM
.BR ERR
nie jest wykonywana gdy polecenie, które zakończyło się niepowodzeniem
jest częścią pętli
.I until
lub
.IR while ,
częścią instrukcji
.IR if ,
częścią listy
.B &&
lub
.B \(bv\(bv
albo jeśli wartość zwracana przez to polecenie jest wstawiana za pomocą
.BR ! .
Opcja
.B \-l
powoduje, że powłoka wypisuje zestawienie nazw sygnałów i odpowiadających
im numerów.
Sygnały ignorowane przy wejściu do powłoki nie mogą być przechwycone ani
zresetowane.
W procesie potomnym, podczas jego tworzenia, sygnały przechwycone
resetowane są do swych wartości pierwotnych.
Zwracanym kodem jest fałsz jeśli którykolwiek z
.I sigspec
jest nieprawidłowy; w przeciwnym razie
.B trap
zwraca true.
.TP
\fBtype\fP [\fB\-atp\fP] \fInazwa\fP [\fInazwa\fP ...]
Bez opcji wskazuje, jak powinna być interpretowana każda z
.IR nazw ,
jeśli zostanie użyta jako nazwa polecenia.
Jeżeli użyto opcji
.BR \-t ,
to
.B type
wypisuje łańcuch będący jednym z
.IR alias ,
.IR keyword ,
.IR function ,
.IR builtin
lub
.IR file ,
jeśli
.I nazwa
jest odpowiednio aliasem, zastrzeżonym słowem powłoki, funkcją, poleceniem
wbudowanym lub plikiem dyskowym.
Jeśli nie znaleziono
.IR nazwy ,
to nie jest wypisywane nic i jako kod zakończenia zwracany jest fałsz.
Jeśli posłużono się opcją
.B \-p
to
.B type
zwraca albo nazwę pliku dyskowego, który zostałby wykonany jeśli
.I nazwa
zostałaby podana jako nazwa polecenia, albo nic jeśli
! .if t \f(CWtype -t nazwa\fP
! .if n ,,type -t nazwa''
nie zwróciłoby
.IR file .
Jeśli polecenie istnieje w tablicy mieszającej,
.B \-p
wypisuje wartość z tablicy, niekoniecznie plik, który pojawia się jako
pierwszy w
.SM
.BR PATH .
Jeżeli użyto opcji
.BR \-a ,
to
.B type
wypisuje wszystkie miejsca zawierajace wykonywalną
.IR nazwę .
Obejmuje to aliasy i funkcje, wtedy i tylko wtedy gdy użyto również opcji
.BR \-p .
Przy użyciu
.B \-a
nie korzysta się z tablicy mieszającej poleceń.
.B type
zwraca prawdę jeśli znaleziono jakieś jego argumenty, fałsz jeśli nie
znaleziono żadnych.
.TP
\fBulimit\fP [\fB\-SHacdflmnpstuv\fP [\fIlimit\fP]]
Zapewnia kontrolę nad zasobami dostępnymi powłoce i procesów jakie ona
uruchamia, na systemach umożliwiających taką kontrolę.
Opcje \fB\-H\fP i \fB\-S\fP określają, że dla danego zasobu ustawiane jest
twarde (hard) lub miękkie (soft) ograniczenie. Ograniczenie twarde nie może
być zwiększane po ustawieniu; ograniczenie miękkie może być zwiększane aż do
wartości ograniczenia twardego. Jeśli nie podano ani \fB\-H\fP ani
\fB\-S\fP, to ustawiane jest zarówno ograniczenie miękkie jak i twarde.
Ograniczenie
.I limit
może być liczbą w jednostkach określonych dla zasobu lub jedną ze specjalnych
wartości:
.BR hard ,
.BR soft
lub
.BR unlimited ,
oznaczających odpowiednio: bieżące twarde ograniczenie, bieżące miękkie
ograniczenie oraz brak ograniczenia.
Jeżeli pominięto
.IR limit ,
wypisywana jest bieżąca wartość ograniczenia miękkiego danego zasobu, chyba
że podano opcję \fB\-H\fP. Gdy podano więcej niż jedno określenie zasobu,
przed wartością wypisywana jest nazwa ograniczenia i jednostka miary.
Inne opcje interpretowane są następująco:
.RS
.PD 0
.TP
.B \-a
Podawane są wszystkie bieżące ograniczenia
.TP
.B \-c
Maksymalny rozmiar tworzonych plików core
.TP
.B \-d
Maksymalny rozmiar segmentu danych procesu
.TP
.B \-f
Maksymalny rozmiar plików tworzonych przez powłokę
.TP
.B \-l
Maksymalny rozmiar, jaki może zostać zablokowany w pamięci
.TP
.B \-m
Maksymalny rozmiar części rezydentnej
.TP
.B \-n
Maksymalna liczba otwartych deskryptorów pliku (większość systemów nie
pozwala na ustawianie tej wartości)
.TP
.B \-p
Rozmiar potoku w blokach 512-bajtowych (może nie być ustawione)
.TP
.B \-s
Maksymalny rozmiar stosu
.TP
.B \-t
Maksymalny czas CPU w sekundach
.TP
.B \-u
Maksymalna liczba procesów dostępnych dla pojedynczego użytkownika
.TP
.B \-v
Maksymalna wielkość pamięci wirtualnej dostępna dla powłoki
.PD
.PP
Jeżeli podano
.IR limit ,
to staje się nową wartością ograniczenia zadanego zasobu (opcja
.B \-a
tylko wyświetla).
Jeżeli nie podano żadnej ocpji, to zakłada się opcję
.BR \-f .
Wartości podawane są przyrostowo co 1024-bajty, z wyjątkiem
.BR \-t ,
podawanego w sekundach,
.BR \-p ,
w jednostkach 512-bajtowych bloków,
oraz
.B \-n
i
.BR \-u ,
będących wartościami bez miana. Zwracanym kodem jest 0, chyba że podano
nieprawidłową opcję lub argument albo podczas ustawiania nowego ograniczenia
wystąpił błąd.
.RE
.TP
\fBumask\fP [\fB\-p\fP] [\fB\-S\fP] [\fItryb\fP]
Maska praw dostępu dla plików tworzonych przez użytkownika ustawiana jest na
.IR tryb .
Jeżeli
.I tryb
rozpoczyna się od cyfry, jest interpretowany jako liczba ósemkowa; w
przeciwnym razie interpretowany jest jako maska w trybie symbolicznym,
podobnie jak akceptowane przez
.IR chmod (1).
Jeżeli pominięto
.I tryb
wypisywana jest aktualna wartość maski.
Opcja
.B \-S
powoduje, że maska zostanie wypisana w postaci symbolicznej; domyślne
wyjście jest w postaci liczby ósemkowej.
Jeżeli podano opcję
.B \-p
i pominięto
.IR tryb ,
to wyjście ma postać, która może być powtórnie wykorzystana jako wejście.
Kodem zwracanym jest 0 jeśli pomyślnie zmieniono tryb lub nie podano
argumentu \fItryb\fP, zaś fałsz w pozostałych sytuacjach.
.TP
\fBunalias\fP [\-\fBa\fP] [\fInazwa\fP ...]
Usuwa każdą z \fInazw\fP z listy zdefiniowanych aliasów. Jeżeli podano
.BR \-a ,
to usuwane są definicje wszystkich aliasów. Zwracanym kodem jest prawda,
chyba że podana
.I nazwa
nie jest zdefiniowanym aliasem.
.TP
\fBunset\fP [\-\fBfv\fP] [\fInazwa\fP ...]
Dla każdej
.IR nazwy ,
usuwa odpowiadającą jej wartość lub funkcję. Jeżeli nie podano żadnych opcji
lub podano opcję
.BR \-v ,
to każda z
.I nazw
odnosi się do zmiennej powłoki.
Zmienne read-only nie mogą być kasowane.
Jeżeli podano
.BR \-f ,
to każda z
.I nazw
wskazuje na funkcję powłoki, a definicja funkcji jest usuwana.
Każda z usuniętych zmiennych lub funkcji usuwana jest ze środowiska
przesyłanego następnym poleceniom.
Jeśli usunięta zostanie któraś ze zmiennych
.SM
.BR RANDOM ,
.SM
.BR SECONDS ,
.SM
.BR LINENO ,
.SM
.BR HISTCMD ,
.SM
.BR FUNCNAME ,
.SM
.BR GROUPS ,
lub
.SM
.BR DIRSTACK ,
to traci ona swe specjalne właściwości, nawet jeśli zostanie następnie
ponownie ustawiona. Kodem zakończenia jest prawda, chyba że
.I nazwa
nie istnieje lub jest readonly.
.TP
\fBwait\fP [\fIn\fP]
Czeka na określony proces i zwraca jego kod zakończenia.
.I n
może być identyfikatorem procesu lub określeniem zadania; jeśli podano
określenie zadania, to nastąpi oczekiwanie na wszystkie procesy w potoku
tego zadania.
Jeżeli nie podano
.IR n ,
następuje oczekiwanie na wszystkie aktualnie aktywne procesy potomne i
zwracany jest kod zerowy.
Jeśli
.I n
określa nieistniejący proces lub zadanie, to zwracany jest kod 127.
W pozostałych przypadkach zwracany jest kod zakończenia ostatniego procesu
lub zadania na jakie czekano.
.\" bash_builtins
.if \n(zZ=1 .ig zZ
.SH "POWŁOKA OKROJONA"
.\" rbash.1
.\" początek podręcznika rbash
.zY
.PP
Jeśli
.B bash
uruchomiony jest pod nazwą
.BR rbash ,
lub przy jego wywołaniu posłużono się opcją
.BR \-r ,
to staje się powłoką okrojoną (restricted).
Powłoka okrojona służy do ustawienia środowiska lepiej kontrolowanego
niż powłoka standardowa. Zachowuje się ona identycznie jak
.B bash
z wyjątkiem tego, że poniższe nie są dozwolone lub nie są wykonywane:
.IP \(bu
zmiana katalogów przy pomocy \fBcd\fP
.IP \(bu
ustawianie lub kasowanie wartości
.BR SHELL ,
.BR PATH ,
.BR ENV
lub
.B BASH_ENV
.IP \(bu
podawanie nazw poleceń zawierających
.B /
.IP \(bu
podawanie nazw plików zawierających
.B /
jako argumentu wbudowanego polecenia
.B .
(kropka).
.IP \(bu
importowanie definicji funkcji ze środowiska powłoki przy uruchamianiu
.IP \(bu
analiza wartości \fBSHELLOPTS\fP ze środowiska powłoki przy uruchamianiu
.IP \(bu
przekierowywanie wyjścia przy pomocy operatorów >, >|, <>, >&, &> i >>
.IP \(bu
posługiwanie się wbudowanym poleceniem
.B exec
w celu zastąpienia powłoki innym poleceniem
.IP \(bu
dodawanie lub usuwanie poleceń przy pomocy opcji
.B \-f
i
.B \-d
wbudowanego polecenia
.B enable
.IP \(bu
podawanie opcji
.B \-p
wbudowanego polecenia
.B command
.IP \(bu
wyłączanie trybu okrojonego za pomocą
\fBset +r\fP lub \fBset +o restricted\fP.
.PP
Powyższe ograniczenia wymuszane są po przeczytaniu plików uruchomieniowych.
.PP
Jeśli polecenie do wykonania okazuje się być skryptem powłoki (zobacz
.SM
.B "WYKONYWANIE POLECEŃ"
powyżej), to
.B rbash
wyłącza wszelkie ograniczenia w powłoce zrodzonej do wykonania skryptu.
.\" koniec podręcznika rbash
.if \n(zY=1 .ig zY
.SH "ZOBACZ TAKŻE"
.PD 0
.TP
\fIBash Features\fP, Brian Fox and Chet Ramey
.TP
\fIThe Gnu Readline Library\fP, Brian Fox and Chet Ramey
.TP
\fIThe Gnu History Library\fP, Brian Fox and Chet Ramey
.TP
\fIPortable Operating System Interface (POSIX) Part 2: Shell and Utilities\fP, IEEE
.TP
\fIsh\fP(1), \fIksh\fP(1), \fIcsh\fP(1)
.TP
\fIemacs\fP(1), \fIvi\fP(1)
.TP
\fIreadline\fP(3)
.PD
.SH PLIKI
.PD 0
.TP
.FN /bin/bash
Plik wykonywalny powłoki \fBbash\fP
.TP
.FN /etc/profile
Ogólnosystemowy plik inicjujący, wykonywany dla powłok zgłoszeniowych
.TP
.FN ~/.bash_profile
Osobisty plik inicjujący, wykonywany dla powłok zgłoszeniowych
.TP
.FN ~/.bashrc
Indywidualny plik startowy dla powłoki trybu interaktywnego
.TP
.FN ~/.bash_logout
Indywidualny plik porządkujący dla powłoki zgłoszeniowej, wykonywany
podczas kończenia przez nią pracy
.TP
.FN ~/.inputrc
Indywidualny plik inicjujący dla \fIreadline\fP
.PD
.SH AUTORZY
Brian Fox, Free Software Foundation
.br
bfox@gnu.ai.MIT.Edu
.PP
Chet Ramey, Case Western Reserve University
.br
chet@ins.CWRU.Edu
.SH ZGŁOSZENIA BŁĘDÓW
Jeśli znajdziesz w
.B bash
błąd, powinieneś go zgłosić. Ale najpierw powinieneś upewnić się, że
rzeczywiście jest to błąd i że pojawia się w najświeższej wersji
.B bash
jaką masz.
.PP
Po ustaleniu, że błąd faktycznie istnieje, użyj polecenia
.I bashbug
do wysłania zgłoszenia błędu.
Jeśli masz poprawkę usuwającą problem, zachęcamy do przesłania jej również!
Sugestie i `filozoficzne' zgłoszenia błędów mogą być przesyłane [w języku
angielskim] do \fIbug-bash@gnu.org\fP lub wysyłane na grupę dyskusyjną
.BR gnu.bash.bug .
.PP
WSZYSTKIE zgłoszenia błędów powinny zawierać:
.PP
.PD 0
.TP 20
Numer wersji \fBbash\fR
.TP
Sprzęt i system operacyjny
.TP
Użyty kompilator
.TP
Opis błędnego zachowania
.TP
Krótki skrypt lub przepis na uzyskanie błędu
.PD
.PP
.I bashbug
wstawia pierwsze trzy pozycje automatycznie do szablonu jaki udostępnia
w celu wypełnienia zgłoszenia błędów.
.PP
Komentarze i zgłoszenia błędów dotyczące tej strony podręcznika [oryginału]
powinny być kierowane na adres
.IR chet@ins.CWRU.Edu .
.SH BŁĘDY
.PP
Jest za duży i zbyt wolny.
.PP
Istnieje trochę subtelnych różnic pomiędzy
.B bash
a tradycyjnymi wersjami
.BR sh ,
głównie z powodu specyfikacji
.SM
.BR POSIX .
.PP
Aliasy w niektórych zastosowaniach wprawiają w zakłopotanie.
.PP
Poleceń wbudowanych powłoki i funkcji nie można zatrzymywać/wznawiać.
.PP
Polecenia złożone i sekwencje poleceń postaci `a ; b ; c' nie są
obsługiwane przychylnie przy próbie wstrzymania procesu. Gdy proces jest
zatrzymany, powłoka natychmiast wykonuje następnej polecenie sekwencji.
Wystarcza umieszczanie sekwencji poleceń wewnątrz nawiasów by wymusić
wykonanie ich przez podpowłokę, która może być zatrzymana jako całość.
.PP
Polecenia wewnątrz konstrukcji podstawiania poleceń \fB$(\fP...\fB)\fP nie
są analizowane do momentu próby podstawienia. Powoduje to opóźnioną
sygnalizację błędów, pojawiającą się po upływie pewnego czasu od
wprowadzenia polecenia.
.PP
Zmienne tablicowe nie mogą być (na razie) eksportowane.
.zZ
.zY

.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "native::Core 3"
.TH native::Core 3 "2005-06-17" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
SVN::Core \- Core module of the subversion perl bindings
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use SVN::Core; # does apr_initialize and cleanup for you
.Ve
.PP
.Vb 2
\&    # create a root pool and set it as default pool for later use
\&    my $pool = SVN::Pool->new_default;
.Ve
.PP
.Vb 4
\&    sub something {
\&        # create a subpool of the current default pool
\&        my $pool = SVN::Pool->new_default_sub;
\&        # some svn operations...
.Ve
.PP
.Vb 3
\&        # $pool gets destroyed and the previous default pool
\&        # is restored when $pool's lexical scope ends
\&    }
.Ve
.PP
.Vb 4
\&    # svn_stream_t as native perl io handle
\&    my $stream = $txn->root->apply_text('trunk/filea', undef);
\&    print $stream $text;
\&    close $stream;
.Ve
.PP
.Vb 3
\&    # native perl io handle as svn_stream_t
\&    SVN::Repos::dump_fs($repos, \e*STDOUT, \e*STDERR,
\&                        0, $repos->fs->youngest_rev, 0);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
SVN::Core implements higher level functions of fundamental subversion
functions.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.IP "SVN::Core::auth_open([auth provider array]);" 4
.IX Item "SVN::Core::auth_open([auth provider array]);"
Takes a reference to an array of authentication providers
and returns an auth_baton.  If you use prompt providers
you can not use this function, but need to use the 
auth_open_helper.
.IP "SVN::Core::auth_open_helper([auth provider array);" 4
.IX Item "SVN::Core::auth_open_helper([auth provider array);"
Prompt providers return two values instead of one.  The
2nd parameter is a reference to whatever was passed into
them as the callback.  auth_open_helper splits up these
arguments, passing the provider objects into auth_open
which gives it an auth_baton and putting the other
ones in an array.  The first return value of this
function is the auth_baton, the second is a reference
to an array containing the references to the callbacks.
.Sp
These callback arrays should be stored in the object
the auth_baton is attached to.
.SH "OTHER OBJECTS"
.IX Header "OTHER OBJECTS"
.Sh "svn_stream_t \- SVN::Stream"
.IX Subsection "svn_stream_t - SVN::Stream"
You can use native perl io handles (including io globs) as
svn_stream_t in subversion functions. Returned svn_stream_t are also
translated into perl io handles, so you could access them with regular
print, read, etc.
.PP
Note that some functions take a stream to read or write, while it
does not close it but still hold the reference to the handle. In this case
the handle won't be destroyed properly. You should always use correct
default pool before calling such functions.
.Sh "svn_pool_t \- SVN::Pool"
.IX Subsection "svn_pool_t - SVN::Pool"
The perl bindings significantly simplify the usage of pools, while 
still being manually adjustable.
.PP
Functions requiring pool as the last argument (which are, almost all
of the subversion functions), the pool is optionally. The default pool
is used if it is omitted. If default pool is not set, a new root pool
will be created and set as default automatically when the first
function requiring a default pool is called.
.PP
For callback functions providing pool to your subroutine, you could
also use \f(CW$pool\fR\->default to make it the default pool in the scope.
.PP
\fIMethods\fR
.IX Subsection "Methods"
.IP "new ([$parent])" 4
.IX Item "new ([$parent])"
Create a new pool. The pool is a root pool if \f(CW$parent\fR is not supplied.
.IP "new_default ([$parent])" 4
.IX Item "new_default ([$parent])"
Create a new pool. The pool is a root pool if \f(CW$parent\fR is not supplied.
Set the new pool as default pool.
.IP "new_default_sub" 4
.IX Item "new_default_sub"
Create a new subpool of the current default pool, and set the
resulting pool as new default pool.
.IP "clear" 4
.IX Item "clear"
Clear the pool.
.IP "destroy" 4
.IX Item "destroy"
Destroy the pool. If the pool is the default pool, restore the
previous default pool as default. This is normally called
automatically when the SVN::Pool object is no longer used and
destroyed by the perl garbage collector.
.Sh "svn_error_t \- SVN::Error"
.IX Subsection "svn_error_t - SVN::Error"
By default the perl bindings handle exceptions for you.  The default handler
automatically croaks with an appropriate error message.  This is likely
sufficient for simple scripts, but more complex usage may demand handling of
errors.  
.PP
You can override the default exception handler by changing the
\&\f(CW$SVN::Error::handler\fR variable.  This variable holds a reference to a perl sub
that should be called whenever an error is returned by a svn function.  This
sub will be passed a svn_error_t object.   Its return value is ignored.
.PP
If you set the \f(CW$SVN::Error::handler\fR to undef then each call will return an
svn_error_t object as its first return in the case of an error, followed by the
normal return values.  If there is no error then a svn_error_t will not be
returned and only the normal return values will be returned.  When using this
mode you should be careful only to call functions in array context.  For
example: my ($ci) = \f(CW$ctx\fR\->mkdir('http://svn/foo');  In this case \f(CW$ci\fR will
be an svn_error_t object if an error occurs and a svn_client_commit_info object
otherwise.  If you leave the parenthesis off around \f(CW$ci\fR (scalar context) it
will be the commit_info object, which in the case of an error will be undef.
.PP
If you plan on using this exception handling, understanding the exception
handling system the C \s-1API\s0 uses is helpful.  You can find information on it in
the \s-1HACKING\s0 file and the \s-1API\s0 documentation.  Looking at the implementation of
SVN::Error::croak_on_error and SVN::Error::expanded_message may be helpful as
well.
.IP "$svn_error_t\->\fIapr_err()\fR" 4
.IX Item "$svn_error_t->apr_err()"
\&\s-1APR\s0 error value, possibly \s-1SVN_\s0 custom error.
.IP "$svn_error_t\->\fImessage()\fR" 4
.IX Item "$svn_error_t->message()"
Details from producer of error.
.IP "$svn_error_t\->\fIchild()\fR" 4
.IX Item "$svn_error_t->child()"
svn_error_t object of the error that's wrapped.
.IP "$svn_error_t\->\fIpool()\fR" 4
.IX Item "$svn_error_t->pool()"
The pool holding this error and any child errors it wraps.
.IP "$svn_error_t\->\fIfile()\fR" 4
.IX Item "$svn_error_t->file()"
Source file where the error originated.
.IP "$svn_error_t\->\fIline()\fR" 4
.IX Item "$svn_error_t->line()"
Source line where the error originated.
.IP "SVN::Error::strerror($apr_status_t)" 4
.IX Item "SVN::Error::strerror($apr_status_t)"
Returns the english description of the status code.
.IP "$svn_error_t\->\fIstrerror()\fR" 4
.IX Item "$svn_error_t->strerror()"
Returns the english description of the apr_err status code set on the
\&\f(CW$svn_error_t\fR.  This is short for:
SVN::Error::strerror($svn_error_t\->\fIapr_err()\fR);
.ie n .IP "SVN::Error::create($apr_err, $child\fR, \f(CW$message);" 4
.el .IP "SVN::Error::create($apr_err, \f(CW$child\fR, \f(CW$message\fR);" 4
.IX Item "SVN::Error::create($apr_err, $child, $message);"
Returns a new svn_error_t object with the error status specified in \f(CW$apr_err\fR,
the child as \f(CW$child\fR, and error message of \f(CW$message\fR.
.ie n .IP "SVN::Error::quick_wrap($child, $new_msg\fR); or \f(CW$child\->quick_wrap($new_msg);" 4
.el .IP "SVN::Error::quick_wrap($child, \f(CW$new_msg\fR); or \f(CW$child\fR\->quick_wrap($new_msg);" 4
.IX Item "SVN::Error::quick_wrap($child, $new_msg); or $child->quick_wrap($new_msg);"
A quick n' easy way to create a wrappered exception with your own message
before throwing it up the stack.
.Sp
$child is the svn_error_t object you want to wrap and \f(CW$new_msg\fR is the new error
string you want to set.
.ie n .IP "SVN::Error::compose($chain, $new_error\fR); or \f(CW$chain\->compose($new_error);" 4
.el .IP "SVN::Error::compose($chain, \f(CW$new_error\fR); or \f(CW$chain\fR\->compose($new_error);" 4
.IX Item "SVN::Error::compose($chain, $new_error); or $chain->compose($new_error);"
Add new_err to the end of \f(CW$chain\fR's chain of errors.
.Sp
The \f(CW$new_err\fR chain will be copied into \f(CW$chain\fR's pool and destroyed, so \f(CW$new_err\fR
itself becomes invalid after this function.
.ie n .IP "SVN::Error::clear($svn_error_t); or $svn_error_t\fR\->\fIclear();" 4
.el .IP "SVN::Error::clear($svn_error_t); or \f(CW$svn_error_t\fR\->\fIclear()\fR;" 4
.IX Item "SVN::Error::clear($svn_error_t); or $svn_error_t->clear();"
Free the memory used by \f(CW$svn_error_t\fR, as well as all ancestors and descendants
of \f(CW$svn_error_t\fR.
.Sp
You must call this on every svn_error_t object you get or you will leak memory.
.ie n .IP "SVN::Error::expanded_message($svn_error_t) or $svn_error_t\fR\->\fIexpanded_message()" 4
.el .IP "SVN::Error::expanded_message($svn_error_t) or \f(CW$svn_error_t\fR\->\fIexpanded_message()\fR" 4
.IX Item "SVN::Error::expanded_message($svn_error_t) or $svn_error_t->expanded_message()"
Returns the error message by tracing through the svn_error_t object and its
children and concatenating the error messages.  This is how the internal
exception handlers get their error messages.
.IP "SVN::Error::is_error($value)" 4
.IX Item "SVN::Error::is_error($value)"
Returns true if the value is an svn_error type return.  Returns false if the
value is anything else or undefined.  This is useful for seeing if a call has
returned an error.
.IP "SVN::Error::croak_on_error" 4
.IX Item "SVN::Error::croak_on_error"
Default error handler.  It takes an svn_error_t and extracts the error messages
from it and croaks with those messages.
.Sp
It can be used two ways.  The first is detailed above as setting it as the
automatic exception handler via setting \f(CW$SVN::Error::handler\fR. 
.Sp
The 2nd is if you have \f(CW$SVN::Error::handler\fR set to undef as a wrapper for calls
you want to croak on when there is an error but don't want to have to write an
explicit error handler for example:
.Sp
my \f(CW$result_rev\fR=SVN::Error::croak_on_error($ctx\->checkout($url,$path,'\s-1HEAD\s0',1));
.Sp
If there is no error then croak_on_error will return the arguments passed to it
unchanged.
.IP "SVN::Error::confess_on_error" 4
.IX Item "SVN::Error::confess_on_error"
The same as croak_on_error except it will give a more detailed stack backtrace.
Including showing internal calls within the implementations of the perl
bindings.  This is useful if you're working on developing the bindings.
.IP "SVN::Error::ignore_error" 4
.IX Item "SVN::Error::ignore_error"
This is useful for wrapping around calls which you wish to ignore any potential
error.  It checks to see if the first parameter is an error and if it is it
clears it.  It then returns all the other parameters.
.Sh "svn_log_changed_path_t"
.IX Subsection "svn_log_changed_path_t"
.IP "$lcp\->\fIaction()\fR" 4
.IX Item "$lcp->action()"
\&'A'dd, 'D'elete, 'R'eplace, 'M'odify 
.IP "$lcp\->\fIcopyfrom_path()\fR" 4
.IX Item "$lcp->copyfrom_path()"
Source path of copy (if any).
.IP "$lcp\->\fIcopyfrom_rev()\fR" 4
.IX Item "$lcp->copyfrom_rev()"
Source revision of copy (if any).
.Sh "svn_node_kind_t \- SVN::Node"
.IX Subsection "svn_node_kind_t - SVN::Node"
An enum of the following constants:
.PP
$SVN::Node::none, \f(CW$SVN::Node::file\fR,
\&\f(CW$SVN::Node::dir\fR, \f(CW$SVN::Node::unknown\fR.
.Sh "svn_opt_revision_t"
.IX Subsection "svn_opt_revision_t"
.Sh "svn_config_t"
.IX Subsection "svn_config_t"
Opaque object describing a set of configuration options.
.Sh "svn_dirent_t"
.IX Subsection "svn_dirent_t"
.IP "$dirent\->\fIkind()\fR" 4
.IX Item "$dirent->kind()"
Node kind.  One of these constants:
\&\f(CW$SVN::Node::none\fR, \f(CW$SVN::Node::file\fR,
\&\f(CW$SVN::Node::dir\fR, \f(CW$SVN::Node::unknown\fR.
.IP "$dirent\->\fIsize()\fR" 4
.IX Item "$dirent->size()"
Length of file text, or 0 for directories.
.IP "$dirent\->\fIhas_props()\fR" 4
.IX Item "$dirent->has_props()"
Does the node have props?
.IP "$dirent\->\fIcreated_rev()\fR" 4
.IX Item "$dirent->created_rev()"
Last rev in which this node changed.
.IP "$dirent\->\fItime()\fR" 4
.IX Item "$dirent->time()"
Time of created_rev (mod\-time).
.IP "$dirent\->\fIlast_author()\fR" 4
.IX Item "$dirent->last_author()"
Author of created rev.
.Sh "svn_auth_cred_simple_t"
.IX Subsection "svn_auth_cred_simple_t"
.IP "$simple\->\fIusername()\fR" 4
.IX Item "$simple->username()"
Username.
.IP "$simple\->\fIpassword()\fR" 4
.IX Item "$simple->password()"
Password.
.IP "$simple\->\fImay_save()\fR" 4
.IX Item "$simple->may_save()"
Indicates if the credentials may be saved (to disk).
.Sh "svn_auth_cred_username_t"
.IX Subsection "svn_auth_cred_username_t"
.IP "$username\->\fIusername()\fR" 4
.IX Item "$username->username()"
Username.
.IP "$username\->\fImay_save()\fR" 4
.IX Item "$username->may_save()"
Indicates if the credentials may be saved (to disk).
.Sh "svn_auth_cred_ssl_server_trust_t"
.IX Subsection "svn_auth_cred_ssl_server_trust_t"
.IP "$strust\->\fImay_save()\fR" 4
.IX Item "$strust->may_save()"
Indicates if the credentials may be saved (to disk).
.IP "$strust\->\fIaccepted_failures()\fR" 4
.IX Item "$strust->accepted_failures()"
Bit mask of the accepted failures.
.Sh "svn_auth_ssl_server_cert_info_t"
.IX Subsection "svn_auth_ssl_server_cert_info_t"
.IP "$scert\->\fIhostname()\fR" 4
.IX Item "$scert->hostname()"
Primary \s-1CN\s0.
.IP "$scert\->\fIfingerprint()\fR" 4
.IX Item "$scert->fingerprint()"
\&\s-1ASCII\s0 fingerprint.
.IP "$scert\->\fIvalid_from()\fR" 4
.IX Item "$scert->valid_from()"
\&\s-1ASCII\s0 date from which the certificate is valid.
.IP "$scert\->\fIvalid_until()\fR" 4
.IX Item "$scert->valid_until()"
\&\s-1ASCII\s0 date until which the certificate is valid.
.IP "$scert\->\fIissuer_dname()\fR" 4
.IX Item "$scert->issuer_dname()"
\&\s-1DN\s0 of the certificate issuer.
.IP "$scert\->\fIascii_cert()\fR" 4
.IX Item "$scert->ascii_cert()"
Base\-64 encoded \s-1DER\s0 certificate representation.
.Sh "svn_auth_cred_ssl_client_cert_t"
.IX Subsection "svn_auth_cred_ssl_client_cert_t"
.IP "$ccert\->\fIcert_file()\fR" 4
.IX Item "$ccert->cert_file()"
Full paths to the certificate file.
.IP "$ccert\->\fImay_save()\fR" 4
.IX Item "$ccert->may_save()"
Indicates if the credentials may be saved (to disk).
.Sh "svn_auth_cred_ssl_client_cert_pw_t"
.IX Subsection "svn_auth_cred_ssl_client_cert_pw_t"
.IP "$ccertpw\->\fIpassword()\fR" 4
.IX Item "$ccertpw->password()"
Certificate password.
.IP "$ccertpw\->\fImay_save()\fR" 4
.IX Item "$ccertpw->may_save()"
Indicates if the credentials may be saved (to disk).
.SH "CONSTANTS"
.IX Header "CONSTANTS"
.Sh "SVN::Auth::SSL"
.IX Subsection "SVN::Auth::SSL"
.IP "$SVN::Auth::SSL::NOTYETVALID" 4
.IX Item "$SVN::Auth::SSL::NOTYETVALID"
Certificate is not yet valid.
.IP "$SVN::Auth::SSL::EXPIRED" 4
.IX Item "$SVN::Auth::SSL::EXPIRED"
Certificate has expired.
.IP "$SVN::Auth::SSL::CNMISMATCH" 4
.IX Item "$SVN::Auth::SSL::CNMISMATCH"
Certificate's \s-1CN\s0 (hostname) does not match the remote hostname. 
.IP "$SVN::Auth::SSL::UNKNOWNCA" 4
.IX Item "$SVN::Auth::SSL::UNKNOWNCA"
Certificate authority is unknown (i.e. not trusted). 
.IP "$SVN::Auth::SSL::OTHER" 4
.IX Item "$SVN::Auth::SSL::OTHER"
Other failure. This can happen if neon has introduced a new failure bit that we
do not handle yet.
.SH "AUTHORS"
.IX Header "AUTHORS"
Chia-liang Kao <clkao@clkao.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2003 CollabNet.  All rights reserved.
.PP
This software is licensed as described in the file \s-1COPYING\s0, which you
should have received as part of this distribution.  The terms are also
available at http://subversion.tigris.org/license\-1.html.  If newer
versions of this license are posted there, you may use a newer version
instead, at your option.
.PP
This software consists of voluntary contributions made by many
individuals.  For exact contribution history, see the revision history
and logs, available at http://subversion.tigris.org/.
